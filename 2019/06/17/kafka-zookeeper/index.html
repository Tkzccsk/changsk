<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=6.7.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.7.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.7.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.7.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="消息队列中间件是分布式系统中重要的组件，主要解决应用耦合(使消息的生产者和消费者解耦)，异步消息（消息的生产和消费是异步的），流量削峰等问题。实现高性能，高可用，可伸缩和最终一致性架构，是大型分布式系统不可缺少的中间件。">
<meta name="keywords" content="kafka,zookeeper">
<meta property="og:type" content="article">
<meta property="og:title" content="深入浅出理解基于 Kafka 和 ZooKeeper 的分布式消息队列">
<meta property="og:url" content="http://changsk.top/2019/06/17/kafka-zookeeper/index.html">
<meta property="og:site_name" content="changsk&#39;s blogs">
<meta property="og:description" content="消息队列中间件是分布式系统中重要的组件，主要解决应用耦合(使消息的生产者和消费者解耦)，异步消息（消息的生产和消费是异步的），流量削峰等问题。实现高性能，高可用，可伸缩和最终一致性架构，是大型分布式系统不可缺少的中间件。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://changsk.top/2019/06/17/kafka-zookeeper/1.jpg">
<meta property="og:image" content="http://changsk.top/2019/06/17/kafka-zookeeper/2.jpg">
<meta property="og:image" content="http://changsk.top/2019/06/17/kafka-zookeeper/3.jpg">
<meta property="og:image" content="http://changsk.top/2019/06/17/kafka-zookeeper/4.jpg">
<meta property="og:image" content="http://changsk.top/2019/06/17/kafka-zookeeper/5.jpg">
<meta property="og:image" content="http://changsk.top/2019/06/17/kafka-zookeeper/6.jpg">
<meta property="og:image" content="http://changsk.top/2019/06/17/kafka-zookeeper/7.jpg">
<meta property="og:image" content="http://changsk.top/2019/06/17/kafka-zookeeper/8.jpg">
<meta property="og:image" content="http://changsk.top/2019/06/17/kafka-zookeeper/9.jpg">
<meta property="og:image" content="http://changsk.top/2019/06/17/kafka-zookeeper/10.jpg">
<meta property="og:image" content="http://changsk.top/2019/06/17/kafka-zookeeper/11.jpg">
<meta property="og:updated_time" content="2019-06-17T13:06:35.284Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入浅出理解基于 Kafka 和 ZooKeeper 的分布式消息队列">
<meta name="twitter:description" content="消息队列中间件是分布式系统中重要的组件，主要解决应用耦合(使消息的生产者和消费者解耦)，异步消息（消息的生产和消费是异步的），流量削峰等问题。实现高性能，高可用，可伸缩和最终一致性架构，是大型分布式系统不可缺少的中间件。">
<meta name="twitter:image" content="http://changsk.top/2019/06/17/kafka-zookeeper/1.jpg">



  <link rel="alternate" href="/atom.xml" title="changsk's blogs" type="application/atom+xml">




  <link rel="canonical" href="http://changsk.top/2019/06/17/kafka-zookeeper/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>深入浅出理解基于 Kafka 和 ZooKeeper 的分布式消息队列 | changsk's blogs</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">changsk's blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">chang.sk@foxmail.com</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-collection">

    
    
    
      
    

    

    <a href="/collection/" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>收藏</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    
  
  
  
  

  

  <a href="https://github.com/Tkzccsk" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" style="fill: #222; color: #fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://changsk.top/2019/06/17/kafka-zookeeper/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="changsk">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/me/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="changsk's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">深入浅出理解基于 Kafka 和 ZooKeeper 的分布式消息队列

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-17 11:46:08 / 修改时间：21:06:35" itemprop="dateCreated datePublished" datetime="2019-06-17T11:46:08+08:00">2019-06-17</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">31k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">28 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>消息队列中间件是分布式系统中重要的组件，主要解决<strong>应用耦合</strong>(使消息的生产者和消费者解耦)，<strong>异步消息</strong>（消息的生产和消费是异步的），<strong>流量削峰</strong>等问题。实现<strong>高性能，高可用，可伸缩和最终一致性架构</strong>，是大型分布式系统不可缺少的中间件。</p>
<a id="more"></a>

<p><strong>本场 Chat 主要内容：</strong></p>
<ul>
<li>Kafka 的架构解读；</li>
<li>Kafka 为什么要将 Topic 进行分区；</li>
<li>Kafka 高可靠性实现基础解读；</li>
<li>Kafka 复制原理和同步方式；</li>
<li>Leader 选举机制，及如何确保新选举出的 Leader 是优选；</li>
<li>同步副本 ISR；</li>
<li>Kafka 数据可靠性和持久性保证；</li>
<li>深入解读 HW 机制；</li>
<li>Kafka 架构中 ZooKeeper 以怎样的形式存在；</li>
<li>全程解析：Producer -&gt; kafka -&gt; consumer。</li>
</ul>
<p><strong>相关内容链接：</strong></p>
<ol>
<li><a href="https://gitbook.cn/gitchat/column/5b7d127b84322801444db274" target="_blank" rel="noopener">《分布式中间件实践之路》</a></li>
<li><a href="https://gitbook.cn/gitchat/column/5ad56a79af8f2f35290f6535" target="_blank" rel="noopener">《Python 快速入门实战教程》</a></li>
<li><a href="https://gitbook.cn/gitchat/activity/5ba904caf934bf2b6d5596da" target="_blank" rel="noopener">《分布式锁的最佳实践之：基于 Etcd 的分布式锁》</a></li>
<li><a href="https://gitbook.cn/gitchat/activity/5b3d91c56edf9d4ff8ee21c4" target="_blank" rel="noopener">《基于 Redis 的分布式锁实现及踩坑案例》</a></li>
<li><a href="https://gitbook.cn/gitchat/activity/5b0586f9c2716f0a6df46a99" target="_blank" rel="noopener">《一个高可靠性商用 Redis 集群方案介绍》</a></li>
</ol>
<hr>
<h3 id="1-Kafka-总体架构"><a href="#1-Kafka-总体架构" class="headerlink" title="1. Kafka 总体架构"></a>1. Kafka 总体架构</h3><p>基于 Kafka-ZooKeeper 的分布式消息队列系统总体架构如下：</p>
<p><img src="1.jpg" alt="enter image description here"></p>
<p>如上图所示，一个典型的 Kafka 体系架构包括若干 <strong>Producer（消息生产者）</strong>，若干 <strong>broker（作为 Kafka 节点的服务器</strong>），若干 <strong>Consumer（Group）</strong>，以及一个 <strong>ZooKeeper 集群</strong>。<strong>Kafka通过 ZooKeeper 管理集群配置、选举 Leader 以及在 consumer group 发生变化时进行 Rebalance（即消费者负载均衡，在下一课介绍）。Producer 使用 push（推）模式将消息发布到 broker，Consumer 使用 pull（拉）模式从 broker 订阅并消费消息。</strong></p>
<p>上图仅描摹了一个总体架构，并没有对作为 Kafka 节点的 broker 进行深入刻画，事实上，它的内部细节相当复杂，如下图所示，Kafka 节点涉及 <strong>Topic</strong>、<strong>Partition</strong> 两个重要概念。</p>
<p><img src="2.jpg" alt="enter image description here"></p>
<p>在 Kafka 架构中，有几个术语：</p>
<ul>
<li><strong>Producer</strong>：生产者，即消息发送者，push 消息到 Kafka 集群中的 broker（就是 server）中；</li>
<li><strong>Broker</strong>：Kafka 集群由多个 Kafka 实例（server） 组成，每个实例构成一个 broker，说白了就是服务器；</li>
<li><strong>Topic</strong>：producer 向 kafka 集群 push 的消息会被归于某一类别，即Topic，这本质上只是一个<strong>逻辑概念</strong>，面向的对象是 producer 和 consumer，producer 只需要关注将消息 push 到哪一个 Topic 中，而 consumer 只需要关心自己订阅了哪个 Topic；</li>
<li><strong>Partition</strong>：<strong>每一个 Topic 又被分为多个 Partitions</strong>，<strong>即物理分区</strong>；出于负载均衡的考虑，<strong>同一个 Topic 的 Partitions 分别存储于 Kafka 集群的多个 broker 上</strong>；而为了提高可靠性，<strong>这些 Partitions 可以由 Kafka 机制中的 replicas 来设置备份的数量</strong>；如上面的框架图所示，每个 partition 都存在两个备份；</li>
<li><strong>Consumer</strong>：消费者，从 Kafka 集群的 broker 中 pull 消息、消费消息；</li>
<li><strong>Consumer group</strong>：high-level consumer API 中，<strong>每个 consumer 都属于一个 consumer-group</strong>，<strong>每条消息只能被 consumer-group 中的一个 Consumer 消费</strong>，<strong>但可以被多个 consumer-group 消费</strong>；</li>
<li><strong>replicas</strong>：<strong>partition 的副本</strong>，保障 partition 的<strong>高可用</strong>；</li>
<li><strong>leader</strong>：<strong>replicas 中的一个角色， producer 和 consumer 只跟 leader 交互；</strong></li>
<li><strong>follower</strong>：replicas 中的一个角色，<strong>从 leader 中复制数据，作为副本，一旦 leader 挂掉，会从它的 followers 中选举出一个新的 leader 继续提供服务</strong>；</li>
<li><strong>controller</strong>：Kafka 集群中的其中一个服务器，用来进行 leader election 以及 各种 failover(故障转移)；</li>
<li><strong>ZooKeeper</strong>：Kafka 通过 ZooKeeper 来存储集群的 meta 信息等，文中将详述。</li>
</ul>
<h4 id="1-1-Topic-amp-Partition"><a href="#1-1-Topic-amp-Partition" class="headerlink" title="1.1 Topic &amp; Partition"></a>1.1 Topic &amp; Partition</h4><p><strong>一个 topic 可以认为是一类消息</strong>，<strong>每个 topic 将被分成多个 partition</strong>，<strong>每个 partition 在存储层面是 append log 文件</strong>。任何发布到此 partition 的消息都会被追加到log文件的尾部，每条消息在文件中的位置称为 offset（偏移量），<strong>offset 为一个 long 型的数字，它唯一标记一条消息</strong>。 Kafka 机制中，producer push 来的消息是追加（append）到 partition 中的，这是一种<strong>顺序写磁盘</strong>的机制，效率远高于随机写内存，如下示意图：</p>
<p><img src="3.jpg" alt="enter image description here"></p>
<h4 id="1-2-Kafka-为什么要将-Topic-进行分区？"><a href="#1-2-Kafka-为什么要将-Topic-进行分区？" class="headerlink" title="1.2 Kafka 为什么要将 Topic 进行分区？"></a>1.2 Kafka 为什么要将 Topic 进行分区？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">简而言之：负载均衡 + 水平扩展。</span><br></pre></td></tr></table></figure>

<p>前已述及，<strong>Topic 只是逻辑概念</strong>，面向的是 producer 和 consumer；而 <strong>Partition 则是物理概念</strong>。可以想象，如果 Topic 不进行分区，而将 Topic 内的消息存储于一个 broker，那么关于该 Topic 的所有读写请求都将由这一个 broker 处理，<strong>吞吐量很容易陷入瓶颈</strong>，这显然是不符合高吞吐量应用场景的。有了 Partition 概念以后，假设一个 Topic 被分为 10 个 Partitions，Kafka 会根据一定的算法将 10 个 Partition 尽可能均匀的分布到不同的 broker（服务器）上，当 producer 发布消息时，producer 客户端可以采用 <code>random</code>、<code>key-hash</code> 及 <code>轮询</code> 等算法选定目标 partition，若不指定，Kafka 也将根据一定算法将其置于某一分区上。<strong>Partiton 机制可以极大的提高吞吐量，并且使得系统具备良好的水平扩展能力。</strong></p>
<p>在创建 topic 时可以在 <code>$KAFKA_HOME/config/server.properties</code> 中指定这个 partition 的数量（如下所示），当然可以在 topic 创建之后去修改 partition 的数量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># The default number of log partitions per topic. More partitions allow greater</span><br><span class="line"># parallelism for consumption, but this will also result in more files across</span><br><span class="line"># the brokers.</span><br><span class="line">num.partitions=3</span><br></pre></td></tr></table></figure>

<p>在发送一条消息时，可以<strong>指定这个消息的 key</strong>，producer 根据这个 key 和 partition 机制来判断这个消息发送到哪个partition。partition 机制可以通过指定 producer 的 partition.class 这一参数来指定（即支持自定义），该 class 必须实现 kafka.producer.Partitioner 接口。</p>
<p>有关 topic 与 partition 的更多细节，可以参考下面的“Kafka 文件存储机制”这一节。</p>
<h3 id="2-Kafka-高可靠性实现基础解读"><a href="#2-Kafka-高可靠性实现基础解读" class="headerlink" title="2. Kafka 高可靠性实现基础解读"></a>2. Kafka 高可靠性实现基础解读</h3><p>谈及可靠性，最常规、最有效的策略就是 “<strong>副本（replication）机制</strong>” ，Kafka 实现高可靠性同样采用了该策略。通过调节副本相关参数，可使 Kafka 在性能和可靠性之间取得平衡。本节先从 Kafka 文件存储机制入手，从最底层了解 Kafka 的存储细节，进而对消息的存储有个微观的认知。之后通过介绍 Kafka 的<strong>复制原理</strong>和<strong>同步方式</strong>来阐述宏观层面的概念。最后介绍 <strong>ISR</strong>，<strong>HW</strong> 和 <strong>leader</strong> 选举。</p>
<h4 id="2-1-Kafka-文件存储机制"><a href="#2-1-Kafka-文件存储机制" class="headerlink" title="2.1 Kafka 文件存储机制"></a>2.1 Kafka 文件存储机制</h4><p>Kafka 中消息是以 topic 进行分类的，生产者通过 topic 向 Kafka broker 发送消息，消费者通过 topic 读取数据。然而 <strong>topic 在物理层面又能以 partition 为分组</strong>，一个 topic 可以分成若干个 partition。事实上，partition 并不是最终的存储粒度，<strong>partition 还可以细分为 segment</strong>，<strong>一个 partition 物理上由多个 segment 组成</strong>，那么这些 segment 又是什么呢？</p>
<p>为了便于说明问题，假设这里只有一个 Kafka 集群，且这个集群只有一个 Kafka broker，即只有一台物理机。在这个 Kafka broker 中配置 <code>log.dirs=/tmp/kafka-logs</code>，以此来设置 Kafka 消息文件存储目录；与此同时，通过命令创建一个 topic：mytopic_test，partition 的数量配置为 4（创建 topic 的命令请见上一课）。之后，可以在 <code>/tmp/kafka-logs</code> 目录中可以看到生成了 4 个目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-x 2 root root 4096 Apr 15 13:21 mytopic_test-0</span><br><span class="line">drwxr-xr-x 2 root root 4096 Apr 15 13:21 mytopic_test-1</span><br><span class="line">drwxr-xr-x 2 root root 4096 Apr 15 13:21 mytopic_test-2</span><br><span class="line">drwxr-xr-x 2 root root 4096 Apr 15 13:21 mytopic_test-3</span><br></pre></td></tr></table></figure>

<p>在 Kafka 文件存储中，同一个 topic 下有多个不同的 partition，每个 partiton 为一个目录，partition 的名称规则为：topic 名称 + 有序序号，第一个序号从 0 开始计，最大的序号为 partition 数量减 1，<strong>partition 是实际物理上的概念，而 topic 是逻辑上的概念。</strong></p>
<p><strong>问题 1：为什么不能以 partition 作为存储单位？</strong></p>
<p>上面提到 partition 还可以细分为 segment，这个 segment 又是什么？如果就以 partition 为最小存储单位，可以想象，当 Kafka producer 不断发送消息，必然会引起 <strong>partition 文件的无限扩张</strong>，将对消息文件的维护以及已消费的消息的清理带来严重的影响，因此，需以 segment 为单位将 partition 进一步细分。<strong>每个 partition（目录）相当于一个巨型文件被平均分配到多个大小相等的 segment（段）数据文件中</strong>（每个 segment 文件中消息数量不一定相等）这种特性也方便 old segment 的删除，即方便已被消费的消息的清理，提高磁盘的利用率。每个 partition 只需要支持顺序读写就行，segment 的文件生命周期由服务端配置参数（log.segment.bytes，log.roll.{ms,hours} 等若干参数）决定。</p>
<p><strong>问题 2：segment 的工作原理是怎样的？</strong></p>
<p>segment 文件由两部分组成，分别为 “<strong>.index</strong>” 文件和 “<strong>.log</strong>” 文件，分别表示为 <strong>segment 索引文件和数据文件。</strong>这两个文件的命令规则为：partition 全局的第一个 segment 从 0 开始，后续每个 segment 文件名为上一个 segment 文件最后一条消息的 offset 值，数值大小为 64 位，20 位数字字符长度，没有数字用 0 填充，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00000000000000000000.index</span><br><span class="line">00000000000000000000.log</span><br><span class="line">00000000000000170410.index</span><br><span class="line">00000000000000170410.log</span><br><span class="line">00000000000000239430.index</span><br><span class="line">00000000000000239430.log</span><br></pre></td></tr></table></figure>

<p>以上面的 segment 文件为例，展示出 segment：00000000000000170410 的 “.index” 文件和 “.log” 文件的对应的关系，如下图：</p>
<p><img src="4.jpg" alt="enter image description here"></p>
<p>如上图，<strong>“.index” 索引文件存储大量的元数据</strong>，<strong>“.log” 数据文件存储大量的消息</strong>，<strong>索引文件中的元数据指向对应数据文件中 message 的物理偏移地址</strong>。其中以 “.index” 索引文件中的元数据 [3, 348] 为例，在 “.log” 数据文件表示第 3 个消息，即在全局 partition 中表示 170410+3=170413 个消息，该消息的物理偏移地址为 348。</p>
<p><strong>问题 3：如何从 partition 中通过 offset 查找 message 呢？</strong></p>
<p>以上图为例，读取 offset=170418 的消息，首先查找 segment 文件，其中 00000000000000000000.index 为最开始的文件，第二个文件为 00000000000000170410.index（起始偏移为 170410+1=170411），而第三个文件为 00000000000000239430.index（起始偏移为 239430+1=239431），所以这个 offset=170418 就落到了第二个文件之中。其它后续文件可以依次类推，以其偏移量命名并排列这些文件，然后根据<strong>二分查找</strong>法就可以快速定位到具体文件位置。其次根据 00000000000000170410.index 文件中的 [8,1325] 定位到 00000000000000170410.log 文件中的 1325 的位置进行读取。</p>
<p>要是读取 offset=170418 的消息，从 00000000000000170410.log 文件中的 1325 的位置进行读取，那么，如何确定何时读完本条消息呢？（否则就读到下一条消息的内容了）</p>
<p>这个问题由<strong>消息的物理结构</strong>解决，<strong>消息都具有固定的物理结构</strong>，包括：offset（8 Bytes）、消息体的大小（4 Bytes）、crc32（4 Bytes）、magic（1 Byte）、attributes（1 Byte）、key length（4 Bytes）、key（K Bytes）、payload（N Bytes）等等字段，可以确定一条消息的大小，即读取到哪里截止。</p>
<h4 id="2-2-复制原理和同步方式"><a href="#2-2-复制原理和同步方式" class="headerlink" title="2.2 复制原理和同步方式"></a>2.2 复制原理和同步方式</h4><p>Kafka 中 topic 的每个 partition 有一个预写式的日志文件，虽然 partition 可以继续细分为若干个 segment 文件，但是对于上层应用来说，仍然可以将 partition 看成最小的存储单元（一个有多个 segment 文件拼接的 “巨型” 文件），每个 partition 都由一些列有序的、不可变的消息组成，这些消息被连续的追加到 partition 中。</p>
<p><img src="5.jpg" alt="enter image description here"></p>
<p>上图中有两个新名词：HW 和 LEO。这里先介绍下 <strong>LEO，LogEndOffset 的缩写</strong>，表示每个 partition 的 log 最后一条 Message 的位置。<strong>HW 是 HighWatermark 的缩写</strong>，是指 consumer 能够看到的此 partition 的位置，这个涉及到多副本的概念，这里先提及一下，下文再详述。</p>
<p>言归正传，为了提高消息的可靠性，<strong>Kafka 每个 topic 的 partition 有 N 个副本（replicas）</strong>，其中 N（大于等于 1）是 topic 的复制因子（replica fator）的个数。<strong>Kafka 通过多副本机制实现故障自动转移</strong>，当 Kafka 集群中出现 broker 失效时，副本机制可保证服务可用。对于任何一个 partition，<strong>它的 N 个 replicas 中，其中一个 replica 为 leader，其他都为 follower，leader 负责处理 partition 的所有读写请求，follower 则负责被动地去复制 leader 上的数据</strong>。如下图所示，Kafka 集群中有 4 个 broker，某 topic 有 3 个 partition，且复制因子即副本个数也为 3：</p>
<p><img src="6.jpg" alt="enter image description here"></p>
<p>如果 leader 所在的 broker 发生故障或宕机，对应 partition 将因无 leader 而不能处理客户端请求，这时副本的作用就体现出来了：一个新 leader 将从 follower 中被选举出来并继续处理客户端的请求。</p>
<p><strong>如何确保新选举出的 leader 是优选呢？</strong></p>
<p>一个 partition 有多个副本（replicas），为了提高可靠性，<strong>这些副本分散在不同的 broker 上</strong>，由于带宽、读写性能、网络延迟等因素，同一时刻，这些<strong>副本的状态通常是不一致的</strong>：即 <strong>followers 与 leader 的状态不一致</strong>。那么，如何保证新选举出的 leader 是优选呢？ Kafka 机制中，leader 将负责维护和跟踪一个 <strong>ISR（In-Sync Replicas</strong>）列表，即<strong>同步副本队列</strong>，这个<strong>列表里面的副本与 leader 保持同步，状态一致</strong>。如果新的 leader 从 ISR 列表中的副本中选出，那么就可以保证新 leader 为优选。当然，这不是唯一的策略，下文将继续解读。</p>
<h4 id="2-3-同步副本-ISR"><a href="#2-3-同步副本-ISR" class="headerlink" title="2.3 同步副本 ISR"></a>2.3 同步副本 ISR</h4><p>上一节中讲到了<strong>同步副本队列 ISR（In-Sync Replicas）</strong>。虽然副本极大的增强了可用性，但是副本数量对 Kafka 的吞吐率有一定影响。<strong>默认情况下 Kafka 的 replica 数量为 1，即每个 partition 都只有唯一的 leader，无 follower，没有容灾能力</strong>。为了确保消息的可靠性，生产环境中，通常将其值（由 broker 的参数 offsets.topic.replication.factor 指定）大小设置为大于 1，比如 3。 <strong>所有的副本（replicas）统称为 Assigned Replicas，即 AR</strong>。<strong>ISR 是 AR 中的一个子集</strong>，<strong>由 leader 维护 ISR 列表</strong>，follower 从 leader 同步数据有一些延迟（由参数 replica.lag.time.max.ms <strong>设置超时阈值</strong>），<strong>超过阈值的 follower 将被剔除出 ISR， 存入 OSR（Outof-Sync Replicas）</strong>列表，新加入的 follower 也会先存放在 OSR 中。<strong>AR=ISR+OSR。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注：ISR中包括：leader + 与leader保持同步的followers。</span><br></pre></td></tr></table></figure>

<p>上面一节还涉及到一个概念，即 HW。<strong>HW 俗称高水位</strong>，HighWatermark 的缩写，<strong>取一个 partition 对应的 ISR 中最小的 LEO 作为 HW</strong>，<strong>consumer 最多只能消费到 HW 所在的位置</strong>。另外每个 replica 都有 HW，leader 和 follower 各自负责更新自己的 HW 的状态。<strong>对于 leader 新写入的消息，consumer 不能立刻消费，leader 会等待该消息被所有 ISR 中的 replicas 同步后更新 HW，此时消息才能被 consumer 消费。这样就保证了如果 leader 所在的 broker 失效，该消息仍然可以从新选举的 leader 中获取。对于来自内部 broker 的读取请求，没有 HW 的限制。</strong></p>
<p>下图详细的说明了当 producer 生产消息至 broker 后，ISR 以及 HW 和 LEO 的流转过程：</p>
<p><img src="7.jpg" alt="enter image description here"></p>
<p>由此可见，Kafka 的复制机制<strong>既不是完全的同步复制</strong>，<strong>也不是单纯的异步复制</strong>。事实上，<strong>同步复制要求所有能工作的 follower 都复制完，这条消息才会被 commit</strong>，这种复制方式受限于复制最慢的 follower，会极大的影响吞吐率。而<strong>异步复制方式下，follower 异步的从 leader 复制数据，数据只要被 leader 写入 log 就被认为已经 commit</strong>，这种情况下如果 follower 都还没有复制完，落后于 leader 时，突然 leader 宕机，则会丢失数据，降低可靠性。而 Kafka 使用 <strong>ISR</strong> 的策略则在可靠性和吞吐率方面取得了较好的平衡。</p>
<p>Kafka 的 ISR 的管理最终都会反馈到 ZooKeeper 节点上，具体位置为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/brokers/topics/[topic]/partitions/[partition]/state</span><br></pre></td></tr></table></figure>

<p>目前，有两个地方会对这个 ZooKeeper 的节点进行维护。</p>
<ol>
<li>Controller 来维护：<strong>Kafka 集群中的其中一个 Broker 会被选举为 Controller</strong>，<strong>主要负责 Partition 管理和副本状态管理</strong>，也会执行类似于重分配 partition 之类的管理任务。在符合某些特定条件下，Controller 下的 LeaderSelector 会选举新的 leader，ISR 和新的 <code>leader_epoch</code> 及 <code>controller_epoch</code> 写入 ZooKeeper 的相关节点中。同时发起 LeaderAndIsrRequest 通知所有的 replicas。</li>
<li>leader 来维护：leader 有单独的线程定期检测 ISR 中 follower 是否脱离 ISR，如果发现 ISR 变化，则会将新的 ISR 的信息返回到 ZooKeeper 的相关节点中。</li>
</ol>
<h4 id="2-4-数据可靠性和持久性保证"><a href="#2-4-数据可靠性和持久性保证" class="headerlink" title="2.4 数据可靠性和持久性保证"></a>2.4 数据可靠性和持久性保证</h4><p>当 producer 向 leader 发送数据时，可以通过 request.required.acks 参数来设置数据<strong>可靠性的级别</strong>：</p>
<p><strong>1. request.required.acks = 1</strong></p>
<p>这是<strong>默认情况</strong>，即：<strong>producer 发送数据到 leader，leader 写本地日志成功，返回客户端成功；此时 ISR 中的其它副本还没有来得及拉取该消息，如果此时 leader 宕机了，那么此次发送的消息就会丢失。</strong></p>
<p><strong>2. request.required.acks = 0</strong></p>
<p><strong>producer 不停向leader发送数据，而不需要 leader 反馈成功消息，这种情况下数据传输效率最高，但是数据可靠性确是最低的。可能在发送过程中丢失数据，可能在 leader 宕机时丢失数据。</strong></p>
<p><strong>3. request.required.acks = -1（all）</strong></p>
<p><strong>producer 发送数据给 leader，leader 收到数据后要等到 ISR 列表中的所有副本都同步数据完成后（强一致性），才向生产者返回成功消息，如果一直收不到成功消息，则认为发送数据失败会自动重发数据。这是可靠性最高的方案，当然，性能也会受到一定影响。</strong></p>
<p>*<em>注意：参数 min.insync.replicas *</em></p>
<p>如果要提高数据的可靠性，在设置 request.required.acks=-1 的同时，还需参数 min.insync.replicas 配合，如此才能发挥最大的功效。min.insync.replicas 这个参数用于设定 ISR 中的最小副本数，默认值为1，当且仅当 request.required.acks 参数设置为-1时，此参数才生效。当 ISR 中的副本数少于 min.insync.replicas 配置的数量时，客户端会返回异常：<code>org.apache.kafka.common.errors.NotEnoughReplicasExceptoin: Messages are rejected since there are fewer in-sync replicas than required</code>。不难理解，如果 min.insync.replicas 设置为 2，当 ISR 中实际副本数为 1 时（只有leader），将无法保证可靠性，此时拒绝客户端的写请求以防止消息丢失。</p>
<h4 id="2-5-深入解读-HW-机制"><a href="#2-5-深入解读-HW-机制" class="headerlink" title="2.5 深入解读 HW 机制"></a>2.5 深入解读 HW 机制</h4><p>考虑这样一种场景：acks=-1，部分 ISR 副本完成同步，此时leader挂掉，如下图所示：follower1 同步了消息 4、5，follower2 同步了消息 4，与此同时 follower2 被选举为 leader，那么此时 follower1 中的多出的消息 5 该做如何处理呢？</p>
<p><img src="8.jpg" alt="enter image description here"></p>
<p>这里就需要 HW 的协同配合了。如前所述，一个 partition 中的 ISR 列表中，<strong>leader 的 HW 是所有 ISR 列表里副本中最小的那个的 LEO</strong>。类似于木桶原理，水位取决于最低那块短板。</p>
<p><img src="9.jpg" alt="enter image description here"></p>
<p>如上图，某个 topic 的某 partition 有三个副本，分别为 A、B、C。A 作为 leader 肯定是 LEO 最高，B 紧随其后，C 机器由于配置比较低，网络比较差，故而同步最慢。这个时候 A 机器宕机，这时候如果 B 成为 leader，假如没有 HW，在 A 重新恢复之后会做同步（makeFollower) 操作，在宕机时 log 文件之后直接做追加操作，而假如 B 的 LEO 已经达到了 A 的 LEO，会产生数据不一致的情况，所以使用 HW 来避免这种情况。 A 在做同步操作的时候，先将 log 文件截断到之前自己的 HW 的位置，即 3，之后再从 B 中拉取消息进行同步。</p>
<p><strong>如果失败的 follower 恢复过来，它首先将自己的 log 文件截断到上次 checkpointed 时刻的 HW 的位置，之后再从 leader 中同步消息。leader 挂掉会重新选举，新的 leader 会发送 “指令” 让其余的 follower 截断至自身的 HW 的位置然后再拉取新的消息。</strong></p>
<p>当 ISR 中的个副本的 LEO 不一致时，如果此时 leader 挂掉，选举新的 leader 时并不是按照 LEO 的高低进行选举，而是按照 ISR 中的<strong>顺序选举</strong>。</p>
<h4 id="2-6-Leader-选举"><a href="#2-6-Leader-选举" class="headerlink" title="2.6 Leader 选举"></a>2.6 Leader 选举</h4><p>为了保证可靠性，对于任意一条消息，<strong>只有它被 ISR 中的所有 follower 都从 leader 复制过去才会被认为已提交</strong>，并返回信息给 producer。如此，可以避免因部分数据被写进 leader，而尚未被任何 follower 复制就宕机的情况下而造成数据丢失。对于 producer 而言，它可以选择是否等待消息 commit，这可以通过参数 <strong>request.required.acks</strong> 来设置。这种机制可以确保：只要 ISR 中有一个或者以上的 follower，一条被 commit 的消息就不会丢失。</p>
<p><strong>问题 1：如何在保证可靠性的前提下避免吞吐量下降？</strong></p>
<p>有一个很重要的问题是当 leader 宕机了，怎样在 follower 中选举出新的 leader，因为 follower 可能落后很多或者直接 crash 了，所以必须确保选择 “最新” 的 follower 作为新的 leader。一个基本的原则就是，如果 leader 挂掉，新的 leader 必须拥有原来的 leader 已经 commit 的所有消息，这不就是 ISR 中副本的特征吗？</p>
<p>但是，存在一个问题，ISR 列表维持多大的规模合适呢？换言之，<strong>leader 在一个消息被 commit 前需要等待多少个 follower 确认呢</strong>？等待 follower 的数量越多，与 leader 保持同步的 follower 就越多，可靠性就越高，但这也会造成吞吐率的下降。</p>
<p><strong>少数服从多数的选举原则</strong></p>
<p>一种常用的选举 leader 的策略是 “<strong>少数服从多数</strong>” ，不过，Kafka 并不是采用这种方式。这种模式下，如果有 2f+1 个副本，那么在 commit 之前必须保证有 f+1 个 replica 复制完消息，同时为了保证能正确选举出新的 leader，失败的副本数不能超过 f 个。这种方式有个很大的优势，系统的延迟取决于最快的几台机器，也就是说比如副本数为 3，那么延迟就取决于最快的那个 follower 而不是最慢的那个。</p>
<p>“少数服从多数” 的策略也有一些劣势，为了保证 leader 选举的正常进行，它所能容忍的失败的 follower 数比较少，如果要容忍 1 个 follower 挂掉，那么至少要 3 个以上的副本，如果要容忍 2 个 follower 挂掉，必须要有 5 个以上的副本。也就是说，<strong>在生产环境下为了保证较高的容错率，必须要有大量的副本，而大量的副本又会在大数据量下导致性能的急剧下降</strong>。这种算法更多用在 ZooKeeper 这种共享集群配置的系统中，而很少在需要大量数据的系统中使用。</p>
<p><strong>Kafka 选举 leader 的策略是怎样的？</strong></p>
<p>实际上，leader 选举的算法非常多，比如 ZooKeeper 的 Zab、Raft 以及 Viewstamped Replication。而 Kafka 所使用的 leader 选举算法更像是微软的 PacificA 算法。</p>
<p><strong>Kafka 在 ZooKeeper 中为每一个 partition 动态的维护了一个 ISR，这个 ISR 里的所有 replica 都与 leader 保持同步，只有 ISR 里的成员才能有被选为 leader 的可能</strong>（通过参数配置：<code>unclean.leader.election.enable=false</code>）。在这种模式下，<strong>对于 f+1 个副本，一个 Kafka topic 能在保证不丢失已经 commit 消息的前提下容忍 f 个副本的失败</strong>，在大多数使用场景下，这种模式是十分有利的。事实上，<strong>对于任意一条消息，只有它被 ISR 中的所有 follower 都从 leader 复制过去才会被认为已提交，并返回信息给 producer，从而保证可靠性</strong>。但与 “少数服从多数” 策略不同的是，<strong>Kafka ISR 列表中副本的数量不需要超过副本总数的一半，即不需要满足 “多数派” 原则，通常，ISR 列表副本数大于等于 2 即可，如此，便在可靠性和吞吐量方面取得平衡。</strong></p>
<p><strong>极端情况下的 leader 选举策略</strong></p>
<p>前已述及，当 ISR 中至少有一个 follower 时（<strong>ISR 包括 leader</strong>），Kafka 可以确保已经 commit 的消息不丢失，但如果某一个 partition 的所有 replica 都挂了，自然就无法保证数据不丢失了。这种情况下如何进行 leader 选举呢？通常有两种方案：</p>
<ol>
<li>等待 ISR 中任意一个 replica 恢复过来，并且选它作为 leader；</li>
<li><strong>选择第一个恢复过来的 replica（并不一定是在 ISR 中）作为leader。</strong>（默认）</li>
</ol>
<p>如何选择呢？这就需要在<strong>可用性和一致性</strong>当中作出抉择。如果一定要等待 ISR 中的 replica 恢复过来，不可用的时间就可能会相对较长。而且如果 ISR 中所有的 replica 都无法恢复了，或者数据丢失了，这个 partition 将永远不可用。</p>
<p>选择第一个恢复过来的 replica 作为 leader，如果这个 replica 不是 ISR 中的 replica，那么，它可能并不具备所有已经 commit 的消息，从而造成消息丢失。默认情况下，Kafka 采用第二种策略，即 <code>unclean.leader.election.enable=true</code>，也可以将此参数设置为 false 来启用第一种策略。</p>
<p><code>unclean.leader.election.enable</code> 这个参数对于 leader 的选举、系统的可用性以及数据的可靠性都有至关重要的影响。生产环境中应慎重权衡。</p>
<h3 id="3-Kafka-架构中-ZooKeeper-以怎样的形式存在？"><a href="#3-Kafka-架构中-ZooKeeper-以怎样的形式存在？" class="headerlink" title="3. Kafka 架构中 ZooKeeper 以怎样的形式存在？"></a>3. Kafka 架构中 ZooKeeper 以怎样的形式存在？</h3><p>ZooKeeper 是一个分布式的、开放源码的<strong>分布式应用程序协调服务</strong>，是 Google 的 Chubby 一个开源的实现。分布式应用程序可以基于它实现统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等工作。在基于 Kafka 的分布式消息队列中，ZooKeeper 的作用有：<strong>broker 注册</strong>、<strong>topic 注册</strong>、<strong>producer 和 consumer 负载均衡、维护 partition 与 consumer 的关系、记录消息消费的进度以及 consumer 注册等。</strong></p>
<h4 id="3-1-broker-在-ZooKeeper-中的注册"><a href="#3-1-broker-在-ZooKeeper-中的注册" class="headerlink" title="3.1 broker 在 ZooKeeper 中的注册"></a>3.1 broker 在 ZooKeeper 中的注册</h4><ul>
<li>为了记录 broker 的注册信息，在 ZooKeeper 上，<strong>专门创建了属于 Kafka 的一个节点</strong>，其路径为 /brokers；</li>
<li>Kafka 的每个 broker 启动时，都会到 ZooKeeper 中进行注册，告诉 ZooKeeper 其 broker.id，在整个集群中，broker.id 应该全局唯一，并在 ZooKeeper 上创建其属于自己的节点，其节点路径为 <code>/brokers/ids/{broker.id}</code>；</li>
<li>创建完节点后，Kafka 会将该 broker 的 broker.name 及端口号记录到该节点；</li>
<li>另外，该 <strong>broker 节点属性为临时节点</strong>，<strong>当 broker 会话失效时，ZooKeeper 会删除该节点，这样，我们就可以很方便的监控到broker 节点的变化，及时调整负载均衡等。</strong></li>
</ul>
<h4 id="3-2-Topic-在-ZooKeeper-中的注册"><a href="#3-2-Topic-在-ZooKeeper-中的注册" class="headerlink" title="3.2 Topic 在 ZooKeeper 中的注册"></a>3.2 Topic 在 ZooKeeper 中的注册</h4><p>在 Kafka 中，所有 <strong>topic 与 broker 的对应关系都由 ZooKeeper 进行维护</strong>，在 ZooKeeper 中，建立专门的节点来记录这些信息，其节点路径为 <code>/brokers/topics/{topic_name}</code>。 前面说过，为了保障数据的可靠性，<strong>每个 Topic 的 Partitions 实际上是存在备份的</strong>，并且<strong>备份的数量由 Kafka 机制中的 replicas 来控制</strong>。那么问题来了：如下图所示，假设某个 TopicA 被分为 2 个 Partitions，并且存在两个备份，由于这 2 个 Partitions（1-2）被分布在不同的 broker 上，同一个 partiton 与其备份不能（也不应该）存储于同一个 broker 上。以 Partition1 为例，假设它被存储于 broker2，其对应的备份分别存储于 broker1 和 broker4，有了备份，可靠性得到保障，但数据一致性却是个问题。</p>
<p><img src="10.jpg" alt="enter image description here"></p>
<p>为了保障数据的一致性，ZooKeeper 机制得以引入。<strong>基于 ZooKeeper，Kafka 为每一个 partition 找一个节点作为 leader，其余备份作为 follower</strong>；接续上图的例子，就 TopicA 的 partition1 而言，如果位于 broker2（Kafka 节点）上的 partition1 为 leader，那么位于 broker1 和 broker4 上面的 partition1 就充当 follower，则有下图：</p>
<p><img src="11.jpg" alt="enter image description here"></p>
<p>基于上图的架构，当 producer push 的消息写入 partition（分区) 时，作为 leader 的 broker（Kafka 节点） 会将消息写入自己的分区，同时还会将此消息复制到各个 follower，实现同步。如果，某个follower 挂掉，leader 会再找一个替代并同步消息；如果 leader 挂了，follower 们会选举出一个新的 leader 替代，继续业务，<strong>这些都是由 ZooKeeper 完成的。</strong></p>
<h4 id="3-3-consumer-在-ZooKeeper-中的注册"><a href="#3-3-consumer-在-ZooKeeper-中的注册" class="headerlink" title="3.3 consumer 在 ZooKeeper 中的注册"></a>3.3 consumer 在 ZooKeeper 中的注册</h4><p><strong>注册新的消费者分组</strong></p>
<p><strong>当新的消费者组注册到 ZooKeeper 中时，ZooKeeper 会创建专用的节点来保存相关信息</strong>，其节点路径为 <code>ls/consumers/{group_id}</code>，其节点下有三个子节点，分别为 <code>[ids, owners, offsets]</code>。</p>
<ul>
<li>ids 节点：记录该消费组中当前正在消费的消费者；</li>
<li>owners 节点：记录该消费组消费的 topic 信息；</li>
<li>offsets 节点：<strong>记录每个 topic 的每个分区的 offset</strong>。</li>
</ul>
<p><strong>注册新的消费者</strong></p>
<p>当新的消费者注册到 Kafka 中时，会在 <code>/consumers/{group_id}/ids</code> 节点下创建临时子节点，并记录相关信息。</p>
<p><strong>监听消费者分组中消费者的变化</strong></p>
<p>每个消费者都要关注其所属消费者组中消费者数目的变化，即监听 <code>/consumers/{group_id}/ids</code> 下子节点的变化。<strong>一旦发现消费者新增或减少，就会触发消费者的负载均衡。</strong></p>
<h4 id="3-4-Producers-负载均衡"><a href="#3-4-Producers-负载均衡" class="headerlink" title="3.4 Producers 负载均衡"></a>3.4 Producers 负载均衡</h4><p>对于同一个 topic 的不同 partition，<strong>Kafka会尽力将这些 partition 分布到不同的 broker 服务器上，这种均衡策略实际上是基于 ZooKeeper 实现的</strong>。<strong>在一个 broker 启动时，会首先完成 broker 的注册过程，并注册一些诸如 “有哪些可订阅的 topic” 之类的元数据信息。producers 启动后也要到 ZooKeeper 下注册，创建一个临时节点来监听 broker 服务器列表的变化。由于在 ZooKeeper 下 broker 创建的也是临时节点，当 brokers 发生变化时，producers 可以得到相关的通知，从改变自己的 broker list。其它的诸如 topic 的变化以及broker 和 topic 的关系变化，也是通过 ZooKeeper 的这种 Watcher 监听实现的。</strong></p>
<p>在生产中，必须指定 topic；但是对于 partition，有两种指定方式：</p>
<ul>
<li>明确指定 partition(0-N)，则数据被发送到指定 partition；</li>
<li>设置为 <code>RD_KAFKA_PARTITION_UA</code>，则 Kafka 会回调 partitioner 进行均衡选取，partitioner 方法需要自己实现。可以轮询或者传入 key 进行 hash。未实现则采用默认的随机方法 <code>rd_kafka_msg_partitioner_random</code> 随机选择。</li>
</ul>
<h4 id="3-5-Consumer-负载均衡"><a href="#3-5-Consumer-负载均衡" class="headerlink" title="3.5 Consumer 负载均衡"></a>3.5 Consumer 负载均衡</h4><p><strong>Kafka 保证同一 consumer group 中只有一个 consumer 可消费某条消息</strong>，实际上，Kafka 保证的是稳定状态下<strong>每一个 consumer 实例只会消费某一个或多个特定的数据</strong>，<strong>而某个 partition 的数据只会被某一个特定的 consumer 实例所消费</strong>。这样设计的劣势是无法让同一个 consumer group 里的 consumer 均匀消费数据，优势是每个 consumer 不用都跟大量的 broker 通信，减少通信开销，同时也降低了分配难度，实现也更简单。另外，因为<strong>同一个 partition 里的数据是有序的</strong>，这种设计可以保证每个 partition 里的数据也是有序被消费。</p>
<p><strong>consumer 数量不等于 partition 数量</strong></p>
<p>如果某 consumer group 中 consumer 数量少于 partition 数量，则至少有一个 consumer 会消费多个 partition 的数据；如果 consumer 的数量与 partition 数量相同，则正好一个 consumer 消费一个 partition 的数据，而如果 consumer 的数量多于 partition 的数量时，会有部分 consumer 无法消费该 topic 下任何一条消息。</p>
<p><strong>借助 ZooKeeper 实现负载均衡</strong></p>
<p>关于负载均衡，对于某些低级别的 API，consumer 消费时必须指定 topic 和 partition，这显然不是一种友好的均衡策略。基于高级别的 API，<strong>consumer 消费时只需制定 topic，借助 ZooKeeper 可以根据 partition 的数量和 consumer 的数量做到均衡的动态配置。</strong></p>
<p><strong>consumers 在启动时会到 ZooKeeper 下以自己的 conusmer-id 创建临时节点</strong> <code>/consumer/[group-id]/ids/[conusmer-id]</code>，并对 <code>/consumer/[group-id]/ids</code> <strong>注册监听事件</strong>，当消费者发生变化时，同一 group 的其余消费者会得到通知。当然，<strong>消费者还要监听 broker 列表的变化</strong>。librdkafka 通常会将 partition 进行排序后，根据消费者列表，进行轮流的分配。</p>
<h4 id="3-6-记录消费进度-Offset"><a href="#3-6-记录消费进度-Offset" class="headerlink" title="3.6 记录消费进度 Offset"></a>3.6 记录消费进度 Offset</h4><p>在 consumer 对指定消息 partition 的消息进行消费的过程中，需要定时地将 <strong>partition 消息的消费进度 Offset 记录到 ZooKeeper</strong>上，以便在<strong>该 consumer 进行重启或者其它 consumer 重新接管该消息分区的消息消费权后，能够从之前的进度开始继续进行消息消费</strong>。<strong>Offset 在 ZooKeeper 中由一个专门节点进行记录</strong>，其节点路径为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#节点内容就是Offset的值。</span><br><span class="line">/consumers/[group_id]/offsets/[topic]/[broker_id-partition_id]</span><br></pre></td></tr></table></figure>

<p>PS：<strong>Kafka 已推荐将 consumer 的 Offset 信息保存在 Kafka 内部的 topic 中</strong>，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__consumer_offsets(/brokers/topics/__consumer_offsets)</span><br></pre></td></tr></table></figure>

<p>并且默认提供了 <code>kafka_consumer_groups.sh</code> 脚本<strong>供用户查看consumer 信息</strong>（命令：<code>sh kafka-consumer-groups.sh –bootstrap-server * –describe –group *</code>）。在当前版本中，offset 存储方式要么存储在本地文件中，要么存储在 broker 端，具体的存储方式取决 <code>offset.store.method</code> 的配置，默认是存储在 broker 端。</p>
<h4 id="3-7-记录-Partition-与-Consumer-的关系"><a href="#3-7-记录-Partition-与-Consumer-的关系" class="headerlink" title="3.7 记录 Partition 与 Consumer 的关系"></a>3.7 记录 Partition 与 Consumer 的关系</h4><p>consumer group 下有多个 consumer（消费者），对于每个消费者组（consumer group），Kafka都会为其分配一个全局唯一的 group ID，group 内部的所有消费者共享该 ID。<strong>订阅的 topic 下的每个分区只能分配给某个 group 下的一个consumer</strong>（<strong>当然该分区还可以被分配给其它 group</strong>）。同时，Kafka 为每个消费者分配一个 consumer ID，通常采用 <code>hostname:UUID</code> 形式表示。</p>
<p>在Kafka中，规定了<strong>每个 partition 只能被同组的一个消费者进行消费</strong>，因此，<strong>需要在 ZooKeeper 上记录下 partition 与 consumer 之间的关系</strong>，<strong>每个 consumer 一旦确定了对一个 partition 的消费权力，需要将其 consumer ID 写入到 ZooKeeper 对应消息分区的临时节点</strong>上，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/consumers/[group_id]/owners/[topic]/[broker_id-partition_id]</span><br></pre></td></tr></table></figure>

<p>其中，[<code>broker_id-partition_id</code>] 就是一个消息分区的标识，节点内容就是该消息分区 消费者的 consumer ID。</p>
<h3 id="4-全程解析（Producer-kafka-consumer）"><a href="#4-全程解析（Producer-kafka-consumer）" class="headerlink" title="4. 全程解析（Producer-kafka-consumer）"></a>4. 全程解析（Producer-kafka-consumer）</h3><h4 id="4-1-producer-发布消息"><a href="#4-1-producer-发布消息" class="headerlink" title="4.1 producer 发布消息"></a>4.1 producer 发布消息</h4><p><strong>producer 采用 push 模式将消息发布到 broker</strong>，<strong>每条消息都被 append 到 patition</strong> 中，属于顺序写磁盘（顺序写磁盘效率比随机写内存要高，保障 kafka 吞吐率）。producer 发送消息到 broker 时，<strong>会根据分区算法选择将其存储到哪一个 partition。</strong></p>
<p><strong>其路由机制为：</strong></p>
<ol>
<li>指定了 patition，则直接使用；</li>
<li>未指定 patition 但指定 key，通过对 key 进行 hash 选出一个 patition；</li>
<li>patition 和 key 都未指定，使用轮询选出一个 patition。</li>
</ol>
<p><strong>写入流程：</strong></p>
<ol>
<li>producer 先从 ZooKeeper 的 “/brokers/…/state” <strong>节点找到该 partition 的leader；</strong></li>
<li>producer 将消息发送给该 leader；</li>
<li>leader 将消息写入本地 log；</li>
<li>followers 从 leader <strong>pull</strong> 消息，写入本地 log 后 leader 发送 <strong>ACK</strong>；</li>
<li>leader 收到所有 ISR 中的 replica 的 ACK 后，增加 <strong>HW</strong>（high watermark，最后 commit 的 offset） 并向 producer 发送 <strong>ACK</strong>；</li>
</ol>
<h4 id="4-2-Broker-存储消息"><a href="#4-2-Broker-存储消息" class="headerlink" title="4.2 Broker 存储消息"></a>4.2 Broker 存储消息</h4><p><strong>物理上把 topic 分成一个或多个 patition</strong>，<strong>每个 patition 物理上对应一个文件夹</strong>（该文件夹存储该 patition 的所有<strong>消息和索引文件</strong>）</p>
<h4 id="4-3-Consumer-消费消息"><a href="#4-3-Consumer-消费消息" class="headerlink" title="4.3 Consumer 消费消息"></a>4.3 Consumer 消费消息</h4><p>high-level consumer API 提供了 consumer group 的语义，<strong>一个消息只能被 group 内的一个 consumer 所消费，且 consumer 消费消息时不关注 offset，最后一个 offset 由 ZooKeeper 保存</strong>（下次消费时，该group 中的consumer将从offset记录的位置开始消费）。</p>
<p><strong>注意：</strong></p>
<ol>
<li>如果消费线程大于 patition 数量，则有些线程将收不到消息；</li>
<li>如果 patition 数量大于消费线程数，则有些线程多收到多个 patition 的消息；</li>
<li>如果一个线程消费多个 patition，则无法保证你收到的消息的顺序，而<strong>一个 patition 内的消息是有序的</strong>。</li>
</ol>
<p><strong>consumer 采用 pull 模式从 broker 中读取数据。</strong></p>
<p><strong>push 模式很难适应消费速率不同的消费者</strong>，因为消息发送速率是由 broker 决定的。它的目标是尽可能以最快速度传递消息，但是这样很容易造成 consumer 来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而 pull 模式则可以根据 consumer 的消费能力以适当的速率消费消息。</p>
<p>对于 Kafka 而言，pull 模式更合适，它可简化 broker 的设计，consumer 可自主控制消费消息的速率，同时 consumer 可以自己控制消费方式——即可批量消费也可逐条消费，同时还能选择不同的提交方式从而实现不同的传输语义。</p>
<blockquote>
<p>上述文章参考自：<a href="https://gitbook.cn/books/5ae1e77197c22f130e67ec4e/index.html" target="_blank" rel="noopener">深入浅出理解基于 Kafka 和 ZooKeeper 的分布式消息队列</a></p>
</blockquote>

      
    </div>

    

    
    
    

    

    
      
    
    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="changsk 微信支付">
        <p>微信支付</p>
      </div>
    

    

    

  </div>
</div>

      </div>
    

    
      <div>
        



  



<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>changsk</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    
    <a href="http://changsk.top/2019/06/17/kafka-zookeeper/" title="深入浅出理解基于 Kafka 和 ZooKeeper 的分布式消息队列">http://changsk.top/2019/06/17/kafka-zookeeper/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li>
</ul>

      </div>
    


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/kafka/" rel="tag"><i class="fa fa-tag"></i> kafka</a>
          
            <a href="/tags/zookeeper/" rel="tag"><i class="fa fa-tag"></i> zookeeper</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        

        

        
          
          <div class="social_share">
            
            
               <div id="needsharebutton-postbottom">
                 <span class="btn">
                    <i class="fa fa-share-alt" aria-hidden="true"></i>
                 </span>
               </div>
            
          </div>
        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/06/17/java-sleep-wait/" rel="next" title="java中sleep和wait的区别">
                <i class="fa fa-chevron-left"></i> java中sleep和wait的区别
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/06/17/what-is-resuful/" rel="prev" title="什么是restful？">
                什么是restful？ <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/me/me.jpg" alt="changsk">
            
              <p class="site-author-name" itemprop="name">changsk</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">261</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">33</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">116</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/Tkzccsk" title="GitHub &rarr; https://github.com/Tkzccsk" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:2486623255@qq.com" title="E-Mail &rarr; mailto:2486623255@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://blog.csdn.net/tkzc_csk" title="CSDN &rarr; https://blog.csdn.net/tkzc_csk" rel="noopener" target="_blank"><i class="fa fa-fw fa-crosshairs"></i>CSDN</a>
                </span>
              
            </div>
          

          
             <div class="cc-license motion-element" itemprop="license">
              
                
              
              
              
              <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
             </div>
          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Kafka-总体架构"><span class="nav-number">1.</span> <span class="nav-text">1. Kafka 总体架构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-Topic-amp-Partition"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 Topic &amp; Partition</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-Kafka-为什么要将-Topic-进行分区？"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 Kafka 为什么要将 Topic 进行分区？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Kafka-高可靠性实现基础解读"><span class="nav-number">2.</span> <span class="nav-text">2. Kafka 高可靠性实现基础解读</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-Kafka-文件存储机制"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 Kafka 文件存储机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-复制原理和同步方式"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 复制原理和同步方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-同步副本-ISR"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 同步副本 ISR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-数据可靠性和持久性保证"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 数据可靠性和持久性保证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-深入解读-HW-机制"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 深入解读 HW 机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-Leader-选举"><span class="nav-number">2.6.</span> <span class="nav-text">2.6 Leader 选举</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Kafka-架构中-ZooKeeper-以怎样的形式存在？"><span class="nav-number">3.</span> <span class="nav-text">3. Kafka 架构中 ZooKeeper 以怎样的形式存在？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-broker-在-ZooKeeper-中的注册"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 broker 在 ZooKeeper 中的注册</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-Topic-在-ZooKeeper-中的注册"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 Topic 在 ZooKeeper 中的注册</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-consumer-在-ZooKeeper-中的注册"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 consumer 在 ZooKeeper 中的注册</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-Producers-负载均衡"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 Producers 负载均衡</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-Consumer-负载均衡"><span class="nav-number">3.5.</span> <span class="nav-text">3.5 Consumer 负载均衡</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-记录消费进度-Offset"><span class="nav-number">3.6.</span> <span class="nav-text">3.6 记录消费进度 Offset</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-记录-Partition-与-Consumer-的关系"><span class="nav-number">3.7.</span> <span class="nav-text">3.7 记录 Partition 与 Consumer 的关系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-全程解析（Producer-kafka-consumer）"><span class="nav-number">4.</span> <span class="nav-text">4. 全程解析（Producer-kafka-consumer）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-producer-发布消息"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 producer 发布消息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-Broker-存储消息"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 Broker 存储消息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-Consumer-消费消息"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 Consumer 消费消息</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">changsk</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">997k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">15:06</span>
  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    
      <div id="needsharebutton-float">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
    
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>



  
  











  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script src="/lib/three/three.min.js"></script>

  
  <script src="/lib/three/three-waves.min.js"></script>


  


  <script src="/js/src/utils.js?v=6.7.0"></script>

  <script src="/js/src/motion.js?v=6.7.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.7.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.7.0"></script>




  
  <script src="/js/src/scrollspy.js?v=6.7.0"></script>
<script src="/js/src/post-details.js?v=6.7.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.7.0"></script>



  


  


  

  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  
  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>
  <script>
    
      pbOptions = {};
      
        pbOptions.iconStyle = "box";
      
        pbOptions.boxForm = "horizontal";
      
        pbOptions.position = "bottomCenter";
      
        pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
      flOptions = {};
      
        flOptions.iconStyle = "box";
      
        flOptions.boxForm = "horizontal";
      
        flOptions.position = "middleRight";
      
        flOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-float', flOptions);
    
  </script>


  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function(i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap');
      $(e).after($wrap);
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
        var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
          return $(e).text();
        }).toArray().join('\n');
        var ta = document.createElement('textarea');
        var range = document.createRange(); //For Chrome
        var sel = window.getSelection(); //For Chrome
        var yPosition = window.pageYOffset || document.documentElement.scrollTop;
        ta.style.top = yPosition + 'px'; //Prevent page scroll
        ta.style.position = 'absolute';
        ta.style.opacity = '0';
        ta.value = code;
        ta.textContent = code; //For FireFox
        ta.contentEditable = true;
        ta.readOnly = false;
        document.body.appendChild(ta);
        range.selectNode(ta);
        sel.removeAllRanges();
        sel.addRange(range);
        ta.setSelectionRange(0, code.length);
        var result = document.execCommand('copy');
        
          if (result) $(this).text('复制成功');
          else $(this).text('复制失败');
        
        ta.blur(); //For iOS
        $(this).blur();
      })).on('mouseleave', function(e) {
        var $b = $(this).find('.copy-btn');
        setTimeout(function() {
          $b.text('复制');
        }, 300);
      }).append(e);
    })
  </script>


  

</body>
</html>

<script type="text/javascript" src="/js/src/clicklove.js"></script>
