<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>changsk&#39;s blogs</title>
  
  <subtitle>chang.sk@foxmail.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://changsk.top/"/>
  <updated>2019-07-03T12:44:43.608Z</updated>
  <id>http://changsk.top/</id>
  
  <author>
    <name>changsk</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指offer-链表中环的入口结点</title>
    <link href="http://changsk.top/2019/07/03/jianzhioffer-entrance-node/"/>
    <id>http://changsk.top/2019/07/03/jianzhioffer-entrance-node/</id>
    <published>2019-07-03T12:35:06.000Z</published>
    <updated>2019-07-03T12:44:43.608Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p><a id="more"></a><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><img src="1.jpg" alt></p><p>假设x为环前面的路程（黑色路程），a为环入口到相遇点的路程（蓝色路程，假设顺时针走）， c为环的长度（蓝色+橙色路程）<br>当快慢指针相遇的时候：</p><p>此时慢指针走的路程为Sslow = x + m * c + a<br>快指针走的路程为Sfast = x + n * c + a<br>2 Sslow = Sfast<br>2 * ( x + m<em>c + a ) = (x + n *c + a)<br>从而可以推导出：<br>x = (n - 2 * m )</em>c - a<br>= (n - 2 <em>m -1 )</em>c + c - a<br>即环前面的路程 = 数个环的长度（为可能为0） + c - a<br>什么是c - a？这是相遇点后，环后面部分的路程。（橙色路程）<br>所以，我们可以让一个指针从起点A开始走，让一个指针从相遇点B开始继续往后走，<br>2个指针速度一样，那么，当从原点的指针走到环入口点的时候（此时刚好走了x）<br>从相遇点开始走的那个指针也一定刚好到达环入口点。<br>所以2者会相遇，且恰好相遇在环的入口点。</p><p>最后，判断是否有环，且找环的算法复杂度为：</p><blockquote><p>时间复杂度：O(n)<br>空间复杂度：O(1)</p></blockquote><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//头结点为空，或者只有头结点的情况</span></span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode p1 = pHead;<span class="comment">//慢指针</span></span><br><span class="line">        ListNode p2 = pHead;<span class="comment">//快指针</span></span><br><span class="line">        <span class="keyword">while</span>(p2 != <span class="keyword">null</span> &amp;&amp; p2.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">                p2 = p2.next.next;</span><br><span class="line">            <span class="comment">//快慢指针相遇</span></span><br><span class="line">            <span class="keyword">if</span>(p1 == p2)&#123;</span><br><span class="line">                p1 = pHead;</span><br><span class="line">                <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line">                    p1 = p1.next;</span><br><span class="line">                    p2 = p2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> p1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="http://changsk.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="http://changsk.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-字符流中第一个不重复的字符</title>
    <link href="http://changsk.top/2019/07/03/jianzhioffer-first-char/"/>
    <id>http://changsk.top/2019/07/03/jianzhioffer-first-char/</id>
    <published>2019-07-03T12:08:54.000Z</published>
    <updated>2019-07-03T12:27:09.345Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h3><p>如果当前字符流没有存在出现一次的字符，返回#字符。</p><a id="more"></a><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><ol><li><p>创建一个长度为256的char数组(ascii字符用一个字节表示)。</p></li><li><p>数组的下标表示字符（数字可以表示字符），数组中的值由3种数字组成</p><blockquote><p>0，代表该字符没有出现过</p><p>-1，表示该字符出现过不止一次</p><p>其他值，表示该字符是<strong>第一次出现的字符</strong>当中的第几个</p></blockquote></li><li><p>每次遍历数组，寻找只出现过一次且出现次序最小的字符。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//记录一个字符第一次出现的次序</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] chars = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(chars[ch] == <span class="number">0</span>) chars[ch] = ++index;</span><br><span class="line">        <span class="keyword">else</span> chars[ch] = -<span class="number">1</span>; <span class="comment">//-1代表重复出现</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">char</span> c = <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">255</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//一个字符出现过，且只出现过一次，且出现的次序比之前的小</span></span><br><span class="line">            <span class="keyword">if</span>(chars[i] != <span class="number">0</span> &amp;&amp; chars[i] != -<span class="number">1</span> &amp;&amp; chars[i] &lt; min)&#123;</span><br><span class="line">                min = chars[i];</span><br><span class="line">                c = (<span class="keyword">char</span>)i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。&lt;/p&gt;
&lt;h3 id=&quot;输出描述&quot;&gt;&lt;a href=&quot;#输出描述&quot; class=&quot;headerlink&quot; title=&quot;输出描述&quot;&gt;&lt;/a&gt;输出描述&lt;/h3&gt;&lt;p&gt;如果当前字符流没有存在出现一次的字符，返回#字符。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="http://changsk.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="http://changsk.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-表示数值的字符串</title>
    <link href="http://changsk.top/2019/07/03/jianzhioffer-num-str/"/>
    <id>http://changsk.top/2019/07/03/jianzhioffer-num-str/</id>
    <published>2019-07-03T11:30:27.000Z</published>
    <updated>2019-07-03T11:46:44.286Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,“5e2”,”-123”,“3.1416”和”-1E-16”都表示数值。 但是”12e”,“1a3.14”,“1.2.3”,”±5”和”12e+4.3”都不是。</p><a id="more"></a><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><blockquote><p>利用 java中的正则表达式匹配可以很容易的写出来</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        String s=String.valueOf(str);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. X?   X，一次或一次也没有</span></span><br><span class="line"><span class="comment">        2. X*   X，零次或多次</span></span><br><span class="line"><span class="comment">        3. java 正则表达式中 . 表示任何字符。若要匹配 . 要用转义 \\.</span></span><br><span class="line"><span class="comment">        4. X+   X，一次或多次 </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> s.matches(<span class="string">"[+-]?[0-9]*(\\.[0-9]+)?([eE][+-]?[0-9]+)?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,“5e2”,”-123”,“3.1416”和”-1E-16”都表示数值。 但是”12e”,“1a3.14”,“1.2.3”,”±5”和”12e+4.3”都不是。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="http://changsk.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="http://changsk.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-构建乘积数组</title>
    <link href="http://changsk.top/2019/07/03/jianzhioffer-product-array/"/>
    <id>http://changsk.top/2019/07/03/jianzhioffer-product-array/</id>
    <published>2019-07-03T11:05:25.000Z</published>
    <updated>2019-07-03T11:09:03.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]。<strong>不能使用除法</strong>。</p><a id="more"></a><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><img src="1.jpg" alt></p><p><code>B[i]</code>的值可以看作上图的矩阵中每行的乘积。<br>每个B[i]都可以分为两部分（1左边的位一部分，右边的又是一部分）。<br>下三角用连乘可以很容求得，同理可得上三角。<br>先算下三角中的连乘，即我们先算出B[i]中的一部分，然后倒过来按上三角中的分布规律，把另一部分也乘进去。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> len = A.length;</span><br><span class="line">        <span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="comment">//下三角</span></span><br><span class="line">        B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++) B[i] = B[i - <span class="number">1</span>] * A[i - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//上三角</span></span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">2</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            tmp *= A[i + <span class="number">1</span>];</span><br><span class="line">            B[i] *= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]&lt;em&gt;A[1]&lt;/em&gt;…&lt;em&gt;A[i-1]&lt;/em&gt;A[i+1]&lt;em&gt;…&lt;/em&gt;A[n-1]。&lt;strong&gt;不能使用除法&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="http://changsk.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="http://changsk.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>redis概述</title>
    <link href="http://changsk.top/2019/07/03/redis-summary/"/>
    <id>http://changsk.top/2019/07/03/redis-summary/</id>
    <published>2019-07-03T02:39:16.000Z</published>
    <updated>2019-07-03T11:00:17.604Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考：<a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes</a></p></blockquote><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><code>Redis</code> 是速度非常快的<strong>非关系型（NoSQL）内存键值数据库</strong>，可以存储键和五种不同类型的值之间的映射。</p><p><strong>键的类型只能为字符串</strong>，值支持五种数据类型：<strong>字符串、列表、集合、散列表、有序集合。</strong></p><p>Redis 支持很多特性，例如<strong>将内存中的数据持久化到硬盘中</strong>，<strong>使用复制来扩展读性能</strong>，<strong>使用分片来扩展写性能。</strong></p><a id="more"></a><h1 id="数据类型-值的类型"><a href="#数据类型-值的类型" class="headerlink" title="数据类型(值的类型)"></a>数据类型(值的类型)</h1><table><thead><tr><th align="center">数据类型</th><th align="center">可以存储的值</th><th align="center">操作</th></tr></thead><tbody><tr><td align="center">STRING</td><td align="center">字符串、整数或者浮点数</td><td align="center">对整个字符串或者字符串的其中一部分执行操作<br> 对整数和浮点数执行自增或者自减操作</td></tr><tr><td align="center">LIST</td><td align="center">列表</td><td align="center">从两端压入或者弹出元素 <br> 对单个或者多个元素<br> 进行修剪，只保留一个范围内的元素</td></tr><tr><td align="center">SET</td><td align="center">无序集合</td><td align="center">添加、获取、移除单个元素<br> 检查一个元素是否存在于集合中<br> 计算交集、并集、差集<br> 从集合里面随机获取元素</td></tr><tr><td align="center">HASH</td><td align="center">包含键值对的无序散列表</td><td align="center">添加、获取、移除单个键值对<br> 获取所有键值对<br> 检查某个键是否存在</td></tr><tr><td align="center">ZSET</td><td align="center">有序集合</td><td align="center">添加、获取、删除元素<br> 根据分值范围或者成员来获取元素<br> 计算一个键的排名</td></tr></tbody></table><blockquote><p><a href="https://redislabs.com/ebook/part-1-getting-started/chapter-1-getting-to-know-redis/1-2-what-redis-data-structures-look-like/" target="_blank" rel="noopener">What Redis data structures look like</a></p></blockquote><h2 id="STRING"><a href="#STRING" class="headerlink" title="STRING"></a>STRING</h2><p><img src="1.png" alt></p><blockquote><p>set hello world<br>OK<br>get hello<br>“world”<br>del hello<br>(integer) 1<br>get hello<br>(nil)</p></blockquote><h2 id="LIST"><a href="#LIST" class="headerlink" title="LIST"></a>LIST</h2><p><img src="2.png" alt></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt; rpush list-key item</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; rpush list-key item2</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; rpush list-key item</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">&gt; lrange list-key 0 -1</span><br><span class="line">1) "item"</span><br><span class="line">2) "item2"</span><br><span class="line">3) "item"</span><br><span class="line"></span><br><span class="line">&gt; lindex list-key 1</span><br><span class="line">"item2"</span><br><span class="line"></span><br><span class="line">&gt; lpop list-key</span><br><span class="line">"item"</span><br><span class="line"></span><br><span class="line">&gt; lrange list-key 0 -1</span><br><span class="line">1) "item2"</span><br><span class="line">2) "item"</span><br></pre></td></tr></table></figure><h2 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h2><p><img src="3.png" alt></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt; sadd set-key item</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item3</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; sadd set-key item</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; smembers set-key</span><br><span class="line">1) "item"</span><br><span class="line">2) "item2"</span><br><span class="line">3) "item3"</span><br><span class="line"></span><br><span class="line">&gt; sismember set-key item4</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; sismember set-key item</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">&gt; srem set-key item2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; srem set-key item2</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; smembers set-key</span><br><span class="line">1) "item"</span><br><span class="line">2) "item3"</span><br></pre></td></tr></table></figure><h2 id="HASH"><a href="#HASH" class="headerlink" title="HASH"></a>HASH</h2><p><img src="4.png" alt></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt; hset hash-key sub-key1 value1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hset hash-key sub-key2 value2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hset hash-key sub-key1 value1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; hgetall hash-key</span><br><span class="line">1) "sub-key1"</span><br><span class="line">2) "value1"</span><br><span class="line">3) "sub-key2"</span><br><span class="line">4) "value2"</span><br><span class="line"></span><br><span class="line">&gt; hdel hash-key sub-key2</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; hdel hash-key sub-key2</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; hget hash-key sub-key1</span><br><span class="line">"value1"</span><br><span class="line"></span><br><span class="line">&gt; hgetall hash-key</span><br><span class="line">1) "sub-key1"</span><br><span class="line">2) "value1"</span><br></pre></td></tr></table></figure><h2 id="ZSET"><a href="#ZSET" class="headerlink" title="ZSET"></a>ZSET</h2><p><img src="5.png" alt></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt; zadd zset-key 728 member1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd zset-key 982 member0</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zadd zset-key 982 member0</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; zrange zset-key 0 -1 withscores</span><br><span class="line">1) "member1"</span><br><span class="line">2) "728"</span><br><span class="line">3) "member0"</span><br><span class="line">4) "982"</span><br><span class="line"></span><br><span class="line">&gt; zrangebyscore zset-key 0 800 withscores</span><br><span class="line">1) "member1"</span><br><span class="line">2) "728"</span><br><span class="line"></span><br><span class="line">&gt; zrem zset-key member1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; zrem zset-key member1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">&gt; zrange zset-key 0 -1 withscores</span><br><span class="line">1) "member0"</span><br><span class="line">2) "982"</span><br></pre></td></tr></table></figure><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p><strong>dictht</strong> 是一个散列表结构，<strong>使用拉链法保存哈希冲突。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p>Redis 的字典 dict 中包含两个哈希表 dictht，这是为了方便进行 rehash 操作。在扩容时，将其中一个 dictht 上的键值对 rehash 到另一个 dictht 上面，完成之后释放空间并交换两个 dictht 的角色。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>rehash 操作不是一次性完成，而是采用渐进方式，<strong>这是为了避免一次性执行过多的 rehash 操作给服务器带来过大的负担。</strong></p><p>渐进式 rehash 通过记录 dict 的 rehashidx 完成，它从 0 开始，然后每执行一次 rehash 都会递增。例如在一次 rehash 中，要把 dict[0] rehash 到 dict[1]，这一次会把 dict[0] 上 table[rehashidx] 的键值对 rehash 到 dict[1] 上，dict[0] 的 table[rehashidx] 指向 null，并令 rehashidx++。</p><p>在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash。</p><p>采用渐进式 rehash 会导致字典中的数据分散在两个 dictht 上，因此对字典的查找操作也需要到对应的 dictht 去执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Performs N steps of incremental rehashing. Returns 1 if there are still</span></span><br><span class="line"><span class="comment"> * keys to move from the old to the new hash table, otherwise 0 is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that a rehashing step consists in moving a bucket (that may have more</span></span><br><span class="line"><span class="comment"> * than one key as we use chaining) from the old to the new hash table, however</span></span><br><span class="line"><span class="comment"> * since part of the hash table may be composed of empty spaces, it is not</span></span><br><span class="line"><span class="comment"> * guaranteed that this function will rehash even a single bucket, since it</span></span><br><span class="line"><span class="comment"> * will visit at max N*10 empty buckets in total, otherwise the amount of</span></span><br><span class="line"><span class="comment"> * work it does would be unbound and the function may block for a long time. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> empty_visits = n * <span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can't overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) d-&gt;rehashidx);</span><br><span class="line">        <span class="keyword">while</span> (d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="keyword">while</span> (de) &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More to rehash... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><p><strong>是有序集合的底层实现之一。</strong></p><p><strong>跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。</strong></p><p><img src="6.png" alt><br>在查找时，从上层指针开始查找，找到对应的区间之后再到下一层去查找。下图演示了查找 22 的过程。</p><p><img src="7.png" alt><br>与红黑树等平衡树相比，跳跃表具有以下优点：</p><ul><li><strong>插入速度非常快速，因为不需要进行旋转等操作来维护平衡性；</strong></li><li>更容易实现；</li><li>支持无锁操作。</li></ul><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><p>可以对 String 进行自增自减运算，从而实现计数器功能。</p><p><strong>Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</strong></p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p><strong>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</strong></p><h2 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h2><p><strong>例如 DNS 记录就很适合使用 Redis 进行存储。</strong></p><p>查找表和缓存类似，也是利用了 Redis 快速的查找特性。<strong>但是查找表的内容不能失效，而缓存的内容可以失效</strong>,<strong>因为缓存不作为可靠的数据来源。</strong></p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>List 是一个双向链表，可以通过 <strong>lpop</strong> 和 <strong>lpush</strong> 写入和读取消息。</p><p>不过最好使用 Kafka、RabbitMQ 等消息中间件。</p><h2 id="会话缓存"><a href="#会话缓存" class="headerlink" title="会话缓存"></a>会话缓存</h2><p>可以使用 Redis 来统一存储多台应用服务器的会话信息。</p><p>当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p><h2 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h2><p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。</p><p>可以使用 Reids 自带的 <strong>SETNX</strong> 命令实现分布式锁，除此之外，<strong>还可以使用官方提供的 RedLock 分布式锁实现。</strong></p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p><strong>Set 可以实现交集、并集等操作，从而实现共同好友等功能。</strong></p><p><strong>ZSet 可以实现有序性操作，从而实现排行榜等功能。</strong></p><h1 id="Redis-与-Memcached"><a href="#Redis-与-Memcached" class="headerlink" title="Redis 与 Memcached"></a>Redis 与 Memcached</h1><p><strong>两者都是非关系型内存键值数据库</strong>，主要有以下不同：</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><strong>Memcached 仅支持字符串类型</strong>，而 Redis 支持五种不同的数据类型，可以更灵活地解决问题。</p><h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><p>Redis 支持两种持久化策略：<strong>RDB</strong> 快照和 <strong>AOF</strong> 日志，<strong>而 Memcached 不支持持久化。</strong></p><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p><strong>Memcached 不支持分布式</strong>，<strong>只能通过在客户端使用一致性哈希来实现分布式存储</strong>，<strong>这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。</strong></p><p><strong>Redis Cluster 实现了分布式的支持。</strong></p><h2 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h2><ul><li>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 <strong>Memcached 的数据则会一直在内存中。</strong></li><li><strong>Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</strong></li></ul><h1 id="键的过期时间"><a href="#键的过期时间" class="headerlink" title="键的过期时间"></a>键的过期时间</h1><p><strong>Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。</strong></p><p>对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。</p><h1 id="数据淘汰策略"><a href="#数据淘汰策略" class="headerlink" title="数据淘汰策略"></a>数据淘汰策略</h1><p>可以设置内存最大使用量，<strong>当内存使用量超出时，会施行数据淘汰策略。</strong></p><p>Reids 具体有 6 种淘汰策略：</p><table><thead><tr><th align="center">策略</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">volatile-lru</td><td align="center">从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td align="center">volatile-ttl</td><td align="center">从已设置过期时间的数据集中挑选将要过期的数据淘汰</td></tr><tr><td align="center">volatile-random</td><td align="center">从已设置过期时间的数据集中任意选择数据淘汰</td></tr><tr><td align="center">allkeys-lru</td><td align="center">从所有数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td align="center">allkeys-random</td><td align="center">从所有数据集中任意选择数据进行淘汰</td></tr><tr><td align="center">noeviction</td><td align="center">禁止驱逐数据</td></tr></tbody></table><p>作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。</p><p><strong>使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据</strong>。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 <strong>allkeys-lru</strong> 淘汰策略，<strong>将最近最少使用的数据淘汰。</strong></p><p>Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。</p><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要<strong>将内存中的数据持久化到硬盘</strong>上。</p><h2 id="RDB-持久化"><a href="#RDB-持久化" class="headerlink" title="RDB 持久化"></a>RDB 持久化</h2><p>将某个时间点的所有数据都存放到硬盘上。</p><p><strong>可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。</strong></p><p><strong>如果系统发生故障，将会丢失最后一次创建快照之后的数据。</strong></p><p><strong>如果数据量很大，保存快照的时间会很长。</strong></p><h2 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h2><p><strong>将写命令添加到 AOF 文件（Append Only File）的末尾。</strong></p><p>使用 AOF 持久化需要设置同步选项，从而<strong>确保写命令什么时候会同步到磁盘文件上</strong>。<strong>这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘</strong>。有以下同步选项：</p><table><thead><tr><th align="center">选项</th><th align="center">同步频率</th></tr></thead><tbody><tr><td align="center">always</td><td align="center">每个写命令都同步</td></tr><tr><td align="center">everysec</td><td align="center">每秒同步一次</td></tr><tr><td align="center">no</td><td align="center">让操作系统来决定何时同步</td></tr></tbody></table><ul><li>always 选项会严重减低服务器的性能；</li><li>everysec 选项比较合适，可以<strong>保证系统崩溃时只会丢失一秒左右的数据</strong>，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；</li><li><strong>no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。</strong></li></ul><p><strong>随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。</strong></p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>一个事务包含了多个命令，<strong>服务器在执行事务期间，不会改去执行其它客户端的命令请求。</strong></p><p><strong>事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。</strong></p><p>Redis 最简单的事务实现方式是使用 <strong>MULTI</strong> 和 <strong>EXEC</strong> 命令将事务操作包围起来。</p><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>Redis 服务器是一个事件驱动程序。</p><h2 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h2><p><strong>服务器通过套接字与客户端或者其它服务器进行通信</strong>，文件事件就是对套接字操作的抽象。</p><p><strong>Redis 基于 Reactor 模式开发了自己的网络事件处理器，使用 I/O 多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器。</strong></p><p><img src="8.png" alt></p><h2 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h2><p>服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象。</p><p>时间事件又分为：</p><ul><li><strong>定时事件</strong>：是让一段程序在指定的时间之内执行一次；</li><li><strong>周期性事件</strong>：是让一段程序每隔指定时间就执行一次。</li></ul><p><strong>Redis 将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用相应的事件处理器。</strong></p><h2 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h2><p>服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能一直监听，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。</p><p>事件调度与执行由 aeProcessEvents 函数负责，伪代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aeProcessEvents</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 获取到达时间离当前时间最接近的时间事件</span></span><br><span class="line">    time_event = aeSearchNearestTimer()</span><br><span class="line">    <span class="comment"># 计算最接近的时间事件距离到达还有多少毫秒</span></span><br><span class="line">    remaind_ms = time_event.when - unix_ts_now()</span><br><span class="line">    <span class="comment"># 如果事件已到达，那么 remaind_ms 的值可能为负数，将它设为 0</span></span><br><span class="line">    <span class="keyword">if</span> remaind_ms &lt; <span class="number">0</span>:</span><br><span class="line">        remaind_ms = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 根据 remaind_ms 的值，创建 timeval</span></span><br><span class="line">    timeval = create_timeval_with_ms(remaind_ms)</span><br><span class="line">    <span class="comment"># 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 决定</span></span><br><span class="line">    aeApiPoll(timeval)</span><br><span class="line">    <span class="comment"># 处理所有已产生的文件事件</span></span><br><span class="line">    procesFileEvents()</span><br><span class="line">    <span class="comment"># 处理所有已到达的时间事件</span></span><br><span class="line">    processTimeEvents()</span><br></pre></td></tr></table></figure><p>将 aeProcessEvents 函数置于一个循环里面，加上初始化和清理函数，就构成了 Redis 服务器的主函数，伪代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 初始化服务器</span></span><br><span class="line">    init_server()</span><br><span class="line">    <span class="comment"># 一直处理事件，直到服务器关闭为止</span></span><br><span class="line">    <span class="keyword">while</span> server_is_not_shutdown():</span><br><span class="line">        aeProcessEvents()</span><br><span class="line">    <span class="comment"># 服务器关闭，执行清理操作</span></span><br><span class="line">    clean_server()</span><br></pre></td></tr></table></figure><p>从事件处理的角度来看，服务器运行流程如下：</p><p><img src="9.png" alt></p><h1 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h1><p>通过使用 <code>slaveof host port</code> 命令来让一个服务器成为另一个服务器的从服务器。</p><p><strong>一个从服务器只能有一个主服务器，并且不支持主主复制。</strong></p><h2 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h2><ol><li>主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；</li><li>从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；</li><li>主服务器每执行一次写命令，就向从服务器发送相同的写命令。</li></ol><h2 id="主从链"><a href="#主从链" class="headerlink" title="主从链"></a>主从链</h2><p>随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，<strong>可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。</strong></p><p><img src="10.png" alt></p><h1 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h1><p><strong>Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。</strong></p><h1 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h1><p><strong>分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。</strong></p><p>假设有 4 个 Reids 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，… ，有不同的方式来选择一个指定的键存储在哪个实例中。</p><ul><li>最简单的方式是<strong>范围分片</strong>，例如用户 id 从 0~1000 的存储到实例 R0 中，用户 id 从 1001~2000 的存储到实例 R1 中，等等。但是这样需要<strong>维护一张映射范围表</strong>，维护操作代价很高。</li><li>还有一种方式是<strong>哈希分片</strong>，使用<code>CRC32</code> 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。</li></ul><p>根据执行分片的位置，可以分为三种分片方式：</p><ul><li>客户端分片：客户端使用<strong>一致性哈希</strong>等算法决定键应当分布到哪个节点。</li><li>代理分片：<strong>将客户端请求发送到代理上，由代理转发请求到正确的节点上。</strong></li><li>服务器分片：<strong>Redis Cluster。</strong></li></ul><h1 id="一个简单的论坛系统分析"><a href="#一个简单的论坛系统分析" class="headerlink" title="一个简单的论坛系统分析"></a>一个简单的论坛系统分析</h1><p>该论坛系统功能如下：</p><ul><li>可以发布文章；</li><li>可以对文章进行点赞；</li><li>在首页可以按文章的发布时间或者文章的点赞数进行排序显示。</li></ul><h2 id="文章信息"><a href="#文章信息" class="headerlink" title="文章信息"></a>文章信息</h2><p>文章包括标题、作者、赞数等信息，在关系型数据库中很容易构建一张表来存储这些信息，在 Redis 中可以使用 HASH 来存储每种信息以及其对应的值的映射。</p><p>Redis 没有关系型数据库中的表这一概念来将同种类型的数据存放在一起，而是<strong>使用命名空间的方式来实现这一功能。</strong>键名的前面部分存储命名空间，后面部分的内容存储 ID，通常使用 : 来进行分隔。例如下面的 HASH 的键名为 article:92617，其中 article 为命名空间，ID 为 92617。</p><p><img src="11.png" alt></p><h2 id="点赞功能"><a href="#点赞功能" class="headerlink" title="点赞功能"></a>点赞功能</h2><p>当有用户为一篇文章点赞时，除了要对该文章的 votes 字段进行加 1 操作，还必须记录该用户已经对该文章进行了点赞，防止用户点赞次数超过 1。可以建立文章的已投票用户集合来进行记录。</p><p>为了节约内存，规定一篇文章发布满一周之后，就不能再对它进行投票，而文章的已投票集合也会被删除，<strong>可以为文章的已投票集合设置一个一周的过期时间就能实现这个规定。</strong></p><p><img src="12.png" alt></p><h2 id="对文章进行排序"><a href="#对文章进行排序" class="headerlink" title="对文章进行排序"></a>对文章进行排序</h2><p>为了按发布时间和点赞数进行排序，可以建立<strong>一个文章发布时间的有序集合</strong>和<strong>一个文章点赞数的有序集合</strong>。（下图中的 score 就是这里所说的点赞数；下面所示的有序集合分值并不直接是时间和点赞数，而是根据时间和点赞数间接计算出来的）</p><p><img src="13.png" alt></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>Carlson J L. Redis in Action[J]. Media.johnwiley.com.au, 2013.</li><li><a href="http://redisbook.com/index.html" target="_blank" rel="noopener">黄健宏. Redis 设计与实现 [M]. 机械工业出版社, 2014.</a></li><li><a href="https://redislabs.com/ebook/foreword/" target="_blank" rel="noopener">REDIS IN ACTION</a></li><li><a href="http://ticki.github.io/blog/skip-lists-done-right/" target="_blank" rel="noopener">Skip Lists: Done Right</a></li><li><a href="http://www.cnblogs.com/loveincode/p/7411911.html" target="_blank" rel="noopener">论述 Redis 和 Memcached 的差异</a></li><li><a href="http://wiki.jikexueyuan.com/project/redis-guide" target="_blank" rel="noopener">Redis 3.0 中文版- 分片</a></li><li><a href="http://www.scienjus.com/redis-use-case/" target="_blank" rel="noopener">Redis 应用场景</a></li><li><a href="https://redis.io/topics/lru-cache" target="_blank" rel="noopener">Using Redis as an LRU cache</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://github.com/CyC2018/CS-Notes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/CyC2018/CS-Notes&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Redis&lt;/code&gt; 是速度非常快的&lt;strong&gt;非关系型（NoSQL）内存键值数据库&lt;/strong&gt;，可以存储键和五种不同类型的值之间的映射。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;键的类型只能为字符串&lt;/strong&gt;，值支持五种数据类型：&lt;strong&gt;字符串、列表、集合、散列表、有序集合。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Redis 支持很多特性，例如&lt;strong&gt;将内存中的数据持久化到硬盘中&lt;/strong&gt;，&lt;strong&gt;使用复制来扩展读性能&lt;/strong&gt;，&lt;strong&gt;使用分片来扩展写性能。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://changsk.top/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://changsk.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>ping原理和ICMP协议</title>
    <link href="http://changsk.top/2019/07/03/ping-icmp/"/>
    <id>http://changsk.top/2019/07/03/ping-icmp/</id>
    <published>2019-07-03T01:53:59.000Z</published>
    <updated>2019-07-03T01:55:22.345Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自:<a href="https://blog.csdn.net/inject2006/article/details/2139149" target="_blank" rel="noopener">ping 原理与ICMP协议</a></p></blockquote><a id="more"></a><h2 id="ping-的原理"><a href="#ping-的原理" class="headerlink" title="ping 的原理"></a>ping 的原理</h2><p>​    <strong>ping 程序是用来探测主机到主机之间是否可通信</strong>，如果不能ping到某台主机，表明不能和这台主机建立连接。<strong>ping 使用的是ICMP协议</strong>，<strong>它发送icmp回送请求消息给目的主机</strong>。ICMP协议规定：<strong>目的主机必须返回ICMP回送应答消息给源主机</strong>。如果源主机在一定时间内收到应答，则认为主机可达。<br>​    <strong>ICMP协议通过IP协议发送的</strong>，IP协议是一种<code>无连接</code>的，<code>不可靠</code>的数据包协议。在Unix/Linux，序列号从0开始计数，依次递增。而Windows　ping程序的ICMP序列号是没有规律。<br>​    ICMP协议在实际传输中数据包：<code>20字节IP首部 + 8字节ICMP首部+ 数据</code><br>​     ICMP报文格式:<code>IP首部(20字节)+8位类型+8位代码+16位校验和+(不同的类型和代码，格式也有所不同)</code></p><h3 id="Ping工作过程"><a href="#Ping工作过程" class="headerlink" title="Ping工作过程"></a>Ping工作过程</h3><p>​    假定主机A的IP地址是192.168.1.1，主机B的IP地址是192.168.1.2，都在同一子网内，则当你在主机A上运行“Ping 192.168.1.2”后，都发生了些什么呢?</p><p>首先，<strong>Ping命令会构建一个固定格式的ICMP请求数据包</strong>，然后由ICMP协议将这个数据包连同地址“192.168.1.2”一起<strong>交给IP层协议</strong>（和ICMP一样，实际上是一组后台运行的进程），IP层协议将以地址“192.168.1.2”作为目的地址，本机IP地址作为源地址，加上一些其他的控制信息，构建一个<strong>IP数据包</strong>，并在一个映射表中查找出IP地址192.168.1.2所对应的物理地址（也叫<strong>MAC地址</strong>，熟悉网卡配置的朋友不会陌生，这是数据链路层协议构建数据链路层的传输单元——<strong>帧</strong>所必需的），一并交给数据链路层。后者构建一个数据帧，目的地址是IP层传过来的物理地址，源地址则是本机的物理地址，还要附加上一些控制信息，依据以太网的介质访问规则，将它们传送出去。<br>其中映射表由<strong>ARP</strong>实现。ARP(Address Resolution Protocol)是地址解析协议,是一种将<strong>IP地址转化成物理地址</strong>的协议。ARP具体说来就是将网络层（IP层，也就是相当于OSI的第三层）地址解析为数据连接层（MAC层，也就是相当于OSI的第二层）的MAC地址。</p><p>主机B收到这个数据帧后，先检查它的目的地址，并和本机的物理地址对比，如符合，则接收；否则丢弃。接收后检查该数据帧，将IP数据包从帧中提取出来，交给本机的<strong>IP层协议</strong>。同样，IP层检查后，<strong>将有用的信息提取后交给ICMP协议</strong>，后者处理后，<strong>马上构建一个ICMP应答包</strong>，发送给主机A，其过程和主机A发送ICMP请求包到主机B一模一样。<br>即先由IP地址，在网络层传输，然后再根据mac地址由数据链路层传送到目的主机。</p><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><h3 id="ICMP协议介绍"><a href="#ICMP协议介绍" class="headerlink" title="ICMP协议介绍"></a>ICMP协议介绍</h3><p><strong>前面讲到了，IP协议并不是一个可靠的协议，它不保证数据被送达，那么，自然的，保证数据送达的工作应该由其他的模块来完成。其中一个重要的模块就是ICMP(网络控制报文)协议。</strong></p><p>当传送IP数据包发生错误－－比如<code>主机不可达</code>，<code>路由不可达</code>等等，<strong>ICMP协议将会把错误信息封包，然后传送回给主机</strong>。给主机一个处理错误的机会，这 也就是为什么说建立在IP层以上的协议是可能做到安全的原因。ICMP数据包由8bit的错误类型和8bit的代码和16bit的校验和组成。而前 16bit就组成了ICMP所要传递的信息。</p><p>尽管在大多数情况下，错误的包传送应该给出ICMP报文，<strong>但是在特殊情况下，是不产生ICMP错误报文的</strong>。如下</p><ol><li>ICMP差错报文不会产生ICMP差错报文（出IMCP查询报文）（防止IMCP的无限产生和传送）</li><li>目的地址是广播地址或多播地址的IP数据报。</li><li>作为链路层广播的数据报。</li><li>不是IP分片的第一片。</li><li>源地址不是单个主机的数据报。这就是说，<code>源地址不能为零地址、环回地址、广播地 址或多播地址</code>。</li></ol><p>虽然里面的一些规定现在还不是很明白，但是所有的这一切规定，都是为了防止产生ICMP报文的无限传播而定义的。</p><p>ICMP协议大致分为两类，一种是<strong>查询报文</strong>，一种是<strong>差错报文</strong>。其中查询报文有以下几种用途:</p><ul><li>ping查询</li><li>子网掩码查询（用于无盘工作站在初始化自身的时候初始化子网掩码）</li><li>时间戳查询（可以用来同步时间）</li></ul><p>而差错报文则产生在数据传送发生错误的时候。就不赘述了。</p><h3 id="ICMP的应用-ping（IP）"><a href="#ICMP的应用-ping（IP）" class="headerlink" title="ICMP的应用-ping（IP）"></a>ICMP的应用-ping（IP）</h3><p><strong>ping可以说是ICMP的最著名的应用</strong>，当我们某一个网站上不去的时候。通常会ping一下这个网站。ping会回显出一些有用的信息。一般的信息如下:</p><blockquote><p>Reply from 10.4.24.1: bytes=32 time&lt;1ms TTL=255<br>Reply from 10.4.24.1: bytes=32 time&lt;1ms TTL=255<br>Reply from 10.4.24.1: bytes=32 time&lt;1ms TTL=255<br>Reply from 10.4.24.1: bytes=32 time&lt;1ms TTL=255</p></blockquote><blockquote><p>Ping statistics for 10.4.24.1:<br> Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),<br>Approximate round trip times in milli-seconds:<br> Minimum = 0ms, Maximum = 0ms, Average = 0ms</p></blockquote><p>ping这个单词源自<strong>声纳定位</strong>，而这个程序的作用也确实如此，它<strong>利用ICMP协议包来侦测另一个主机是否可达</strong>。原理是用类型码为0的ICMP发请 求，受到请求的主机则用类型码为8的ICMP回应。ping程序来计算间隔时间，并计算有多少个包被送达。用户就可以判断网络大致的情况。我们可以看到， ping给出来了传送的时间和TTL的数据。我给的例子不太好，因为走的路由少，有兴趣地可以ping一下国外的网站比如sf.net，就可以观察到一些 丢包的现象，而程序运行的时间也会更加的长。<br>ping还给我们一个看主机到目的主机的路由的机会。这是因为，<strong>ICMP的ping请求数据报在每经过一个路由器的时候，路由器都会把自己的ip放到该数据报中。而目的主机则会把这个ip列表复制到回应icmp数据包中发回给主机。</strong>但是，无论如何，ip头所能纪录的路由列表是非常的有限。如果要观察路由， 我们还是需要使用更好的工具，就是要讲到的Traceroute(windows下面的名字叫做tracert)。</p><h3 id="ICMP的应用-Traceroute（UDP）"><a href="#ICMP的应用-Traceroute（UDP）" class="headerlink" title="ICMP的应用-Traceroute（UDP）"></a>ICMP的应用-Traceroute（UDP）</h3><p><strong>Traceroute是用来侦测主机到目的主机之间所经路由情况的重要工具</strong>，也是最便利的工具。前面说到，尽管ping工具也可以进行侦测，但是，因为ip头的限制，ping不能完全的记录下所经过的路由器。所以Traceroute正好就填补了这个缺憾。</p><p>Traceroute的原理是非常非常的有意思，它收到目的主机的IP后，首先给目的主机发送一个TTL=1（还记得TTL是什么吗？）的<strong>UDP</strong>(后面就 知道UDP是什么了)数据包，而经过的第一个路由器收到这个数据包以后，就自动把TTL减1，而TTL变为0以后，路由器就把这个包给抛弃了，并<strong>同时产生 一个主机不可达的ICMP数据报给主机</strong>。主机收到这个数据报以后再发一个TTL=2的UDP数据报给目的主机，然后刺激第二个路由器给主机发ICMP数据 报。如此往复直到到达目的主机。这样，traceroute就拿到了所有的路由器ip。从而避开了ip头只能记录有限路由IP的问题。</p><p>有人要问，我怎么知道UDP到没到达目的主机呢？这就涉及一个技巧的问题，TCP和UDP协议有一个端口号定义，而普通的网络程序只监控少数的几个号码较 小的端口，比如说80,比如说23,等等。而traceroute发送的是端口号&gt;30000(真变态)的UDP报，所以到达目的主机的时候，目的主机只能发送一个<strong>端口不可达的ICMP数据报</strong>给主机。主机接到这个报告以后就知道，主机到了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自:&lt;a href=&quot;https://blog.csdn.net/inject2006/article/details/2139149&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ping 原理与ICMP协议&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://changsk.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="ping" scheme="http://changsk.top/tags/ping/"/>
    
      <category term="ICMP" scheme="http://changsk.top/tags/ICMP/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-82:Remove Duplicates from Sorted List II</title>
    <link href="http://changsk.top/2019/07/03/leetcode-82/"/>
    <id>http://changsk.top/2019/07/03/leetcode-82/</id>
    <published>2019-07-03T01:32:43.000Z</published>
    <updated>2019-07-03T01:53:06.139Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/</a></p><p>这道题目和<a href="http://changsk.top/2019/07/02/leetcode-83/">leetcode-83:Remove Duplicates from Sorted List(排序链表中删除重复结点)</a>的区别是，这道题要求把重复的数字一个都不保留，全都删除。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>题目难度：Medium</p></blockquote><p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.</p><a id="more"></a><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><blockquote><p>Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br>Output: 1-&gt;2-&gt;5</p></blockquote><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><blockquote><p>Input: 1-&gt;1-&gt;1-&gt;2-&gt;3<br>Output: 2-&gt;3</p></blockquote><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//head 为空，或者只有一个结点，那么直接返回head</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">//创建新的结点，并和原来的链表相连 </span></span><br><span class="line">        ListNode newHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        newHead.next =head;</span><br><span class="line">        ListNode pre = newHead, cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur.next != <span class="keyword">null</span> &amp;&amp; cur.val == cur.next.val) cur = cur.next;</span><br><span class="line">            <span class="comment">//cur结点没有重复的情况</span></span><br><span class="line">            <span class="keyword">if</span>(pre.next == cur)&#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cur结点有重复的情况下，pre结点不动</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                pre.next = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这道题目和&lt;a href=&quot;http://changsk.top/2019/07/02/leetcode-83/&quot;&gt;leetcode-83:Remove Duplicates from Sorted List(排序链表中删除重复结点)&lt;/a&gt;的区别是，这道题要求把重复的数字一个都不保留，全都删除。&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;题目难度：Medium&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-83:Remove Duplicates from Sorted List(排序链表中删除重复结点)</title>
    <link href="http://changsk.top/2019/07/02/leetcode-83/"/>
    <id>http://changsk.top/2019/07/02/leetcode-83/</id>
    <published>2019-07-02T13:01:13.000Z</published>
    <updated>2019-07-02T13:03:42.523Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>题目难度：Easy</p></blockquote><p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p><a id="more"></a><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><blockquote><p>Input: 1-&gt;1-&gt;2<br>Output: 1-&gt;2</p></blockquote><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><blockquote><p>Input: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>Output: 1-&gt;2-&gt;3</p></blockquote><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode curNode = head;</span><br><span class="line">        <span class="keyword">while</span>(curNode.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curNode.val == curNode.next.val)</span><br><span class="line">                curNode.next = curNode.next.next;</span><br><span class="line">            <span class="keyword">else</span> curNode = curNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;题目难度：Easy&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Given a sorted linked list, delete all duplicates such that each element appear only once.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-数组中重复的数字</title>
    <link href="http://changsk.top/2019/07/02/jianzhioffer-repeated-number/"/>
    <id>http://changsk.top/2019/07/02/jianzhioffer-repeated-number/</id>
    <published>2019-07-02T12:49:11.000Z</published>
    <updated>2019-07-02T12:52:11.821Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><a id="more"></a><h2 id="AC代码1"><a href="#AC代码1" class="headerlink" title="AC代码1"></a>AC代码1</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//    numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//    length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//    duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation;</span></span><br><span class="line">    <span class="comment">//                  Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++</span></span><br><span class="line">    <span class="comment">//    这里要特别注意~返回任意重复的一个，赋值duplication[0]</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers == <span class="keyword">null</span> || numbers.length == <span class="number">0</span> || numbers.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; numbers.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(numbers[i] != i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(numbers[numbers[i]] == numbers[i])&#123; <span class="comment">//判断数组下标为 numbers[i] 的元素是否为 numbers[i]，是的话表示重复</span></span><br><span class="line">                    duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> temp = numbers[i];   <span class="comment">//要注意这一块的交换</span></span><br><span class="line">                numbers[i] = numbers[temp];</span><br><span class="line">                numbers[temp] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AC代码2"><a href="#AC代码2" class="headerlink" title="AC代码2"></a>AC代码2</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//    numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//    length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//    duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation;</span></span><br><span class="line">    <span class="comment">//                  Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++</span></span><br><span class="line">    <span class="comment">//    这里要特别注意~返回任意重复的一个，赋值duplication[0]</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers == <span class="keyword">null</span> || numbers.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == numbers[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> j = i, temp;</span><br><span class="line">            <span class="keyword">while</span>(j != numbers[j])&#123;</span><br><span class="line">                <span class="keyword">if</span>(numbers[numbers[j]] == numbers[j])&#123;</span><br><span class="line">                    duplication[<span class="number">0</span>] = numbers[j];</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                temp = numbers[j];</span><br><span class="line">                numbers[numbers[j]] = numbers[j];</span><br><span class="line">                j = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="http://changsk.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="http://changsk.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Mysql中索引无效的情况</title>
    <link href="http://changsk.top/2019/07/02/mysql-index-Invalid/"/>
    <id>http://changsk.top/2019/07/02/mysql-index-Invalid/</id>
    <published>2019-07-02T12:19:51.000Z</published>
    <updated>2019-07-02T12:31:27.565Z</updated>
    
    <content type="html"><![CDATA[<ol><li><strong>最佳左前缀原则</strong>——如果索引了多列，要遵守最左前缀原则。指的是查询要从索引的最左前列开始并且不跳过索引中的列。违反了最佳左前缀原则，索引会失效，进行全表扫描</li><li>不在索引列上做任何操作（计算，函数【avg，max，min等】，（自动或者手动）类型装换），会导致索引失效而导致全表扫描</li><li>mysql使用不等于(!= 或者&lt;&gt;)的时候，无法使用索引，会导致索引失效</li><li>mysql中使用is not null 或者 is null会导致无法使用索引</li><li>mysql中like查询是以%开头，索引会失效变成全表扫描，覆盖索引。</li><li>mysql中，如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)。要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引</li><li>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引</li><li>如果mysql使用全表扫描要比使用索引快,则不会使用到索引</li></ol><blockquote><p>参考：<br><a href="https://blog.csdn.net/qq_34258346/article/details/80272198" target="_blank" rel="noopener">mysql索引失效情况</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;strong&gt;最佳左前缀原则&lt;/strong&gt;——如果索引了多列，要遵守最左前缀原则。指的是查询要从索引的最左前列开始并且不跳过索引中的列。违反了最佳左前缀原则，索引会失效，进行全表扫描&lt;/li&gt;
&lt;li&gt;不在索引列上做任何操作（计算，函数【avg，max，m
      
    
    </summary>
    
      <category term="数据库" scheme="http://changsk.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库索引" scheme="http://changsk.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>cookie和session区别</title>
    <link href="http://changsk.top/2019/07/02/cookie-session/"/>
    <id>http://changsk.top/2019/07/02/cookie-session/</id>
    <published>2019-07-02T11:34:12.000Z</published>
    <updated>2019-07-02T11:59:53.057Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://juejin.im/post/5cd9037ee51d456e5c5babca" target="_blank" rel="noopener">你真的了解 Cookie 和 Session 吗</a></p></blockquote><p>我在做面试官的时候，曾经问过很多朋友这个问题： Cookie 和 Session 有什么区别呢？大部分的面试者应该都可以说上一两句，比如：什么是 Cookie？什么是 Session？两者的区别等。</p><p>但如果再往深入探讨的话，就慢慢有一些朋友不太了解了，谈起原理时就很少有朋友全部回答准确。今天和大家一起深入聊聊有关 Cookie 和 Session 的话题 。</p><a id="more"></a><h2 id="第一层楼"><a href="#第一层楼" class="headerlink" title="第一层楼"></a>第一层楼</h2><p>什么是 Cookie 和 Session ?初级程序员高频面试题。</p><p><strong>什么是 Cookie</strong></p><p><code>HTTP Cookie</code>（也叫 Web Cookie或浏览器 Cookie）是<strong>服务器发送到用户浏览器并保存在本地的一小块数据</strong>，<strong>它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上</strong>。通常，<strong>它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态</strong>。<strong>Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。</strong></p><p>Cookie 主要用于以下三个方面：</p><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><p><strong>什么是 Session</strong></p><p><strong>Session 代表着服务器和客户端一次会话的过程</strong>。<strong>Session 对象存储特定用户会话所需的属性及配置信息</strong>。这样，<strong>当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</strong></p><h2 id="第二层楼"><a href="#第二层楼" class="headerlink" title="第二层楼"></a>第二层楼</h2><p>Cookie 和 Session 有什么不同？</p><ul><li><p>作用范围不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端。</p><blockquote><p>session会服务器上保存一段时间，这个会产生一个问题——当用户访问增多，会占用你服务器的资源，从而影响性能。</p></blockquote></li><li><p>存取方式的不同，<strong>Cookie 只能保存 ASCII</strong>，<strong>Session 可以存任意数据类型</strong>，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</p></li><li><p>有效期不同，<strong>Cookie 可设置为长时间保持</strong>，<strong>比如我们经常使用的默认登录功能</strong>，<strong>Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</strong></p></li><li><p>隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。</p></li><li><p>存储大小不同， <strong>单个 Cookie 保存的数据不能超过 4K</strong>，Session 可存储数据远高于 Cookie。</p></li></ul><p>前两层楼内容，绝大部分同学都可以准确回答</p><h2 id="第三层楼"><a href="#第三层楼" class="headerlink" title="第三层楼"></a>第三层楼</h2><p>为什么需要 Cookie 和 Session，他们有什么关联？</p><p>说起来为什么需要 Cookie ，这就需要从浏览器开始说起，我们都知道<strong>浏览器是没有状态的(HTTP 协议无状态)</strong>，<strong>这意味着浏览器并不知道是张三还是李四在和服务端打交道</strong>。<strong>这个时候就需要有一个机制来告诉服务端，本次操作用户是否登录，是哪个用户在执行的操作，那这套机制的实现就需要 Cookie 和 Session 的配合。</strong></p><p>那么 Cookie 和 Session 是如何配合的呢？我画了一张图大家可以先了解下。</p><p><img src="1.jpg" alt="img"></p><p>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session ，<strong>请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器</strong>，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，<strong>同时 Cookie 记录此 SessionID 属于哪个域名。</strong></p><p>当用户第二次访问服务器的时候，请求会自动<strong>判断此域名下是否存在 Cookie 信息</strong>，如果存在自动将 Cookie 信息也发送给服务端，<strong>服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息</strong>，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</p><p>根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁<strong>，大部分系统也是根据此原理来验证用户登录状态。</strong></p><p>三层楼的内容，大部分同学可以讲清楚。</p><h2 id="第四层楼"><a href="#第四层楼" class="headerlink" title="第四层楼"></a>第四层楼</h2><p>既然服务端是根据 Cookie 中的信息判断用户是否登录，那么如果浏览器中禁止了 Cookie，如何保障整个机制的正常运转。</p><p>第一种方案，每次请求中都携带一个 SessionID 的参数，也可以 <strong>Post</strong> 的方式提交，也可以在请求的地址后面拼接 <code>xxx?SessionID=123456...</code>。</p><p>第二种方案，<strong>Token 机制</strong>。Token 机制多用于 App 客户端和服务器交互的模式，也可以用于 Web 端做用户状态管理。</p><p><strong>Token 的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。Token 机制和 Cookie 和 Session 的使用机制比较类似。</strong></p><p><strong>当用户第一次登录后，服务器根据提交的用户信息生成一个 Token，响应时将 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次登录验证。</strong></p><p>四层楼的内容，一部分同学可以讲清楚。</p><h2 id="第五层楼"><a href="#第五层楼" class="headerlink" title="第五层楼"></a>第五层楼</h2><p>如何考虑分布式 Session 问题？</p><p>在互联网公司为了可以支撑更大的流量，<strong>后端往往需要多台服务器共同来支撑前端用户请求</strong>，那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题。</p><p>分布式 Session 一般会有以下几种解决方案：</p><ul><li><strong>Nginx ip_hash</strong> 策略，<strong>服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一 IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。</strong></li><li><strong>Session 复制，任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。</strong></li><li><strong>共享 Session，服务端无状态话，将用户的 Session 等信息使用缓存中间件来统一管理，保障分发到每一个服务器的响应结果都一致。</strong></li></ul><p>建议采用第三种方案。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://juejin.im/post/5cd9037ee51d456e5c5babca&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;你真的了解 Cookie 和 Session 吗&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我在做面试官的时候，曾经问过很多朋友这个问题： Cookie 和 Session 有什么区别呢？大部分的面试者应该都可以说上一两句，比如：什么是 Cookie？什么是 Session？两者的区别等。&lt;/p&gt;
&lt;p&gt;但如果再往深入探讨的话，就慢慢有一些朋友不太了解了，谈起原理时就很少有朋友全部回答准确。今天和大家一起深入聊聊有关 Cookie 和 Session 的话题 。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://changsk.top/categories/Java/"/>
    
    
      <category term="Cookie" scheme="http://changsk.top/tags/Cookie/"/>
    
      <category term="Session" scheme="http://changsk.top/tags/Session/"/>
    
  </entry>
  
  <entry>
    <title>http状态码</title>
    <link href="http://changsk.top/2019/07/02/http-status-code/"/>
    <id>http://changsk.top/2019/07/02/http-status-code/</id>
    <published>2019-07-02T09:48:51.000Z</published>
    <updated>2019-07-02T12:00:35.075Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP状态码含义：</p><a id="more"></a><table><thead><tr><th align="left">状态码</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left"><strong>100</strong></td><td align="left">客户端应当继续发送请求。<strong>这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝</strong>。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</td></tr><tr><td align="left">101</td><td align="left">服务器已经理解了客户端的请求，并将<strong>通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求</strong>。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 　　只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。</td></tr><tr><td align="left">102</td><td align="left">由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</td></tr><tr><td align="left"><strong>200</strong></td><td align="left"><strong>请求已成功</strong>，请求所希望的响应头或数据体将随此响应返回。</td></tr><tr><td align="left">201</td><td align="left">请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’。</td></tr><tr><td align="left">202</td><td align="left">服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。 　　返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。</td></tr><tr><td align="left">203</td><td align="left">服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。</td></tr><tr><td align="left">204</td><td align="left">服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。 　　如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。 　　由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</td></tr><tr><td align="left">205</td><td align="left">服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 　　与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</td></tr><tr><td align="left">206</td><td align="left">服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 　　该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 　　响应必须包含如下的头部域： 　　Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。 　　Date 　　ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。 　　Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 　　假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。 　　假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。 　　任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。</td></tr><tr><td align="left">207</td><td align="left">由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</td></tr><tr><td align="left">300</td><td align="left">被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 　　除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。 　　如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</td></tr><tr><td align="left"><strong>301</strong></td><td align="left"><strong>被请求的资源已永久移动到新位置</strong>，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 　　新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 　　注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。</td></tr><tr><td align="left"><strong>302</strong></td><td align="left"><strong>请求的资源现在临时从不同的 URI 响应请求</strong>。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 　　新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 　　注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</td></tr><tr><td align="left">303</td><td align="left">对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 　　新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　注意：许多 HTTP/1.1 版以前的 浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。</td></tr><tr><td align="left"><strong>304</strong></td><td align="left"><strong>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。</strong>304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 　　该响应必须包含以下的头信息： 　　Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。 　　ETag 和/或 Content-Location，假如同样的请求本应返回200响应。 　　Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 　　假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。 　　假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。 　　假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。</td></tr><tr><td align="left">305</td><td align="left"><strong>被请求的资源必须通过指定的代理才能被访问</strong>。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 　　注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。</td></tr><tr><td align="left">306</td><td align="left">在最新版的规范中，306状态码已经不再被使用。</td></tr><tr><td align="left">307</td><td align="left">请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 　　新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。 　　如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</td></tr><tr><td align="left"><strong>400</strong></td><td align="left"><strong>1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 　　2、请求参数有误。</strong></td></tr><tr><td align="left">401</td><td align="left"><strong>当前请求需要用户验证</strong>。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。</td></tr><tr><td align="left">402</td><td align="left">该状态码是为了将来可能的需求而预留的。</td></tr><tr><td align="left">403</td><td align="left"><strong>服务器已经理解请求，但是拒绝执行它</strong>。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。</td></tr><tr><td align="left"><strong>404</strong></td><td align="left"><strong>请求失败，请求所希望得到的资源未被在服务器上发现</strong>。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</td></tr><tr><td align="left">405</td><td align="left"><strong>请求行中指定的请求方法不能被用于请求相应的资源</strong>。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 　　鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</td></tr><tr><td align="left">406</td><td align="left">请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 　　除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</td></tr><tr><td align="left">407</td><td align="left">与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。</td></tr><tr><td align="left">408</td><td align="left"><strong>请求超时</strong>。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</td></tr><tr><td align="left">409</td><td align="left">由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。 　　冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。</td></tr><tr><td align="left">410</td><td align="left">被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。 　　410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。</td></tr><tr><td align="left">411</td><td align="left">服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。</td></tr><tr><td align="left">412</td><td align="left">服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</td></tr><tr><td align="left">413</td><td align="left">服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 　　如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。</td></tr><tr><td align="left">414</td><td align="left">请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括： 　　本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 　　重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。 　　客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。</td></tr><tr><td align="left">415</td><td align="left">对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。</td></tr><tr><td align="left">416</td><td align="left">如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。 　　假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。</td></tr><tr><td align="left">417</td><td align="left">在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。</td></tr><tr><td align="left">421</td><td align="left">从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td></tr><tr><td align="left">422</td><td align="left">从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td></tr><tr><td align="left">422</td><td align="left">请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked 　　当前资源被锁定。（RFC 4918 WebDAV）</td></tr><tr><td align="left">424</td><td align="left">由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）</td></tr><tr><td align="left">425</td><td align="left">在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。</td></tr><tr><td align="left">426</td><td align="left">客户端应当切换到TLS/1.0。（RFC 2817）</td></tr><tr><td align="left">449</td><td align="left">由微软扩展，代表请求应当在执行完适当的操作后进行重试。</td></tr><tr><td align="left"><strong>500</strong></td><td align="left"><strong>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。</strong></td></tr><tr><td align="left">501</td><td align="left">服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</td></tr><tr><td align="left">502</td><td align="left">作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</td></tr><tr><td align="left">503</td><td align="left"><strong>由于临时的服务器维护或者过载，服务器当前无法处理请求</strong>。<strong>这个状况是临时的</strong>，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。 　　注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。</td></tr><tr><td align="left">504</td><td align="left">作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 　　注意：某些代理服务器在DNS查询超时时会返回400或者500错误</td></tr><tr><td align="left">505</td><td align="left"><strong>服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本</strong>。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</td></tr><tr><td align="left">506</td><td align="left">由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</td></tr><tr><td align="left">507</td><td align="left">服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)</td></tr><tr><td align="left">509</td><td align="left">服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</td></tr><tr><td align="left">510</td><td align="left">获取资源所需要的策略并没有没满足。（RFC 2774）</td></tr></tbody></table><blockquote><p>参考：<a href="http://tool.oschina.net/commons?type=5" target="_blank" rel="noopener">http://tool.oschina.net/commons?type=5</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP状态码含义：&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://changsk.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTP" scheme="http://changsk.top/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-236:Lowest Common Ancestor of a Binary Tree（LCA，最近公共祖先节点）</title>
    <link href="http://changsk.top/2019/07/02/leetcode-236/"/>
    <id>http://changsk.top/2019/07/02/leetcode-236/</id>
    <published>2019-07-02T08:51:32.000Z</published>
    <updated>2019-07-02T11:17:47.056Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>题目难度：Medium</p></blockquote><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p><p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”</p><p>Given the following binary tree: root = [3,5,1,6,2,0,8,null,null,7,4]</p><a id="more"></a><p><img src="1.jpg" alt></p><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><p>Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>Output: 3<br>Explanation: The LCA of nodes 5 and 1 is 3.</p><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><p>Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br>Output: 5<br>Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</p><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>All of the nodes’ values will be unique.<br>p and q are different and both values will exist in the binary tree.</p><h2 id="AC代码1"><a href="#AC代码1" class="headerlink" title="AC代码1"></a>AC代码1</h2><p>最简单粗暴的解法：<strong>从下往上</strong>依次遍历树中每个节点，第一次出现子树(包括节点本身)既有p又有q的结点为LCA所求结点。<br>时间复杂度：<strong>O(n * n)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode resNode = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">findCommonNode</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span>(root.left  !=  <span class="keyword">null</span>) findCommonNode(root.left, p, q);</span><br><span class="line">       <span class="keyword">if</span>(root.right  !=  <span class="keyword">null</span>) findCommonNode(root.right, p, q);</span><br><span class="line">       <span class="keyword">if</span>(hasNode(root, p) &amp;&amp; hasNode(root, q)) </span><br><span class="line">               <span class="keyword">if</span>(resNode == <span class="keyword">null</span>) resNode = root;</span><br><span class="line">       <span class="keyword">return</span> resNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNode</span><span class="params">(TreeNode root, TreeNode node)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span>(root == node) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span>(root.left == node || root.right == node) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">return</span> hasNode(root.left, node) || hasNode(root.right, node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findCommonNode(root, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AC代码2"><a href="#AC代码2" class="headerlink" title="AC代码2"></a>AC代码2</h2><p>leetcode大神的解法，以<strong>递归</strong>的方式解决<code>LCA</code>问题。<br>时间复杂度：<strong>O(n)</strong><br>空间复杂度：<strong>O(n)</strong>。主要是递归栈的深度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        以下三种情况会返回：</span></span><br><span class="line"><span class="comment">        1. root == null，return null</span></span><br><span class="line"><span class="comment">        2. root 只等于 p 或者 q 其中一个结点</span></span><br><span class="line"><span class="comment">        3. q 和 p 相等的情况下，root == q == p</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root == p || root == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p , q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p , q);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        1. 如果 left == null，返回 right(不管right是否为null)</span></span><br><span class="line"><span class="comment">        2. left != null，right == null，返回 left</span></span><br><span class="line"><span class="comment">        3. left 和 right 都不等于null，说明 left 和 right 只和 q 或者 p 其中一个结点相等，root为p和q的最近公共子节点，返回root</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> left == <span class="keyword">null</span> ? right: right == <span class="keyword">null</span> ? left: root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AC代码3"><a href="#AC代码3" class="headerlink" title="AC代码3"></a>AC代码3</h2><p>建立两队列，一个队列保存从根节点到p的路径，另一个队列保存从根节点到q的路径。<strong>两个路径中第一个不相同的节点的前一个节点即为LCA所求。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root == p || root == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; q1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;TreeNode&gt; q2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        getTrace(root, q1, p);</span><br><span class="line">        getTrace(root, q2, q);</span><br><span class="line">        <span class="keyword">return</span> LCA(q1, q2);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">getTrace</span><span class="params">(TreeNode root, LinkedList&lt;TreeNode&gt; queue, TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == node)&#123;</span><br><span class="line">            queue.offer(root);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">if</span>(getTrace(root.left, queue, node) || getTrace(root.right, queue, node)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        queue.pollLast();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">LCA</span><span class="params">(Queue&lt;TreeNode&gt; q1, Queue&lt;TreeNode&gt; q2)</span></span>&#123;</span><br><span class="line">        TreeNode node = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            TreeNode n1 = q1.poll();</span><br><span class="line">            TreeNode n2 = q2.poll();</span><br><span class="line">            <span class="keyword">if</span>(n1 == n2) node = n1;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AC代码4"><a href="#AC代码4" class="headerlink" title="AC代码4"></a>AC代码4</h2><p><strong>离线Tarjan算法</strong></p><p>后续有时间再研究。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;题目难度：Medium&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.&lt;/p&gt;
&lt;p&gt;According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”&lt;/p&gt;
&lt;p&gt;Given the following binary tree: root = [3,5,1,6,2,0,8,null,null,7,4]&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-23:Merge k Sorted Lists(合并k个有序链表)</title>
    <link href="http://changsk.top/2019/07/02/leetcode-23/"/>
    <id>http://changsk.top/2019/07/02/leetcode-23/</id>
    <published>2019-07-02T08:41:08.000Z</published>
    <updated>2019-07-02T09:05:17.971Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-k-sorted-lists/</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>题目难度：Hard</p></blockquote><p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p><a id="more"></a><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p><strong>Input:</strong></p><blockquote><p>[<br>1-&gt;4-&gt;5,<br>1-&gt;3-&gt;4,<br>2-&gt;6<br>]</p></blockquote><p><strong>Output:</strong></p><blockquote><p>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p></blockquote><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><p>leetcode 优秀的解法：灵活运用<strong>二路归并排序</strong>的思想。</p><p>时间复杂度：<strong>O(log(k) * n)</strong> ,<code>k为链表长度，n为单个链表长度</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> partition(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">partition</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == end) <span class="keyword">return</span> lists[start];</span><br><span class="line">        <span class="keyword">if</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (start + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            ListNode l1 = partition(lists, start, mid);</span><br><span class="line">            ListNode l2 = partition(lists, mid + <span class="number">1</span>, end);</span><br><span class="line">            <span class="keyword">return</span> mergeCore(l1, l2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//合并两个链表，返回合并后的头结点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeCore</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">                l1.next = mergeCore(l1.next, l2);</span><br><span class="line">                <span class="keyword">return</span> l1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                l2.next = mergeCore(l1, l2.next);</span><br><span class="line">                <span class="keyword">return</span> l2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/merge-k-sorted-lists/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/merge-k-sorted-lists/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;题目难度：Hard&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-不用加减乘除做加法</title>
    <link href="http://changsk.top/2019/07/02/jianzhioffer-addition2/"/>
    <id>http://changsk.top/2019/07/02/jianzhioffer-addition2/</id>
    <published>2019-07-02T08:28:22.000Z</published>
    <updated>2019-07-02T08:34:07.341Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>写一个函数，求两个整数之和，要求在函数体内不得使用<code>+、-、*、/</code>四则运算符号。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><p>用<strong>位运算</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row_sum = <span class="number">0</span>; <span class="comment">// 不含进位的和</span></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;  <span class="comment">// 进位</span></span><br><span class="line">        <span class="keyword">while</span>(num2 != <span class="number">0</span>)&#123;         <span class="comment">// 当进位为 0 时停止循环，条件row_sum + carry == num1 + num2 始终成立</span></span><br><span class="line">            row_sum = num1 ^ num2; <span class="comment">// 不含进位的和可以用异或 ^ 实现</span></span><br><span class="line">            carry = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>; <span class="comment">// 通过 &amp; ，可以确定哪里有进位，然后左移一位表示进位</span></span><br><span class="line">            <span class="comment">//计算 row_sum 和进位的和</span></span><br><span class="line">            num1 = row_sum;</span><br><span class="line">            num2 = carry;</span><br><span class="line">        &#125;         </span><br><span class="line">        <span class="keyword">return</span> num1; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;写一个函数，求两个整数之和，要求在函数体内不得使用&lt;code&gt;+、-、*、/&lt;/code&gt;四则运算符号。&lt;/p&gt;
&lt;h2 i
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://changsk.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="http://changsk.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-求1+2+3+...+n</title>
    <link href="http://changsk.top/2019/07/02/jianzhioffer-addition/"/>
    <id>http://changsk.top/2019/07/02/jianzhioffer-addition/</id>
    <published>2019-07-02T08:18:59.000Z</published>
    <updated>2019-07-02T08:28:03.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><a id="more"></a><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><p>利用<strong>递归</strong>的思想</p><p>短路与<strong>&amp;&amp;</strong>可以充当if else的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = n;</span><br><span class="line">        <span class="keyword">boolean</span> ans = (n &gt; <span class="number">0</span>) &amp;&amp; ((sum += Sum_Solution(n - <span class="number">1</span>)) &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="http://changsk.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="http://changsk.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-孩子们的游戏(圆圈中最后剩下的数)</title>
    <link href="http://changsk.top/2019/07/02/jianzhioffer-Joseph-ring/"/>
    <id>http://changsk.top/2019/07/02/jianzhioffer-Joseph-ring/</id>
    <published>2019-07-02T07:42:31.000Z</published>
    <updated>2019-07-02T08:14:22.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p><a id="more"></a><h2 id="AC代码1"><a href="#AC代码1" class="headerlink" title="AC代码1"></a>AC代码1</h2><p>这道题其实就是一个<strong>约瑟夫环</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || m == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] selected = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//循环次数为 n - 1次，会把selected中n-1个数置为true，剩下的最后一个false即为所求</span></span><br><span class="line">        <span class="keyword">while</span>(count != n - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">                cur = (cur + <span class="number">1</span>) % n;</span><br><span class="line">                <span class="keyword">while</span>(selected[cur] == <span class="keyword">true</span>) cur = (cur + <span class="number">1</span>) % n;</span><br><span class="line">            &#125;</span><br><span class="line">            selected[cur] = <span class="keyword">true</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">            <span class="keyword">if</span>(selected[i] == <span class="keyword">false</span>) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AC代码2"><a href="#AC代码2" class="headerlink" title="AC代码2"></a>AC代码2</h2><p>原理请看：<a href="https://blog.csdn.net/crazy__chen/article/details/45115911" target="_blank" rel="noopener">https://blog.csdn.net/crazy__chen/article/details/45115911</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>||m==<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            s=(s+m)%i;</span><br><span class="line">        &#125;   </span><br><span class="line">       <span class="keyword">return</span> s ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="http://changsk.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="http://changsk.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-扑克牌顺子</title>
    <link href="http://changsk.top/2019/07/02/jianzhioffer-Playing-cards/"/>
    <id>http://changsk.top/2019/07/02/jianzhioffer-Playing-cards/</id>
    <published>2019-07-02T03:41:26.000Z</published>
    <updated>2019-07-02T07:15:16.512Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>将原数组升序排序</li><li>计算0的个数<strong>zeros</strong></li><li>计算两两非0元素之间的间隔之和<strong>gaps</strong>（1和3之间的间隔为3 - 1 <strong>- 1</strong> = 1，代表数字1和3之间插入一个数字2，可形成顺子），如果出现两个非0元素相等，直接返回false（不可能形成顺子）</li><li>计算<strong>zeros</strong>和<strong>gaps</strong>的差值。如果<strong>zeros</strong>大于等于<strong>gaps</strong>，表示<strong>zeros</strong>可以填补形成顺子所需的数字，返回true；否则返回false。</li></ol><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers == <span class="keyword">null</span> || numbers.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Arrays.sort(numbers); <span class="comment">//升序排序</span></span><br><span class="line">        <span class="keyword">int</span> numsOfZero = <span class="number">0</span>;<span class="comment">//0的个数</span></span><br><span class="line">        <span class="keyword">int</span> gaps = <span class="number">0</span>;<span class="comment">//间隔的个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; numbers.length;i++)&#123;</span><br><span class="line">            <span class="comment">//两相邻数字相等，不可能形成顺子</span></span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; numbers[i] != <span class="number">0</span> &amp;&amp; numbers[i - <span class="number">1</span>] == numbers[i]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//间隔的计算，两相邻数字都不为0，且相差要大于1</span></span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; numbers[i - <span class="number">1</span>] != <span class="number">0</span> &amp;&amp; numbers[i] - numbers[i - <span class="number">1</span>] != <span class="number">1</span>) gaps += numbers[i] - numbers[i - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == <span class="number">0</span>) numsOfZero++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(gaps &lt;= numsOfZero) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5
      
    
    </summary>
    
      <category term="剑指offer" scheme="http://changsk.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="http://changsk.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>数据库中聚集索引和非聚集索引的区别</title>
    <link href="http://changsk.top/2019/07/02/database-Clustered-index-Nonclustered-index/"/>
    <id>http://changsk.top/2019/07/02/database-Clustered-index-Nonclustered-index/</id>
    <published>2019-07-02T03:13:21.000Z</published>
    <updated>2019-07-02T03:34:55.856Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://blog.csdn.net/tkzc_csk/article/details/88688359" target="_blank" rel="noopener">聚集索引和非聚集索引</a></p></blockquote><h2 id="索引简介"><a href="#索引简介" class="headerlink" title="索引简介"></a>索引简介</h2><p>众所周知，<strong>索引是关系型数据库中给数据库表中一列或多列的值排序后的存储结构</strong>，SQL的主流索引结构有<strong>B+树以及Hash</strong>结构，聚集索引以及非聚集索引用的是B+树索引。</p><p>SQL Sever索引类型有：<strong>唯一索引，主键索引，聚集索引，非聚集索引。</strong></p><p>MySQL 索引类型有：<strong>唯一索引，主键（聚集）索引，非聚集索引，全文索引。</strong></p><a id="more"></a><h2 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h2><p>聚集（clustered）索引，也叫聚簇索引。</p><p>定义：<strong>数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同</strong>，<strong>一个表中只能拥有一个聚集索引。</strong> <strong>由于聚集索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚集索引</strong></p><p>单单从定义来看是不是显得有点抽象，打个比方，一个表就像是我们以前用的新华字典，聚集索引就像是拼音目录，而每个字存放的页码就是我们的数据物理地址，我们如果要查询一个“哇”字，我们只需要查询“哇”字对应在新华字典拼音目录对应的页码，就可以查询到对应的“哇”字所在的位置，而拼音目录对应的A-Z的字顺序，和新华字典实际存储的字的顺序A-Z也是一样的，如果我们中文新出了一个字，拼音开头第一个是B，那么他插入的时候也要按照拼音目录顺序插入到A字的后面。</p><h2 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h2><p>非聚集（unclustered）索引。</p><p>定义：该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。</p><p>其实按照定义，除了聚集索引以外的索引都是非聚集索引，只是人们想细分一下非聚集索引，分成普通索引，唯一索引，全文索引。如果非要把非聚集索引类比成现实生活中的东西，那么非聚集索引就像新华字典的偏旁字典，他结构顺序与实际存放顺序不一定一致。</p><h2 id="聚集索引和非聚集索引的区别"><a href="#聚集索引和非聚集索引的区别" class="headerlink" title="聚集索引和非聚集索引的区别"></a>聚集索引和非聚集索引的区别</h2><ul><li>聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个</li><li>聚集索引存储记录是物理上连续存在，而非聚集索引是<strong>逻辑上的连续</strong>，物理存储并不连续</li></ul><p><strong>聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。</strong></p><p>聚集索引表记录的排列顺序与索引的排列顺序一致</p><ul><li>优点是查询速度快，可以进行范围查找，因为一旦具有第一个索引值的纪录被找到，<strong>具有连续索引值的记录也一定物理的紧跟其后。</strong></li><li>缺点是对表进行修改速度较慢，<strong>这是为了保持表中的记录的物理顺序与索引的顺序一致，而把记录插入到数据页的相应位置，必须在数据页中进行数据重排， 降低了执行速度。</strong></li></ul><p>建议使用聚集索引的场合为：<br>a. 此列包含有限数目的不同值；<br>b. 查询的结果返回一个区间的值；<br>c. 查询的结果返回某值相同的大量结果集。</p><p><strong>非聚集索引指定了表中记录的逻辑顺序，但记录的物理顺序和索引的顺序不一致</strong></p><p>聚集索引和非聚集索引都采用了B+（平衡树）树的结构，<strong>但非聚集索引的叶子层并不与实际的数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针的方式。</strong><br>非聚集索引比聚集索引层次多，添加记录不会引起数据顺序的重组。<br>建议使用非聚集索引的场合为：<br>a. 此列包含了大量数目不同的值；<br>b. 查询的结束返回的是少量的结果集；<br>c. order by 子句中使用了该列。</p><p><strong>表中经常有一个列或列的组合，其值能唯一地标识表中的每一行。这样的一列或多列称为表的主键.(默认为聚集索引)</strong></p><p><strong>聚集索引确定表中数据的物理顺序</strong>。聚集索引类似于电话簿，后者按姓氏排列数据。但该索引可以包含多个列（组合索引），就像电话簿按姓氏和名字进行组织一样。</p><p>聚集索引相当于我们书本上前面的目录的一样，它可以方便快速的找到你想找的内容，而非聚集索引就相当于书最后几页的解释，它是对书中某个语句或者是生词的解释，就像我们上学时候的地理说一样，书后面都有各种地理名称的英文解释；<br>《数据库原理》里面的解释：<strong>聚集索引的顺序就是数据的物理存储顺序</strong>，<strong>而非聚集索引的顺序和数据物理排列无关</strong>。<strong>因为数据在物理存放时只能有一种排列方式，所以一个表只能有一个聚集索引</strong>。在SQL SERVER中，索引是通过二叉树的数据结构来描述的；我们可以如此理解这个两种索引：<strong>聚集索引的叶节点就是数据节点，而非聚集索引的叶节点仍然是索引节点，只不过其包含一个指向对应数据块的指针。</strong><br>聚集索引会降低 insert，和update操作的性能，所以，是否使用聚集索引要全面衡量。</p><blockquote><p>参考文章：<br><a href="https://www.jianshu.com/p/5681ebd5b0ef" target="_blank" rel="noopener">https://www.jianshu.com/p/5681ebd5b0ef</a><br><a href="https://www.cnblogs.com/weixing/p/4317774.html" target="_blank" rel="noopener">https://www.cnblogs.com/weixing/p/4317774.html</a><br><a href="https://www.cnblogs.com/s-b-b/p/8334593.html" target="_blank" rel="noopener">https://www.cnblogs.com/s-b-b/p/8334593.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://blog.csdn.net/tkzc_csk/article/details/88688359&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;聚集索引和非聚集索引&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;索引简介&quot;&gt;&lt;a href=&quot;#索引简介&quot; class=&quot;headerlink&quot; title=&quot;索引简介&quot;&gt;&lt;/a&gt;索引简介&lt;/h2&gt;&lt;p&gt;众所周知，&lt;strong&gt;索引是关系型数据库中给数据库表中一列或多列的值排序后的存储结构&lt;/strong&gt;，SQL的主流索引结构有&lt;strong&gt;B+树以及Hash&lt;/strong&gt;结构，聚集索引以及非聚集索引用的是B+树索引。&lt;/p&gt;
&lt;p&gt;SQL Sever索引类型有：&lt;strong&gt;唯一索引，主键索引，聚集索引，非聚集索引。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MySQL 索引类型有：&lt;strong&gt;唯一索引，主键（聚集）索引，非聚集索引，全文索引。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://changsk.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="聚集索引" scheme="http://changsk.top/tags/%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95/"/>
    
      <category term="非聚集索引" scheme="http://changsk.top/tags/%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95/"/>
    
      <category term="数据库索引" scheme="http://changsk.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-翻转单词顺序列</title>
    <link href="http://changsk.top/2019/07/02/jianzhioffer-flip-word-order/"/>
    <id>http://changsk.top/2019/07/02/jianzhioffer-flip-word-order/</id>
    <published>2019-07-02T02:41:07.000Z</published>
    <updated>2019-07-02T02:46:45.455Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p><a id="more"></a><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) <span class="keyword">return</span> str;</span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> start = -<span class="number">1</span>, end = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(chars[<span class="number">0</span>] != <span class="string">' '</span>) start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; chars.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; chars[i] != <span class="string">' '</span> &amp;&amp; chars[i - <span class="number">1</span>] == <span class="string">' '</span>) start = i;</span><br><span class="line">            <span class="keyword">if</span>(chars[i] != <span class="string">' '</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>((i + <span class="number">1</span> &lt; chars.length &amp;&amp; chars[i + <span class="number">1</span>] == <span class="string">' '</span>) || i + <span class="number">1</span> == chars.length)&#123;</span><br><span class="line">                    end = i;</span><br><span class="line">                    reverse(chars, start, end);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(chars, <span class="number">0</span>, chars.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//翻转chars数组中start至end(包括start和end)之间的字符</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = chars[start];</span><br><span class="line">            chars[start] = chars[end];</span><br><span class="line">            chars[end] = c;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="http://changsk.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="http://changsk.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
</feed>
