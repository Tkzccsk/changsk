<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>changsk&#39;s blogs</title>
  
  <subtitle>chang.sk@foxmail.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://changsk.top/"/>
  <updated>2019-07-14T05:20:39.267Z</updated>
  <id>http://changsk.top/</id>
  
  <author>
    <name>changsk</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>进程间通信方式</title>
    <link href="http://changsk.top/2019/07/13/process-communication/"/>
    <id>http://changsk.top/2019/07/13/process-communication/</id>
    <published>2019-07-13T15:38:29.000Z</published>
    <updated>2019-07-14T05:20:39.267Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://www.jianshu.com/p/c1015f5ffa74" target="_blank" rel="noopener">进程间通信IPC (InterProcess Communication)</a></p></blockquote><h2 id="进程间通信的概念"><a href="#进程间通信的概念" class="headerlink" title="进程间通信的概念"></a>进程间通信的概念</h2><p>每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以<strong>进程之间要交换数据必须通过内核</strong>，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为<strong>进程间通信（IPC，InterProcess Communication）</strong></p><a id="more"></a><p><img src="1.jpg" alt="img"></p><p>进程间通信模型</p><h2 id="进程间通信的7种方式"><a href="#进程间通信的7种方式" class="headerlink" title="进程间通信的7种方式"></a>进程间通信的7种方式</h2><p><strong>第一类：传统的Unix通信机制</strong></p><h3 id="管道-匿名管道-pipe"><a href="#管道-匿名管道-pipe" class="headerlink" title="管道/匿名管道(pipe)"></a>管道/匿名管道(pipe)</h3><ul><li><p>管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。</p></li><li><p>只能用于父子进程或者兄弟进程之间(<strong>具有亲缘关系的进程</strong>);</p></li><li><p>单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。</p></li><li><p>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</p></li></ul><p>  <img src="2.jpg" alt="img"></p><p>  进程间管道通信模型</p><p><strong>管道的实质：</strong><br> 管道的实质是一个<strong>内核缓冲区</strong>，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。<br> 该缓冲区可以看做是一个<strong>循环队列</strong>，<strong>读和写的位置都是自动增长的</strong>，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。<br> <strong>当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。</strong></p><p><strong>管道的局限：</strong><br> 管道的主要局限性正体现在它的特点上：</p><ul><li><strong>只支持单向数据流</strong>；</li><li>只能用于具有亲缘关系的进程之间；</li><li>没有名字；</li><li>管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，<strong>为缓冲区分配一个页面大小</strong>）；</li><li>管道所传送的是无格式<strong>字节流</strong>，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如<strong>多少字节算作一个消息</strong>（或命令、或记录）等等；</li></ul><h3 id="有名管道-FIFO"><a href="#有名管道-FIFO" class="headerlink" title="有名管道(FIFO)"></a>有名管道(FIFO)</h3><p> 匿名管道，由于没有名字，<strong>只能用于亲缘关系的进程间通信</strong>。为了克服这个缺点，提出了有名管道(FIFO)。<br> 有名管道不同于匿名管道之处在于它提供了一个<strong>路径名</strong>与之关联，<strong>以有名管道的文件形式存在于文件系统中</strong>，这样，<strong>即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信</strong>，因此，通过有名管道不相关的进程也能交换数据。值的注意的是，有名管道严格遵循<strong>先进先出(first in first out)</strong>,对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如<code>lseek()</code>等文件定位操作。<strong>有名管道的名字存在于文件系统中，内容存放在内存中。</strong></p><blockquote><p><strong>匿名管道和有名管道总结：</strong><br> （1）管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写。<br> （2）匿名管道是单向的，只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。<br> （3）<strong>无名管道阻塞问题：</strong>无名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，如果管道发现另一端断开，将自动退出。<br> （4）<strong>有名管道阻塞问题：</strong>有名管道在打开时需要确实对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。</p></blockquote><p><a href="https://link.jianshu.com?t=http://blog.chinaunix.net/uid-26833883-id-3227144.html" target="_blank" rel="noopener">延伸阅读：该博客有匿名管道和有名管道的C语言实践</a></p><h3 id="信号-Signal"><a href="#信号-Signal" class="headerlink" title="信号(Signal)"></a>信号(Signal)</h3><ul><li>信号是Linux系统中用于进程间互相通信或者操作的一种机制，<strong>信号可以在任何时候发给某一进程，而无需知道该进程的状态。</strong></li><li>如果该进程当前并未处于执行状态，则该信号就由内核保存起来，直到该进程恢复执行并传递给它为止。</li><li>如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。</li></ul><blockquote><p><strong>Linux系统中常用信号：</strong><br> （1）<strong>SIGHUP：</strong>用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。<br> （2）<strong>SIGINT：</strong>程序终止信号。程序运行过程中，按<code>Ctrl+C</code>键将产生该信号。<br> （3）<strong>SIGQUIT：</strong>程序退出信号。程序运行过程中，按<code>Ctrl+\\</code>键将产生该信号。<br> （4）<strong>SIGBUS和SIGSEGV：</strong>进程访问非法地址。<br> （5）<strong>SIGFPE：</strong>运算中出现致命错误，如除零操作、数据溢出等。<br> （6）<strong>SIGKILL：</strong>用户终止进程执行信号。shell下执行<code>kill -9</code>发送该信号。<br> （7）<strong>SIGTERM：</strong>结束进程信号。shell下执行<code>kill 进程pid</code>发送该信号。<br> （8）<strong>SIGALRM：</strong>定时器信号。<br> （9）<strong>SIGCLD：</strong>子进程退出信号。如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程。</p></blockquote><p><strong>信号来源</strong><br> <strong>信号是软件层次上对中断机制的一种模拟，是一种异步通信方式</strong>，信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件主要有两个来源：</p><ul><li>硬件来源：用户按键输入<code>Ctrl+C</code>退出、硬件异常如无效的存储访问等。</li><li>软件终止：终止进程信号、其他进程调用kill函数、软件异常产生信号。</li></ul><p><strong>信号生命周期和处理流程</strong><br> （1）信号被某个进程产生，并设置此信号传递的对象（一般为对应进程的<code>pid</code>），<strong>然后传递给操作系统</strong>； （2）操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），如果对应进程没有阻塞，操作系统将传递此信号。<br> （3）目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，<strong>暂时终止当前代码的执行，保护上下文（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、转而执行中断服务程序，执行完成后在回复到中断的位置。当然，对于抢占式内核，在中断返回时还将引发新的调度。</strong></p><p><img src="3.jpg" alt="img"></p><p>信号的生命周期</p><h3 id="消息-Message-队列"><a href="#消息-Message-队列" class="headerlink" title="消息(Message)队列"></a>消息(Message)队列</h3><ul><li><strong>消息队列是存放在内核中的消息链表</strong>，每个消息队列由消息队列标识符表示。</li><li>与管道（无名管道：<strong>只存在于内存中的文件</strong>；命名管道：<strong>存在于实际的磁盘介质或者文件系统</strong>）不同的是<strong>消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。</strong></li><li>另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。<a href="https://link.jianshu.com?t=http://blog.csdn.net/yang_yulei/article/details/19772649" target="_blank" rel="noopener">延伸阅读：消息队列C语言的实践</a> </li></ul><blockquote><p><strong>消息队列特点总结：</strong><br> （1）消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识.<br> （2）消息队列允许一个或多个进程向它写入与读取消息.<br> （3）管道和消息队列的通信数据都是先进先出的原则。<br> （4）消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比FIFO更有优势。<br> （5）<strong>消息队列克服了信号承载信息量少</strong>，<strong>管道只能承载无格式字节流以及缓冲区大小受限等缺点。</strong><br> （6）目前主要有两种类型的消息队列：POSIX消息队列以及System V消息队列，系统V消息队列目前被大量使用。系统V消息队列是随内核持续的，只有在内核重启或者人工删除时，该消息队列才会被删除。</p></blockquote><h3 id="共享内存-share-memory"><a href="#共享内存-share-memory" class="headerlink" title="共享内存(share memory)"></a>共享内存(share memory)</h3><ul><li><p>使得多个进程可以直接读写同一块内存空间，<strong>是最快的可用IPC形式</strong>。是针对其他通信机制运行效率较低而设计的。</p></li><li><p>为了在多个进程间交换信息，<strong>内核专门留出了一块内存区</strong>，可以<strong>由需要访问的进程将其映射到自己的私有地址空间</strong>。<strong>进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。</strong></p></li><li><p>由于多个进程共享一段内存，因此需要<strong>依靠某种同步机制（如信号量）来达到进程间的同步及互斥。</strong></p><p>延伸阅读：Linux支持的主要三种共享内存方式：mmap()系统调用、Posix共享内存，以及System V共享内存实践</p></li></ul><p>  <img src="4.jpg" alt="img"></p><p>  共享内存原理图</p><h3 id="信号量-semaphore"><a href="#信号量-semaphore" class="headerlink" title="信号量(semaphore)"></a>信号量(semaphore)</h3><p> <strong>信号量是一个计数器</strong>，用于多进程对共享数据的访问，<strong>信号量的意图在于进程间同步。</strong><br> 为了获得共享资源，进程需要执行下列操作：<br> （1）<strong>创建一个信号量</strong>：这要求调用者指定初始值，对于<strong>二值信号量</strong>来说，它通常是1，也可是0。<br> （2）<strong>等待一个信号量</strong>：<strong>该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作。</strong><br> （3）<strong>挂出一个信号量</strong>：<strong>该操作将信号量的值加1，也称为V操作。</strong></p><p>为了正确地实现信号量，<strong>信号量值的测试及减1操作应当是原子操作（即P、V操作都是原子操作）</strong>。为此，信号量通常是在内核中实现的。Linux环境中，有三种类型：<strong>Posix（可移植性操作系统接口）有名信号量（使用Posix IPC名字标识）</strong>、<strong>Posix基于内存的信号量（存放在共享内存区中）</strong>、<strong>System V信号量（在内核中维护）</strong>。这三种信号量都可用于进程间或线程间的同步。</p><p><img src="5.jpg" alt="img"></p><p>两个进程使用一个二值信号量</p><p><img src="6.jpg" alt="img"></p><p>两个进程所以用一个Posix有名二值信号量</p><p><img src="7.jpg" alt="img"></p><p>一个进程两个线程共享基于内存的信号量</p><blockquote><p><strong>信号量与普通整型变量的区别：</strong><br> （1）信号量是非负整型变量，除了初始化之外，它只能通过两个标准原子操作：wait(semap) , signal(semap) ; 来进行访问；<br> （2）操作也被成为PV原语（P来源于荷兰语proberen”测试”，V来源于荷兰语verhogen”增加”，P表示通过的意思，V表示释放的意思），而普通整型变量则可以在任何语句块中被访问；</p></blockquote><blockquote><p><strong>信号量与互斥量之间的区别：</strong><br> （1）<strong>互斥量用于线程的互斥，信号量用于线程的同步。这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。</strong><br> <strong>互斥：**</strong>是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。** <strong>同步：**</strong>是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。** <strong>在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源</strong><br> （2）互斥量值只能为0/1，信号量值可以为非负整数。<br> 也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。<br> （3）互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。</p></blockquote><h3 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字(socket)"></a>套接字(socket)</h3><p> 套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说<strong>它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。</strong></p><p><img src="8.jpg" alt="img"></p><p>Socket是应用层和传输层之间的桥梁</p><p>套接字是支持<code>TCP/IP</code>的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</p><p><strong>套接字特性</strong><br> 套接字的特性由3个属性确定，它们分别是：域、端口号、协议类型。<br> <strong>（1）套接字的域</strong><br> 它指定套接字通信中使用的网络介质，最常见的套接字域有两种：<br> <strong>一是AF_INET，它指的是Internet网络。</strong>当客户使用套接字进行跨网络的连接时，它就需要用到服务器计算机的IP地址和端口来指定一台联网机器上的某个特定服务，所以在使用socket作为通信的终点，<strong>服务器应用程序必须在开始通信之前绑定一个端口，服务器在指定的端口等待客户的连接。</strong><br> <strong>另一个域AF_UNIX，表示UNIX文件系统，</strong>它就是文件输入/输出，而它的地址就是文件名。<br> <strong>（2）套接字的端口号</strong><br> 每一个基于TCP/IP网络通讯的程序(进程)都被赋予了唯一的端口和端口号，端口是一个信息缓冲区，用于保留Socket中的输入/输出信息，<strong>端口号是一个16位无符号整数，范围是0-65535</strong>，以区别主机上的每一个程序（端口号就像房屋中的房间号），低于256的端口号保留给标准应用程序，比如pop3的端口号就是110，每一个套接字都组合进了IP地址、端口，这样形成的整体就可以区别每一个套接字。<br> <strong>（3）套接字协议类型</strong><br> 因特网提供三种通信机制，<br> <strong>一是流套接字，</strong>流套接字在域中通过TCP/IP连接实现，同时也是AF_UNIX中常用的套接字类型。流套接字提供的是一个<strong>有序</strong>、<strong>可靠</strong>、<strong>双向字节流</strong>的连接，因此发送的数据可以确保<strong>不会丢失、重复或乱序</strong>到达，<strong>而且它还有一定的出错后重新发送的机制。</strong><br> <strong>二个是数据报套接字，</strong>它不需要建立连接和维持一个连接，它们在域中通常是通过<code>UDP/IP</code>协议实现的。它对可以发送的数据的长度有限制，<strong>数据报作为一个单独的网络消息被传输,它可能会丢失、复制或错乱到达</strong>，UDP不是一个可靠的协议，但是它的速度比较高，因为它并一需要总是要建立和维持一个连接。<br> <strong>三是原始套接字，</strong><code>原始套接字允许对较低层次的协议直接访问，比如IP、 ICMP协议</code>，它常用于检验新的协议实现，或者访问现有服务中配置的新设备，因为RAW SOCKET可以自如地控制Windows下的多种协议，能够对网络底层的传输机制进行控制，所以可以应用原始套接字来操纵网络层和传输层应用。比如，<strong>我们可以通过RAW SOCKET来接收发向本机的ICMP、IGMP协议包，或者接收TCP/IP栈不能够处理的IP包，也可以用来发送一些自定包头或自定协议的IP包。网络监听技术很大程度上依赖于SOCKET_RAW。</strong></p><blockquote><p><strong>原始套接字与标准套接字的区别在于：</strong><br> <code>原始套接字可以读写内核没有处理的IP数据包，而流套接字只能读取TCP协议的数据，数据报套接字只能读取UDP协议的数据。因此，如果要访问其他协议发送数据必须使用原始套接字。</code></p></blockquote><p><strong>套接字通信的建立</strong></p><p><img src="9.jpg" alt="img"></p><p>Socket通信基本流程</p><p><strong>服务器端</strong><br> （1）首先服务器应用程序用系统调用socket来创建一个套接字，它是<strong>系统分配给该服务器进程的类似文件描述符的资源，它不能与其他的进程共享。</strong><br> （2）然后，服务器进程会给套接字起个名字，我们使用系统调用bind来给套接字命名。然后服务器进程就开始等待客户连接到这个套接字。<br> （3）接下来，系统调用listen来创建一个队列并将其用于存放来自客户的进入连接。<br> （4）最后，服务器通过系统调用accept来接受客户的连接。<strong>它会创建一个与原有的命名套接不同的新套接字</strong>，<strong>这个套接字只用于与这个特定客户端进行通信</strong>，而命名套接字（即原先的套接字）则被保留下来继续处理来自其他客户的连接（建立客户端和服务端的用于通信的流，进行通信）。</p><p><strong>客户端</strong><br> （1）客户应用程序首先调用socket来创建一个未命名的套接字，然后将服务器的命名套接字作为一个地址来调用connect与服务器建立连接。<br> （2）一旦连接建立，我们就可以像使用底层的文件描述符那样用套接字来实现双向数据的通信（通过流进行数据传输）。<br> <a href="https://link.jianshu.com?t=http://developer.51cto.com/art/201509/490775.htm" target="_blank" rel="noopener">延伸阅读 ：Java socket编程</a></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="http://blog.chinaunix.net/uid-26833883-id-3227144.html" target="_blank" rel="noopener">进程间通信–管道</a></li><li><a href="https://blog.csdn.net/ljianhui/article/details/10253345" target="_blank" rel="noopener">Linux进程间通信——使用共享内存</a></li><li><a href="http://blog.chinaunix.net/uid-26833883-id-3230564.html" target="_blank" rel="noopener">进程间通信—共享内存</a></li><li><a href="https://www.cnblogs.com/diyingyun/archive/2011/12/04/2275229.html" target="_blank" rel="noopener">信号量与互斥锁</a></li><li><a href="http://blog.chinaunix.net/uid-23193900-id-3194924.html" target="_blank" rel="noopener">信号量</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://www.jianshu.com/p/c1015f5ffa74&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;进程间通信IPC (InterProcess Communication)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;进程间通信的概念&quot;&gt;&lt;a href=&quot;#进程间通信的概念&quot; class=&quot;headerlink&quot; title=&quot;进程间通信的概念&quot;&gt;&lt;/a&gt;进程间通信的概念&lt;/h2&gt;&lt;p&gt;每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以&lt;strong&gt;进程之间要交换数据必须通过内核&lt;/strong&gt;，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为&lt;strong&gt;进程间通信（IPC，InterProcess Communication）&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://changsk.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="进程" scheme="http://changsk.top/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>进程和线程的区别</title>
    <link href="http://changsk.top/2019/07/13/process-thread/"/>
    <id>http://changsk.top/2019/07/13/process-thread/</id>
    <published>2019-07-13T15:04:13.000Z</published>
    <updated>2019-07-13T15:37:40.878Z</updated>
    
    <content type="html"><![CDATA[<p>根本区别：<strong>进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位</strong>。</p><a id="more"></a><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p><strong>线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位</strong>，<strong>一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。</strong></p><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><blockquote><p>根本区别：进程是资源分配的最小单位，线程是程序执行的最小单位。</p></blockquote><ol><li><strong>开销方面</strong>：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程<strong>共享代码和数据空间</strong>，<strong>每个线程都有自己独立的运行栈和程序计数器（PC）</strong>，<strong>线程之间切换的开销小</strong>。</li></ol><blockquote><p>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。</p></blockquote><ol start="2"><li><p><strong>通信方面</strong>：线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。</p></li><li><p><strong>所处环境</strong>：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</p></li><li><p><strong>内存分配</strong>方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），<strong>线程组之间只能共享资源</strong>。</p></li><li><p><strong>包含关系</strong>：<strong>一个程序至少有一个进程,一个进程至少有一个线程.</strong></p></li></ol><blockquote><p>参考：<br><a href="http://mp.weixin.qq.com/s/f_OezOorxInJqzx8WT7x2g" target="_blank" rel="noopener">一道面试题：说说进程和线程的区别</a><br><a href="https://blog.csdn.net/kuangsonghan/article/details/80674777" target="_blank" rel="noopener">进程和线程的主要区别（总结）</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根本区别：&lt;strong&gt;进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://changsk.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="进程" scheme="http://changsk.top/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="线程" scheme="http://changsk.top/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-变态青蛙跳台阶</title>
    <link href="http://changsk.top/2019/07/13/jianzhioffer-jumping-stairs/"/>
    <id>http://changsk.top/2019/07/13/jianzhioffer-jumping-stairs/</id>
    <published>2019-07-13T14:37:12.000Z</published>
    <updated>2019-07-13T15:00:04.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="青蛙跳"><a href="#青蛙跳" class="headerlink" title="青蛙跳"></a>青蛙跳</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><a id="more"></a><h3 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        helper(count, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> count, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count == target)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(count &gt; target) <span class="keyword">return</span>;</span><br><span class="line">        helper(count + <span class="number">1</span>,target); <span class="comment">// helper 的第一个参数不能是 ++count,因为这样的话 count 会自增1，影响后面的 helper 调用</span></span><br><span class="line">        helper(count + <span class="number">2</span>,target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> JumpFloor(target - <span class="number">1</span>) + JumpFloor(target - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法3"><a href="#解法3" class="headerlink" title="解法3"></a>解法3</h3><p>类似于求斐波那契数列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] steps = <span class="keyword">new</span> <span class="keyword">int</span>[target];</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        steps[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        steps[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; target;i++)</span><br><span class="line">            steps[i] = steps[i - <span class="number">1</span>] + steps[i - <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> steps[target - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法4"><a href="#解法4" class="headerlink" title="解法4"></a>解法4</h3><p>比解法3空间效率更高，常数级别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; target;i++)&#123;</span><br><span class="line">            c = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="蛙跳台阶"><a href="#蛙跳台阶" class="headerlink" title="蛙跳台阶"></a>蛙跳台阶</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>分析：因为n级台阶，第一步有n种跳法：跳1级、跳2级、到跳n级<br>跳1级，剩下n-1级，则剩下跳法是f(n-1)<br>跳2级，剩下n-2级，则剩下跳法是f(n-2)<br>所以f(n)=f(n-1)+f(n-2)+…+f(1)<br>因为f(n-1)=f(n-2)+f(n-3)+…+f(1)<br>所以f(n)=2*f(n-1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">        return 1&lt;&lt;--target</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;青蛙跳&quot;&gt;&lt;a href=&quot;#青蛙跳&quot; class=&quot;headerlink&quot; title=&quot;青蛙跳&quot;&gt;&lt;/a&gt;青蛙跳&lt;/h2&gt;&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="http://changsk.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="http://changsk.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer:矩阵覆盖</title>
    <link href="http://changsk.top/2019/07/12/jianzhioffer-matrix-coverage/"/>
    <id>http://changsk.top/2019/07/12/jianzhioffer-matrix-coverage/</id>
    <published>2019-07-12T10:30:39.000Z</published>
    <updated>2019-07-12T13:52:55.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>我们可以用<code>2 * 1</code>的小矩形横着或者竖着去覆盖更大的矩形。请问用n个<code>2 * 1</code>的小矩形无重叠地覆盖一个<code>2*n</code>的大矩形，总共有多少种方法？</p><a id="more"></a><h2 id="AC代码1"><a href="#AC代码1" class="headerlink" title="AC代码1"></a>AC代码1</h2><p>递归的方式。</p><p>设<code>2 * n</code>的大矩阵共有<code>f(n)</code>种覆盖方法，那么</p><p><code>f(n) = f(n - 1) + f(n - 2)</code>，即</p><p>f(n) 可以由<code>f(n - 1)</code> 加上一个竖着的2 * 1的小矩阵拼接，</p><p>也可以由<code>f(n - 2)</code> 加上两个横着的2 * 1的小矩阵拼接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>; </span><br><span class="line">        <span class="keyword">return</span> RectCover(target - <span class="number">1</span>) + RectCover(target - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AC代码2"><a href="#AC代码2" class="headerlink" title="AC代码2"></a>AC代码2</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[target];</span><br><span class="line">        nums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        nums[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; target;i++)&#123;</span><br><span class="line">            nums[i] = nums[i - <span class="number">1</span>] + nums[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[target - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;我们可以用&lt;code&gt;2 * 1&lt;/code&gt;的小矩形横着或者竖着去覆盖更大的矩形。请问用n个&lt;code&gt;2 * 1&lt;/code&gt;的小矩形无重叠地覆盖一个&lt;code&gt;2*n&lt;/code&gt;的大矩形，总共有多少种方法？&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="http://changsk.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="http://changsk.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-121:Best Time to Buy and Sell Stock</title>
    <link href="http://changsk.top/2019/07/12/leetcode-121/"/>
    <id>http://changsk.top/2019/07/12/leetcode-121/</id>
    <published>2019-07-12T10:02:29.000Z</published>
    <updated>2019-07-13T14:39:18.684Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p><p>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p><p>Note that you cannot sell a stock before you buy one.</p><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p><strong>Example 1:</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">Output: <span class="number">5</span></span><br><span class="line">Explanation: Buy <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">2</span> (price = <span class="number">1</span>) <span class="keyword">and</span> sell <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">5</span> (price = <span class="number">6</span>), profit = <span class="number">6</span><span class="number">-1</span> = <span class="number">5.</span></span><br><span class="line">             Not <span class="number">7</span><span class="number">-1</span> = <span class="number">6</span>, <span class="keyword">as</span> selling price needs <span class="keyword">to</span> be larger than buying price.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Input:</span> [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line"><span class="string">Output:</span> <span class="number">0</span></span><br><span class="line"><span class="string">Explanation:</span> In <span class="keyword">this</span> <span class="keyword">case</span>, no transaction is done, i.e. max profit = <span class="number">0.</span></span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">int</span> maxPrice = prices[len - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i = len - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            max = Math.max(max, maxPrice - prices[i]);</span><br><span class="line">            maxPrice = Math.max(maxPrice, prices[i]);</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/best-time-to-buy-and-sell-stock/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer:二维数组中的查找</title>
    <link href="http://changsk.top/2019/07/12/jianzhioffer-find-two-dimensional-array/"/>
    <id>http://changsk.top/2019/07/12/jianzhioffer-find-two-dimensional-array/</id>
    <published>2019-07-12T09:47:11.000Z</published>
    <updated>2019-07-12T09:51:23.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><a id="more"></a><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><p><strong>从二维数组对应的矩阵的右上角或者左下角开始查找。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length == <span class="number">0</span> || array[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> rows = array.length;</span><br><span class="line">        <span class="keyword">int</span> clos = array[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> curX = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curY = clos - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(array[curX][curY] != target) &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[curX][curY] &gt; target) </span><br><span class="line">                <span class="keyword">if</span>(curY - <span class="number">1</span> &gt;= <span class="number">0</span>) curY--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(curX + <span class="number">1</span> &lt; rows) curX++;</span><br><span class="line">                 <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(array[curX][curY] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="http://changsk.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="http://changsk.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-21:Merge Two Sorted Lists(合并两个有序链表)</title>
    <link href="http://changsk.top/2019/07/11/leetcode-21/"/>
    <id>http://changsk.top/2019/07/11/leetcode-21/</id>
    <published>2019-07-11T02:41:25.000Z</published>
    <updated>2019-07-13T14:38:22.179Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-two-sorted-lists/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>题目难度：Easy</p></blockquote><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><p><strong>Example:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="AC代码1"><a href="#AC代码1" class="headerlink" title="AC代码1"></a>AC代码1</h2><p>普通的解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Merge(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">null</span>) <span class="keyword">return</span> list2;</span><br><span class="line">        <span class="keyword">if</span>(list2 == <span class="keyword">null</span>) <span class="keyword">return</span> list1;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode newhead = head;</span><br><span class="line">        <span class="keyword">while</span>(list1 != <span class="keyword">null</span> || list2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">                head.next = list2;</span><br><span class="line">                <span class="keyword">return</span> newhead.next;</span><br><span class="line">                <span class="comment">//head = head.next;</span></span><br><span class="line">                <span class="comment">//list2 = list2.next;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(list2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">                head.next = list1;</span><br><span class="line">                <span class="keyword">return</span> newhead.next;</span><br><span class="line">                <span class="comment">//head = head.next;</span></span><br><span class="line">                <span class="comment">//list1 = list1.next;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(list1.val &gt; list2.val)&#123;</span><br><span class="line">                    head.next = list2;</span><br><span class="line">                    head = head.next;</span><br><span class="line">                    list2 = list2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(list1.val &lt; list2.val)&#123;</span><br><span class="line">                    head.next = list1;</span><br><span class="line">                    head = head.next;</span><br><span class="line">                    list1 = list1.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    head.next = list1;</span><br><span class="line">                    head = head.next;</span><br><span class="line">                    head.next = list2;</span><br><span class="line">                    head = head.next;</span><br><span class="line">                    list1 = list1.next;</span><br><span class="line">                    list2 = list2.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><p>递归解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mergeCore(l1,l2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeCore</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">                l1.next = mergeCore(l1.next, l2);</span><br><span class="line">                <span class="keyword">return</span> l1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                l2.next = mergeCore(l1, l2.next);</span><br><span class="line">                <span class="keyword">return</span> l2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/merge-two-sorted-lists/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/merge-two-sorted-lists/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-221:Maximal Square(最大正方形)</title>
    <link href="http://changsk.top/2019/07/11/leetcode-221/"/>
    <id>http://changsk.top/2019/07/11/leetcode-221/</id>
    <published>2019-07-11T02:30:12.000Z</published>
    <updated>2019-07-13T14:39:49.678Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/maximal-square/" target="_blank" rel="noopener">https://leetcode.com/problems/maximal-square/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>题目难度：Medium</p></blockquote><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.</p><p><strong>Example:</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: </span><br><span class="line"></span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line"><span class="attribute">Output</span>: 4</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>动态规划，构造一个等大小的<code>dp[n][m]</code>矩阵，<code>dp[i][j]</code>表示以<code>matrix[i][j]</code>为右下角的全1正方形的边长。初始化<code>dp[i][0]</code>和<code>dp[0][j]</code>分别为<code>matrix[i][0]</code>和<code>matrix[0][j]</code>，因为以边缘这一行一列中的点为右下角的全<code>1</code>正方形边长只有<code>0</code>和<code>1</code>两种情况，分别由他们本身是<code>0</code>还是<code>1</code>决定。初始化之后开始遍历这个dp矩阵，如果<code>matrix[i][j]</code>为<code>0</code>，则<code>dp[i][j]</code>为<code>1</code>，如果<code>matrix[i][j]</code>为<code>1</code>，则<code>dp[i][j]=min{dp[i-1][j],dp[i][j-1],dp[i-1][j-1]}+1</code>，这一步可以这样理解：</p><p><img src="1.jpg" alt></p><p>只有满足<code>matrix[i][j]</code>左方上方和左上方三个地方的正方形边长为<code>2</code>的时候，它的边长才能为<code>3</code>，任意一个为<code>1</code>，则它的边长为<code>2</code>，所以取三者最小值<code>+1</code>就是以该点为右下角的全<code>1</code>正方形边长。最后只用遍历<code>dp</code>矩阵找出最大值即可。</p><blockquote><p>作者：I讨厌鬼I</p><p>链接：<a href="https://www.jianshu.com/p/100a5937869d" target="_blank" rel="noopener">https://www.jianshu.com/p/100a5937869d</a></p><p>来源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p></blockquote><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = a.length, n = a[<span class="number">0</span>].length, result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] b = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i-<span class="number">1</span>][j-<span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                b[i][j] = Math.min(Math.min(b[i][j-<span class="number">1</span>] , b[i-<span class="number">1</span>][j-<span class="number">1</span>]), b[i-<span class="number">1</span>][j]) + <span class="number">1</span>;</span><br><span class="line">                result = Math.max(b[i][j], result); <span class="comment">// update result</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result*result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/maximal-square/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/maximal-square/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
      <category term="DP" scheme="http://changsk.top/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-53:Maximum Subarray</title>
    <link href="http://changsk.top/2019/07/11/leetcode-53/"/>
    <id>http://changsk.top/2019/07/11/leetcode-53/</id>
    <published>2019-07-11T01:23:59.000Z</published>
    <updated>2019-07-13T14:38:37.686Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/maximum-subarray/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-subarray/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>题目难度：Easy</p></blockquote><p>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p><p><strong>Example:</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="string">-2</span>,1,<span class="string">-3</span>,4,<span class="string">-1</span>,2,1,<span class="string">-5</span>,4],</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,<span class="string">-1</span>,2,1] has the largest sum = 6.</span><br></pre></td></tr></table></figure><p><strong>Follow up:</strong></p><p>If you have figured out the O(<em>n</em>) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> sum = max;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt;= sum + nums[i]) sum = nums[i];</span><br><span class="line">            <span class="keyword">else</span> sum += nums[i]; </span><br><span class="line">            max = Math.max(max, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/maximum-subarray/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/maximum-subarray/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-142:Linked List Cycle II</title>
    <link href="http://changsk.top/2019/07/10/leetcode-142/"/>
    <id>http://changsk.top/2019/07/10/leetcode-142/</id>
    <published>2019-07-10T13:47:14.000Z</published>
    <updated>2019-07-13T14:39:25.899Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/linked-list-cycle-ii/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>题目难度：Medium</p></blockquote><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p><p>To represent a cycle in the given linked list, we use an integer <code>pos</code> which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p><p><strong>Note:</strong> Do not modify the linked list.</p><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p><strong>Example 1:</strong></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input:<span class="built_in"> head</span> = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,-<span class="number">4</span>], pos = <span class="number">1</span></span><br><span class="line">Output:<span class="built_in"> tail</span> connects <span class="keyword">to</span> <span class="type">node</span> index <span class="number">1</span></span><br><span class="line">Explanation: There <span class="literal">is</span> a cycle <span class="keyword">in</span> the linked list, <span class="keyword">where</span><span class="built_in"> tail</span> connects <span class="keyword">to</span> the second <span class="type">node</span>.</span><br></pre></td></tr></table></figure><p><img src="1.jpg" alt="img"></p><p><strong>Example 2:</strong></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input:<span class="built_in"> head</span> = [<span class="number">1</span>,<span class="number">2</span>], pos = <span class="number">0</span></span><br><span class="line">Output:<span class="built_in"> tail</span> connects <span class="keyword">to</span> <span class="type">node</span> index <span class="number">0</span></span><br><span class="line">Explanation: There <span class="literal">is</span> a cycle <span class="keyword">in</span> the linked list, <span class="keyword">where</span><span class="built_in"> tail</span> connects <span class="keyword">to</span> the first <span class="type">node</span>.</span><br></pre></td></tr></table></figure><p><img src="2.jpg" alt="img"></p><p><strong>Example 3:</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="string">head</span> <span class="string">=</span> <span class="string">[1],</span> <span class="string">pos</span> <span class="string">=</span> <span class="bullet">-1</span></span><br><span class="line"><span class="attr">Output:</span> <span class="literal">no</span> <span class="string">cycle</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="string">There</span> <span class="string">is</span> <span class="literal">no</span> <span class="string">cycle</span> <span class="string">in</span> <span class="string">the</span> <span class="string">linked</span> <span class="string">list.</span></span><br></pre></td></tr></table></figure><p><img src="3.jpg" alt="img"></p><p><strong>Follow-up</strong>:Can you solve it without using extra space?</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode slowNode = head;</span><br><span class="line">        ListNode quickNode = head;</span><br><span class="line">        <span class="keyword">while</span>(quickNode != <span class="keyword">null</span> &amp;&amp; quickNode.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slowNode = slowNode.next;</span><br><span class="line">            quickNode = quickNode.next.next;</span><br><span class="line">            <span class="keyword">if</span>(slowNode == quickNode)&#123;</span><br><span class="line">                quickNode = head;</span><br><span class="line">                <span class="keyword">while</span>(slowNode != quickNode)&#123;</span><br><span class="line">                    slowNode = slowNode.next;</span><br><span class="line">                    quickNode = quickNode.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> quickNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/linked-list-cycle-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/linked-list-cycle-ii/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-92:Reverse Linked List II</title>
    <link href="http://changsk.top/2019/07/10/leetcode-92/"/>
    <id>http://changsk.top/2019/07/10/leetcode-92/</id>
    <published>2019-07-10T13:14:58.000Z</published>
    <updated>2019-07-13T14:39:11.544Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-linked-list-ii/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Reverse a linked list from position <em>m</em> to <em>n</em>. Do it in one-pass.</p><p><strong>Note:</strong> 1 ≤ <em>m</em> ≤ <em>n</em> ≤ length of list.</p><p><strong>Example:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL, m = <span class="number">2</span>, n = <span class="number">4</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br></pre></td></tr></table></figure><h2 id="AC代码1"><a href="#AC代码1" class="headerlink" title="AC代码1"></a>AC代码1</h2><p>朴素的解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m == n) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">        ListNode curNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">1</span>) &#123; <span class="comment">//从头节点开始</span></span><br><span class="line">            newHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            curNode = head;</span><br><span class="line">            ListNode end = head; <span class="comment">//m - n之间的元素翻转完成之后的尾节点</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; n - m + <span class="number">1</span>)&#123;</span><br><span class="line">                curNode = head;</span><br><span class="line">                head = head.next;</span><br><span class="line">                curNode.next = newHead.next;</span><br><span class="line">                newHead.next = curNode; </span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            end.next = head;</span><br><span class="line">            <span class="keyword">return</span> newHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            newHead = head;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; m - <span class="number">2</span>) &#123;</span><br><span class="line">                head = head.next;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode start = head; <span class="comment">// m 的前一个节点</span></span><br><span class="line">            ListNode end = head.next; <span class="comment">//m - n之间的元素翻转完成之后的尾节点</span></span><br><span class="line">            head = head.next;</span><br><span class="line">            ListNode fakeNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            curNode = head;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; n - m + <span class="number">1</span>)&#123;</span><br><span class="line">                curNode = head;</span><br><span class="line">                head = head.next;</span><br><span class="line">                curNode.next = fakeNode.next;</span><br><span class="line">                fakeNode.next = curNode; </span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(head != <span class="keyword">null</span>) end.next = head;</span><br><span class="line">            start.next = fakeNode.next;</span><br><span class="line">            <span class="keyword">return</span> newHead;</span><br><span class="line">        &#125;        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AC代码2"><a href="#AC代码2" class="headerlink" title="AC代码2"></a>AC代码2</h2><p>优雅的解法，借用<code>leetcode</code>上面的代码</p><p>举例：</p><p>有一个链表， 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; null, m = 2，n = 4，那么翻转后的链表为<br>1 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 6 -&gt; null。</p><p>首先创建一个假的头结点 dummy 0，然后把它放到原链表的最前面，现在的链表是 </p><p>0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; null。</p><p>然后创建两指针，并初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ListNode pre = dummy;</span><br><span class="line">ListNode cur = dummy.next;</span><br></pre></td></tr></table></figure><blockquote><p>0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; null<br>pre  cur（pre 指向0，cur指向1）</p></blockquote><p>然后使cur指向要翻转的第一个节点2，pre指向cur的前一个节点1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = m;</span><br><span class="line"><span class="keyword">while</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    pre = pre.next;</span><br><span class="line">    cur = cur.next;</span><br><span class="line">    i--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; null<br>         pre  cur（pre 指向1，cur指向2）</p></blockquote><p>接下来开始进行翻转操作：<br>现在的链表:</p><blockquote><p>0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; null</p></blockquote><p>翻转一次后的链表</p><blockquote><p>0 -&gt; 1 -&gt; 3 -&gt; 2 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; null</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (n - m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    ListNode temp = cur.next;</span><br><span class="line">    cur.next = temp.next;</span><br><span class="line">    temp.next = pre.next;</span><br><span class="line">    pre.next = temp;</span><br><span class="line">    n--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ListNode temp = cur.next;</span><br></pre></td></tr></table></figure><blockquote><p>0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; null<br>  pre  cur   temp（pre 指向1，cur指向2,temp 指向3）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cur.next = temp.next;</span><br></pre></td></tr></table></figure><blockquote><p>0 -&gt; 1 -&gt; 2 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; null<br>3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; null<br>2 和 3 同时指向 4， 2 到 3的指针断开，（pre 指向1，cur指向2,temp 指向3）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">temp.next = pre.next;</span><br></pre></td></tr></table></figure><blockquote><p>3 指向 2<br>3-&gt; 2 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; null<br>0 -&gt; 1 -&gt; 2 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; null </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pre.next = temp;</span><br></pre></td></tr></table></figure><blockquote><p>1 指向 3<br>0 -&gt; 1 -&gt; 3  -&gt; 2 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; null<br>         pre         cur  (pre 指向1，cur指向2)</p></blockquote><p>上述是翻转第一次的过程，共需要翻转n - m = 2 次。<br>可以看到 pre 和 cur 指针不会变。</p><p><strong>完整代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || m == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        ListNode cur = dummy.next;</span><br><span class="line">        <span class="keyword">int</span> i = m;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (n - m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ListNode temp = cur.next;</span><br><span class="line">            cur.next = temp.next;</span><br><span class="line">            temp.next = pre.next;</span><br><span class="line">            pre.next = temp;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/reverse-linked-list-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/reverse-linked-list-ii/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>https的交互过程</title>
    <link href="http://changsk.top/2019/07/10/https-interaction-process/"/>
    <id>http://changsk.top/2019/07/10/https-interaction-process/</id>
    <published>2019-07-10T12:33:51.000Z</published>
    <updated>2019-07-10T12:43:37.899Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://blog.csdn.net/yjclsx/article/details/81238010" target="_blank" rel="noopener">https的交互过程</a></p></blockquote><p>HTTPS其实是由两部分组成：<code>HTTP + SSL / TLS</code>，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会被加密，所以传输的数据都是加密后的数据。</p><a id="more"></a><p>下面介绍https具体是如何进行加密，解密，验证的，也就是https的交互过程。</p><h2 id="https的交互过程"><a href="#https的交互过程" class="headerlink" title="https的交互过程"></a>https的交互过程</h2><h3 id="客户端发起HTTPS请求"><a href="#客户端发起HTTPS请求" class="headerlink" title="客户端发起HTTPS请求"></a>客户端发起HTTPS请求</h3><p>比如在浏览器里输入<a href="https://blog.csdn.net/yjclsx，然后请求到server的**443**端口。浏览器会把自身支持的一系列Cipher" target="_blank" rel="noopener">https://blog.csdn.net/yjclsx，然后请求到server的**443**端口。浏览器会把自身支持的一系列Cipher</a> Suite（密钥算法套件，简称Cipher）发送给服务端。</p><h3 id="服务端返回"><a href="#服务端返回" class="headerlink" title="服务端返回"></a>服务端返回</h3><p>服务端接收到客户端所有的Cipher后与自身支持的对比，<strong>如果不支持则连接断开</strong>，反之则会从中选出一种<code>加密算法</code>和<code>HASH算法</code>以<strong>证书的形式返回给客户端</strong>，证书中还包含了<code>公钥、颁证机构、网址、失效日期</code>等等。</p><blockquote><p>采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥，用于非对称加密。</p></blockquote><h3 id="客户端验证证书并响应"><a href="#客户端验证证书并响应" class="headerlink" title="客户端验证证书并响应"></a>客户端验证证书并响应</h3><p>客户端收到服务端响应后会做以下几件事：</p><h4 id="验证证书的合法性"><a href="#验证证书的合法性" class="headerlink" title="验证证书的合法性"></a>验证证书的合法性</h4><p>颁发证书的机构是否合法与是否过期，证书中包含的网站地址是否与正在访问的地址一致等。证书验证通过后，在浏览器的地址栏提示网站安全。</p><h4 id="生成随机密码"><a href="#生成随机密码" class="headerlink" title="生成随机密码"></a>生成随机密码</h4><p>如果证书验证通过，或者用户接受了不授信的证书，此时客户端会生成一串随机数，用于后续进行对称加密，以后称之为密钥，然后<strong>用证书中的公钥加密这个密钥</strong>。</p><h4 id="HASH握手信息"><a href="#HASH握手信息" class="headerlink" title="HASH握手信息"></a>HASH握手信息</h4><p>用最开始约定好的<strong>HASH</strong>方式，<strong>把握手消息取HASH值</strong>，然后用密钥加密 “<code>握手消息+握手消息的HASH值(即签名)</code>”  。在这里之所以要加上握手消息的HASH值，主要是把握手消息做一个签名，<strong>用于验证握手消息在传输过程中没有被篡改过。</strong></p><p>最后将之前生成的所有信息发送给服务端。 </p><h3 id="服务端解析和验证"><a href="#服务端解析和验证" class="headerlink" title="服务端解析和验证"></a>服务端解析和验证</h3><p>服务端接收客户端发来的数据之后要做以下的操作：</p><h4 id="解析和验证"><a href="#解析和验证" class="headerlink" title="解析和验证"></a>解析和验证</h4><p>使用自己的私钥将客户端使用公钥加密的信息解密得到之前客户端生成的密钥。然后使用密钥解密客户端发来的加密后的握手消息得到 “握手消息+握手消息的HASH值(即签名)”  ，最后同样对握手信息进行HASH签名，比对和客户端传来的HASH值是否一致，如果一致则HASH验证通过，即表明握手消息在传输过程中没有被篡改过。</p><h4 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h4><p>同样使用密钥加密一段握手消息，发送给客户端。</p><h3 id="客户端解析和验证"><a href="#客户端解析和验证" class="headerlink" title="客户端解析和验证"></a>客户端解析和验证</h3><p>客户端用密钥解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束。</p><h3 id="后续通信"><a href="#后续通信" class="headerlink" title="后续通信"></a>后续通信</h3><p><strong>由于RSA等非对称加密算法的性能是非常低的</strong>，原因在于寻找大素数、大数计算、数据分割需要耗费很多的CPU周期，所以一般的HTTPS连接<strong>只在第一次握手时使用非对称加密</strong>，<strong>通过握手交换对称加密的密钥</strong>，之后所有的通信数据将由之前客户端生成的密钥进行对称加密。</p><p>因为这串密钥只有客户端和服务端知道，所以即使中间请求被拦截也是没法解密数据的，以此保证了通信的安全。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这里客户端与服务端互相发送加密的握手消息并验证，<strong>目的是为了保证双方都安全地获得了一致的密钥，并且可以正常的加密解密数据，为后续真正数据的传输做一次测试</strong>。另外，HTTPS一般使用的加密与HASH算法如下：<br>非对称加密算法：RSA，DSA/DSS<br>对称加密算法：AES，RC4，DES, 3DES<br>HASH算法：MD5，SHA1，SHA256</p><p>参考文献<br>1、<a href="http://www.cnblogs.com/zhuqil/archive/2012/07/23/2604572.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhuqil/archive/2012/07/23/2604572.html</a></p><p>2、<a href="https://www.cnblogs.com/zery/p/5164795.html" target="_blank" rel="noopener">https://www.cnblogs.com/zery/p/5164795.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://blog.csdn.net/yjclsx/article/details/81238010&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https的交互过程&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;HTTPS其实是由两部分组成：&lt;code&gt;HTTP + SSL / TLS&lt;/code&gt;，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会被加密，所以传输的数据都是加密后的数据。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://changsk.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTPS" scheme="http://changsk.top/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>Linux修改权限命令--chmod</title>
    <link href="http://changsk.top/2019/07/10/Linux-chmod/"/>
    <id>http://changsk.top/2019/07/10/Linux-chmod/</id>
    <published>2019-07-10T07:46:03.000Z</published>
    <updated>2019-07-10T07:56:19.586Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://blog.csdn.net/jerrytomcat/article/details/81744860" target="_blank" rel="noopener">Linux修改权限功能——chmod</a></p></blockquote><h2 id="chmod命令概况"><a href="#chmod命令概况" class="headerlink" title="chmod命令概况"></a>chmod命令概况</h2><p>chmod是<code>Linux/Unix</code>中修改文件或者目录权限的命令，通过修改权限可以让指定的人对文件可读、可写、可运行，极大地保证了数据的安全性。</p> <a id="more"></a><h2 id="chmod命令的语法"><a href="#chmod命令的语法" class="headerlink" title="chmod命令的语法"></a>chmod命令的语法</h2><blockquote><p>命令名称：  chmod</p><p>执行权限：  所有用户</p><p>功能描述：  改变文件或目录权限</p></blockquote><pre><code>语法：   第一种方法      chmod     [{ugoa}{+-=}{rwx}]      [文件或目录]        备注：             u：所有者    g：所属组    o：其他人    a：所有人                          +：为用户增加权限     -：为用户减少权限     =：为用户赋予权限                          r：读权限     w：写权限      x：执行权限         第二种方法      chmod   -R    [mode=421]     [文件或目录]     ←（这种方法用的比较多）        备注：            r：4   w：2   x：1                         r为读权限，可以用4来表示，                         w为写权限，可以用2来表示，                         x为执行权限，可以用1来表示。                        -R 递归修改（就是将嵌套在很多文件夹中的文件权限修改了，如果没有这个，只能到指定的文                                                                   件夹下进行修改）范例：         chmod     777     /etc/hurenxiang     将hurenxiang这个文件夹权限改为对所有用户可读，可写，可执行chmod     775     /etc/caiyao         将caiyao这个文件夹权限改为其他用户不可写             </code></pre><h2 id="chmod命令结构详解"><a href="#chmod命令结构详解" class="headerlink" title="chmod命令结构详解"></a>chmod命令结构详解</h2><p>在Linux中输入<code>ll</code>，会出现指定目录下文件/目录的详细信息，本文重点讲解权限部分，也就是下图中红色框中的部分。</p><p><img src="1.jpg" alt></p><p>详解下图：权限一共是10个字符，第1个字符分为1组，后面9个字符分为3组。</p><p>第1个字符有两种情况：如果是“d”则代表这是一个文件夹，如果是“—”代表这是一个文件；</p><p>第2、3、4个字符：这3个字符共同代表的是文件的拥有者，可以用u来表示，拥有四个权限：r：读权限 ， w：写权限，x：执行权限，—：无权限；</p><p>第5、6、7个字符：这3个字符代表的是文件所属群组，可以用g来表示，拥有四个权限：r：读权限 ， w：写权限，x：执行权限，—：无权限；</p><p>第8、9、10个字符：这3个字符代表的是除拥有者和所属群组之外的其他所有的用户，可以用o来表示，拥有四个权限：r：读权限 ， w：写权限，x：执行权限，—：无权限。</p><p>注意：后面9个字符除了u，g，o外，还有一个a，代表了所有用户。</p><p><img src="2.jpg" alt></p><h2 id="chmod命令的使用"><a href="#chmod命令的使用" class="headerlink" title="chmod命令的使用"></a>chmod命令的使用</h2><p>chmod命令都详细讲解完了，下面用几个例子巩固一下：</p><ol><li>这是通过两个实例，详细回顾了一波上面的知识点。</li></ol><blockquote><p>-rw–wx–x     //该文件的拥有者有读取和写入的权限，但没有执行权限；<br>                           所在群组没有读取的权限，但有写入和执行的权限；<br>                           其他用户没有读取和写入的权限，但有执行的权限</p></blockquote><blockquote><p>d–xr-xrw-     //该文件夹的拥有者没有读取和写入的权限，但有执行的权限；<br>                           所在群组没有写入的权限，但有读取和执行的权限；<br>                           其他用户没有执行权限，但有读取和写入的权限</p></blockquote><ol start="2"><li>这是修改权限的一种方法实例。</li></ol><blockquote><p>chmod  u-w , g+r  hurenxiang     //对hurenxiang文件设置本人没有写入的权限，设置所在群组有读取的权限<br>chmod  g+x , o+w  hurenxiang     //对hurenxiang文件设置群组有执行的权限，设置其他用户有写入的权限</p></blockquote><ol start="3"><li>这是修改权限的另一种方法实例（建议）。</li></ol><blockquote><p>chmod  777  hurenxiang       //对hurenxiang文件所有的用户都有读取，写入，执行的权限<br>chmod  751  hurenxiang       //对hurenxiang文件群组中的人没有写入的权限，其他的用户没有读取和写入的权限</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://blog.csdn.net/jerrytomcat/article/details/81744860&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux修改权限功能——chmod&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;chmod命令概况&quot;&gt;&lt;a href=&quot;#chmod命令概况&quot; class=&quot;headerlink&quot; title=&quot;chmod命令概况&quot;&gt;&lt;/a&gt;chmod命令概况&lt;/h2&gt;&lt;p&gt;chmod是&lt;code&gt;Linux/Unix&lt;/code&gt;中修改文件或者目录权限的命令，通过修改权限可以让指定的人对文件可读、可写、可运行，极大地保证了数据的安全性。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://changsk.top/categories/Linux/"/>
    
    
      <category term="chmod" scheme="http://changsk.top/tags/chmod/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-206:Reverse Linked List(翻转链表)</title>
    <link href="http://changsk.top/2019/07/10/leetcode-206/"/>
    <id>http://changsk.top/2019/07/10/leetcode-206/</id>
    <published>2019-07-10T07:33:48.000Z</published>
    <updated>2019-07-13T14:39:41.522Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-linked-list/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>题目难度：Easy</p></blockquote><p>Reverse a singly linked list.</p><p><strong>Example:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br><span class="line">Output: <span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>Follow up:</strong></p><p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode next;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next = dummyHead.next;</span><br><span class="line">            dummyHead.next = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/reverse-linked-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/reverse-linked-list/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-160:Intersection of Two Linked Lists(两个链表的交点)</title>
    <link href="http://changsk.top/2019/07/10/leetcode-160/"/>
    <id>http://changsk.top/2019/07/10/leetcode-160/</id>
    <published>2019-07-10T07:17:42.000Z</published>
    <updated>2019-07-13T14:39:33.769Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">https://leetcode.com/problems/intersection-of-two-linked-lists/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>题目难度：Easy</p></blockquote><p>Write a program to find the node at which the intersection of two singly linked lists begins.</p><p>For example, the following two linked lists:</p><p><img src="1.jpg" alt></p><p>begin to intersect at node c1.</p><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p><strong>Example 1:</strong></p><p><img src="2.jpg" alt></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intersectVal = <span class="number">8</span>, listA = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>], listB = [<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>], skipA = <span class="number">2</span>, skipB = <span class="number">3</span></span><br><span class="line">Output: <span class="keyword">Reference</span> of the <span class="keyword">node</span> <span class="title">with</span> value = <span class="number">8</span></span><br><span class="line">Input Explanation: The intersected <span class="keyword">node</span><span class="title">'s</span> value is <span class="number">8</span> (note that this must not be <span class="number">0</span> if the two lists intersect). From the head of A, it reads as [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]. From the head of B, it reads as [<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]. There are <span class="number">2</span> nodes before the intersected <span class="keyword">node</span> <span class="title">in</span> A; There are <span class="number">3</span> nodes before the intersected <span class="keyword">node</span> <span class="title">in</span> B.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="3.jpg" alt></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intersectVal = <span class="number">2</span>, listA = [<span class="number">0</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>], listB = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>], skipA = <span class="number">3</span>, skipB = <span class="number">1</span></span><br><span class="line">Output: <span class="keyword">Reference</span> of the <span class="keyword">node</span> <span class="title">with</span> value = <span class="number">2</span></span><br><span class="line">Input Explanation: The intersected <span class="keyword">node</span><span class="title">'s</span> value is <span class="number">2</span> (note that this must not be <span class="number">0</span> if the two lists intersect). From the head of A, it reads as [<span class="number">0</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]. From the head of B, it reads as [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>]. There are <span class="number">3</span> nodes before the intersected <span class="keyword">node</span> <span class="title">in</span> A; There are <span class="number">1</span> <span class="keyword">node</span> <span class="title">before</span> the intersected <span class="keyword">node</span> <span class="title">in</span> B.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><p><img src="4.jpg" alt></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: intersectVal = <span class="number">0</span>, listA = [<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>], listB = [<span class="number">1</span>,<span class="number">5</span>], skipA = <span class="number">3</span>, skipB = <span class="number">2</span></span><br><span class="line">Output: <span class="literal">null</span></span><br><span class="line">Input Explanation: From <span class="keyword">the</span> head <span class="keyword">of</span> A, <span class="keyword">it</span> reads <span class="keyword">as</span> [<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>]. From <span class="keyword">the</span> head <span class="keyword">of</span> B, <span class="keyword">it</span> reads <span class="keyword">as</span> [<span class="number">1</span>,<span class="number">5</span>]. Since <span class="keyword">the</span> <span class="literal">two</span> lists <span class="built_in">do</span> <span class="keyword">not</span> <span class="built_in">intersect</span>, intersectVal must be <span class="number">0</span>, <span class="keyword">while</span> skipA <span class="keyword">and</span> skipB can be arbitrary values.</span><br><span class="line">Explanation: The <span class="literal">two</span> lists <span class="built_in">do</span> <span class="keyword">not</span> <span class="built_in">intersect</span>, so <span class="literal">return</span> <span class="literal">null</span>.</span><br></pre></td></tr></table></figure><p><strong>Notes:</strong></p><ul><li>If the two linked lists have no intersection at all, return <code>null</code>.</li><li>The linked lists must retain their original structure after the function returns.</li><li>You may assume there are no cycles anywhere in the entire linked structure.</li><li>Your code should preferably run in O(n) time and use only O(1) memory.</li></ul><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode p1 = headA;</span><br><span class="line">        ListNode p2 = headB;</span><br><span class="line">        <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line">            p1 = (p1 == <span class="keyword">null</span> ? headB : p1.next);</span><br><span class="line">            p2 = (p2 == <span class="keyword">null</span> ? headA : p2.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/intersection-of-two-linked-lists/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/intersection-of-two-linked-lists/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>TCP中的粘包现象产生的原因以及解决办法</title>
    <link href="http://changsk.top/2019/07/10/tcp-sticky-bag/"/>
    <id>http://changsk.top/2019/07/10/tcp-sticky-bag/</id>
    <published>2019-07-10T03:14:51.000Z</published>
    <updated>2019-07-10T03:46:49.888Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://blog.csdn.net/qq_28764223/article/details/80610437" target="_blank" rel="noopener">TCP粘包，拆包及解决方法</a></p></blockquote><p>在进行<code>Java NIO</code>学习时，发现，如果客户端连续不断的向服务端发送数据包时，服务端接收的数据会出现两个数据包粘在一起的情况，这就是TCP协议中经常会遇到的粘包以及拆包的问题。</p><a id="more"></a><p>我们都知道TCP属于传输层的协议，传输层除了有TCP协议外还有UDP协议。那么UDP是否会发生粘包或拆包的现象呢？答案是不会。<strong>UDP是基于报文发送的</strong>，从UDP的帧结构可以看出，在UDP首部采用了16bit来指示UDP数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。而TCP是基于字节流的，虽然应用层和TCP传输层之间的数据交互是大小不等的数据块，但是<strong>TCP把这些数据块仅仅看成一连串无结构的字节流，没有边界</strong>；另外从TCP的帧结构也可以看出，在TCP的首部没有表示数据长度的字段，基于上面两点，在使用TCP传输数据时，才有粘包或者拆包现象发生的可能。</p><h3 id="粘包、拆包表现形式"><a href="#粘包、拆包表现形式" class="headerlink" title="粘包、拆包表现形式"></a>粘包、拆包表现形式</h3><p>现在假设客户端向服务端连续发送了两个数据包，用<code>packet1</code>和<code>packet2</code>来表示，那么服务端收到的数据可以分为三种，现列举如下：</p><p>第一种情况，接收端正常收到两个数据包，即没有发生拆包和粘包的现象，此种情况不在本文的讨论范围内。</p><p><img src="1.jpg" alt="normal"></p><p>第二种情况，接收端只收到一个数据包，由于TCP是不会出现丢包的，所以<strong>这一个数据包中包含了发送端发送的两个数据包的信息</strong>，这种现象即为粘包。这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。</p><p><img src="2.jpg" alt="one"></p><p>第三种情况，这种情况有两种表现形式，如下图。接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。这两种情况如果不加特殊处理，对于接收端同样是不好处理的。</p><p><img src="3.jpg" alt="half_one"></p><p><img src="4.jpg" alt></p><h3 id="粘包、拆包发生原因"><a href="#粘包、拆包发生原因" class="headerlink" title="粘包、拆包发生原因"></a>粘包、拆包发生原因</h3><p>发生TCP粘包或拆包有很多原因，现列出常见的几点，可能不全面，欢迎补充，</p><p>1、要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。</p><p>2、待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。</p><p>3、要发送的数据小于TCP发送缓冲区的大小，会启用Nagle算法（可配置是否启用），TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。</p><p>5、接收数据端的应用层没有及时读取接收缓冲区中的数据，导致接收缓冲区有多次收到的数据，将发生粘包。</p><p>等等。</p><h3 id="粘包、拆包解决办法"><a href="#粘包、拆包解决办法" class="headerlink" title="粘包、拆包解决办法"></a>粘包、拆包解决办法</h3><p>通过以上分析，我们清楚了粘包或拆包发生的原因，那么如何解决这个问题呢？解决问题的关键在于如何给每个数据包添加边界信息，常用的方法有如下几个：</p><p>1、发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。</p><p>2、发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</p><p>3、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。</p><p>等等。</p><h3 id="样例程序"><a href="#样例程序" class="headerlink" title="样例程序"></a>样例程序</h3><p>我将在程序中使用两种方法来解决粘包和拆包问题，固定数据包长度和添加长度首部，这两种方法各有优劣。固定数据包长度传输效率一般，尤其是在要发送的数据长度长短差别很大的时候效率会比较低，但是编程实现比较简单；添加长度首部虽然可以获得较高的传输效率，冗余信息少且固定，但是编程实现较为复杂。下面给出的样例程序是基于之前的文章《<a href="http://blog.insanecoder.top/javazhong-bio-niohe-aioshi-yong-yang-li/" target="_blank" rel="noopener">Java中BIO，NIO和AIO使用样例</a>》中提到的NIO实例的，如果对NIO的使用还不是很熟悉，可以先了解一下Java中NIO编程。</p><h4 id="固定数据包长度"><a href="#固定数据包长度" class="headerlink" title="固定数据包长度"></a>固定数据包长度</h4><p>这种处理方式的思路很简单，发送端在发送实际数据前先把数据封装为固定长度，然后在发送出去，接收端接收到数据后按照这个固定长度进行拆分即可。发送端程序如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送端</span></span><br><span class="line">String msg = <span class="string">"hello world "</span> + number++;  </span><br><span class="line">socketChannel.write(ByteBuffer.wrap(<span class="keyword">new</span> FixLengthWrapper(msg).getBytes()));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 封装固定长度的工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixLengthWrapper</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_LENGTH = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FixLengthWrapper</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(MAX_LENGTH);</span><br><span class="line">        byteBuffer.put(msg.getBytes());</span><br><span class="line">        <span class="keyword">byte</span>[] fillData = <span class="keyword">new</span> <span class="keyword">byte</span>[MAX_LENGTH - msg.length()];</span><br><span class="line">        byteBuffer.put(fillData);</span><br><span class="line">        data = byteBuffer.array();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FixLengthWrapper</span><span class="params">(<span class="keyword">byte</span>[] msg)</span> </span>&#123;</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(MAX_LENGTH);</span><br><span class="line">        byteBuffer.put(msg);</span><br><span class="line">        <span class="keyword">byte</span>[] fillData = <span class="keyword">new</span> <span class="keyword">byte</span>[MAX_LENGTH - msg.length];</span><br><span class="line">        byteBuffer.put(fillData);</span><br><span class="line">        data = byteBuffer.array();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes() &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : getBytes()) &#123;</span><br><span class="line">            sb.append(String.format(<span class="string">"0x%02X "</span>, b));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到客户端在发送数据前首先把数据封装为长度为32bytes的数据包，这个长度是根据目前实际数据包长度来规定的，这个长度必须要大于所有可能出现的数据包的长度，这样才不会出现把数据“截断”的情况。接收端程序如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processByFixLength</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">    <span class="keyword">while</span> (socketChannel.read(byteBuffer) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"> </span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        <span class="keyword">while</span> (byteBuffer.remaining() &gt;= FixLengthWrapper.MAX_LENGTH) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[FixLengthWrapper.MAX_LENGTH];</span><br><span class="line">            byteBuffer.get(data, <span class="number">0</span>, FixLengthWrapper.MAX_LENGTH);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(data) + <span class="string">" &lt;---&gt; "</span> + number++);</span><br><span class="line">        &#125;</span><br><span class="line">        byteBuffer.compact();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出接收端的处理很简单，只需要每次读取固定的长度即可区分出来不同的数据包。</p><h4 id="添加长度首部"><a href="#添加长度首部" class="headerlink" title="添加长度首部"></a>添加长度首部</h4><p>这种方式的处理较上面提到的方式稍微复杂一点。在发送端需要给待发送的数据添加固定的首部，然后再发送出去，然后在接收端需要根据这个首部的长度信息进行数据包的组合或拆分，发送端程序如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送端</span></span><br><span class="line">String msg = <span class="string">"hello world "</span> + number++;  </span><br><span class="line"><span class="comment">// add the head represent the data length</span></span><br><span class="line">socketChannel.write(ByteBuffer.wrap(<span class="keyword">new</span> PacketWrapper(msg).getBytes()));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 添加长度首部的工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PacketWrapper</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] payload;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PacketWrapper</span><span class="params">(String payload)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.payload = payload.getBytes();</span><br><span class="line">        <span class="keyword">this</span>.length = <span class="keyword">this</span>.payload.length;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PacketWrapper</span><span class="params">(<span class="keyword">byte</span>[] payload)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.payload = payload;</span><br><span class="line">        <span class="keyword">this</span>.length = <span class="keyword">this</span>.payload.length;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes() &#123;</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="keyword">this</span>.length + <span class="number">4</span>);</span><br><span class="line">        byteBuffer.putInt(<span class="keyword">this</span>.length);</span><br><span class="line">        byteBuffer.put(payload);</span><br><span class="line">        <span class="keyword">return</span> byteBuffer.array();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : getBytes()) &#123;</span><br><span class="line">            sb.append(String.format(<span class="string">"0x%02X "</span>, b));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从程序可以看到，发送端在发送数据前首先给待发送数据添加了代表长度的首部，首部长为4bytes（即int型长度），这样接收端在收到这个数据之后，首先需要读取首部，拿到实际数据长度，然后再继续读取实际长度的数据，即实现了组包和拆包的操作。程序如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processByHead</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (socketChannel.read(byteBuffer) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 保存bytebuffer状态</span></span><br><span class="line">        <span class="keyword">int</span> position = byteBuffer.position();</span><br><span class="line">        <span class="keyword">int</span> limit = byteBuffer.limit();</span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        <span class="comment">// 判断数据长度是否够首部长度</span></span><br><span class="line">        <span class="keyword">if</span> (byteBuffer.remaining() &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            byteBuffer.position(position);</span><br><span class="line">            byteBuffer.limit(limit);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断bytebuffer中剩余数据是否足够一个包</span></span><br><span class="line">        <span class="keyword">int</span> length = byteBuffer.getInt();</span><br><span class="line">        <span class="keyword">if</span> (byteBuffer.remaining() &lt; length) &#123;</span><br><span class="line">            byteBuffer.position(position);</span><br><span class="line">            byteBuffer.limit(limit);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 拿到实际数据包</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line"> </span><br><span class="line">        byteBuffer.get(data, <span class="number">0</span>, length);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(data) + <span class="string">" &lt;---&gt; "</span> + number++);</span><br><span class="line">        byteBuffer.compact();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键信息已经在程序中做了注释，可以很明显的感觉到这种方法的处理难度相对于固定长度要大一些，不过这种方式可以获取更大的传输效率。</p><p>这里需要提醒各位同学一个问题，由于我在测试的时候采用的是一台机器连续发送数据来模拟高并发的场景，所以在测试的时候会发现服务器端收到的数据包的个数经常会小于包的序号，好像发生了丢包。但经过仔细分析可以发现，这种情况是因为TCP发送缓存溢出导致的丢包，也就是这个数据包根本没有发出来。也就是说，发送端发送数据过快，导致接收端缓存很快被填满，这个时候接收端会把通知窗口设置为0从而控制发送端的流量，这样新到的数据只能暂存在发送端的发送缓存中，当发送缓存溢出后，就出现了我上面提到的丢包，这个问题可以通过增大发送端缓存来缓解这个问题，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.socket().setSendBufferSize(<span class="number">102400</span>);</span><br></pre></td></tr></table></figure><p>当然这个话题不在本文的讨论范围，如果有兴趣的同学可以参阅《TCP/IP详解卷一》中的拥塞窗口一章。</p><p>关于源码说明，源码默认是把粘包和拆包处理这一部分注释掉了，分别位于NIOTcpServer和NIOTcpClient文件中，需要测试粘包和拆包处理程序的同学需要把这一段注释给去掉。</p><p>详见：<a href="https://blog.csdn.net/scythe666/article/details/51996268（含源码下载）" target="_blank" rel="noopener">https://blog.csdn.net/scythe666/article/details/51996268（含源码下载）</a></p><p>tcp粘包udp不粘包的原因：<a href="https://blog.csdn.net/hik_zxw/article/details/48398935" target="_blank" rel="noopener">https://blog.csdn.net/hik_zxw/article/details/48398935</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://blog.csdn.net/qq_28764223/article/details/80610437&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TCP粘包，拆包及解决方法&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在进行&lt;code&gt;Java NIO&lt;/code&gt;学习时，发现，如果客户端连续不断的向服务端发送数据包时，服务端接收的数据会出现两个数据包粘在一起的情况，这就是TCP协议中经常会遇到的粘包以及拆包的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://changsk.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="TCP" scheme="http://changsk.top/tags/TCP/"/>
    
      <category term="粘包" scheme="http://changsk.top/tags/%E7%B2%98%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>redis分布式锁之redisson</title>
    <link href="http://changsk.top/2019/07/10/redis-distributed-lock-redisson/"/>
    <id>http://changsk.top/2019/07/10/redis-distributed-lock-redisson/</id>
    <published>2019-07-10T02:09:30.000Z</published>
    <updated>2019-07-10T02:33:58.286Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://mp.weixin.qq.com/s?__biz=MzU0OTk3ODQ3Ng==&mid=2247483893&idx=1&sn=32e7051116ab60e41f72e6c6e29876d9&chksm=fba6e9f6ccd160e0c9fa2ce4ea1051891482a95b1483a63d89d71b15b33afcdc1f2bec17c03c&mpshare=1&scene=1&srcid=0416Kx8ryElbpy4xfrPkSSdB&key=1eff032c36dd9b3716bab5844171cca99a4ea696da85eed0e4b2b7ea5c39a665110b82b4c975d2fd65c396e91f4c7b3e8590c2573c6b8925de0df7daa886be53d793e7f06b2c146270f7c0a5963dd26a&ascene=1&uin=MTg2ODMyMTYxNQ%3D%3D&devicetype=Windows+10&version=62060739&lang=zh_CN&pass_ticket=y1D2AijXbuJ8HCPhyIi0qPdkT0TXqKFYo%2FmW07fgvW%2FXxWFJiJjhjTsnInShv0ap" target="_blank" rel="noopener">拜托，面试请不要再问我Redis分布式锁的实现原理【石杉的架构笔记】</a></p></blockquote><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>现在面试，一般都会聊聊<strong>分布式系统</strong>这块的东西。通常面试官都会从服务框架（Spring Cloud、Dubbo）聊起，一路聊到分布式事务、分布式锁、ZooKeeper等知识。</p><p>所以咱们这篇文章就来聊聊分布式锁这块知识，具体的来看看<strong>Redis分布式锁的实现原理。</strong></p><a id="more"></a><p>说实话，如果在公司里落地生产环境用分布式锁的时候，一定是会用开源类库的，比如Redis分布式锁，一般就是用<strong>Redisson</strong>框架就好了，非常的简便易用。</p><p>大家如果有兴趣，可以去看看Redisson的官网，看看如何在项目中引入Redisson的依赖，然后基于Redis实现分布式锁的加锁与释放锁。</p><p>下面给大家看一段简单的使用代码片段，先直观的感受一下：</p><p><img src="1.jpg" alt="img"></p><p>怎么样，上面那段代码，是不是感觉简单的不行！</p><p>此外，人家还支持redis单实例、redis哨兵、redis cluster、redis master-slave等各种部署架构，都可以给你完美实现。</p><h2 id="Redisson实现Redis分布式锁的底层原理"><a href="#Redisson实现Redis分布式锁的底层原理" class="headerlink" title="Redisson实现Redis分布式锁的底层原理"></a>Redisson实现Redis分布式锁的底层原理</h2><p>好的，接下来就通过一张手绘图，给大家说说Redisson这个开源框架对Redis分布式锁的实现原理。</p><p><img src="2.jpg" alt="img"></p><h3 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h3><p>咱们来看上面那张图，现在某个客户端要加锁。如果该客户端面对的是一个redis cluster集群，他首先会根据hash节点选择一台机器。</p><p><strong>这里注意</strong>，仅仅只是选择一台机器！这点很关键！</p><p>紧接着，就会发送一段lua脚本到redis上，那段lua脚本如下所示：</p><p><img src="3.jpg" alt="img"></p><p>为啥要用<strong>lua脚本</strong>呢？</p><p>因为一大坨复杂的业务逻辑，可以通过封装在lua脚本中发送给redis，保证这段复杂业务逻辑执行的<strong>原子性</strong>。</p><p>那么，这段lua脚本是什么意思呢？</p><p><strong>KEYS[1]</strong>代表的是你加锁的那个key，比如说：</p><blockquote><p>RLock lock = redisson.getLock(“myLock”);</p></blockquote><p>这里你自己设置了加锁的那个锁key就是“myLock”。</p><p><strong>ARGV[1]</strong>代表的就是锁key的默认生存时间，默认30秒。</p><p><strong>ARGV[2]</strong>代表的是加锁的客户端的ID，类似于下面这样：</p><blockquote><p>8743c9c0-0795-4907-87fd-6c719a6b4586:1</p></blockquote><p>给大家解释一下，第一段if判断语句，就是用“exists myLock”命令判断一下，如果你要加锁的那个锁key不存在的话，你就进行加锁。</p><p>如何加锁呢？很简单，用下面的命令：</p><blockquote><p>hset myLock </p><p>8743c9c0-0795-4907-87fd-6c719a6b4586:1 1</p></blockquote><p>通过这个命令设置一个hash数据结构，这行命令执行后，会出现一个类似下面的数据结构：</p><p><img src="4.jpg" alt="img"></p><p>上述就代表“8743c9c0-0795-4907-87fd-6c719a6b4586:1”这个客户端对“myLock”这个锁key完成了加锁。</p><p>接着会执行“pexpire myLock 30000”命令，设置myLock这个锁key的生存时间是30秒。</p><p>好了，到此为止，ok，加锁完成了。</p><h3 id="锁互斥机制"><a href="#锁互斥机制" class="headerlink" title="锁互斥机制"></a>锁互斥机制</h3><p>那么在这个时候，如果客户端2来尝试加锁，执行了同样的一段lua脚本，会咋样呢？</p><p>很简单，第一个if判断会执行“exists myLock”，发现myLock这个锁key已经存在了。</p><p>接着第二个if判断，判断一下，myLock锁key的hash数据结构中，是否包含客户端2的ID，但是明显不是的，因为那里包含的是客户端1的ID。</p><p>所以，客户端2会获取到pttl myLock返回的一个数字，这个数字代表了myLock这个锁key的<strong>剩余生存时间。</strong>比如还剩15000毫秒的生存时间。</p><p>此时客户端2会进入一个<strong>while循环</strong>，不停的尝试加锁。</p><h3 id="watch-dog自动延期机"><a href="#watch-dog自动延期机" class="headerlink" title="watch dog自动延期机"></a>watch dog自动延期机</h3><p>客户端1加锁的锁key默认生存时间才30秒，如果超过了30秒，客户端1还想一直持有这把锁，怎么办呢？</p><p>简单！只要客户端1一旦加锁成功，就会启动一个watch dog看门狗，<strong>他是一个后台线程，会每隔10秒检查一下</strong>，如果客户端1还持有锁key，那么就会不断的延长锁key的生存时间。</p><h3 id="可重入加锁机制"><a href="#可重入加锁机制" class="headerlink" title="可重入加锁机制"></a>可重入加锁机制</h3><p>那如果客户端1都已经持有了这把锁了，结果可重入的加锁会怎么样呢？</p><p>比如下面这种代码：</p><p><img src="5.jpg" alt="img"></p><p>这时我们来分析一下上面那段lua脚本。</p><p>第一个if判断肯定不成立，“exists myLock”会显示锁key已经存在了。</p><p>第二个if判断会成立，因为myLock的hash数据结构中包含的那个ID，就是客户端1的那个ID，也就是“8743c9c0-0795-4907-87fd-6c719a6b4586:1”</p><p>此时就会执行可重入加锁的逻辑，他会用：</p><blockquote><p>incrby myLock </p><p>8743c9c0-0795-4907-87fd-6c71a6b4586:1 1</p></blockquote><p>通过这个命令，对客户端1的加锁次数，累加1。</p><p>此时myLock数据结构变为下面这样：</p><p><img src="6.jpg" alt="img"></p><p>大家看到了吧，那个myLock的hash数据结构中的那个客户端ID，就对应着加锁的次数</p><h3 id="释放锁机制"><a href="#释放锁机制" class="headerlink" title="释放锁机制"></a>释放锁机制</h3><p>如果执行lock.unlock()，就可以释放分布式锁，此时的业务逻辑也是非常简单的。</p><p>其实说白了，就是每次都对myLock数据结构中的那个加锁次数减1。</p><p>如果发现加锁次数是0了，说明这个客户端已经不再持有锁了，此时就会用：</p><p>“del myLock”命令，从redis里删除这个key。</p><p>然后呢，另外的客户端2就可以尝试完成加锁了。</p><p>这就是所谓的<strong>分布式锁的开源Redisson框架的实现机制。</strong></p><p>一般我们在生产系统中，可以用Redisson框架提供的这个类库来基于redis进行分布式锁的加锁与释放锁。</p><h2 id="上述Redis分布式锁的缺点"><a href="#上述Redis分布式锁的缺点" class="headerlink" title="上述Redis分布式锁的缺点"></a>上述Redis分布式锁的缺点</h2><p>其实上面那种方案最大的问题，就是如果你对某个redis master实例，写入了myLock这种锁key的value，此时会异步复制给对应的redis slave实例。</p><p>但是这个过程中一旦发生redis master宕机，主备切换，redis slave变为了redis master。(但是这个加锁的key还没有来得及同步到slave节点)。</p><p>接着就会导致，客户端2来尝试加锁的时候，在新的redis master上完成了加锁，而客户端1也以为自己成功加了锁。</p><p>此时就会导致多个客户端对一个分布式锁完成了加锁。</p><p>这时系统在业务语义上一定会出现问题，<strong>导致各种脏数据的产生</strong>。</p><p>所以这个就是redis cluster，或者是redis master-slave架构的<strong>主从异步复制</strong>导致的redis分布式锁的最大缺陷：<strong>在redis master实例宕机的时候，可能导致多个客户端同时完成加锁。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU0OTk3ODQ3Ng==&amp;mid=2247483893&amp;idx=1&amp;sn=32e7051116ab60e41f72e6c6e29876d9&amp;chksm=fba6e9f6ccd160e0c9fa2ce4ea1051891482a95b1483a63d89d71b15b33afcdc1f2bec17c03c&amp;mpshare=1&amp;scene=1&amp;srcid=0416Kx8ryElbpy4xfrPkSSdB&amp;key=1eff032c36dd9b3716bab5844171cca99a4ea696da85eed0e4b2b7ea5c39a665110b82b4c975d2fd65c396e91f4c7b3e8590c2573c6b8925de0df7daa886be53d793e7f06b2c146270f7c0a5963dd26a&amp;ascene=1&amp;uin=MTg2ODMyMTYxNQ%3D%3D&amp;devicetype=Windows+10&amp;version=62060739&amp;lang=zh_CN&amp;pass_ticket=y1D2AijXbuJ8HCPhyIi0qPdkT0TXqKFYo%2FmW07fgvW%2FXxWFJiJjhjTsnInShv0ap&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;拜托，面试请不要再问我Redis分布式锁的实现原理【石杉的架构笔记】&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;现在面试，一般都会聊聊&lt;strong&gt;分布式系统&lt;/strong&gt;这块的东西。通常面试官都会从服务框架（Spring Cloud、Dubbo）聊起，一路聊到分布式事务、分布式锁、ZooKeeper等知识。&lt;/p&gt;
&lt;p&gt;所以咱们这篇文章就来聊聊分布式锁这块知识，具体的来看看&lt;strong&gt;Redis分布式锁的实现原理。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://changsk.top/categories/Redis/"/>
    
    
      <category term="Redisson" scheme="http://changsk.top/tags/Redisson/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-用两个栈实现队列</title>
    <link href="http://changsk.top/2019/07/10/jianzhioffer-two-stack-queue/"/>
    <id>http://changsk.top/2019/07/10/jianzhioffer-two-stack-queue/</id>
    <published>2019-07-10T01:41:20.000Z</published>
    <updated>2019-07-10T01:46:49.627Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><a id="more"></a><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="http://changsk.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="http://changsk.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Spring中Bean的生命周期</title>
    <link href="http://changsk.top/2019/07/09/spring-bean-life-cycle/"/>
    <id>http://changsk.top/2019/07/09/spring-bean-life-cycle/</id>
    <published>2019-07-09T13:27:30.000Z</published>
    <updated>2019-07-10T01:35:22.736Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://segmentfault.com/a/1190000016065534" target="_blank" rel="noopener">Bean的生命周期</a></p></blockquote><p>正确理解spring容器中bean的生命周期很重要，有利于对bean的装配过程中进行一些自定义内容。如下图所示的生命周期：</p><a id="more"></a><p><img src="1.jpg" alt></p><p>如上图所见，在bean准备就绪之前，bean工厂执行了若干启动步骤，详细描述如下：</p><ul><li>spring对bean实例化；</li><li>spring将值和bean的引用注入到bean对应的属性中；</li><li>如果bean实现了BeanNameAware接口，spring将bean的id传递给setBeanName()方法，该方法的作用就是<strong>设置bean的id到BeanFactory中方便创建该bean，同时让bean知道自己在BeanFactory配置中的名字</strong>；</li><li>如果bean实现了BeanFactoryAware接口，spring将调用setBeanFactroy()方法，将BeanFactory容器实例传入，<strong>便于bean够获取配置他们的BeanFactory的引用</strong>；</li><li>如果bean实现了ApplicationContextAware接口，spring将调用setApplicationContext()方法，将bean所在应用上下文的引用传进来，<strong>便于bean获取它所在的Spring容器</strong>(ApplicationContext是BeanFactory的子接口，有更多的实现方法)；</li><li>如果bean实现了BeanPostProcessor接口，spring将调用它的postProcessBeforeInitialization()方法，该方法在bean初始化之前调用。BeanPostProcessor经常被用作对Bean内容的更改，并且由于这个是在Bean初始化结束时调用那个的方法，也可以被用于内存或者缓存技术；</li><li>如果bean实现了InitializingBean接口，spring将调用它的afterPropertiesSet()方法，当bean的所用属性被设置完成之后调用该方法；</li><li>如果bean实现了BeanPostProcessor接口，spring将调用它的postProcessAfterInitialization()方法，在bean初始化完成之后调用；完成以上工作之后就可以应用这个Bean了，默认的Bean是SingleTon。</li><li>如果bean实现了DisposableBean接口，spring将调用它的destory()方法；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://segmentfault.com/a/1190000016065534&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Bean的生命周期&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;正确理解spring容器中bean的生命周期很重要，有利于对bean的装配过程中进行一些自定义内容。如下图所示的生命周期：&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://changsk.top/categories/Java/"/>
    
    
      <category term="Spring" scheme="http://changsk.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC执行流程及源码解析</title>
    <link href="http://changsk.top/2019/07/09/spring-mvc/"/>
    <id>http://changsk.top/2019/07/09/spring-mvc/</id>
    <published>2019-07-09T13:02:51.000Z</published>
    <updated>2019-07-10T01:37:53.236Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="[http://cxis.me/2017/04/06/SpringMVC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/](http://cxis.me/2017/04/06/SpringMVC执行流程及源码解析/)">SpringMVC执行流程及源码解析</a></p></blockquote><p>在<code>SpringMVC</code>中主要是围绕着<code>DispatcherServlet</code>来设计，可以把它当做<strong>指挥中心</strong>。这里先说明一下SpringMVC文档给出的执行流程，然后是我们稍微具体的执行流程，最后是流程大致的源码跟踪。关于很很很详细的源码解析，这里暂先不做。</p><a id="more"></a><h2 id="官方文档中的流程"><a href="#官方文档中的流程" class="headerlink" title="官方文档中的流程"></a>官方文档中的流程</h2><p>首先看下<code>SpringMVC</code>文档上给的流程图：</p><p><img src="1.jpg" alt></p><p>这张图片给了我们大概的执行流程：</p><ol><li>用户请求首先发送到<strong>前端控制器DispatcherServlet</strong>，DispatcherServlet根据请求的信息来决定使用哪个页面控制器Controller（也就是我们通常编写的Controller）来处理该请求。找到控制器之后，DispatcherServlet将请求委托给控制器去处理。</li><li>接下来页面控制器开始处理用户请求，页面控制器会根据请求信息进行处理，<strong>调用业务层</strong>等等，处理完成之后，会把结果封装成一个<strong>ModelAndView</strong>返回给DispatcherServlet。</li><li>前端控制器DispatcherServlet接到页面控制器的返回结果后，根据返回的视图名选择相应的试图模板，并根据返回的数据进行渲染。</li><li>最后前端控制器DispatcherServlet将结果返回给用户。</li></ol><h2 id="更具体的流程"><a href="#更具体的流程" class="headerlink" title="更具体的流程"></a>更具体的流程</h2><p>上面只是总体流程，接下来我们稍微深入一点，看下更具体的流程，这里没有图，只有步骤解析：</p><ol><li>用户请求发送到前端控制器DispatcherServlet。</li><li>前端控制器DispatcherServlet接收到请求后，DispatcherServlet会使用<code>HandlerMapping</code>来处理，<strong>HandlerMapping会查找到具体进行处理请求的Handler对象。</strong></li><li>HandlerMapping找到对应的Handler之后，并不是返回一个Handler原始对象，而是一个<strong>Handler执行链</strong>，在这个执行链中包括了<strong>拦截器和处理请求的Handler</strong>。HandlerMapping返回一个执行链给DispatcherServlet。</li><li>DispatcherServlet接收到执行链之后，<strong>会调用Handler适配器去执行Handler。</strong></li><li>Handler适配器执行完成Handler（也就是我们写的Controller）之后会得到一个ModelAndView，并返回给DispatcherServlet。</li><li>DispatcherServlet接收到<strong>Handler适配器</strong>返回的ModelAndView之后，<strong>会根据其中的视图名调用视图解析器。</strong></li><li>视图解析器根据逻辑视图名解析成一个真正的<strong>View视图</strong>，并返回给DispatcherServlet。</li><li>DispatcherServlet接收到视图之后，会根据上面的ModelAndView中的model来进行视图中数据的填充，也就是所谓的视图渲染。</li><li>渲染完成之后，DispatcherServlet就可以将结果返回给用户了。</li></ol><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>DispatcherServlet是一个Servlet，我们知道在Servlet在处理一个请求的时候会交给<strong>service</strong>方法进行处理，这里也不例外，DispatcherServlet继承了FrameworkServlet，首先进入FrameworkServlet的service方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="comment">//请求方法</span></span><br><span class="line">    String method = request.getMethod();</span><br><span class="line">    <span class="comment">//PATCH方法单独处理</span></span><br><span class="line">    <span class="keyword">if</span> (method.equalsIgnoreCase(RequestMethod.PATCH.name())) &#123;</span><br><span class="line">        processRequest(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//其他的请求类型的方法经由父类，也就是HttpServlet处理</span></span><br><span class="line">        <span class="keyword">super</span>.service(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HttpServlet中会根据请求类型的不同分别调用<strong>doGet</strong>或者<strong>doPost</strong>等方法，FrameworkServlet中已经重写了这些方法，在这些方法中会调用processRequest进行处理，在processRequest中会调用doService方法，这个doService方法就是在DispatcherServlet中实现的。下面就看下DispatcherServlet中的doService方法的实现。</p><h3 id="请求到达DispatcherServlet"><a href="#请求到达DispatcherServlet" class="headerlink" title="请求到达DispatcherServlet"></a>请求到达DispatcherServlet</h3><p>doService方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给request中的属性做一份快照</span></span><br><span class="line">    Map&lt;String, Object&gt; attributesSnapshot = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Taking snapshot of request attributes before include"</span>);</span><br><span class="line">        attributesSnapshot = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</span><br><span class="line">        <span class="keyword">while</span> (attrNames.hasMoreElements()) &#123;</span><br><span class="line">            String attrName = (String) attrNames.nextElement();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.cleanupAfterInclude || attrName.startsWith(<span class="string">"org.springframework.web.servlet"</span>)) &#123;</span><br><span class="line">                attributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果我们没有配置类似本地化或者主题的处理器之类的</span></span><br><span class="line">    <span class="comment">//SpringMVC会使用默认的值</span></span><br><span class="line">    <span class="comment">//默认配置文件是DispatcherServlet.properties</span></span><br><span class="line">    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class="line">    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.localeResolver);</span><br><span class="line">    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.themeResolver);</span><br><span class="line">    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span><br><span class="line"></span><br><span class="line">    FlashMap inputFlashMap = <span class="keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line">    <span class="keyword">if</span> (inputFlashMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">        request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">    &#125;</span><br><span class="line">    request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> FlashMap());</span><br><span class="line">    request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="keyword">this</span>.flashMapManager);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//开始处理</span></span><br><span class="line">        doDispatch(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Restore the original attribute snapshot, in case of an include.</span></span><br><span class="line">        <span class="keyword">if</span> (attributesSnapshot != <span class="keyword">null</span>) &#123;</span><br><span class="line">            restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DispatcherServlet开始真正的处理，doDispatch方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HttpServletRequest processedRequest = request;</span><br><span class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//SpringMVC中异步请求的相关知识，暂先不解释</span></span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">        Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//先检查是不是Multipart类型的，比如上传等</span></span><br><span class="line">            <span class="comment">//如果是Multipart类型的，则转换为MultipartHttpServletRequest类型</span></span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = processedRequest != request;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取当前请求的Handler</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span> || mappedHandler.getHandler() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取当前请求的Handler适配器</span></span><br><span class="line">            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对于header中last-modified的处理</span></span><br><span class="line">            String method = request.getMethod();</span><br><span class="line">            <span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line">            <span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line">                <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//拦截器的preHandle方法进行处理</span></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//真正调用Handler的地方</span></span><br><span class="line">                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//处理成默认视图名，就是添加前缀和后缀等</span></span><br><span class="line">            applyDefaultViewName(request, mv);</span><br><span class="line">            <span class="comment">//拦截器postHandle方法进行处理</span></span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            dispatchException = ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理最后的结果，渲染之类的都在这里</span></span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line">        triggerAfterCompletionWithError(processedRequest, response, mappedHandler, err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">            mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">        <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">            cleanupMultipart(processedRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到大概的步骤还是按照我们上面分析的走的。</p><h3 id="查找请求对应的Handler对象"><a href="#查找请求对应的Handler对象" class="headerlink" title="查找请求对应的Handler对象"></a>查找请求对应的Handler对象</h3><p>对应着这句代码<code>mappedHandler = getHandler(processedRequest, false);</code>，看下具体的getHandler方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request, <span class="keyword">boolean</span> cache)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getHandler(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往下看getHandler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//遍历所有的handlerMappings进行处理</span></span><br><span class="line">    <span class="comment">//handlerMappings是在启动的时候预先注册好的</span></span><br><span class="line">    <span class="keyword">for</span> (HandlerMapping hm : <span class="keyword">this</span>.handlerMappings) &#123;</span><br><span class="line">        HandlerExecutionChain handler = hm.getHandler(request);</span><br><span class="line">        <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> handler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往下看getHandler，在AbstractHandlerMapping类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//根据request获取handler</span></span><br><span class="line">    Object handler = getHandlerInternal(request);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//如果没有找到就使用默认的handler</span></span><br><span class="line">        handler = getDefaultHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果Handler是String，表明是一个bean名称</span></span><br><span class="line">    <span class="comment">//需要超照对应bean</span></span><br><span class="line">    <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String handlerName = (String) handler;</span><br><span class="line">        handler = getApplicationContext().getBean(handlerName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//封装Handler执行链</span></span><br><span class="line">    <span class="keyword">return</span> getHandlerExecutionChain(handler, request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="根据requrst获取handler"><a href="#根据requrst获取handler" class="headerlink" title="根据requrst获取handler"></a>根据requrst获取handler</h4><p>首先看下根据requrst获取handler步骤getHandlerInternal方法，在AbstractHandlerMethodMapping中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//获取request中的url，用来匹配handler</span></span><br><span class="line">    String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);</span><br><span class="line">    <span class="comment">//根据路径寻找Handler</span></span><br><span class="line">    HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);</span><br><span class="line">    <span class="comment">//根据handlerMethod中的bean来实例化Handler并添加进HandlerMethod</span></span><br><span class="line">    <span class="keyword">return</span> (handlerMethod != <span class="keyword">null</span>) ? handlerMethod.createWithResolvedBean() : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下根据路径寻找handler的方法lookupHandlerMethod：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">lookupHandlerMethod</span><span class="params">(String lookupPath, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    List&lt;Match&gt; matches = <span class="keyword">new</span> ArrayList&lt;Match&gt;();</span><br><span class="line"><span class="comment">//直接匹配</span></span><br><span class="line">    List&lt;T&gt; directPathMatches = <span class="keyword">this</span>.urlMap.get(lookupPath);</span><br><span class="line">    <span class="comment">//如果有匹配的，就添加进匹配列表中</span></span><br><span class="line">    <span class="keyword">if</span> (directPathMatches != <span class="keyword">null</span>) &#123;</span><br><span class="line">        addMatchingMappings(directPathMatches, matches, request);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//还没有匹配的，就遍历所有的处理方法查找</span></span><br><span class="line">    <span class="keyword">if</span> (matches.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// No choice but to go through all mappings</span></span><br><span class="line">        addMatchingMappings(<span class="keyword">this</span>.handlerMethods.keySet(), matches, request);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//找到了匹配的</span></span><br><span class="line">    <span class="keyword">if</span> (!matches.isEmpty()) &#123;</span><br><span class="line">        Comparator&lt;Match&gt; comparator = <span class="keyword">new</span> MatchComparator(getMappingComparator(request));</span><br><span class="line">        Collections.sort(matches, comparator);</span><br><span class="line"><span class="comment">//排序之后，获取第一个</span></span><br><span class="line">        Match bestMatch = matches.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//如果有多个匹配的，会找到第二个最合适的进行比较一下</span></span><br><span class="line">        <span class="keyword">if</span> (matches.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            Match secondBestMatch = matches.get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (comparator.compare(bestMatch, secondBestMatch) == <span class="number">0</span>) &#123;</span><br><span class="line">                Method m1 = bestMatch.handlerMethod.getMethod();</span><br><span class="line">                Method m2 = secondBestMatch.handlerMethod.getMethod();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                        <span class="string">"Ambiguous handler methods mapped for HTTP path '"</span> + request.getRequestURL() + <span class="string">"': &#123;"</span> +</span><br><span class="line">                        m1 + <span class="string">", "</span> + m2 + <span class="string">"&#125;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//设置request参数</span></span><br><span class="line">        handleMatch(bestMatch.mapping, lookupPath, request);</span><br><span class="line">        <span class="comment">//返回匹配的url的处理的方法</span></span><br><span class="line">        <span class="keyword">return</span> bestMatch.handlerMethod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//最后还没有找到，返回null</span></span><br><span class="line">        <span class="keyword">return</span> handleNoMatch(handlerMethods.keySet(), lookupPath, request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取默认Handler"><a href="#获取默认Handler" class="headerlink" title="获取默认Handler"></a>获取默认Handler</h4><p>如果上面没有获取到Handler，就会获取默认的Handler。如果还获取不到就返回null。</p><h4 id="处理String类型的Handler"><a href="#处理String类型的Handler" class="headerlink" title="处理String类型的Handler"></a>处理String类型的Handler</h4><p>如果上面处理完的Handler是String类型的，就会根据这个handlerName获取bean。</p><h4 id="封装Handler执行链"><a href="#封装Handler执行链" class="headerlink" title="封装Handler执行链"></a>封装Handler执行链</h4><p>上面获取完Handler，就开始封装执行链了，就是将我们配置的拦截器加入到执行链中去，getHandlerExecutionChain：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandlerExecutionChain</span><span class="params">(Object handler, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果当前Handler不是执行链类型，就使用一个新的执行链实例封装起来</span></span><br><span class="line">    HandlerExecutionChain chain =</span><br><span class="line">        (handler <span class="keyword">instanceof</span> HandlerExecutionChain) ?</span><br><span class="line">            (HandlerExecutionChain) handler : <span class="keyword">new</span> HandlerExecutionChain(handler);</span><br><span class="line"><span class="comment">//先获取适配类型的拦截器添加进去拦截器链</span></span><br><span class="line">    chain.addInterceptors(getAdaptedInterceptors());</span><br><span class="line"><span class="comment">//当前的url</span></span><br><span class="line">    String lookupPath = urlPathHelper.getLookupPathForRequest(request);</span><br><span class="line">    <span class="comment">//遍历拦截器，找到跟当前url对应的，添加进执行链中去</span></span><br><span class="line">    <span class="keyword">for</span> (MappedInterceptor mappedInterceptor : mappedInterceptors) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mappedInterceptor.matches(lookupPath, pathMatcher)) &#123;</span><br><span class="line">            chain.addInterceptor(mappedInterceptor.getInterceptor());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取对应请求的Handler适配器"><a href="#获取对应请求的Handler适配器" class="headerlink" title="获取对应请求的Handler适配器"></a>获取对应请求的Handler适配器</h3><p>getHandlerAdapter：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerAdapter <span class="title">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="comment">//遍历所有的HandlerAdapter，找到和当前Handler匹配的就返回</span></span><br><span class="line">    <span class="comment">//我们这里会匹配到RequestMappingHandlerAdapter</span></span><br><span class="line">    <span class="keyword">for</span> (HandlerAdapter ha : <span class="keyword">this</span>.handlerAdapters) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ha.supports(handler)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ha;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓存的处理"><a href="#缓存的处理" class="headerlink" title="缓存的处理"></a>缓存的处理</h3><p>也就是对last-modified的处理</p><h3 id="执行拦截器的preHandle方法"><a href="#执行拦截器的preHandle方法" class="headerlink" title="执行拦截器的preHandle方法"></a>执行拦截器的preHandle方法</h3><p>就是遍历所有的我们定义的interceptor，执行preHandle方法</p><h3 id="使用Handler适配器执行当前的Handler"><a href="#使用Handler适配器执行当前的Handler" class="headerlink" title="使用Handler适配器执行当前的Handler"></a>使用Handler适配器执行当前的Handler</h3><p>ha.handle执行当前Handler，我们这里使用的是RequestMappingHandlerAdapter，首先会进入AbstractHandlerMethodAdapter的handle方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> handleInternal(request, response, (HandlerMethod) handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>handleInternal方法，在RequestMappingHandlerAdapter中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> ModelAndView <span class="title">handleInternal</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">        HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123;</span><br><span class="line">        <span class="comment">// Always prevent caching in case of session attribute management.</span></span><br><span class="line">        checkAndPrepare(request, response, <span class="keyword">this</span>.cacheSecondsForSessionAttributeHandlers, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Uses configured default cacheSeconds setting.</span></span><br><span class="line">        checkAndPrepare(request, response, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute invokeHandlerMethod in synchronized block if required.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.synchronizeOnSession) &#123;</span><br><span class="line">        HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object mutex = WebUtils.getSessionMutex(session);</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">                <span class="keyword">return</span> invokeHandleMethod(request, response, handlerMethod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//执行方法，封装ModelAndView</span></span><br><span class="line">    <span class="keyword">return</span> invokeHandleMethod(request, response, handlerMethod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组装默认视图名称"><a href="#组装默认视图名称" class="headerlink" title="组装默认视图名称"></a>组装默认视图名称</h3><p>前缀和后缀名都加上</p><h3 id="执行拦截器的postHandle方法"><a href="#执行拦截器的postHandle方法" class="headerlink" title="执行拦截器的postHandle方法"></a>执行拦截器的postHandle方法</h3><p>遍历intercepter的postHandle方法。</p><h3 id="处理最后的结果，渲染之类的"><a href="#处理最后的结果，渲染之类的" class="headerlink" title="处理最后的结果，渲染之类的"></a>处理最后的结果，渲染之类的</h3><p>processDispatchResult方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">        HandlerExecutionChain mappedHandler, ModelAndView mv, Exception exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> errorView = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ModelAndViewDefiningException) &#123;</span><br><span class="line">            mv = ((ModelAndViewDefiningException) exception).getModelAndView();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object handler = (mappedHandler != <span class="keyword">null</span> ? mappedHandler.getHandler() : <span class="keyword">null</span>);</span><br><span class="line">            mv = processHandlerException(request, response, handler, exception);</span><br><span class="line">            errorView = (mv != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Did the handler return a view to render?</span></span><br><span class="line">    <span class="keyword">if</span> (mv != <span class="keyword">null</span> &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">    <span class="comment">//渲染</span></span><br><span class="line">        render(mv, request, response);</span><br><span class="line">        <span class="keyword">if</span> (errorView) &#123;</span><br><span class="line">            WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">        <span class="comment">// Concurrent handling started during a forward</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mappedHandler.triggerAfterCompletion(request, response, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点看下render方法，进行渲染：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//设置本地化</span></span><br><span class="line">    Locale locale = <span class="keyword">this</span>.localeResolver.resolveLocale(request);</span><br><span class="line">    response.setLocale(locale);</span><br><span class="line"></span><br><span class="line">    View view;</span><br><span class="line">    <span class="keyword">if</span> (mv.isReference()) &#123;</span><br><span class="line">        <span class="comment">//解析视图名，得到视图</span></span><br><span class="line">        view = resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No need to lookup: the ModelAndView object contains the actual View object.</span></span><br><span class="line">        view = mv.getView();</span><br><span class="line">        <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"ModelAndView ["</span> + mv + <span class="string">"] neither contains a view name nor a "</span> +</span><br><span class="line">                    <span class="string">"View object in servlet with name '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//委托给视图进行渲染</span></span><br><span class="line">    view.render(mv.getModelInternal(), request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>view.render就是进行视图的渲染，然后跳转页面等处理。</p><p>到这里大概的流程就走完了。其中涉及到的东西还有很多，暂先不做详细处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;[http://cxis.me/2017/04/06/SpringMVC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/](http://cxis.me/2017/04/06/SpringMVC执行流程及源码解析/)&quot;&gt;SpringMVC执行流程及源码解析&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;code&gt;SpringMVC&lt;/code&gt;中主要是围绕着&lt;code&gt;DispatcherServlet&lt;/code&gt;来设计，可以把它当做&lt;strong&gt;指挥中心&lt;/strong&gt;。这里先说明一下SpringMVC文档给出的执行流程，然后是我们稍微具体的执行流程，最后是流程大致的源码跟踪。关于很很很详细的源码解析，这里暂先不做。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://changsk.top/categories/Java/"/>
    
    
      <category term="Spring" scheme="http://changsk.top/tags/Spring/"/>
    
  </entry>
  
</feed>
