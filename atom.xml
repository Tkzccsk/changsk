<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>changsk&#39;s blogs</title>
  
  <subtitle>chang.sk@foxmail.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://changsk.top/"/>
  <updated>2019-07-01T11:34:17.239Z</updated>
  <id>http://changsk.top/</id>
  
  <author>
    <name>changsk</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode_416:Partition Equal Subset Sum</title>
    <link href="http://changsk.top/2019/07/01/leetcode-416/"/>
    <id>http://changsk.top/2019/07/01/leetcode-416/</id>
    <published>2019-07-01T08:42:41.000Z</published>
    <updated>2019-07-01T11:34:17.239Z</updated>
    
    <content type="html"><![CDATA[<ol start="416"><li><p><strong>Partition Equal Subset Sum</strong></p><p>题目链接：<a href="https://leetcode.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/partition-equal-subset-sum/</a></p><a id="more"></a></li></ol><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Given a <strong>non-empty</strong> array containing <strong>only positive integers</strong>, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p><p><strong>Note:</strong></p><ol><li>Each of the array element will not exceed 100.</li><li>The array size will not exceed 200.</li></ol><blockquote><p>题目难度:Medium </p></blockquote><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><blockquote><p>Input: [1, 5, 11, 5]<br>Output: true<br>Explanation: The array can be partitioned as [1, 5, 5] and [11].</p></blockquote><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><blockquote><p>Input: [1, 2, 3, 5]<br>Output: false<br>Explanation: The array cannot be partitioned into equal sum subsets.</p></blockquote><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//和为奇数，直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> ((sum &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> dfs(nums, sum/<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    function: 判断在nums数组中，下标从 start开始到数组结束，是否存在和为 target 的子集（可以不连续）</span></span><br><span class="line"><span class="comment">    nums: 原始数组</span></span><br><span class="line"><span class="comment">    target: 目标值，即nums数组中选择子集，使其和为target,</span></span><br><span class="line"><span class="comment">    start: 数目遍历的开始索引</span></span><br><span class="line"><span class="comment">    return: nums数组中存在子集，使其和为target,返回true;否则返回false</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(target == <span class="number">0</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">             <span class="keyword">if</span>(target - nums[i] &lt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//提前结束</span></span><br><span class="line">             <span class="keyword">if</span>(i != start &amp;&amp; nums[i] == nums[i-<span class="number">1</span>])  <span class="comment">//很关键的一步判断，防止做多余的操作</span></span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">             </span><br><span class="line">             <span class="keyword">if</span>(dfs(nums, target - nums[i], i+<span class="number">1</span>)) </span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ol start=&quot;416&quot;&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Partition Equal Subset Sum&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/partition-equal-subset-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/partition-equal-subset-sum/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>0-1背包问题</title>
    <link href="http://changsk.top/2019/07/01/0-1-Backpack-problem/"/>
    <id>http://changsk.top/2019/07/01/0-1-Backpack-problem/</id>
    <published>2019-07-01T07:56:35.000Z</published>
    <updated>2019-07-01T11:39:26.927Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://blog.csdn.net/chanmufeng/article/details/82955730" target="_blank" rel="noopener">彻底理解0-1背包问题</a></p></blockquote><h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h2><p>给定n个重量为w1,w2,w3,…,wn,价值为v1,v2,v3,…,vn,的物品和容量为C的背包，求这个物品中一个最有价值的子集，使得在满足背包的容量的前提下，包内的总价值最大。</p><p><strong>0-1背包问题指的是每个物品只能使用一次</strong></p><a id="more"></a><h2 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h2><p>首先我们用递归的方式来尝试解决这个问题。<br>我们用<code>F(n,C)</code> 表示将前n个物品放进容量为C的背包里，得到的最大的价值。</p><p>我们用自顶向下的角度来看，假如我们已经进行到了最后一步（即求解将n个物品放到背包里获得的最大价值），此时我们便有两种选择:</p><ol><li>不放第n个物品，此时总价值为<code>F(n−1,C)</code></li><li>放置第n个物品，此时总价值为<code>vn+F(n−1,C−wn)</code></li></ol><p>两种选择中总价值最大的方案就是我们的最终方案，递推式（有时也称之为状态转移方程）如下:</p><p><em>F</em>(<em>i</em>,<em>C</em>)=<em>m<strong>a</strong>x</em>(<em>F</em>(<em>i</em>−1,<em>C</em>),<em>v</em>(<em>i</em>)+<em>F</em>(<em>i</em>−1,<em>C</em>−<em>w</em>(<em>i</em>)))  (前提是 w[i] &lt;= C)</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KnapSack01</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解决背包问题的递归函数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w        物品的重量数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v        物品的价值数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index    当前待选择的物品索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity 当前背包有效容量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最大价值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solveKS</span><span class="params">(<span class="keyword">int</span>[] w, <span class="keyword">int</span>[] v, <span class="keyword">int</span> index, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//基准条件：如果索引无效或者容量不足，直接返回当前价值0</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || capacity &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不放第index个物品所得价值</span></span><br><span class="line">        <span class="keyword">int</span> res = solveKS(w, v, index - <span class="number">1</span>, capacity);</span><br><span class="line">        <span class="comment">//放第index个物品所得价值（前提是：第index个物品可以放得下）</span></span><br><span class="line">        <span class="keyword">if</span> (w[index] &lt;= capacity) &#123;</span><br><span class="line">            res = Math.max(res, v[index] + solveKS(w, v, index - <span class="number">1</span>, capacity - w[index]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">knapSack</span><span class="params">(<span class="keyword">int</span>[] w, <span class="keyword">int</span>[] v, <span class="keyword">int</span> C)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = w.length;</span><br><span class="line">        <span class="keyword">return</span> solveKS(w, v, size - <span class="number">1</span>, C);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] w = &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] v = &#123;<span class="number">12</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">15</span>&#125;;</span><br><span class="line">        System.out.println(knapSack(w,v,<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><p>我们用递归方法可以很简单的实现以上代码，但是有个严重的问题就是，直接采用自顶向下的递归算法会导致要<strong>不止一次的解决公共子问题</strong>，因此效率是相当低下的。<br>我们可以将已经求得的子问题的结果保存下来，这样对子问题只会求解一次，这便是记忆化搜索。<br>下面在上述代码的基础上加上记忆化搜索</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KnapSack01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] memo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解决背包问题的递归函数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w        物品的重量数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v        物品的价值数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index    当前待选择的物品索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity 当前背包有效容量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最大价值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solveKS</span><span class="params">(<span class="keyword">int</span>[] w, <span class="keyword">int</span>[] v, <span class="keyword">int</span> index, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//基准条件：如果索引无效或者容量不足，直接返回当前价值0</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || capacity &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果此子问题已经求解过，则直接返回上次求解的结果</span></span><br><span class="line">        <span class="keyword">if</span> (memo[index][capacity] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[index][capacity];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不放第index个物品所得价值</span></span><br><span class="line">        <span class="keyword">int</span> res = solveKS(w, v, index - <span class="number">1</span>, capacity);</span><br><span class="line">        <span class="comment">//放第index个物品所得价值（前提是：第index个物品可以放得下）</span></span><br><span class="line">        <span class="keyword">if</span> (w[index] &lt;= capacity) &#123;</span><br><span class="line">            res = Math.max(res, v[index] + solveKS(w, v, index - <span class="number">1</span>, capacity - w[index]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加子问题的解，便于下次直接使用</span></span><br><span class="line">        memo[index][capacity] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">knapSack</span><span class="params">(<span class="keyword">int</span>[] w, <span class="keyword">int</span>[] v, <span class="keyword">int</span> C)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = w.length;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[size][C + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> solveKS(w, v, size - <span class="number">1</span>, C);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] w = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] v = &#123;<span class="number">12</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">15</span>&#125;;</span><br><span class="line">        System.out.println(knapSack(w, v, <span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h2><p><img src="1.jpg" alt></p><p><img src="2.jpg" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KnapSack01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">knapSack</span><span class="params">(<span class="keyword">int</span>[] w, <span class="keyword">int</span>[] v, <span class="keyword">int</span> C)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = w.length;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[size][C + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化第一行</span></span><br><span class="line">        <span class="comment">//仅考虑容量为i的背包放第0个物品的情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= C; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = w[<span class="number">0</span>] &lt;= i ? v[<span class="number">0</span>] : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//填充其他行和列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= C; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (w[i] &lt;= j) &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], v[i] + dp[i - <span class="number">1</span>][j - w[i]]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[size - <span class="number">1</span>][C];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] w = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] v = &#123;<span class="number">12</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">15</span>&#125;;</span><br><span class="line">        System.out.println(knapSack(w, v, <span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="空间复杂度的极致优化"><a href="#空间复杂度的极致优化" class="headerlink" title="空间复杂度的极致优化"></a>空间复杂度的极致优化</h2><p>上面的动态规划算法使用了O(n*C)的空间复杂度（因为我们使用了二维数组来记录子问题的解），其实我们完全可以只使用一维数组来存放结果，但同时我们需要注意的是，为了防止计算结果被覆盖，我们必须从后向前分别进行计算。</p><p><img src="3.jpg" alt></p><p>我们仍然假设背包空间为5，根据</p><p><em>F</em>(<em>i</em>,<em>C</em>)=<em>m<strong>a</strong>x</em>(<em>F</em>(<em>i</em>−1,<em>C</em>),<em>v</em>(<em>i</em>)+<em>F</em>(<em>i</em>−1,<em>C</em>−<em>w</em>(<em>i</em>)))</p><p>我们可以知道，当我们利用一维数组进行记忆化的时候，我们只需要使用到当前位置的值和该位置之前的值，举个例子<br>假设我们要计算F(i,4),我们需要用到的值为F(i−1,4) ,和F(i−1,4−w(i)),因此为了防止结果被覆盖，我们需要从后向前依次计算结果<br>最终的动态规划代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KnapSack01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">knapSack</span><span class="params">(<span class="keyword">int</span>[] w, <span class="keyword">int</span>[] v, <span class="keyword">int</span> C)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = w.length;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[C + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化第一行</span></span><br><span class="line">        <span class="comment">//仅考虑容量为C的背包放第0个物品的情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= C; i++) &#123;</span><br><span class="line">            dp[i] = w[<span class="number">0</span>] &lt;= i ? v[<span class="number">0</span>] : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = C; j &gt;= w[i]; j--) &#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], v[i] + dp[j - w[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[C];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] w = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] v = &#123;<span class="number">12</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">15</span>&#125;;</span><br><span class="line">        System.out.println(knapSack(w, v, <span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用背包问题的思想解决问题"><a href="#利用背包问题的思想解决问题" class="headerlink" title="利用背包问题的思想解决问题"></a>利用背包问题的思想解决问题</h2><p><strong>leetcode 416 Partition Equal Subset Sum</strong></p><blockquote><p>给定一个仅包含正整数的非空数组，确定该数组是否可以分成两部分，要求两部分的和相等</p></blockquote><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>该问题我们可以利用背包问题的思想进行求解。</p><p>假设给定元素个数为n的数组arr，数组元素的和为sum，对应于背包问题，等价于有n个物品，每个物品的重量和价值均为为arr[i]，背包的限重为sum/2，求解背包中的物品最大价值为多少？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">knapSack</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[sum + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= sum;i ++)&#123;</span><br><span class="line">           dp[i] = i == nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; size;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = sum;j &gt;= nums[i];j--)&#123;</span><br><span class="line">                dp[j] = dp[j] || dp[j-nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[sum];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> item : nums)&#123;</span><br><span class="line">            sum += item;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果数组元素和不是2的倍数，直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> knapSack(nums,sum/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://blog.csdn.net/chanmufeng/article/details/82955730&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;彻底理解0-1背包问题&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;0-1背包问题&quot;&gt;&lt;a href=&quot;#0-1背包问题&quot; class=&quot;headerlink&quot; title=&quot;0-1背包问题&quot;&gt;&lt;/a&gt;0-1背包问题&lt;/h2&gt;&lt;p&gt;给定n个重量为w1,w2,w3,…,wn,价值为v1,v2,v3,…,vn,的物品和容量为C的背包，求这个物品中一个最有价值的子集，使得在满足背包的容量的前提下，包内的总价值最大。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;0-1背包问题指的是每个物品只能使用一次&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
    
      <category term="背包问题" scheme="http://changsk.top/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="http://changsk.top/2019/07/01/Linux-common-command/"/>
    <id>http://changsk.top/2019/07/01/Linux-common-command/</id>
    <published>2019-07-01T02:28:20.000Z</published>
    <updated>2019-07-01T02:54:56.921Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://blog.csdn.net/colin_yu/article/details/77892874" target="_blank" rel="noopener">Linux最常用150个命令汇总</a></p></blockquote><table><thead><tr><th>线上查询及帮助命令(2个)</th><th></th></tr></thead><tbody><tr><td>man</td><td>查看命令帮助，命令的词典，更复杂的还有info，但不常用。</td></tr><tr><td>help</td><td>查看Linux内置命令的帮助，比如cd命令。</td></tr></tbody></table><a id="more"></a><table><thead><tr><th>文件和目录操作命令(18个)</th><th></th></tr></thead><tbody><tr><td>ls</td><td>全拼list，功能是列出目录的内容及其内容属性信息。</td></tr><tr><td>cd</td><td>全拼change directory，功能是从当前工作目录切换到指定的工作目录。</td></tr><tr><td>cp</td><td>全拼copy，其功能为复制文件或目录。</td></tr><tr><td>find</td><td>查找的意思，用于查找目录及目录下的文件。</td></tr><tr><td>mkdir</td><td>全拼make directories，其功能是创建目录。</td></tr><tr><td>mv</td><td>全拼move，其功能是移动或重命名文件。</td></tr><tr><td>pwd</td><td>全拼print working directory，其功能是显示当前工作目录的绝对路径。</td></tr><tr><td>rename</td><td>用于重命名文件。</td></tr><tr><td>rm</td><td>全拼remove，其功能是删除一个或多个文件或目录。</td></tr><tr><td>rmdir</td><td>全拼remove empty directories，功能是删除空目录。</td></tr><tr><td>touch</td><td>创建新的空文件，改变已有文件的时间戳属性。</td></tr><tr><td>tree</td><td>功能是以树形结构显示目录下的内容。</td></tr><tr><td>basename</td><td>显示文件名或目录名。</td></tr><tr><td>dirname</td><td>显示文件或目录路径。</td></tr><tr><td>chattr</td><td>改变文件的扩展属性。</td></tr><tr><td>lsattr</td><td>查看文件扩展属性。</td></tr><tr><td>file</td><td>显示文件的类型。</td></tr><tr><td>md5sum</td><td>计算和校验文件的MD5值。</td></tr></tbody></table><table><thead><tr><th>查看文件及内容处理命令（21个）</th><th></th></tr></thead><tbody><tr><td>cat</td><td>全拼concatenate，功能是用于连接多个文件并且打印到屏幕输出或重定向到指定文件中。</td></tr><tr><td>tac</td><td>tac是cat的反向拼写，因此命令的功能为反向显示文件内容。</td></tr><tr><td>more</td><td>分页显示文件内容。</td></tr><tr><td>less</td><td>分页显示文件内容，more命令的相反用法。</td></tr><tr><td>head</td><td>显示文件内容的头部。</td></tr><tr><td>tail</td><td>显示文件内容的尾部。</td></tr><tr><td>cut</td><td>将文件的每一行按指定分隔符分割并输出。</td></tr><tr><td>split</td><td>分割文件为不同的小片段。</td></tr><tr><td>paste</td><td>按行合并文件内容。</td></tr><tr><td>sort</td><td>对文件的文本内容排序。</td></tr><tr><td>uniq</td><td>去除重复行。oldboy</td></tr><tr><td>wc</td><td>统计文件的行数、单词数或字节数。</td></tr><tr><td>iconv</td><td>转换文件的编码格式。</td></tr><tr><td>dos2unix</td><td>将DOS格式文件转换成UNIX格式。</td></tr><tr><td>diff</td><td>全拼difference，比较文件的差异，常用于文本文件。</td></tr><tr><td>vimdiff</td><td>命令行可视化文件比较工具，常用于文本文件。</td></tr><tr><td>rev</td><td>反向输出文件内容。</td></tr><tr><td>grep/egrep</td><td>过滤字符串，三剑客老三。</td></tr><tr><td>join</td><td>按两个文件的相同字段合并。</td></tr><tr><td>tr</td><td>替换或删除字符。</td></tr><tr><td>vi/vim</td><td>命令行文本编辑器。</td></tr></tbody></table><table><thead><tr><th>文件压缩及解压缩命令（4个）</th><th></th></tr></thead><tbody><tr><td>tar</td><td>打包压缩。oldboy</td></tr><tr><td>unzip</td><td>解压文件。</td></tr><tr><td>gzip</td><td>gzip压缩工具。</td></tr><tr><td>zip</td><td>压缩工具。</td></tr></tbody></table><table><thead><tr><th>信息显示命令（11个）</th><th></th></tr></thead><tbody><tr><td>uname</td><td>显示操作系统相关信息的命令。</td></tr><tr><td>hostname</td><td>显示或者设置当前系统的主机名。</td></tr><tr><td>dmesg</td><td>显示开机信息，用于诊断系统故障。</td></tr><tr><td>uptime</td><td>显示系统运行时间及负载。</td></tr><tr><td>stat</td><td>显示文件或文件系统的状态。</td></tr><tr><td>du</td><td>计算磁盘空间使用情况。</td></tr><tr><td>df</td><td>报告文件系统磁盘空间的使用情况。</td></tr><tr><td>top</td><td>实时显示系统资源使用情况。</td></tr><tr><td>free</td><td>查看系统内存。</td></tr><tr><td>date</td><td>显示与设置系统时间。</td></tr><tr><td>cal</td><td>查看日历等时间信息。</td></tr></tbody></table><table><thead><tr><th>搜索文件命令（4个）</th><th></th></tr></thead><tbody><tr><td>which</td><td>查找二进制命令，按环境变量PATH路径查找。</td></tr><tr><td>find</td><td>从磁盘遍历查找文件或目录。</td></tr><tr><td>whereis</td><td>查找二进制命令，按环境变量PATH路径查找。</td></tr><tr><td>locate</td><td>从数据库 (/var/lib/mlocate/mlocate.db) 查找命令，使用updatedb更新库。</td></tr></tbody></table><table><thead><tr><th>用户管理命令（10个）</th><th></th></tr></thead><tbody><tr><td>useradd</td><td>添加用户。</td></tr><tr><td>usermod</td><td>修改系统已经存在的用户属性。</td></tr><tr><td>userdel</td><td>删除用户。</td></tr><tr><td>groupadd</td><td>添加用户组。</td></tr><tr><td>passwd</td><td>修改用户密码。</td></tr><tr><td>chage</td><td>修改用户密码有效期限。</td></tr><tr><td>id</td><td>查看用户的uid,gid及归属的用户组。</td></tr><tr><td>su</td><td>切换用户身份。</td></tr><tr><td>visudo</td><td>编辑/etc/sudoers文件的专属命令。</td></tr><tr><td>sudo</td><td>以另外一个用户身份（默认root用户）执行事先在sudoers文件允许的命令。</td></tr></tbody></table><table><thead><tr><th>基础网络操作命令（11个）</th><th></th></tr></thead><tbody><tr><td>telnet</td><td>使用TELNET协议远程登录。</td></tr><tr><td>ssh</td><td>使用SSH加密协议远程登录。</td></tr><tr><td>scp</td><td>全拼secure copy，用于不同主机之间复制文件。</td></tr><tr><td>wget</td><td>命令行下载文件。</td></tr><tr><td>ping</td><td>测试主机之间网络的连通性。</td></tr><tr><td>route</td><td>显示和设置linux系统的路由表。</td></tr><tr><td>ifconfig</td><td>查看、配置、启用或禁用网络接口的命令。</td></tr><tr><td>ifup</td><td>启动网卡。</td></tr><tr><td>ifdown</td><td>关闭网卡。</td></tr><tr><td>netstat</td><td>查看网络状态。</td></tr><tr><td>ss</td><td>查看网络状态。</td></tr></tbody></table><table><thead><tr><th>深入网络操作命令（9个）</th><th></th></tr></thead><tbody><tr><td>nmap</td><td>网络扫描命令。</td></tr><tr><td>lsof</td><td>全名list open files，也就是列举系统中已经被打开的文件。</td></tr><tr><td>mail</td><td>发送和接收邮件。</td></tr><tr><td>mutt</td><td>邮件管理命令。</td></tr><tr><td>nslookup</td><td>交互式查询互联网DNS服务器的命令。</td></tr><tr><td>dig</td><td>查找DNS解析过程。</td></tr><tr><td>host</td><td>查询DNS的命令。</td></tr><tr><td>traceroute</td><td>追踪数据传输路由状况。</td></tr><tr><td>tcpdump</td><td>命令行的抓包工具。</td></tr></tbody></table><table><thead><tr><th>有关磁盘与文件系统的命令（16个）</th><th></th></tr></thead><tbody><tr><td>mount</td><td>挂载文件系统。</td></tr><tr><td>umount</td><td>卸载文件系统。</td></tr><tr><td>fsck</td><td>检查并修复Linux文件系统。</td></tr><tr><td>dd</td><td>转换或复制文件。</td></tr><tr><td>dumpe2fs</td><td>导出ext2/ext3/ext4文件系统信息。</td></tr><tr><td>dump</td><td>ext2/3/4文件系统备份工具。</td></tr><tr><td>fdisk</td><td>磁盘分区命令，适用于2TB以下磁盘分区。</td></tr><tr><td>parted</td><td>磁盘分区命令，没有磁盘大小限制，常用于2TB以下磁盘分区。</td></tr><tr><td>mkfs</td><td>格式化创建Linux文件系统。</td></tr><tr><td>partprobe</td><td>更新内核的硬盘分区表信息。</td></tr><tr><td>e2fsck</td><td>检查ext2/ext3/ext4类型文件系统。</td></tr><tr><td>mkswap</td><td>创建Linux交换分区。</td></tr><tr><td>swapon</td><td>启用交换分区。</td></tr><tr><td>swapoff</td><td>关闭交换分区。</td></tr><tr><td>sync</td><td>将内存缓冲区内的数据写入磁盘。</td></tr><tr><td>resize2fs</td><td>调整ext2/ext3/ext4文件系统大小。</td></tr></tbody></table><table><thead><tr><th>系统权限及用户授权相关命令（4个）</th><th></th></tr></thead><tbody><tr><td>chmod</td><td>改变文件或目录权限。</td></tr><tr><td>chown</td><td>改变文件或目录的属主和属组。</td></tr><tr><td>chgrp</td><td>更改文件用户组。</td></tr><tr><td>umask</td><td>显示或设置权限掩码。</td></tr></tbody></table><table><thead><tr><th>查看系统用户登陆信息的命令（7个）</th><th></th></tr></thead><tbody><tr><td>whoami</td><td>显示当前有效的用户名称，相当于执行id -un命令。</td></tr><tr><td>who</td><td>显示目前登录系统的用户信息。</td></tr><tr><td>w</td><td>显示已经登陆系统的用户列表，并显示用户正在执行的指令。</td></tr><tr><td>last</td><td>显示登入系统的用户。</td></tr><tr><td>lastlog</td><td>显示系统中所有用户最近一次登录信息。</td></tr><tr><td>users</td><td>显示当前登录系统的所有用户的用户列表。</td></tr><tr><td>finger</td><td>查找并显示用户信息。</td></tr></tbody></table><table><thead><tr><th>内置命令及其它（19个）</th><th></th></tr></thead><tbody><tr><td>echo</td><td>打印变量，或直接输出指定的字符串</td></tr><tr><td>printf</td><td>将结果格式化输出到标准输出。</td></tr><tr><td>rpm</td><td>管理rpm包的命令。</td></tr><tr><td>yum</td><td>自动化简单化地管理rpm包的命令。</td></tr><tr><td>watch</td><td>周期性的执行给定的命令，并将命令的输出以全屏方式显示。</td></tr><tr><td>alias</td><td>设置系统别名。</td></tr><tr><td>unalias</td><td>取消系统别名。</td></tr><tr><td>date</td><td>查看或设置系统时间。</td></tr><tr><td>lear</td><td>清除屏幕，简称清屏。</td></tr><tr><td>history</td><td>查看命令执行的历史纪录。</td></tr><tr><td>eject</td><td>弹出光驱。</td></tr><tr><td>time</td><td>计算命令执行时间。</td></tr><tr><td>nc</td><td>功能强大的网络工具。</td></tr><tr><td>xargs</td><td>将标准输入转换成命令行参数。</td></tr><tr><td>exec</td><td>调用并执行指令的命令。</td></tr><tr><td>export</td><td>设置或者显示环境变量。</td></tr><tr><td>unset</td><td>删除变量或函数。</td></tr><tr><td>type</td><td>用于判断另外一个命令是否是内置命令。</td></tr><tr><td>bc</td><td>命令行科学计算器</td></tr></tbody></table><table><thead><tr><th>系统管理与性能监视命令(9个)</th><th></th></tr></thead><tbody><tr><td>chkconfig</td><td>管理Linux系统开机启动项。</td></tr><tr><td>vmstat</td><td>虚拟内存统计。</td></tr><tr><td>mpstat</td><td>显示各个可用CPU的状态统计。</td></tr><tr><td>iostat</td><td>统计系统IO。</td></tr><tr><td>sar</td><td>全面地获取系统的CPU、运行队列、磁盘 I/O、分页（交换区）、内存、 CPU中断和网络等性能数据。</td></tr><tr><td>ipcs</td><td>用于报告Linux中进程间通信设施的状态，显示的信息包括消息列表、共享内存和信号量的信息。</td></tr><tr><td>ipcrm</td><td>用来删除一个或更多的消息队列、信号量集或者共享内存标识。</td></tr><tr><td>strace</td><td>用于诊断、调试Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。</td></tr><tr><td>ltrace</td><td>命令会跟踪进程的库函数调用,它会显现出哪个库函数被调用。</td></tr></tbody></table><table><thead><tr><th>关机/重启/注销和查看系统信息的命令（6个）</th><th></th></tr></thead><tbody><tr><td>shutdown</td><td>关机。</td></tr><tr><td>halt</td><td>关机。</td></tr><tr><td>poweroff</td><td>关闭电源。</td></tr><tr><td>logout</td><td>退出当前登录的Shell。</td></tr><tr><td>exit</td><td>退出当前登录的Shell。</td></tr><tr><td>Ctrl+d</td><td>退出当前登录的Shell的快捷键。</td></tr></tbody></table><table><thead><tr><th>进程管理相关命令（15个）</th><th></th></tr></thead><tbody><tr><td>bg</td><td>将一个在后台暂停的命令，变成继续执行  （在后台执行）。</td></tr><tr><td>fg</td><td>将后台中的命令调至前台继续运行。</td></tr><tr><td>jobs</td><td>查看当前有多少在后台运行的命令。</td></tr><tr><td>kill</td><td>终止进程。</td></tr><tr><td>killall</td><td>通过进程名终止进程。</td></tr><tr><td>pkill</td><td>通过进程名终止进程。</td></tr><tr><td>crontab</td><td>定时任务命令。</td></tr><tr><td>ps</td><td>显示进程的快照。</td></tr><tr><td>pstree</td><td>树形显示进程。</td></tr><tr><td>nice/renice</td><td>调整程序运行的优先级。</td></tr><tr><td>nohup</td><td>忽略挂起信号运行指定的命令。</td></tr><tr><td>pgrep</td><td>查找匹配条件的进程。</td></tr><tr><td>runlevel</td><td>查看系统当前运行级别。</td></tr><tr><td>init</td><td>切换运行级别。</td></tr><tr><td>service</td><td>启动、停止、重新启动和关闭系统服务，还可以显示所有系统服务的当前状态。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://blog.csdn.net/colin_yu/article/details/77892874&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux最常用150个命令汇总&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;线上查询及帮助命令(2个)&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;man&lt;/td&gt;
&lt;td&gt;查看命令帮助，命令的词典，更复杂的还有info，但不常用。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;help&lt;/td&gt;
&lt;td&gt;查看Linux内置命令的帮助，比如cd命令。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://changsk.top/categories/Linux/"/>
    
    
      <category term="Linux命令" scheme="http://changsk.top/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>中兴2020届秋招提前批在线笔试题:排列员工工资顺序</title>
    <link href="http://changsk.top/2019/07/01/zhongxin-algorithm/"/>
    <id>http://changsk.top/2019/07/01/zhongxin-algorithm/</id>
    <published>2019-07-01T02:16:09.000Z</published>
    <updated>2019-07-01T02:18:36.071Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://blog.csdn.net/q651742112/article/details/82596368" target="_blank" rel="noopener">题目：排列员工工资顺序（Java和C++）（中兴在线笔试题）</a></p></blockquote><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>某公司中有N名员工。给定所有员工工资的清单，财务人员要按照特定的顺序排列员工的工资。他按照工资的频次降序排列。即给定清单中所有频次较高的工资将在频次较低的工资之前出现。如果相同数量的员工都有相同的工资，则将按照给定清单中该工资第一次出现的顺序排列。</p><p>写一个算法来帮助财务人员排列员工工资的顺序。</p><a id="more"></a><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>该函数/方法的输入包括两个参数——</p><p>num，一个整数，表示员工的人数</p><p>salaries，一个正整数列表，表示N名员工的工资</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>返回一个正整数列表，该列表按照员工工资的频次排序。</p><p>约束条件：</p><p>1&lt;num&lt;100000</p><p>1&lt;salaries&lt;1000000000</p><p>0&lt;i&lt;num</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ul><li>输入：</li></ul><p>num=19</p><p>salaries=[10000,20000,40000,30000,30000,30000,40000,20000,50000,</p><p>50000,50000,50000,60000,60000,60000,70000,80000,90000,100000]</p><ul><li>输出：</li></ul><p>[50000,50000,50000,50000,30000,30000,30000,60000,60000,</p><p>60000,20000,20000,40000,40000,10000,70000,80000,90000,100000]</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>本题要求把根据数据出现的频数从高到低排序，所以基本的思路是算出每个数的频次，然后直接从高到低排序。</p><p>可是这样会出现一个问题，频次相同的数据没法排序。比如 20 40 20 40 50 这组数据分别得到频次 2 2 2 2 1，本身就是一个降序排序，所以最后结果还是20 40 20 40 50。</p><p>那怎么办呢？我们可以上面那种数据中间那个20为例，即20 40 20 40 50。首先我们来判断20的前半部分是否存在20，如果存在20的话则插入到该20的后面即可，即变为20 20 40 40 50。</p><p>所有排序过程均使用插入排序。插入排序的详细原理读者可以自行百度，插入排序从后往前移动，移动过程中不会改变原有已经排列好的数字的顺序。 </p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>计算每个数的频数。</li><li>根据频数的大小，对数据从高到低排序。排序的方法使用插入排序。</li><li>对第2部排好序的结果再排序。这次从前向后遍历，判断该数的前半部分是否存在该数，存在的话就插入到最近和它相同数的后面。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">salaryArrangement</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">19</span>;</span><br><span class="line"><span class="keyword">int</span> slalay[] = &#123; <span class="number">10000</span>, <span class="number">20000</span>, <span class="number">40000</span>, <span class="number">30000</span>, <span class="number">30000</span>, <span class="number">30000</span>, <span class="number">40000</span>, <span class="number">20000</span>, <span class="number">50000</span>, <span class="number">50000</span>, <span class="number">50000</span>, <span class="number">50000</span>, <span class="number">60000</span>,</span><br><span class="line"><span class="number">60000</span>, <span class="number">60000</span>, <span class="number">70000</span>, <span class="number">80000</span>, <span class="number">90000</span>, <span class="number">100000</span> &#125;;<span class="comment">// 测试数据</span></span><br><span class="line">slalay = b(num, slalay); <span class="comment">// 保存结果</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">System.out.println(<span class="string">"输出结果为："</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++)<span class="comment">// 输出结果</span></span><br><span class="line">&#123;</span><br><span class="line">System.out.print(<span class="string">" "</span>);</span><br><span class="line">System.out.print(slalay[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] b(<span class="keyword">int</span> num, <span class="keyword">int</span> slalay[]) &#123;</span><br><span class="line"><span class="keyword">int</span> i, j, k;</span><br><span class="line"><span class="keyword">int</span> temp_frequency;</span><br><span class="line"><span class="keyword">int</span> temp_slalay;</span><br><span class="line"><span class="keyword">int</span> frequency[] = <span class="keyword">new</span> <span class="keyword">int</span>[num]; <span class="comment">// 频次</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) <span class="comment">// 给频次赋初值</span></span><br><span class="line">&#123;</span><br><span class="line">frequency[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) <span class="comment">// 对已排序的数据统计频次</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; num; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (slalay[i] == slalay[j])</span><br><span class="line">&#123;</span><br><span class="line">frequency[i]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; num; i++) <span class="comment">// 对频次进行插入排序，同时根据频数交换的顺序排列原数据</span></span><br><span class="line">&#123;</span><br><span class="line">temp_frequency = frequency[i];</span><br><span class="line">temp_slalay = slalay[i];</span><br><span class="line">j = i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; temp_frequency &gt; frequency[j]) <span class="comment">//频次递减排序</span></span><br><span class="line">&#123;</span><br><span class="line">frequency[j + <span class="number">1</span>] = frequency[j];</span><br><span class="line">slalay[j + <span class="number">1</span>] = slalay[j]; <span class="comment">// 变换原数据</span></span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">frequency[j + <span class="number">1</span>] = temp_frequency;</span><br><span class="line">slalay[j + <span class="number">1</span>] = temp_slalay;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; num; i++) <span class="comment">// 再进行一次插入排序</span></span><br><span class="line">&#123;</span><br><span class="line">temp_slalay = slalay[i];</span><br><span class="line">j = i - <span class="number">1</span>;</span><br><span class="line">k = i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (k &gt;= <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (temp_slalay == slalay[k]) <span class="comment">// 判断前半部分子序列是否存在当前当前数据</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; temp_slalay != slalay[j]) <span class="comment">// 插入到相同的数的后面</span></span><br><span class="line">&#123;</span><br><span class="line">slalay[j + <span class="number">1</span>] = slalay[j];</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">slalay[j + <span class="number">1</span>] = temp_slalay;</span><br><span class="line"><span class="keyword">break</span>; <span class="comment">// 退出循环判断下个数</span></span><br><span class="line">&#125;</span><br><span class="line">k--;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> slalay;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">b</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span>* slalay)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, k;</span><br><span class="line"><span class="keyword">int</span> temp_frequency;</span><br><span class="line"><span class="keyword">int</span> temp_slalay;</span><br><span class="line"><span class="keyword">int</span> frequency[num]; <span class="comment">// 频次</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) <span class="comment">// 给频次赋初值</span></span><br><span class="line">&#123;</span><br><span class="line">frequency[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) <span class="comment">// 对已排序的数据统计频次</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; num; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (slalay[i] == slalay[j])</span><br><span class="line">&#123;</span><br><span class="line">frequency[i]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; num; i++) <span class="comment">// 对频次进行插入排序，同时根据频数交换的顺序排列原数据</span></span><br><span class="line">&#123;</span><br><span class="line">temp_frequency = frequency[i];</span><br><span class="line">temp_slalay = slalay[i];</span><br><span class="line">j = i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; temp_frequency &gt; frequency[j]) <span class="comment">//频次递减排序</span></span><br><span class="line">&#123;</span><br><span class="line">frequency[j + <span class="number">1</span>] = frequency[j];</span><br><span class="line">slalay[j + <span class="number">1</span>] = slalay[j]; <span class="comment">// 变换原数据</span></span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">frequency[j + <span class="number">1</span>] = temp_frequency;</span><br><span class="line">slalay[j + <span class="number">1</span>] = temp_slalay;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; num; i++) <span class="comment">// 再进行一次插入排序</span></span><br><span class="line">&#123;</span><br><span class="line">temp_slalay = slalay[i];</span><br><span class="line">j = i - <span class="number">1</span>;</span><br><span class="line">k = i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (k &gt;= <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (temp_slalay == slalay[k]) <span class="comment">// 判断前半部分子序列是否存在当前当前数据</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; temp_slalay != slalay[j]) <span class="comment">// 插入到相同的数的后面</span></span><br><span class="line">&#123;</span><br><span class="line">slalay[j + <span class="number">1</span>] = slalay[j];</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">slalay[j + <span class="number">1</span>] = temp_slalay;</span><br><span class="line"><span class="keyword">break</span>; <span class="comment">// 退出循环判断下个数</span></span><br><span class="line">&#125;</span><br><span class="line">k--;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> slalay;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">19</span>;</span><br><span class="line"><span class="keyword">int</span> slalay[<span class="number">19</span>] = &#123; <span class="number">10000</span>, <span class="number">20000</span>, <span class="number">40000</span>, <span class="number">30000</span>, <span class="number">30000</span>, <span class="number">30000</span>, <span class="number">40000</span>, <span class="number">20000</span>, <span class="number">50000</span>, </span><br><span class="line"><span class="number">50000</span>, <span class="number">50000</span>, <span class="number">50000</span>, <span class="number">60000</span>,<span class="number">60000</span>, <span class="number">60000</span>, <span class="number">70000</span>, <span class="number">80000</span>, <span class="number">90000</span>, <span class="number">100000</span> &#125;;<span class="comment">// 测试数据</span></span><br><span class="line"><span class="keyword">int</span> *slalayResult;</span><br><span class="line">slalayResult = b(num, slalay); <span class="comment">// 保存结果</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输出结果为："</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++)<span class="comment">// 输出结果</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,slalayResult[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://blog.csdn.net/q651742112/article/details/82596368&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目：排列员工工资顺序（Java和C++）（中兴在线笔试题）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;某公司中有N名员工。给定所有员工工资的清单，财务人员要按照特定的顺序排列员工的工资。他按照工资的频次降序排列。即给定清单中所有频次较高的工资将在频次较低的工资之前出现。如果相同数量的员工都有相同的工资，则将按照给定清单中该工资第一次出现的顺序排列。&lt;/p&gt;
&lt;p&gt;写一个算法来帮助财务人员排列员工工资的顺序。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>初识azkaban</title>
    <link href="http://changsk.top/2019/07/01/azkaban-introduce/"/>
    <id>http://changsk.top/2019/07/01/azkaban-introduce/</id>
    <published>2019-07-01T02:10:07.000Z</published>
    <updated>2019-07-01T02:13:48.757Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://www.cnblogs.com/shujuxiong/p/9116394.html" target="_blank" rel="noopener">Azkaban 简介</a> </p></blockquote><p>本文简单介绍一下<code>Azkaban</code>及其特点。<code>azkaban</code>是一个开源的<strong>任务调度系统</strong>，用于负责任务的调度运行（如数据仓库调度），用以替代linux中的<code>crontab</code>。</p><a id="more"></a><h2 id="Azkaban是什么？"><a href="#Azkaban是什么？" class="headerlink" title="Azkaban是什么？"></a>Azkaban是什么？</h2><h3 id="Azkaban是什么"><a href="#Azkaban是什么" class="headerlink" title="Azkaban是什么?"></a>Azkaban是什么?</h3><ul><li>Azkaban是一套<strong>简单的任务调度服务</strong>，整体包括三部分<strong>webserver</strong>、<strong>dbserver</strong>、<strong>executorserver</strong>。</li><li>Azkaban是<code>linkin</code>的开源项目，开发语言为Java。</li><li>Azkaban是由<code>Linkedin</code>开源的一个<strong>批量工作流任务调度器</strong>。<strong>用于在一个工作流内以一个特定的顺序运行一组工作和流程。</strong></li><li>Azkaban定义了一种<code>KV</code>文件格式来建立任务之间的依赖关系，并提供一个易于使用的web用户界面维护和跟踪你的工作流。</li></ul><h3 id="Azkaban典型使用场景"><a href="#Azkaban典型使用场景" class="headerlink" title="Azkaban典型使用场景"></a>Azkaban典型使用场景</h3><p>　　实际当中经常有这些场景：每天有一个<strong>大任务</strong>，这个大任务可以分成A,B,C,D四个小任务，A,B任务之间没有依赖关系，C任务依赖A,B任务的结果，D任务依赖C任务的结果。一般的做法是，开两个终端同时执行A,B，两个都执行完了再执行C，最后再执行D。这样的话，整个的执行过程都需要人工参加，并且得盯着各任务的进度。但是我们的很多任务都是在深更半夜执行的，通过写脚本设置<code>crontab</code>执行。其实，整个过程类似于一个<strong>有向无环图（DAG）</strong>。每个子任务相当于大任务中的一个流，任务的起点可以从没有度的节点开始执行，任何没有通路的节点之间可以同时执行，比如上述的A,B。总结起来的话，我们需要的就是一个工作流的调度器，而azkaban就是能解决上述问题的一个调度器。</p><h3 id="Azkaban官网"><a href="#Azkaban官网" class="headerlink" title="Azkaban官网"></a>Azkaban官网</h3><p>　　<a href="https://azkaban.github.io/" target="_blank" rel="noopener">https://azkaban.github.io/</a></p><p><img src="1.jpg" alt="img"></p><p><img src="3.jpg" alt="img"></p><h2 id="Azkaban的功能特点"><a href="#Azkaban的功能特点" class="headerlink" title="Azkaban的功能特点"></a>Azkaban的功能特点</h2><p>它具有如下功能特点：</p><ul><li>1、<strong>Web用户界面</strong></li><li>2、<strong>方便上传工作流</strong></li><li>3、<strong>方便设置任务之间的关系</strong></li><li>4、工作流调度</li><li>5、认证/授权</li><li>6、能够杀死并重启工作流</li><li>7、模块化和可插拔的插件机制</li><li>8、项目工作区</li><li>9、工作流和任务的日志记录和审计</li></ul><h2 id="Azkaban的架构"><a href="#Azkaban的架构" class="headerlink" title="Azkaban的架构"></a>Azkaban的架构</h2><p><code>Azkaban</code>是一种类似于Oozie的<strong>工作流控制引擎</strong>，可以用来解决多个Hadoop（或<code>Spark</code>等）<strong>离线计算任务之间的依赖关系问题</strong>。也可以用其<strong>代替crontab来对周期性任务进行调度</strong>，并且更为直观，可靠，同时提供了美观的可视化管理界面。<br>Azkaban由三部分构成：</p><ol><li>Relational Database(Mysql)<br><strong>azkaban将大多数状态信息都存于MySQL中</strong>,Azkaban Web Server 和 Azkaban Executor Server也需要访问DB。</li><li>Azkaban Web Server<br><strong>提供了Web UI，是azkaban的主要管理者</strong>，包括 project 的管理，认证，调度，对工作流执行过程的监控等。</li><li>Azkaban Executor Server<br><strong>调度工作流和任务</strong>，记录工作流活任务的日志，之所以将AzkabanWebServer和AzkabanExecutorServer分开，主要是因为在某个任务流失败后，可以更方便的将重新执行。而且也更有利于Azkaban系统的升级</li></ol><p><img src="2.jpg" alt="img"></p><p><strong>MySQL实例</strong>：Azkaban使用MySQL来存储项目和执行。</p><p><strong>Azkaban Web服务器</strong>：Azkaban使用<code>Jetty</code>作为Web服务器，用作控制器以及提供Web界面</p><p><strong>Azkaban执行服务器</strong>：Azkaban执行服务器执行提交工作流。</p><p><strong>参考资料：</strong></p><p><a href="http://www.cnblogs.com/zlslch/p/6294321.html" target="_blank" rel="noopener">http://www.cnblogs.com/zlslch/p/6294321.html</a></p><p><a href="http://www.cnblogs.com/zlslch/p/6296079.html" target="_blank" rel="noopener">http://www.cnblogs.com/zlslch/p/6296079.html</a></p><p><a href="http://www.cnblogs.com/zlslch/p/6296214.html" target="_blank" rel="noopener">http://www.cnblogs.com/zlslch/p/6296214.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://www.cnblogs.com/shujuxiong/p/9116394.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Azkaban 简介&lt;/a&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文简单介绍一下&lt;code&gt;Azkaban&lt;/code&gt;及其特点。&lt;code&gt;azkaban&lt;/code&gt;是一个开源的&lt;strong&gt;任务调度系统&lt;/strong&gt;，用于负责任务的调度运行（如数据仓库调度），用以替代linux中的&lt;code&gt;crontab&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://changsk.top/categories/Java/"/>
    
    
      <category term="azkaban" scheme="http://changsk.top/tags/azkaban/"/>
    
  </entry>
  
  <entry>
    <title>java之线程池</title>
    <link href="http://changsk.top/2019/06/29/java-ThreadPool/"/>
    <id>http://changsk.top/2019/06/29/java-ThreadPool/</id>
    <published>2019-06-29T08:13:59.000Z</published>
    <updated>2019-06-29T11:15:14.612Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">Java并发编程：线程池的使用</a></p></blockquote><p>在前面的文章中，我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：</p><blockquote><p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p></blockquote><p>那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？</p><p>在Java中可以通过<strong>线程池</strong>来达到这样的效果。今天我们就来详细讲解一下Java的线程池，首先我们从最核心的<code>ThreadPoolExecutor</code>类中的方法讲起，然后再讲述它的实现原理，接着给出了它的使用示例，最后讨论了一下如何合理配置线程池的大小。</p><p>　<a id="more"></a></p><h2 id="Java中的ThreadPoolExecutor类"><a href="#Java中的ThreadPoolExecutor类" class="headerlink" title="Java中的ThreadPoolExecutor类"></a>Java中的ThreadPoolExecutor类</h2><p><code>java.uitl.concurrent.ThreadPoolExecutor</code>类是线程池中最核心的一个类，因此如果要透彻地了解Java中的线程池，必须先了解这个类。下面我们来看一下<code>ThreadPoolExecutor</code>类的具体实现源码。</p><p>在ThreadPoolExecutor类中提供了四个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">        BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 　　从上面的代码可以得知，<code>ThreadPoolExecutor</code>继承了<code>AbstractExecutorService</code>类，并提供了四个构造器，事实上，通过观察每个构造器的源码具体实现，发现前面三个构造器都是调用的第四个构造器进行的初始化工作。</p><p> 　　下面解释下一下构造器中各个参数的含义：</p><ul><li>corePoolSize：核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，<strong>默认情况下，线程池中并没有任何线程</strong>，而是等待有任务到来才创建线程去执行任务，除非调用了<code>prestartAllCoreThreads()</code>或者<code>prestartCoreThread()</code>方法，从这2个方法的名字就可以看出，是预创建线程的意思，<strong>即在没有任务到来之前就创建corePoolSize个线程或者一个线程</strong>。<strong>默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；</strong></li><li>maximumPoolSize：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；</li><li>keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，<strong>只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用</strong>，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了<code>allowCoreThreadTimeOut(boolean)</code>方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；</li><li>unit：参数keepAliveTime的时间单位，有7种取值，在<code>TimeUnit</code>类中有7种静态属性：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TimeUnit.DAYS;               <span class="comment">//天</span></span><br><span class="line">TimeUnit.HOURS;             <span class="comment">//小时</span></span><br><span class="line">TimeUnit.MINUTES;           <span class="comment">//分钟</span></span><br><span class="line">TimeUnit.SECONDS;           <span class="comment">//秒</span></span><br><span class="line">TimeUnit.MILLISECONDS;      <span class="comment">//毫秒</span></span><br><span class="line">TimeUnit.MICROSECONDS;      <span class="comment">//微妙</span></span><br><span class="line">TimeUnit.NANOSECONDS;       <span class="comment">//纳秒</span></span><br></pre></td></tr></table></figure><ul><li>workQueue：一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue;</span><br><span class="line">LinkedBlockingQueue;</span><br><span class="line">SynchronousQueue;</span><br></pre></td></tr></table></figure><p><code>ArrayBlockingQueue</code>和<code>PriorityBlockingQueue</code>使用较少，一般使用<code>LinkedBlockingQueue</code>和<code>Synchronous</code>。线程池的排队策略与<code>BlockingQueue</code>有关。</p><ul><li>threadFactory：线程工厂，主要用来创建线程；</li><li>handler：表示当拒绝处理任务时的策略，有以下四种取值：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ThreadPoolExecutor</span><span class="selector-class">.AbortPolicy</span>:丢弃任务并抛出<span class="selector-tag">RejectedExecutionException</span>异常。 </span><br><span class="line"><span class="selector-tag">ThreadPoolExecutor</span><span class="selector-class">.DiscardPolicy</span>：也是丢弃任务，但是不抛出异常。 </span><br><span class="line"><span class="selector-tag">ThreadPoolExecutor</span><span class="selector-class">.DiscardOldestPolicy</span>：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span><br><span class="line"><span class="selector-tag">ThreadPoolExecutor</span><span class="selector-class">.CallerRunsPolicy</span>：由调用线程处理该任务</span><br></pre></td></tr></table></figure><p> 具体参数的配置与线程池的关系将在下一节讲述。</p><p>从上面给出的<code>hreadPoolExecutor</code>类的代码可以知道，ThreadPoolExecutor继承了<code>AbstractExecutorService</code>，我们来看一下AbstractExecutorService的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExecutorService</span> <span class="keyword">implements</span> <span class="title">ExecutorService</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">doInvokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                         <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 　AbstractExecutorService是一个抽象类，它实现了<code>ExecutorService</code>接口。</p><p>我们接着看ExecutorService接口的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                  <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"> </span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 而ExecutorService又是继承了<code>Executor</code>接口，我们看一下Executor接口的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 　　到这里，大家应该明白了ThreadPoolExecutor、AbstractExecutorService、ExecutorService和Executor几个之间的关系了。</p><p>　　<code>Executor是一个顶层接口</code>，在它里面只声明了一个方法<strong>execute(Runnable)</strong>，返回值为void，参数为Runnable类型，从字面意思可以理解，就是用来执行传进去的任务的；</p><p>　　然后<code>ExecutorService</code>接口继承了Executor接口，并声明了一些方法：<strong>submit、invokeAll、invokeAny以及shutDown等；</strong></p><p>　　抽象类<code>AbstractExecutorService</code>实现了ExecutorService接口，基本实现了ExecutorService中声明的所有方法；</p><p>　　然后ThreadPoolExecutor继承了类AbstractExecutorService。</p><p>　　在ThreadPoolExecutor类中有几个非常重要的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">execute()</span><br><span class="line">submit()</span><br><span class="line">shutdown()</span><br><span class="line">shutdownNow()</span><br></pre></td></tr></table></figure><p> 　　<strong>execute()方法实际上是Executor中声明的方法</strong>，在ThreadPoolExecutor进行了具体的实现，这个方法是ThreadPoolExecutor的核心方法，<strong>通过这个方法可以向线程池提交一个任务，交由线程池去执行。</strong></p><p>　　submit()方法是在ExecutorService中声明的方法，在AbstractExecutorService就已经有了具体的实现，在ThreadPoolExecutor中并没有对其进行重写，<strong>这个方法也是用来向线程池提交任务的，但是它和execute()方法不同，它能够返回任务执行的结果，去看submit()方法的实现，会发现它实际上还是调用的execute()方法，只不过它利用了Future来获取任务执行结果</strong>（Future相关内容将在下一篇讲述）。</p><p>　　<code>shutdown()</code>和<code>shutdownNow()</code>是用来关闭线程池的。</p><p>　　还有很多其他的方法：</p><p>　　比如：getQueue() 、getPoolSize() 、getActiveCount()、getCompletedTaskCount()等获取与线程池相关属性的方法，有兴趣的朋友可以自行查阅API。</p><h2 id="深入剖析线程池实现原理"><a href="#深入剖析线程池实现原理" class="headerlink" title="深入剖析线程池实现原理"></a>深入剖析线程池实现原理</h2><p>　　在上一节我们从宏观上介绍了ThreadPoolExecutor，下面我们来深入解析一下线程池的具体实现原理，将从下面几个方面讲解：</p><p>　　<strong>1.线程池状态</strong></p><p>　　<strong>2.任务的执行</strong></p><p>　　<strong>3.线程池中的线程初始化</strong></p><p>　　<strong>4.任务缓存队列及排队策略</strong></p><p>　　<strong>5.任务拒绝策略</strong></p><p>　　<strong>6.线程池的关闭</strong></p><p>　　<strong>7.线程池容量的动态调整</strong></p><h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><p>　　在ThreadPoolExecutor中定义了一个<code>volatile</code>变量，另外定义了几个static final变量表示线程池的各个状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> runState;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p> 　　runState表示当前线程池的状态，它是一个<strong>volatile变量用来保证线程之间的可见性；</strong></p><p>　　下面的几个static final变量表示runState可能的几个取值。</p><ol><li><p>当创建线程池后，初始时，线程池处于RUNNING状态；</p></li><li><p>如果调用了shutdown()方法，则线程池处于SHUTDOWN状态，<strong>此时线程池不能够接受新的任务，它会等待所有任务执行完毕；</strong></p></li><li><p>如果调用了shutdownNow()方法，则线程池处于STOP状态，<strong>此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；</strong></p></li><li><p>当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态。</p></li></ol><h3 id="任务的执行"><a href="#任务的执行" class="headerlink" title="任务的执行"></a>任务的执行</h3><p>　　在了解将任务提交给线程池到任务执行完毕整个过程之前，我们先来看一下ThreadPoolExecutor类中其他的一些比较重要成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;              <span class="comment">//任务缓存队列，用来存放等待执行的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();   <span class="comment">//线程池的主要状态锁，对线程池状态（比如线程池大小</span></span><br><span class="line">                                                              <span class="comment">//、runState等）的改变都要使用这个锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();  <span class="comment">//用来存放工作集</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span>  keepAliveTime;    <span class="comment">//线程存货时间   </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;   <span class="comment">//是否允许为核心线程设置存活时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span>   corePoolSize;     <span class="comment">//核心池的大小（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span>   maximumPoolSize;   <span class="comment">//线程池最大能容忍的线程数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span>   poolSize;       <span class="comment">//线程池中当前的线程数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler; <span class="comment">//任务拒绝策略</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;   <span class="comment">//线程工厂，用来创建线程</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;   <span class="comment">//用来记录线程池中曾经出现过的最大线程数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;   <span class="comment">//用来记录已经执行完毕的任务个数</span></span><br></pre></td></tr></table></figure><p> 　　每个变量的作用都已经标明出来了，这里要重点解释一下corePoolSize、maximumPoolSize、largestPoolSize三个变量。</p><p>​        corePoolSize在很多地方被翻译成核心池大小，其实我的理解这个就是线程池的大小。举个简单的例子：</p><p>　　假如有一个工厂，工厂里面有10个工人，每个工人同时只能做一件任务。</p><p>　　因此只要当10个工人中有工人是空闲的，来了任务就分配给空闲的工人做；</p><p>　　当10个工人都有任务在做时，如果还来了任务，<strong>就把任务进行排队等待；</strong></p><p>　　如果说新任务数目增长的速度远远大于工人做任务的速度，那么此时工厂主管可能会想补救措施，比如重新招   4个临时工人进来；</p><p>　　然后就将任务也分配给这4个临时工人做；</p><p>　　如果说着14个工人做任务的速度还是不够，此时工厂主管可能就要考虑不再接收新的任务或者抛弃前面的一些任务了。</p><p>　　当这14个工人当中有人空闲时，而新任务增长的速度又比较缓慢，工厂主管可能就考虑辞掉4个临时工了，只保持原来的10个工人，毕竟请额外的工人是要花钱的。</p><p> 这个例子中的corePoolSize就是10，而maximumPoolSize就是14（10+4）。</p><p>　　也就是说corePoolSize就是线程池大小，maximumPoolSize在我看来是线程池的一种补救措施，即任务量突然过大时的一种补救措施。</p><p>　　不过为了方便理解，在本文后面还是将corePoolSize翻译成核心池大小。</p><p>​        largestPoolSize只是一个用来起记录作用的变量，用来记录线程池中曾经有过的最大线程数目，跟线程池的容量没有任何关系。</p><p>　　下面我们进入正题，看一下任务从提交到最终执行完毕经历了哪些过程。</p><p>　　在ThreadPoolExecutor类中，<strong>最核心的任务提交方法是execute()方法</strong>，虽然通过submit也可以提交任务，但是实际上<strong>submit方法里面最终调用的还是execute()方法</strong>，所以我们只需要研究execute()方法的实现原理即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (runState != RUNNING || poolSize == <span class="number">0</span>)</span><br><span class="line">                ensureQueuedTaskHandled(command);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addIfUnderMaximumPoolSize(command))</span><br><span class="line">            reject(command); <span class="comment">// is shutdown or saturated</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 　　上面的代码可能看起来不是那么容易理解，下面我们一句一句解释：</p><p>　　首先，判断提交的任务command是否为null，若是null，则抛出空指针异常；</p><p>　　接着是这句，这句要好好理解一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command))</span><br></pre></td></tr></table></figure><p> 　　由于是或条件运算符，所以先计算前半部分的值，如果线程池中当前线程数不小于核心池大小，那么就会直接进入下面的if语句块了。</p><p>　　如果线程池中当前线程数小于核心池大小，则接着执行后半部分，也就是执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addIfUnderCorePoolSize(command)</span><br></pre></td></tr></table></figure><p>　　如果执行完<code>addIfUnderCorePoolSize</code>这个方法返回false，则继续执行下面的if语句块，否则整个方法就直接执行完毕了。</p><p>　　如果执行完addIfUnderCorePoolSize这个方法返回false，然后接着判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (runState == RUNNING &amp;&amp; workQueue.offer(command))</span><br></pre></td></tr></table></figure><p> 　　<strong>如果当前线程池处于RUNNING状态，则将任务放入任务缓存队列</strong>；如果当前线程池不处于RUNNING状态或者任务放入缓存队列失败，则执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addIfUnderMaximumPoolSize(command)</span><br></pre></td></tr></table></figure><p>　　如果执行addIfUnderMaximumPoolSize方法失败，则执行reject()方法进行任务拒绝处理。</p><p>　　回到前面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (runState == RUNNING &amp;&amp; workQueue.offer(command))</span><br></pre></td></tr></table></figure><p> 　　这句的执行，如果说当前线程池处于RUNNING状态且将任务放入任务缓存队列成功，则继续进行判断：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (<span class="name">runState</span> != RUNNING || poolSize == <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p> 　　这句判断是为了防止在将此任务添加进任务缓存队列的同时其他线程突然调用shutdown或者shutdownNow方法关闭了线程池的一种应急措施。如果是这样就执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ensureQueuedTaskHandled(command)</span><br></pre></td></tr></table></figure><p> 　　进行应急处理，从名字可以看出是<strong>保证添加到任务缓存队列中的任务得到处理。</strong></p><p>　　我们接着看2个关键方法的实现：<code>addIfUnderCorePoolSize</code>和<code>addIfUnderMaximumPoolSize</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addIfUnderCorePoolSize</span><span class="params">(Runnable firstTask)</span> </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (poolSize &lt; corePoolSize &amp;&amp; runState == RUNNING)</span><br><span class="line">            t = addThread(firstTask);        <span class="comment">//创建线程去执行firstTask任务   </span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    t.start();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 　　这个是addIfUnderCorePoolSize方法的具体实现，从名字可以看出它的意图就是当低于核心池大小时执行的方法。下面看其具体实现，首先获取到锁，因为这地方涉及到线程池状态的变化，先通过if语句判断当前线程池中的线程数目是否小于核心池大小，有朋友也许会有疑问：前面在execute()方法中不是已经判断过了吗，只有线程池当前线程数目小于核心池大小才会执行addIfUnderCorePoolSize方法的，为何这地方还要继续判断？原因很简单，<strong>前面的判断过程中并没有加锁，因此可能在execute方法判断的时候poolSize小于corePoolSize，而判断完之后，在其他线程中又向线程池提交了任务，就可能导致poolSize不小于corePoolSize了</strong>，所以需要在这个地方继续判断。然后接着判断线程池的状态是否为RUNNING，原因也很简单，<strong>因为有可能在其他线程中调用了shutdown或者shutdownNow方法</strong>。然后就是执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t = addThread(firstTask);</span><br></pre></td></tr></table></figure><p> 　　这个方法也非常关键，传进去的参数为提交的任务，返回值为Thread类型。然后接着在下面判断t是否为空，为空则表明创建线程失败（即poolSize&gt;=corePoolSize或者runState不等于RUNNING），否则调用t.start()方法启动线程。</p><p>　　我们来看一下addThread方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Thread <span class="title">addThread</span><span class="params">(Runnable firstTask)</span> </span>&#123;</span><br><span class="line">    Worker w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">    Thread t = threadFactory.newThread(w);  <span class="comment">//创建一个线程，执行任务   </span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        w.thread = t;            <span class="comment">//将创建的线程的引用赋值为w的成员变量       </span></span><br><span class="line">        workers.add(w);</span><br><span class="line">        <span class="keyword">int</span> nt = ++poolSize;     <span class="comment">//当前线程数加1       </span></span><br><span class="line">        <span class="keyword">if</span> (nt &gt; largestPoolSize)</span><br><span class="line">            largestPoolSize = nt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 　　在addThread方法中，首先用提交的任务创建了一个Worker对象，然后调用线程工厂threadFactory创建了一个新的线程t，然后将线程t的引用赋值给了Worker对象的成员变量thread，接着通过workers.add(w)将Worker对象添加到工作集当中。</p><p>　　下面我们看一下Worker类的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock runLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Runnable firstTask;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line">    Thread thread;</span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> runLock.isLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock runLock = <span class="keyword">this</span>.runLock;</span><br><span class="line">        <span class="keyword">if</span> (runLock.tryLock()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (thread != Thread.currentThread())</span><br><span class="line">        thread.interrupt();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                runLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runTask</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock runLock = <span class="keyword">this</span>.runLock;</span><br><span class="line">        runLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (runState &lt; STOP &amp;&amp;</span><br><span class="line">                Thread.interrupted() &amp;&amp;</span><br><span class="line">                runState &gt;= STOP)</span><br><span class="line">            <span class="keyword">boolean</span> ran = <span class="keyword">false</span>;</span><br><span class="line">            beforeExecute(thread, task);   <span class="comment">//beforeExecute方法是ThreadPoolExecutor类的一个方法，没有具体实现，用户可以根据</span></span><br><span class="line">            <span class="comment">//自己需要重载这个方法和后面的afterExecute方法来进行一些统计信息，比如某个任务的执行时间等           </span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                task.run();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">                afterExecute(task, <span class="keyword">null</span>);</span><br><span class="line">                ++completedTasks;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ran)</span><br><span class="line">                    afterExecute(task, ex);</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            runLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable task = firstTask;</span><br><span class="line">            firstTask = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                runTask(task);</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            workerDone(<span class="keyword">this</span>);   <span class="comment">//当任务队列中没有任务时，进行清理工作       </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 　　它实际上实现了Runnable接口，因此上面的Thread t = threadFactory.newThread(w);效果跟下面这句的效果基本一样：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Thread</span> t = <span class="keyword">new</span> <span class="keyword">Thread</span>(w)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p> 　　相当于传进去了一个Runnable任务，在线程t中执行这个Runnable。</p><p>　　既然Worker实现了Runnable接口，那么自然最核心的方法便是run()方法了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Runnable task = firstTask;</span><br><span class="line">        firstTask = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            runTask(task);</span><br><span class="line">            task = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        workerDone(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 　　从run方法的实现可以看出，它首先执行的是通过构造器传进来的任务firstTask，在调用runTask()执行完firstTask之后，在while循环里面不断通过getTask()去取新的任务来执行，那么去哪里取呢？自然是从<strong>任务缓存队列里面去取</strong>，getTask是ThreadPoolExecutor类中的方法，并不是Worker类中的方法，下面是getTask方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> state = runState;</span><br><span class="line">            <span class="keyword">if</span> (state &gt; SHUTDOWN)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            Runnable r;</span><br><span class="line">            <span class="keyword">if</span> (state == SHUTDOWN)  <span class="comment">// Help drain queue</span></span><br><span class="line">                r = workQueue.poll();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (poolSize &gt; corePoolSize || allowCoreThreadTimeOut) <span class="comment">//如果线程数大于核心池大小或者允许为核心池线程设置空闲时间，</span></span><br><span class="line">                <span class="comment">//则通过poll取任务，若等待一定的时间取不到任务，则返回null</span></span><br><span class="line">                r = workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="keyword">if</span> (workerCanExit()) &#123;    <span class="comment">//如果没取到任务，即r为null，则判断当前的worker是否可以退出</span></span><br><span class="line">                <span class="keyword">if</span> (runState &gt;= SHUTDOWN) <span class="comment">// Wake up others</span></span><br><span class="line">                    interruptIdleWorkers();   <span class="comment">//中断处于空闲状态的worker</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Else retry</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">            <span class="comment">// On interruption, re-check runState</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 　　在getTask中，先判断当前线程池状态，如果<strong>runState大于SHUTDOWN（即为STOP或者TERMINATED），</strong>则直接返回null。</p><p>　　如果runState为SHUTDOWN或者RUNNING，则从<strong>任务缓存队列取任务。</strong></p><p>　　如果当前线程池的线程数大于核心池大小corePoolSize或者允许为核心池中的线程设置空闲存活时间，<strong>则调用poll(time,timeUnit)来取任务，这个方法会等待一定的时间，如果取不到任务就返回null。</strong></p><p>　　然后判断取到的任务r是否为null，为null则通过调用workerCanExit()方法来判断当前worker是否可以退出，我们看一下workerCanExit()的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">workerCanExit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">boolean</span> canExit;</span><br><span class="line">    <span class="comment">//如果runState大于等于STOP，或者任务缓存队列为空了</span></span><br><span class="line">    <span class="comment">//或者  允许为核心池线程设置空闲存活时间并且线程池中的线程数目大于1</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        canExit = runState &gt;= STOP ||</span><br><span class="line">            workQueue.isEmpty() ||</span><br><span class="line">            (allowCoreThreadTimeOut &amp;&amp;</span><br><span class="line">             poolSize &gt; Math.max(<span class="number">1</span>, corePoolSize));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> canExit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 　　也就是说如果<strong>线程池处于STOP状态</strong>、或者<strong>任务队列已为空</strong>或者<strong>允许为核心池线程设置空闲存活时间并且线程数大于1</strong>时，允许worker退出。如果允许worker退出，则调用interruptIdleWorkers()中断处于空闲状态的worker，我们看一下interruptIdleWorkers()的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">oid <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers)  <span class="comment">//实际上调用的是worker的interruptIfIdle()方法</span></span><br><span class="line">            w.interruptIfIdle();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 　　从实现可以看出，它实际上调用的是worker的interruptIfIdle()方法，在worker的interruptIfIdle()方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interruptIfIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock runLock = <span class="keyword">this</span>.runLock;</span><br><span class="line">    <span class="keyword">if</span> (runLock.tryLock()) &#123;    <span class="comment">//注意这里，是调用tryLock()来获取锁的，因为如果当前worker正在执行任务，锁已经被获取了，是无法获取到锁的</span></span><br><span class="line">                                <span class="comment">//如果成功获取了锁，说明当前worker处于空闲状态</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (thread != Thread.currentThread())  </span><br><span class="line">    thread.interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            runLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  　　这里有一个非常巧妙的设计方式，假如我们来设计线程池，可能会有一个任务分派线程，当发现有线程空闲时，就从任务缓存队列中取一个任务交给空闲线程执行。但是在这里，并没有采用这样的方式，因为这样会要额外地对任务分派线程进行管理，无形地会增加难度和复杂度，<strong>这里直接让执行完任务的线程去任务缓存队列里面取任务来执行。</strong></p><p> 　　我们再看<code>addIfUnderMaximumPoolSize</code>方法的实现，这个方法的实现思想和addIfUnderCorePoolSize方法的实现思想非常相似，<strong>唯一的区别在于addIfUnderMaximumPoolSize方法是在线程池中的线程数达到了核心池大小并且往任务队列中添加任务失败的情况下执行的：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addIfUnderMaximumPoolSize</span><span class="params">(Runnable firstTask)</span> </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (poolSize &lt; maximumPoolSize &amp;&amp; runState == RUNNING)</span><br><span class="line">            t = addThread(firstTask);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    t.start();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 　　看到没有，其实它和addIfUnderCorePoolSize方法的实现基本一模一样，只是if语句判断条件中的poolSize &lt; maximumPoolSize不同而已。</p><p>　　到这里，大部分朋友应该对任务提交给线程池之后到被执行的整个过程有了一个基本的了解，下面总结一下：</p><ol><li><p>首先，要清楚corePoolSize和maximumPoolSize的含义；</p></li><li><p>其次，要知道Worker是用来起到什么作用的；</p></li><li><p>要知道任务提交给线程池之后的处理策略，这里总结一下主要有4点：</p></li></ol><ul><li>如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；</li><li>如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；</li><li>如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；</li><li>如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。</li></ul><h3 id="线程池中的线程初始化"><a href="#线程池中的线程初始化" class="headerlink" title="线程池中的线程初始化"></a>线程池中的线程初始化</h3><p>　　<strong>默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。</strong></p><p>　　在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到：</p><ul><li>prestartCoreThread()：初始化一个核心线程；</li><li>prestartAllCoreThreads()：初始化所有核心线程</li></ul><p>　　下面是这2个方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">prestartCoreThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addIfUnderCorePoolSize(<span class="keyword">null</span>); <span class="comment">//注意传进去的参数是null</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prestartAllCoreThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (addIfUnderCorePoolSize(<span class="keyword">null</span>))<span class="comment">//注意传进去的参数是null</span></span><br><span class="line">        ++n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 　　注意上面传进去的参数是null，根据第2小节的分析可知如果传进去的参数为null，则最后执行线程会阻塞在getTask方法中的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = workQueue.take();</span><br></pre></td></tr></table></figure><p> 　　即等待任务队列中有任务。</p><p><strong>### 任务缓存队列及排队策略</strong></p><p>　　在前面我们多次提到了任务缓存队列，即workQueue，它用来存放等待执行的任务。</p><p>　　workQueue的类型为<code>BlockingQueue&lt;Runnable&gt;</code>，通常可以取下面三种类型：</p><p>　　1）ArrayBlockingQueue：基于数组的先进先出队列，<strong>此队列创建时必须指定大小；</strong></p><p>　　2）LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；</p><p>　　3）synchronousQueue：这个队列比较特殊，<strong>它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。</strong></p><h3 id="任务拒绝策略"><a href="#任务拒绝策略" class="headerlink" title="任务拒绝策略"></a>任务拒绝策略</h3><p>　　当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</span><br><span class="line">ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。</span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</span><br></pre></td></tr></table></figure><h3 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h3><p>　　ThreadPoolExecutor提供了两个方法，用于线程池的关闭，分别是shutdown()和shutdownNow()，其中：</p><ul><li>shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务</li><li>shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务</li></ul><h3 id="线程池容量的动态调整"><a href="#线程池容量的动态调整" class="headerlink" title="线程池容量的动态调整"></a>线程池容量的动态调整</h3><p>　　ThreadPoolExecutor提供了动态调整线程池容量大小的方法：setCorePoolSize()和setMaximumPoolSize()，</p><ul><li>setCorePoolSize：设置核心池大小</li><li>setMaximumPoolSize：设置线程池最大能创建的线程数目大小</li></ul><p>　　当上述参数从小变大时，ThreadPoolExecutor进行线程赋值，还可能立即创建新的线程来执行任务。</p><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>　　前面我们讨论了关于线程池的实现原理，这一节我们来看一下它的具体使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </span><br><span class="line">         ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">200</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                 <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>));</span><br><span class="line">          </span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">15</span>;i++)&#123;</span><br><span class="line">             MyTask myTask = <span class="keyword">new</span> MyTask(i);</span><br><span class="line">             executor.execute(myTask);</span><br><span class="line">             System.out.println(<span class="string">"线程池中线程数目："</span>+executor.getPoolSize()+<span class="string">"，队列中等待执行的任务数目："</span>+</span><br><span class="line">             executor.getQueue().size()+<span class="string">"，已执行玩别的任务数目："</span>+executor.getCompletedTaskCount());</span><br><span class="line">         &#125;</span><br><span class="line">         executor.shutdown();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> taskNum;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.taskNum = num;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"正在执行task "</span>+taskNum);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">4000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"task "</span>+taskNum+<span class="string">"执行完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 　　执行结果：</p><blockquote><p>正在执行task 0<br>线程池中线程数目：1，队列中等待执行的任务数目：0，已执行玩别的任务数目：0<br>线程池中线程数目：2，队列中等待执行的任务数目：0，已执行玩别的任务数目：0<br>正在执行task 1<br>线程池中线程数目：3，队列中等待执行的任务数目：0，已执行玩别的任务数目：0<br>正在执行task 2<br>线程池中线程数目：4，队列中等待执行的任务数目：0，已执行玩别的任务数目：0<br>正在执行task 3<br>线程池中线程数目：5，队列中等待执行的任务数目：0，已执行玩别的任务数目：0<br>正在执行task 4<br>线程池中线程数目：5，队列中等待执行的任务数目：1，已执行玩别的任务数目：0<br>线程池中线程数目：5，队列中等待执行的任务数目：2，已执行玩别的任务数目：0<br>线程池中线程数目：5，队列中等待执行的任务数目：3，已执行玩别的任务数目：0<br>线程池中线程数目：5，队列中等待执行的任务数目：4，已执行玩别的任务数目：0<br>线程池中线程数目：5，队列中等待执行的任务数目：5，已执行玩别的任务数目：0<br>线程池中线程数目：6，队列中等待执行的任务数目：5，已执行玩别的任务数目：0<br>正在执行task 10<br>线程池中线程数目：7，队列中等待执行的任务数目：5，已执行玩别的任务数目：0<br>正在执行task 11<br>线程池中线程数目：8，队列中等待执行的任务数目：5，已执行玩别的任务数目：0<br>正在执行task 12<br>线程池中线程数目：9，队列中等待执行的任务数目：5，已执行玩别的任务数目：0<br>正在执行task 13<br>线程池中线程数目：10，队列中等待执行的任务数目：5，已执行玩别的任务数目：0<br>正在执行task 14<br>task 3执行完毕<br>task 0执行完毕<br>task 2执行完毕<br>task 1执行完毕<br>正在执行task 8<br>正在执行task 7<br>正在执行task 6<br>正在执行task 5<br>task 4执行完毕<br>task 10执行完毕<br>task 11执行完毕<br>task 13执行完毕<br>task 12执行完毕<br>正在执行task 9<br>task 14执行完毕<br>task 8执行完毕<br>task 5执行完毕<br>task 7执行完毕<br>task 6执行完毕<br>task 9执行完毕</p></blockquote><p>　　从执行结果可以看出，当线程池中线程的数目大于5时，便将任务放入任务缓存队列里面，当任务缓存队列满了之后，便创建新的线程。如果上面程序中，将for循环中改成执行20个任务，就会抛出任务拒绝异常了。</p><p>　　不过在java doc中，并不提倡我们直接使用ThreadPoolExecutor，而是使用Executors类中提供的几个静态方法来创建线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Executors.newCachedThreadPool();        <span class="comment">//创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE</span></span><br><span class="line">Executors.newSingleThreadExecutor();   <span class="comment">//创建容量为1的缓冲池</span></span><br><span class="line">Executors.newFixedThreadPool(<span class="keyword">int</span>);    <span class="comment">//创建固定容量大小的缓冲池</span></span><br></pre></td></tr></table></figure><p> 　　下面是这三个静态方法的具体实现;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　从它们的具体实现来看，它们实际上也是调用了ThreadPoolExecutor，只不过参数都已配置好了。</p><ul><li><p>newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的LinkedBlockingQueue；</p><blockquote><p>创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。FixedThreadPool是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</p></blockquote></li><li><p>newSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1，也使用的LinkedBlockingQueue；</p><blockquote><p>创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO,LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。</p></blockquote></li><li><p>newCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE，使用的SynchronousQueue，<strong>也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。</strong></p><blockquote><p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。这种类型的线程池特点是：</p><ul><li>工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger.MAX_VALUE), 这样可灵活的往线程池中添加线程。</li><li>如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</li><li>在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。</li></ul></blockquote></li></ul><p>　　实际中，如果Executors提供的三个静态方法能满足要求，就尽量使用它提供的三个方法，因为自己去手动配置ThreadPoolExecutor的参数有点麻烦，要根据实际任务的类型和数量来进行配置。</p><p>　　另外，如果ThreadPoolExecutor达不到要求，可以自己继承ThreadPoolExecutor类进行重写。</p><h2 id="如何合理配置线程池的大小"><a href="#如何合理配置线程池的大小" class="headerlink" title="如何合理配置线程池的大小"></a>如何合理配置线程池的大小</h2><p>　　本节来讨论一个比较重要的话题：如何合理配置线程池大小，仅供参考。</p><p>　　一般需要根据任务的类型来配置线程池大小：</p><ul><li>如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 <em>N</em>CPU+1</li><li>如果是IO密集型任务，参考值可以设置为2<em>*N</em>CPU</li></ul><p>　　当然，这只是一个参考值，具体的设置还需要根据实际情况进行调整，比如可以先将线程池大小设置为参考值，再观察任务运行情况和系统负载、资源利用率来进行适当调整。</p><p>　　参考资料：</p><p>　　<a href="http://ifeve.com/java-threadpool/" target="_blank" rel="noopener">http://ifeve.com/java-threadpool/</a></p><p>　　<a href="http://blog.163.com/among_1985/blog/static/275005232012618849266/" target="_blank" rel="noopener">http://blog.163.com/among_1985/blog/static/275005232012618849266/</a></p><p>　　<a href="http://developer.51cto.com/art/201203/321885.htm" target="_blank" rel="noopener">http://developer.51cto.com/art/201203/321885.htm</a></p><p>　　<a href="http://blog.csdn.net/java2000_wl/article/details/22097059" target="_blank" rel="noopener">http://blog.csdn.net/java2000_wl/article/details/22097059</a></p><p>　　<a href="http://blog.csdn.net/cutesource/article/details/6061229" target="_blank" rel="noopener">http://blog.csdn.net/cutesource/article/details/6061229</a></p><p>　　<a href="http://blog.csdn.net/xieyuooo/article/details/8718741" target="_blank" rel="noopener">http://blog.csdn.net/xieyuooo/article/details/8718741</a></p><p>　　《JDK API 1.6》</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3932921.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java并发编程：线程池的使用&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在前面的文章中，我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？&lt;/p&gt;
&lt;p&gt;在Java中可以通过&lt;strong&gt;线程池&lt;/strong&gt;来达到这样的效果。今天我们就来详细讲解一下Java的线程池，首先我们从最核心的&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;类中的方法讲起，然后再讲述它的实现原理，接着给出了它的使用示例，最后讨论了一下如何合理配置线程池的大小。&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://changsk.top/categories/Java/"/>
    
    
      <category term="java" scheme="http://changsk.top/tags/java/"/>
    
      <category term="线程池" scheme="http://changsk.top/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>初识ALS</title>
    <link href="http://changsk.top/2019/06/28/ALS/"/>
    <id>http://changsk.top/2019/06/28/ALS/</id>
    <published>2019-06-27T16:17:43.000Z</published>
    <updated>2019-06-29T08:17:06.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Spark平台推出至今已经地带到2.4.x版本，很多地方都有了重要的更新，加入了很多新的东西。<br>但是在协同过滤这一块却一直以来都只有ALS一种算法。<br>同样是大规模计算平台，Hadoop中的机器学习算法库Mahout就集成了多种推荐算法，不但有<code>user-cf</code>和<code>item-cf</code>这种经典算法，还有KNN、SVD，Slope one这些，可谓随意挑选，简繁由君。<br>ALS算法是2008年以来，用的比较多的协同过滤算法。它已经集成到<code>Spark</code>的<code>Mllib</code>库中，使用起来比较方便。</p><a id="more"></a><h1 id="ALS算法"><a href="#ALS算法" class="headerlink" title="ALS算法"></a>ALS算法</h1><h2 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h2><p>ALS的意思是<strong>交替最小二乘法</strong>（Alternating Least Squares），它只是一种优化算法的名字，被用在求解spark中所提供的推荐系统模型的最优解。spark中协同过滤的文档中一开始就说了。<br><img src="11.jpg" alt><br>从协同过滤的分类来说，ALS算法属于<code>User-Item CF</code>，也叫做混合CF。它同时考虑了User和Item两个方面。<br>用户和商品的关系，可以抽象为如下的三元组：<code>&lt;User,Item,Rating&gt;</code>。其中，Rating是用户对商品的评分，表征用户对该商品的喜好程度。</p><p>这是一个<strong>基于模型</strong>的协同过滤（model-based CF），其实它是一种近几年推荐系统界大火的隐语义模型中的一种。它的基本思想是对<code>稀疏矩阵进行模型分解，评估出缺失项的值，以此来得到一个基本的训练模型。然后依照此模型可以针对新的用户和物品数据进行评估。ALS是采用交替的最小二乘法来算出缺失项的</code>。交替的最小二乘法是在最小二乘法的基础上发展而来的。</p><blockquote><p>隐语义模型又叫潜在因素模型，它试图通过数量相对少的未被观察到的底层原因，来解释大量用户和产品之间可观察到的交互。</p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="SVD"><a href="#SVD" class="headerlink" title="SVD"></a>SVD</h3><p>基于模型的协同过滤算法操作起来就是通过<strong>降维</strong>的方法来补全<code>用户-物品矩阵</code>，<strong>对矩阵中没有出现的值进行估计</strong>。基于这种思想的早期推荐系统常用的一种方法是<code>SVD</code>（奇异值分解）。<br>该方法在矩阵分解之前需要先把评分矩阵R缺失值补全，补全之后稀疏矩阵R表示成稠密矩阵R’，然后将R’分解成如下形式：</p><p><strong>R’ = U<sup>T</sup>SV</strong><br>然后再选取U中的K列和V中的S行作为隐特征的个数，达到降维的目的。<strong>K的选取通常用启发式策略。</strong></p><p>这种方法有两个缺点</p><ul><li>补全成稠密矩阵之后需要耗费巨大的存储空间，在实际中，用户对物品的行为信息何止千万，对这样的稠密矩阵的存储是不现实的。</li><li>SVD的计算复杂度很高，更不用说这样的大规模稠密矩阵了。所以关于SVD的研究很多都是在小数据集上进行的。</li></ul><h3 id="ALS"><a href="#ALS" class="headerlink" title="ALS"></a>ALS</h3><p>隐语义模型也是基于矩阵分解的，但是和SVD不同，它是把原始矩阵分解成两个矩阵相乘而不是三个。</p><p>假设我们有一批用户数据，其中包含m个User和n个Item，则我们定义Rating矩阵，其中的元素表示第u个User对第i个Item的评分。</p><p>在实际使用中，由于<code>n和m的数量都十分巨大</code>，因此R矩阵的规模很容易就会突破1亿项。这时候，传统的矩阵分解方法对于这么大的数据量已经是很难处理了。</p><p>另一方面，一个用户也不可能给所有商品评分，因此，<code>R矩阵注定是个稀疏矩阵</code>。矩阵中所缺失的评分，又叫做<code>missing item</code>。</p><p><img src="1.jpg" alt></p><p>针对这样的特点，我们可以假设<code>用户和商品之间存在若干关联维度</code>（比如用户年龄、性别、受教育程度和商品的外观、价格等），我们只需要将R矩阵投射到这些维度上即可。这个投射的数学表示是：</p><blockquote><p>R<sub>m×n</sub>=U<sub>m×k</sub>×V<sub>k×n</sub></p></blockquote><p>这里的表明这个投射只是一个近似的空间变换。</p><p>不懂这个空间变换的同学，可参见《机器学习（十二）》中的“奇异值分解”的内容，或是本节中的“主成分分析”的内容。</p><p>现在的问题就变成了确定U和V ，我们把</p><blockquote><p>U叫做用户因子矩阵<br>V叫做物品因子矩阵</p></blockquote><p>一般情况下，<code>k的值远小于n和m的值</code>，从而达到了<strong>数据降维</strong>的目的。</p><p>幸运的是，我们<strong>并不需要显式的定义这些关联维度，而只需要假定它们存在即可</strong>，因此这里的关联维度又被称为<code>Latent factor</code>。k的典型取值一般是<strong>20～200</strong>。</p><p>这种方法被称为<code>概率矩阵分解算法</code>(probabilistic matrix factorization，PMF)。ALS算法是PMF在数值计算方面的应用。</p><p>通常上式不能达到精确相等的程度，我们要做的就是要<strong>最小化他们之间的差距</strong>，从而又变成了一个最优化问题。</p><p>求解最优化问题我们很容易就想到了<strong>随机梯度下降</strong>，其中有一种方法就是这样，通过优化如下损失函数来找到X和Y中合适的参数：</p><p><img src="22.jpg" alt></p><p>其中puk就是U矩阵中u行k列的参数，度量了用户u和第k个隐类的关系；qik是V矩阵中i行k列的参数，度量了物品i和第k个隐类的关系。这种方式也是一种很流行的方法，有很多对它的相关扩展，比如加上偏置项的LFM。</p><p>然而ALS用的是另一种求解方法，它先用<strong>随机初始化</strong>的方式固定一个矩阵，例如Y<br><img src="33.jpg" alt><br>然后通过最小化等式两边差的平方来更新另一个矩阵X。</p><p>得到X之后，又可以固定X用相同的方法求Y，如此交替进行，直到<strong>最后收敛</strong>或者<strong>达到用户指定的迭代次数</strong>为止，是为“交替”是也。</p><p>因为这个迭代过程，<strong>交替优化X和Y</strong>，因此又被称作交替最小二乘算法（Alternating Least Squares，ALS）。</p><p>从上式可以看出，X的第i行是A的第i行和Y的函数，因此可以很容易地分开计算X的每一行，这就为并行计算提供了很大的便捷，也正是如此，Spark这种面向大规模计算的平台选择了这个算法。</p><p>在<a href="https://www.cnblogs.com/mooba/p/6539142.html" target="_blank" rel="noopener">Intro to Implicit Matrix Factorization: Classic ALS with Sketchfab Models</a>中，作者用了<code>embarrassingly parallel</code>来形容这个算法，意思是<strong>高度易并行化</strong>的——它的每个子任务之间没有什么依赖关系。</p><p>在现实中，不可能每个用户都和所有的物品都有行为关系，事实上，有交互关系的用户-物品对只占很小的一部分，换句话说，<strong>用户-物品关系列表是非常稀疏的。</strong><br>和SVD这种矩阵分解不同，ALS所用的矩阵分解技术在分解之前不用把系数矩阵填充成稠密矩阵之后再分解，这不但大大减少了存储空间，而且spark可以利用这种稀疏性用简单的线性代数计算求解。<br>这几点使得本算法在大规模数据上计算非常快，解释了为什么spark mllib目前只有ALS一种推荐算法。</p><h2 id="ALS算法的缺点"><a href="#ALS算法的缺点" class="headerlink" title="ALS算法的缺点"></a>ALS算法的缺点</h2><blockquote><ol><li>它是一个离线算法。</li><li>无法准确评估新加入的用户或商品。这个问题也被称为<code>Cold Start</code>问题。</li></ol></blockquote><h2 id="显性反馈和隐性反馈"><a href="#显性反馈和隐性反馈" class="headerlink" title="显性反馈和隐性反馈"></a>显性反馈和隐性反馈</h2><p>基于矩阵分解的协同过滤的标准方法将用户项矩阵中的条目视为由用户给予该项的明确偏好，例如，给予电影评级的用户。<br>在许多真实世界的用例中，通常只能访问隐式反馈（例如查看，点击，购买，喜欢，共享等）。</p><blockquote><p>隐式反馈：<br>用户给商品评分是个非常简单粗暴的用户行为。在实际的电商网站中，还有大量的用户行为，同样能够间接反映用户的喜好，比如用户的购买记录、搜索关键字，甚至是鼠标的移动。我们将这些间接用户行为称之为隐式反馈（implicit feedback），以区别于评分这样的显式反馈（explicit feedback）。</p></blockquote><blockquote><p>隐式反馈有以下几个特点：<br>1.没有负面反馈（negative feedback）。用户一般会直接忽略不喜欢的商品，而不是给予负面评价。<br>2.隐式反馈包含大量噪声。比如，电视机在某一时间播放某一节目，然而用户已经睡着了，或者忘了换台。<br>3.显式反馈表现的是用户的喜好（preference），而隐式反馈表现的是用户的信任（confidence）。比如用户最喜欢的一般是电影，但观看时间最长的却是连续剧。大米购买的比较频繁，量也大，但未必是用户最想吃的食物。<br>4.隐式反馈非常难以量化。</p></blockquote><p>用于<code>spark.ml</code>处理这些数据的方法取自隐式反馈数据集的协作过滤。<br>本质上，这种方法不是直接对收视率矩阵进行建模，而是将数据视为代表实力的数字观察用户操作（例如点击次数或某人观看电影的累计持续时间）。然后，<strong>这些数字与观察到的用户偏好的信心水平相关，而不是给予项目的明确评分</strong>。该模型然后试图找出可用于预测用户对物品的预期偏好的潜在因素。</p><p>在推荐系统中用户和物品的交互数据分为显性反馈和隐性反馈数据。<br>在ALS中这两种情况也是被考虑了进来的，分别可以训练如下两种模型：</p><h3 id="显性反馈模型"><a href="#显性反馈模型" class="headerlink" title="显性反馈模型"></a>显性反馈模型</h3><p><code>val model1 = ALS.train(ratings, rank, numIterations, lambda)</code></p><h3 id="隐性反馈模型"><a href="#隐性反馈模型" class="headerlink" title="隐性反馈模型"></a>隐性反馈模型</h3><p><code>val model2 = ALS.trainImplicit(ratings, rank, numIterations, lambda, alpha)</code></p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><blockquote><p>numBlocks是为了并行化计算而将用户和项目划分到的块的数量（默认为10）。<br>rank是模型中潜在因素的数量（默认为10）。<br>maxIter是要运行的最大迭代次数（默认为10）。<br>regParam指定ALS中的正则化参数（默认为1.0）。<br>implicitPrefs指定是使用显式反馈 ALS变体还是使用 隐式反馈数据（默认为false使用显式反馈的手段）。<br>alpha是一个适用于ALS的隐式反馈变量的参数，该变量管理偏好观察值的 基线置信度（默认值为1.0)<br>nonnegative指定是否对最小二乘使用非负约束（默认为false）。<br>注意： ALS的基于DataFrame的API目前仅支持用户和项目ID的整数。用户和项目ID列支持其他数字类型，但ID必须在整数值范围内。</p></blockquote><p>从上面可以看到，隐式模型多了一个<strong>置信参数</strong>，这就涉及到ALS中对于隐式反馈模型的处理方式了——有的文章称为“加权的正则化矩阵分解”，它的损失函数如下：</p><p><img src="44.jpg" alt></p><p>我们知道，在隐反馈模型中是没有评分的，所以在式子中<code>rui</code>被<code>pui</code>所取代，<strong>pui是偏好的表示，仅仅表示用户和物品之间有没有交互，而不表示评分高低或者喜好程度</strong>。比如用户和物品之间有交互就让pui等于1，没有就等于0。函数中还有一个cui的项，它用来表示用户偏爱某个商品的置信程度，<strong>比如交互次数多的权重就会增加</strong>。如果我们用dui来表示交互次数的话，那么就可以把置信程度表示成如下公式：</p><p><img src="55.jpg" alt></p><blockquote><p>参考：<br><a href="https://blog.csdn.net/nieson2012/article/details/79898676" target="_blank" rel="noopener">【推荐系统系列6】ALS推荐算法原理</a><br><a href="https://blog.csdn.net/qq_33589510/article/details/89888383" target="_blank" rel="noopener">ALS算法解析</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Spark平台推出至今已经地带到2.4.x版本，很多地方都有了重要的更新，加入了很多新的东西。&lt;br&gt;但是在协同过滤这一块却一直以来都只有ALS一种算法。&lt;br&gt;同样是大规模计算平台，Hadoop中的机器学习算法库Mahout就集成了多种推荐算法，不但有&lt;code&gt;user-cf&lt;/code&gt;和&lt;code&gt;item-cf&lt;/code&gt;这种经典算法，还有KNN、SVD，Slope one这些，可谓随意挑选，简繁由君。&lt;br&gt;ALS算法是2008年以来，用的比较多的协同过滤算法。它已经集成到&lt;code&gt;Spark&lt;/code&gt;的&lt;code&gt;Mllib&lt;/code&gt;库中，使用起来比较方便。&lt;/p&gt;
    
    </summary>
    
      <category term="推荐算法" scheme="http://changsk.top/categories/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ALS" scheme="http://changsk.top/tags/ALS/"/>
    
  </entry>
  
  <entry>
    <title>mysql最左匹配原则</title>
    <link href="http://changsk.top/2019/06/27/mysql-leftmost-matching-principle/"/>
    <id>http://changsk.top/2019/06/27/mysql-leftmost-matching-principle/</id>
    <published>2019-06-27T13:36:56.000Z</published>
    <updated>2019-06-27T13:57:43.062Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载自：<a href="https://www.zhihu.com/question/36996520/answer/93256153" target="_blank" rel="noopener">mysql索引最左匹配原则的理解?</a><br>作者：沈杰</p></blockquote><p>下面是一个表结构，有三个字段，分别是<code>id,name,cid</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `student` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(255) DEFAULT NULL,</span><br><span class="line">  `cid` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `name_cid_INX` (`name`,`cid`),</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8</span><br></pre></td></tr></table></figure><p>索引方面：<code>id</code>是主键，<code>(name,cid)</code>是一个多列索引。</p><a id="more"></a><p>先看下面两条SQL语句的执行计划：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM student WHERE   cid=1;</span><br></pre></td></tr></table></figure><p><img src="1.jpg" alt="img"><img src="https://pic2.zhimg.com/80/d3086a6c81bb2c77796cfc2249b610bc_hd.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM student WHERE   cid=1 AND name=&apos;小红&apos;;</span><br></pre></td></tr></table></figure><p><img src="2.jpg" alt="img"><img src="https://pic3.zhimg.com/80/53ab2cdea64b7e58e66c4ef86aa6b06a_hd.jpg" alt="img"></p><p>sql查询用到索引的条件是必须要遵守最左前缀原则，为什么上面两个查询还能用到索引？<br>-————————————————————————————————————————–</p><p>讲上面问题之前，我先补充一些知识，因为我觉得你对索引理解是狭隘的：<br>上述你的两个查询的explain结果中显示用到索引的情况类型是不一样的。,可观察explain结果中的type字段。你的查询中分别是：</p><blockquote><p>type: index<br>type: ref  </p></blockquote><p><strong>解释：</strong></p><ul><li>index：这种类型表示是mysql会对<strong>整个该索引进行扫描</strong>。要想用到这种类型的索引，对这个索引并无特别要求，<strong>只要是索引，或者某个复合索引的一部分</strong>，mysql都可能会采用index类型的方式扫描。但是呢，缺点是效率不高，mysql会从索引中的第一个数据一个个的查找到最后一个数据，直到找到符合判断条件的某个索引。</li></ul><p><strong>所以：</strong>对于第一条语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM student WHERE   cid=1;</span><br></pre></td></tr></table></figure><p>判断条件是cid=1,而cid是(name,cid)复合索引的一部分，没有问题，<strong>可以进行index类型的索引扫描方式</strong>。explain显示结果使用到了索引，是index类型的方式。</p><p>-————————————————————————————————————————–</p><ul><li>ref：这种类型表示mysql会根据特定的算法快速查找到某个符合条件的索引，而不是会对索引中每一个数据都进行一 一的扫描判断，也就是所谓你平常理解的使用索引查询会更快的取出数据。而要想实现这种查找，索引却是有要求的，要实现这种能快速查找的算法，索引就要满足特定的数据结构。<strong>简单说，也就是索引字段的数据必须是有序的，才能实现这种类型的查找，才能利用到索引。</strong></li></ul><p>有些了解的人可能会问，索引不都是一个有序排列的数据结构么。不过答案说的还不够完善，那只是针对单个索引，而复合索引的情况有些同学可能就不太了解了。</p><p><strong>下面就说下复合索引：</strong></p><p>以该表的<code>(name,cid)</code>复合索引为例,它内部结构简单说就是下面这样排列的：</p><p><img src="3.jpg" alt="img"></p><p>mysql创建复合索引的规则是首先会对复合索引的最左边的，也就是第一个name字段的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个的cid字段进行排序。其实就相当于实现了类似 order by name cid这样一种排序规则。</p><p>所以：<strong>第一个name字段是绝对有序的</strong>，而第二字段就是无序的了。所以通常情况下，直接使用第二个cid字段进行条件判断是用不到索引的，当然，可能会出现上面的使用index类型的索引。这就是所谓的mysql为什么要强调最左前缀原则的原因。</p><p><strong>那么什么时候才能用到呢?</strong></p><p>当然是cid字段的索引数据也是有序的情况下才能使用咯，什么时候才是有序的呢？观察可知，当然是在name字段是等值匹配的情况下，cid才是有序的。发现没有，观察两个name名字为 c 的cid字段是不是有序的呢。从上往下分别是4  5。</p><p>这也就是mysql索引规则中要求复合索引要想使用第二个索引，必须先使用第一个索引的原因。（而且<strong>第一个索引必须是等值匹配</strong>）。</p><p>-————————————————————————————————————————–</p><p>所以对于这条sql查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM student WHERE   cid=1 AND name=&apos;小红&apos;;</span><br></pre></td></tr></table></figure><p>没有错，而且复合索引中的两个索引字段都能很好的利用到了！因为语句中最左面的name字段进行了等值匹配，所以cid是有序的，也可以利用到索引了。</p><p><strong>你可能会问</strong>：我建的索引是(name,cid)。而我查询的语句是cid=1 AND name=’小红’; 我是先查询cid，再查询name的，不是先从最左面查的呀？</p><p>好吧，我再解释一下这个问题：首先可以肯定的是把条件判断反过来变成这样 name=’小红’ and cid=1; 最后所查询的结果是一样的。<br>那么问题产生了？既然结果是一样的，到底以何种顺序的查询方式最好呢？</p><p><strong>所以</strong>，而此时那就是我们的mysql查询优化器该登场了，mysql查询优化器会判断纠正这条sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。所以，当然是我们能尽量的利用到索引时的查询顺序效率最高咯，所以mysql查询优化器会最终以这种顺序进行查询执行。</p><p>在最左前缀匹配原则，有一个非常重要的原则：mysql会一直向右匹配直到遇到<code>范围查询</code>(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p><blockquote><p>作者：Jokerone_</p><p>链接：<a href="https://www.jianshu.com/p/b7911e0394b0" target="_blank" rel="noopener">https://www.jianshu.com/p/b7911e0394b0</a></p><p>来源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载自：&lt;a href=&quot;https://www.zhihu.com/question/36996520/answer/93256153&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mysql索引最左匹配原则的理解?&lt;/a&gt;&lt;br&gt;作者：沈杰&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面是一个表结构，有三个字段，分别是&lt;code&gt;id,name,cid&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CREATE TABLE `student` (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  `id` int(11) NOT NULL AUTO_INCREMENT,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  `name` varchar(255) DEFAULT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  `cid` int(11) DEFAULT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  PRIMARY KEY (`id`),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  KEY `name_cid_INX` (`name`,`cid`),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;索引方面：&lt;code&gt;id&lt;/code&gt;是主键，&lt;code&gt;(name,cid)&lt;/code&gt;是一个多列索引。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://changsk.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Mysql" scheme="http://changsk.top/tags/Mysql/"/>
    
      <category term="最左匹配原则" scheme="http://changsk.top/tags/%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Collaborative-Filtering协同过滤详解</title>
    <link href="http://changsk.top/2019/06/27/Collaborative-Filtering/"/>
    <id>http://changsk.top/2019/06/27/Collaborative-Filtering/</id>
    <published>2019-06-27T12:11:58.000Z</published>
    <updated>2019-06-27T13:25:18.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p><code>基于用户的协同过滤算法</code>是通过用户的<code>历史行为数据</code>发现用户对商品或内容的喜欢(如商品<strong>购买</strong>，<strong>收藏</strong>，<strong>内容评论</strong>或<strong>分享</strong>)，并对这些喜好进行度量和<strong>打分</strong>。根据不同用户对相同商品或内容的态度和偏好程度计算用户之间的关系。在有相同喜好的用户间进行商品推荐。简单的说就是如果A,B两个用户都购买了x、y、z三本图书，并且给出了5星的好评。那么A和B就属于同一类用户。可以将A看过的图书w也推荐给用户B。</p> <a id="more"></a><p><img src="1.jpg" alt></p><p><strong>基于用户协同过滤算法的原理图</strong></p><p>所以，协同过滤算法主要分为两个步骤：</p><p>1、寻找相似的用户集合；</p><p>2、寻找集合中用户喜欢的且目标用户没有的进行推荐。</p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="寻找用户间的相似度"><a href="#寻找用户间的相似度" class="headerlink" title="寻找用户间的相似度"></a>寻找用户间的相似度</h2><h3 id="Jaccard公式"><a href="#Jaccard公式" class="headerlink" title="Jaccard公式"></a>Jaccard公式</h3><p><code>Jaccard</code>系数主要用于计算符号度量或布尔值度量的个体间的相似度，因为个体的特征属性都是由符号度量或者布尔值标识，因此无法衡量差异具体值的大小，只能获得“是否相同”这个结果，所以<code>Jaccard系数只关心个体间共同具有的特征是否一致</code>这个问题。如果比较X与Y的Jaccard相似系数，只比较xn和yn中相同的个数。</p><p> <img src="2.jpg" alt></p><p><strong>Jaccard公式</strong></p><h3 id="皮尔逊相关系数"><a href="#皮尔逊相关系数" class="headerlink" title="皮尔逊相关系数"></a>皮尔逊相关系数</h3><p>皮尔逊相关系统是比欧几里德距离更加复杂的可以判断人们兴趣相似度的一种方法。<code>它在数据不是很规范时，会倾向于给出更好的结果。</code><br>假定有两个变量X、Y，那么两变量间的皮尔逊相关系数可通过以下公式计算：</p><p>公式一：</p><p><img src="3.jpg" alt></p><p>皮尔逊相关系数公式一<br>公式二：</p><p><img src="4.jpg" alt></p><p>皮尔逊相关系数公式二<br>公式三：</p><p><img src="5.jpg" alt></p><p>皮尔逊相关系数公式三<br>公式四：</p><p><img src="6.jpg" alt></p><p>皮尔逊相关系数公式四</p><blockquote><p>上述四个公式等价，其中E是数学期望，cov表示协方差，N表示变量取值的个数。</p></blockquote><h3 id="欧几里德距离"><a href="#欧几里德距离" class="headerlink" title="欧几里德距离"></a>欧几里德距离</h3><p>假定两个用户X、Y，均为n维向量，表示用户对n个商品的评分，那么X与Y的欧几里德距离就是：</p><p> <img src="7.jpg" alt></p><p>多维欧几里德距离公式<br>数值越小则代表相似度越高，但是对于不同的n，计算出来的距离不便于控制，所以需要进行如下转换：</p><p> <img src="8.jpg" alt></p><p>相似度公式<br>使得结果分布在(0,1]上，数值越大，相似度越高。</p><h3 id="余弦距离"><a href="#余弦距离" class="headerlink" title="余弦距离"></a>余弦距离</h3><p><code>余弦距离</code>，也称为<code>余弦相似度</code>，是用向量空间中两个向量余弦值作为衡量两个个体间差异大小的度量值。</p><p>与前面的欧几里德距离相似，用户X、Y为两个n维向量，套用余弦公式，其余弦距离表示为：</p><p> <img src="8.jpg" alt></p><p>余弦距离公式<br>即两个向量夹角的余弦值。但是相比欧式距离，余弦距离更加注意两个向量在方向上的相对差异，而不是在空间上的绝对距离，具体可以借助下图来感受两者间的区别：</p><p> <img src="10.jpg" alt></p><p>余弦距离与欧式距离的区别</p><h2 id="推荐物品"><a href="#推荐物品" class="headerlink" title="推荐物品"></a>推荐物品</h2><p>在选取上述方法中的一种得到各个<code>用户相似度</code>后，针对目标用户u，我们<strong>选出最相似的k个用户</strong>，用集合S(u,k)表示，<code>将S中所有用户喜欢的物品提取出来并去除目标用户u已经喜欢的物品</code>。然后对余下的物品进行评分与相似度加权，得到的结果进行排序。最后由排序结果对目标用户u进行推荐。其中，对于每个可能推荐的物品i，用户u对其的感兴趣的程度可以用如下公式计算：</p><p> <img src="11.jpg" alt></p><p>用户u对物品i感兴趣的程度<br>rvi表示用户v对i的喜欢程度，即对i的评分，wuv表示用户u和v之间的相似度。</p><h2 id="收集用户偏好"><a href="#收集用户偏好" class="headerlink" title="收集用户偏好"></a>收集用户偏好</h2><p>要从<code>用户的行为和偏好</code>中发现规律，并基于此给予推荐，<strong>如何收集用户的偏好信息成为系统推荐效果最基础的决定因素</strong>。用户有很多方式向系统提供自己的偏好信息，而且不同的应用也可能大不相同，下面举例进行介绍：</p><p><strong>表 1 用户行为和用户偏好</strong></p><table><thead><tr><th>用户行为</th><th align="center">类型</th><th>特征</th><th>作用</th></tr></thead><tbody><tr><td>评分</td><td align="center">显式</td><td>整数量化的偏好，可能的取值是 [0, n]；n 一般取值为 5 或者是 10</td><td>通过用户对物品的评分，可以精确的得到用户的偏好</td></tr><tr><td>投票</td><td align="center">显式</td><td>布尔量化的偏好，取值是 0 或 1</td><td>通过用户对物品的投票，可以较精确的得到用户的偏好</td></tr><tr><td>转发</td><td align="center">显式</td><td>布尔量化的偏好，取值是 0 或 1</td><td>通过用户对物品的投票，可以精确的得到用户的偏好,如果是站内，同时可以推理得到被转发人的偏好（不精确）</td></tr><tr><td>保存书签</td><td align="center">显示</td><td>布尔量化的偏好，取值是 0 或 1</td><td>通过用户对物品的投票，可以精确的得到用户的偏好</td></tr><tr><td>标记标签(Tag)</td><td align="center">显示</td><td>一些单词，需要对单词进行分析，得到偏好</td><td>通过分析用户的标签，可以得到用户对项目的理解，同时可以分析出用户的情感：喜欢还是讨厌</td></tr><tr><td>评论</td><td align="center">显示</td><td>一段文字，需要进行文本分析，得到偏好</td><td>通过分析用户的评论，可以得到用户的情感：喜欢还是讨厌</td></tr><tr><td>点击流( 查看 )</td><td align="center">隐式</td><td>一组用户的点击，用户对物品感兴趣，需要进行分析，得到偏好</td><td>用户的点击一定程度上反映了用户的注意力，所以它也可以从一定程度上反映用户的喜好</td></tr><tr><td>页面停留时间</td><td align="center">隐式</td><td>一组时间信息，噪音大，需要进行去噪，分析，得到偏好</td><td>用户的页面停留时间一定程度上反映了用户的注意力和喜好，但噪音偏大，不好利用</td></tr><tr><td>购买</td><td align="center">隐式</td><td>布尔量化的偏好，取值是 0 或 1</td><td>用户的购买是很明确的说明这个项目它感兴趣</td></tr></tbody></table><p>以上列举的用户行为都是比较通用的，推荐引擎设计人员可以根据自己应用的特点添加特殊的用户行为，并用他们表示用户对物品的喜好|</p><p>在一般应用中，我们提取的用户行为一般都多于一种，关于如何组合这些不同的用户行为，基本上有以下两种方式：</p><ul><li>将不同的行为分组：一般可以分为“<strong>查看</strong>”和“<strong>购买</strong>”等等，然后基于不同的行为，计算不同的用户 / 物品相似度。类似于当当网或者 Amazon 给出的“<code>购买了该图书的人还购买了 …</code>”，“<code>查看了图书的人还查看了 …</code>”</li><li>根据不同行为反映用户喜好的程度将它们进行<strong>加权</strong>，得到用户对于物品的总体喜好。一般来说，<strong>显式的用户反馈比隐式的权值大</strong>，<strong>但比较稀疏，毕竟进行显示反馈的用户是少数；同时相对于“查看”，“购买”行为反映用户喜好的程度更大，但这也因应用而异。</strong></li></ul><p>收集了用户行为数据，我们还需要对数据进行一定的预处理，其中最核心的工作就是：<strong>减噪</strong>和<strong>归一化</strong>。</p><ul><li>减噪：用户行为数据是用户在使用应用过程中产生的，它可能存在大量的噪音和<strong>用户的误操作</strong>，我们可以<strong>通过经典的数据挖掘算法过滤掉行为数据中的噪音</strong>，这样可以是我们的分析更加精确。</li><li>归一化：如前面讲到的，在<code>计算用户对物品的喜好程度时，可能需要对不同的行为数据进行加权</code>。但可以想象，<code>不同行为的数据取值可能相差很大</code>，比如，<code>用户的查看数据必然比购买数据大的多</code>，<strong>如何将各个行为的数据统一在一个相同的取值范围中</strong>，从而使得加权求和得到的总体喜好更加精确，就需要我们进行归一化处理。最简单的归一化处理，就是将<strong>各类数据除以此类中的最大值</strong>，以保证归一化后的数据取值在 [0,1] 范围中</li></ul><p>进行了预处理后，根据不同应用的行为分析方法，可以选择分组或者加权处理，之后我们可以得到一个用户偏好的二维矩阵，一维是用户列表，另一维是物品列表，值是用户对物品的偏好，一般是 [0,1] 或者 [-1, 1] 的浮点数值。</p><h2 id="基于用户的-CF（User-CF）"><a href="#基于用户的-CF（User-CF）" class="headerlink" title="基于用户的 CF（User CF）"></a>基于用户的 CF（User CF）</h2><p>基于用户的协同过滤(user-basedCF)是基于这样一个事实：<code>每个用户都有与其具有相似兴趣爱好和购买行为的用户群，这些相似用户(邻居用户)的购买项目可以作为对当前用户(目标用户)进行项目推荐的基础。因此，这种方法也被称为基于邻居的协同过滤或最近邻居算法。</code></p><p>基于用户的 CF 的基本思想相当简单，<code>基于用户对物品的偏好找到相邻邻居用户，然后将邻居用户喜欢的推荐给当前用户</code>。计算上，<strong>就是将一个用户对所有物品的偏好作为一个向量来计算用户之间的相似度，找到 K 邻居后，根据邻居的相似度权重以及他们对物品的偏好，预测当前用户没有偏好的未涉及物品，计算得到一个排序的物品列表作为推荐</strong>。图 2 给出了一个例子，对于用户 A，根据用户的历史偏好，这里只计算得到一个邻居 – 用户 C，然后将用户 C 喜欢的物品 D 推荐给用户 A。</p><p><img src="12.jpg" alt></p><p>图 2 基于用户的 CF 的基本原理</p><h2 id="基于物品的-CF（Item-CF）"><a href="#基于物品的-CF（Item-CF）" class="headerlink" title="基于物品的 CF（Item CF）"></a>基于物品的 CF（Item CF）</h2><p>基于物品的 CF 的原理和基于用户的 CF 类似，<code>只是在计算邻居时采用物品本身，而不是从用户的角度，即基于用户对物品的偏好找到相似的物品，然后根据用户的历史偏好，推荐相似的物品给他</code>。从计算的角度看，<strong>就是将所有用户对某个物品的偏好作为一个向量来计算物品之间的相似度，得到物品的相似物品后，根据用户历史的偏好预测当前用户还没有表示偏好的物品，计算得到一个排序的物品列表作为推荐</strong>。图 3 给出了一个例子，对于物品 A，根据所有用户的历史偏好，喜欢物品 A 的用户都喜欢物品 C，得出物品 A 和物品 C 比较相似，而用户 C 喜欢物品 A，那么可以推断出用户 C 可能也喜欢物品 C。</p><p>基于物品的协同过滤的一个优点是容易解释推荐原因，第二个是电商网站中<strong>物品的相似度是相对不变的</strong>，<strong>物品相似度的矩阵维护起来相对容易。</strong></p><p><img src="13.jpg" alt></p><p>图 3 基于物品的 CF 的基本原理</p><h2 id="User-CF-vs-Item-CF"><a href="#User-CF-vs-Item-CF" class="headerlink" title="User CF vs. Item CF"></a>User CF vs. Item CF</h2><p>前面介绍了<code>User CF</code> 和<code>Item CF</code> 的基本原理，下面我们分几个不同的角度深入看看它们各自的优缺点和适用场景：</p><h3 id="计算复杂度"><a href="#计算复杂度" class="headerlink" title="计算复杂度"></a>计算复杂度</h3><p>Item CF 和 User CF 是基于协同过滤推荐的两个最基本的算法，User CF 是很早以前就提出来了，Item CF 是从 Amazon 的论文和专利发表之后（2001 年左右）开始流行，大家都觉得 Item CF 从性能和复杂度上比 User CF 更优，其中的一个主要原因就是对于一个在线网站，<code>用户的数量往往大大超过物品的数量</code>，<code>同时物品的数据相对稳定</code>，<strong>因此计算物品的相似度不但计算量较小，同时也不必频繁更新</strong>。但我们往往忽略了这种情况只适应于提供商品的电子商务网站，<strong>对于新闻，博客或者微内容的推荐系统，情况往往是相反的，物品的数量是海量的，同时也是更新频繁的，所以单从复杂度的角度，这两个算法在不同的系统中各有优势，推荐引擎的设计者需要根据自己应用的特点选择更加合适的算法。</strong></p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>在非社交网络的网站中，内容内在的联系是很重要的推荐原则，它比基于相似用户的推荐原则更加有效。比如在购书网站上，当你看一本书的时候，推荐引擎会给你推荐相关的书籍，这个推荐的重要性远远超过了网站首页对该用户的综合推荐。可以看到，在这种情况下，Item CF 的推荐成为了引导用户浏览的重要手段。同时 Item CF 便于为推荐做出解释，<strong>在一个非社交网络的网站中，给某个用户推荐一本书，同时给出的解释是某某和你有相似兴趣的人也看了这本书，这很难让用户信服，因为用户可能根本不认识那个人；但如果解释说是因为这本书和你以前看的某本书相似，用户可能就觉得合理而采纳了此推荐。</strong></p><p><strong>相反的，在现今很流行的社交网络站点中，User CF 是一个更不错的选择，User CF 加上社会网络信息，可以增加用户对推荐解释的信服程度。</strong></p><h3 id="推荐多样性和精度"><a href="#推荐多样性和精度" class="headerlink" title="推荐多样性和精度"></a>推荐多样性和精度</h3><p>研究推荐引擎的学者们在相同的数据集合上分别用 <code>User CF</code> 和<code>Item CF</code>计算推荐结果，发现推荐列表中，只有 50% 是一样的，还有 50% 完全不同。但是这两个算法确有相似的精度，所以可以说，这两个算法是很互补的。</p><p>关于推荐的多样性，有两种度量方法：</p><ul><li><p>第一种度量方法是从单个用户的角度度量，就是说给定一个用户，查看系统给出的推荐列表是否多样，也就是要<strong>比较推荐列表中的物品之间两两的相似度</strong>，不难想到，对这种度量方法，Item CF 的多样性显然不如 User CF 的好，因为 Item CF 的推荐就是和以前看的东西最相似的。</p></li><li><p>第二种度量方法是考虑系统的多样性，也被称为覆盖率 (Coverage)，它是指<strong>一个推荐系统是否能够提供给所有用户丰富的选择</strong>。在这种指标下，Item CF 的多样性要远远好于 User CF, 因为 <strong>User CF 总是倾向于推荐热门的</strong>，从另一个侧面看，也就是说，<strong>Item CF 的推荐有很好的新颖性，很擅长推荐长尾里的物品</strong>。所以，尽管大多数情况，<strong>Item CF 的精度略小于 User CF， 但如果考虑多样性，Item CF 却比 User CF 好很多。</strong></p></li></ul><p>如果你对推荐的多样性还心存疑惑，那么下面我们再举个实例看看 User CF 和 Item CF 的多样性到底有什么差别。首先，假设每个用户兴趣爱好都是广泛的，喜欢好几个领域的东西，不过每个用户肯定也有一个主要的领域，对这个领域会比其他领域更加关心。给定一个用户，假设他喜欢 3 个领域 A,B,C，A 是他喜欢的主要领域，这个时候我们来看 User CF 和 Item CF 倾向于做出什么推荐：如果用 User CF, 它会将 A,B,C 三个领域中比较热门的东西推荐给用户；而如果用 ItemCF，它会基本上只推荐 A 领域的东西给用户。所以我们看到<strong>因为 User CF 只推荐热门的</strong>，<strong>所以它在推荐长尾里项目方面的能力不足</strong>；而 Item CF 只推荐 A 领域给用户，这样他有限的推荐列表中就可能包含了一定数量的不热门的长尾物品，同时 Item CF 的推荐对这个用户而言，显然多样性不足。但是对整个系统而言，因为不同的用户的主要兴趣点不同，所以系统的覆盖率会比较好。</p><blockquote><p>从人们需求的角度来看，大多数的需求会集中在头部，而这部分我们可以称之为流行，而分布在尾部的需求是个性化的，零散的小量的需求。而这部分差异化的、少量的需求会在<a href="https://baike.baidu.com/item/需求曲线/3351682" target="_blank" rel="noopener">需求曲线</a>上面形成一条长长的“尾巴”，而所谓长尾效应就在于它的数量上，将所有非流行的市场累加起来就会形成一个比流行市场还大的市场。</p></blockquote><p>从上面的分析，可以很清晰的看到，这两种推荐都有其合理性，但都不是最好的选择，因此他们的精度也会有损失。其实对这类系统的最好选择是，如果系统给这个用户推荐 30 个物品，既不是每个领域挑选 10 个最热门的给他，也不是推荐 30 个 A 领域的给他，而是比如推荐 15 个 A 领域的给他，剩下的 15 个从 B,C 中选择。所以<code>结合 User CF 和 Item CF 是最优的选择</code>，结合的基本原则就是<strong>当采用 Item CF 导致系统对个人推荐的多样性不足时，我们通过加入 User CF 增加个人推荐的多样性，从而提高精度，而当因为采用 User CF 而使系统的整体多样性不足时，我们可以通过加入 Item CF 增加整体的多样性，同样同样可以提高推荐的精度。</strong></p><h3 id="用户对推荐算法的适应度"><a href="#用户对推荐算法的适应度" class="headerlink" title="用户对推荐算法的适应度"></a>用户对推荐算法的适应度</h3><p>前面我们大部分都是从推荐引擎的角度考虑哪个算法更优，但其实我们更多的应该考虑作为推荐引擎的最终使用者 — 应用用户对推荐算法的适应度。</p><p><strong>对于 User CF，推荐的原则是假设用户会喜欢那些和他有相同喜好的用户喜欢的东西，但如果一个用户没有相同喜好的朋友，那 User CF 的算法的效果就会很差，所以一个用户对的 CF 算法的适应度是和他有多少共同喜好用户成正比的。</strong></p><p><strong>Item CF 算法也有一个基本假设，就是用户会喜欢和他以前喜欢的东西相似的东西，那么我们可以计算一个用户喜欢的物品的自相似度。一个用户喜欢物品的自相似度大，就说明他喜欢的东西都是比较相似的，也就是说他比较符合 Item CF 方法的基本假设，那么他对 Item CF 的适应度自然比较好；反之，如果自相似度小，就说明这个用户的喜好习惯并不满足 Item CF 方法的基本假设，那么对于这种用户，用 Item CF 方法做出好的推荐的可能性非常低。</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th></th><th>UserCF</th><th>ItemCF</th></tr></thead><tbody><tr><td>性能</td><td>适用于用户较少的场合，如果用户很多，计算用户相似度矩阵代价很大</td><td>适用于物品数明显小于用户数的场合，如果物品很多（网页），计算物品相似度矩阵代价很大</td></tr><tr><td>领域</td><td>时效性较强，用户个性化兴趣不太明显的领域</td><td>长尾物品丰富，用户个性化需求强烈的领域</td></tr><tr><td>实时性</td><td>用户有新行为，不一定造成推荐结果的立即变化</td><td>用户有新行为，一定会导致推荐结果的实时变化</td></tr><tr><td>冷启动</td><td>在新用户对很少的物品产生行为后，不能立即对他进行个性化推荐，因为用户相似度表是每隔一段时间离线计算的</td><td>新用户只要对一个物品产生行为，就可以给他推荐和该物品相关的其他物品</td></tr><tr><td></td><td>新物品上线后一段时间，一旦有用户对物品产生行为，就可以将新物品推荐给和对它产生行为的用户兴趣相似的其他用户</td><td>但没有办法在不离线更新物品相似度表的情况下将新物品推荐给用户</td></tr><tr><td>推荐理由</td><td>很难提供令用户信服的推荐解释</td><td>利用用户的历史行为给用户做推荐解释，可以令用户比较信服</td></tr></tbody></table><h2 id="矩阵分解"><a href="#矩阵分解" class="headerlink" title="矩阵分解　　　　　　　　　　　　"></a>矩阵分解　　　　　　　　　　　　</h2><p>Spark推荐模型库当前只包含基于矩阵分解（matrix factorization）的实现，由此我们也将重点关注这类模型。它们有吸引人的地方。首先，这些模型在协同过滤中的表现十分出色。而在Netflix Prize等知名比赛中的表现也很拔尖</p><h3 id="显式矩阵分解"><a href="#显式矩阵分解" class="headerlink" title="显式矩阵分解　　　　"></a>显式矩阵分解　　　　</h3><p>要找到和“用户物品”矩阵近似的k维（低阶）矩阵，最终要求出如下两个矩阵：一个用于表示用户的U × k维矩阵，以及一个表征物品的I × k维矩阵。</p><p>这两个矩阵也称作因子矩阵。它们的乘积便是原始评级矩阵的一个近似。值得注意的是，原始评级矩阵通常很稀疏，但因子矩阵却是稠密的。</p><p>特点：因子分解类模型的好处在于，一旦建立了模型，对推荐的求解便相对容易。但也有弊端，即当用户和物品的数量很多时，其对应的物品或是用户的因子向量可能达到数以百万计。</p><p>这将在存储和计算能力上带来挑战。另一个好处是，这类模型的表现通常都很出色。</p><h3 id="隐式矩阵分解（关联因子分确定，可能随时会变化）"><a href="#隐式矩阵分解（关联因子分确定，可能随时会变化）" class="headerlink" title="隐式矩阵分解（关联因子分确定，可能随时会变化）"></a>隐式矩阵分解（关联因子分确定，可能随时会变化）</h3><p>隐式模型仍然会创建一个用户因子矩阵和一个物品因子矩阵。但是，模型所求解的是偏好矩阵而非评级矩阵的近似。类似地，此时用户因子向量和物品因子向量的点积所得到的分数</p><p>也不再是一个对评级的估值，而是对某个用户对某一物品偏好的估值（该值的取值虽并不严格地处于0到1之间，但十分趋近于这个区间）</p><h3 id="最小二乘法（Alternating-Least-Squares-ALS）：解决矩阵分解的最优化方法"><a href="#最小二乘法（Alternating-Least-Squares-ALS）：解决矩阵分解的最优化方法" class="headerlink" title="最小二乘法（Alternating Least Squares    ALS）：解决矩阵分解的最优化方法"></a>最小二乘法（Alternating Least Squares    ALS）：解决矩阵分解的最优化方法</h3><p><code>ALS</code>的实现原理是迭代式求解一系列最小二乘回归问题。在每一次迭代时，固定用户因子矩阵或是物品因子矩阵中的一个，然后用固定的这个矩阵以及评级数据来更新另一个矩阵。</p><p>之后，被更新的矩阵被固定住，再更新另外一个矩阵。如此迭代，<strong>直到模型收敛（或是迭代了预设好的次数）。</strong></p><blockquote><p>参考：<br><a href="https://www.cnblogs.com/ECJTUACM-873284962/p/8729010.html" target="_blank" rel="noopener">Collaborative Filtering(协同过滤)算法详解</a><br><a href="https://www.imooc.com/article/39466" target="_blank" rel="noopener">协同过滤算法：基于用户和基于物品的优缺点比较</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本思想&quot;&gt;&lt;a href=&quot;#基本思想&quot; class=&quot;headerlink&quot; title=&quot;基本思想&quot;&gt;&lt;/a&gt;基本思想&lt;/h1&gt;&lt;p&gt;&lt;code&gt;基于用户的协同过滤算法&lt;/code&gt;是通过用户的&lt;code&gt;历史行为数据&lt;/code&gt;发现用户对商品或内容的喜欢(如商品&lt;strong&gt;购买&lt;/strong&gt;，&lt;strong&gt;收藏&lt;/strong&gt;，&lt;strong&gt;内容评论&lt;/strong&gt;或&lt;strong&gt;分享&lt;/strong&gt;)，并对这些喜好进行度量和&lt;strong&gt;打分&lt;/strong&gt;。根据不同用户对相同商品或内容的态度和偏好程度计算用户之间的关系。在有相同喜好的用户间进行商品推荐。简单的说就是如果A,B两个用户都购买了x、y、z三本图书，并且给出了5星的好评。那么A和B就属于同一类用户。可以将A看过的图书w也推荐给用户B。&lt;/p&gt;
    
    </summary>
    
      <category term="推荐算法" scheme="http://changsk.top/categories/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="协同过滤" scheme="http://changsk.top/tags/%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4/"/>
    
      <category term="推荐算法" scheme="http://changsk.top/tags/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>初识ElasticSearch</title>
    <link href="http://changsk.top/2019/06/27/es-introduce/"/>
    <id>http://changsk.top/2019/06/27/es-introduce/</id>
    <published>2019-06-27T08:15:31.000Z</published>
    <updated>2019-06-27T09:05:46.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="没有ES之前"><a href="#没有ES之前" class="headerlink" title="没有ES之前"></a>没有ES之前</h1><h2 id="思考：大规模数据如何检索？"><a href="#思考：大规模数据如何检索？" class="headerlink" title="思考：大规模数据如何检索？"></a>思考：大规模数据如何检索？</h2><p>当系统数据量上了10亿、100亿条的时候，我们在做系统架构的时候通常会从以下角度去考虑问题：<br>1）用什么数据库好？(mysql、sybase、oracle、达梦、神通、mongodb、hbase…)<br>2）如何解决单点故障；(lvs、F5、A10、Zookeeper、MQ)<br>3）如何保证数据安全性；(热备、冷备、异地多活)<br>4）如何解决检索难题；(数据库代理中间件：mysql-proxy、Cobar、MaxScale等;)<br>5）如何解决统计分析问题；(离线、近实时)</p><a id="more"></a><h2 id="传统数据库的应对解决方案"><a href="#传统数据库的应对解决方案" class="headerlink" title="传统数据库的应对解决方案"></a>传统数据库的应对解决方案</h2><p>对于关系型数据，我们通常采用以下或类似架构去解决查询瓶颈和写入瓶颈：<br>解决要点：<br>1）<strong>通过主从备份解决数据安全性问题；</strong><br>2）<strong>通过数据库代理中间件心跳监测，解决单点故障问题；</strong><br>3）<strong>通过代理中间件将查询语句分发到各个slave节点进行查询，并汇总结果</strong><br><img src="1.jpg" alt="这里写图片描述"></p><h2 id="非关系型数据库的解决方案"><a href="#非关系型数据库的解决方案" class="headerlink" title="非关系型数据库的解决方案"></a>非关系型数据库的解决方案</h2><p>对于Nosql数据库，以mongodb为例，其它原理类似：<br>解决要点：<br>1）<strong>通过副本备份保证数据安全性；</strong><br>2）<strong>通过节点竞选机制解决单点问题；</strong><br>3）<strong>先从配置库检索分片信息，然后将请求分发到各个节点，最后由路由节点合并汇总结果</strong><br><img src="2.jpg" alt="这里写图片描述"></p><h2 id="另辟蹊径——完全把数据放入内存怎么样？"><a href="#另辟蹊径——完全把数据放入内存怎么样？" class="headerlink" title="另辟蹊径——完全把数据放入内存怎么样？"></a>另辟蹊径——完全把数据放入内存怎么样？</h2><p>我们知道，完全把数据放在内存中是不可靠的，实际上也不太现实，当我们的数据达到PB级别时，按照每个节点96G内存计算，在内存完全装满的数据情况下，我们需要的机器是：1PB=1024T=1048576G<br>节点数=1048576/96=10922个<br>实际上，考虑到数据备份，节点数往往在2.5万台左右。成本巨大决定了其不现实！</p><p>从前面讨论我们了解到，把数据放在内存也好，不放在内存也好，都不能完完全全解决问题。<br>全部放在内存速度问题是解决了，但成本问题上来了。<br>为解决以上问题，从源头着手分析，通常会从以下方式来寻找方法：<br>1、存储数据时按有序存储；<br>2、将数据和索引分离；<br>3、压缩数据；<br>这就引出了Elasticsearch。</p><h1 id="Elasticsearch的概述"><a href="#Elasticsearch的概述" class="headerlink" title="Elasticsearch的概述"></a>Elasticsearch的概述</h1><h2 id="Elasticsearch-是什么"><a href="#Elasticsearch-是什么" class="headerlink" title="Elasticsearch 是什么"></a>Elasticsearch 是什么</h2><p>Elasticsearch（ES）是一个基于<code>Lucene</code>构建的<strong>开源</strong>、<strong>分布式</strong>、<strong>RESTful接口</strong>的<strong>全文搜索引擎</strong>。Elasticsearch还是一个<strong>分布式文档数据库</strong>，其中<strong>每个字段均可被索引</strong>，而且<strong>每个字段的数据均可被搜索</strong>，ES能够横向扩展至数以百计的服务器存储以及处理PB级的数据。可以在极短的时间内存储、搜索和分析大量的数据。通常作为具有复杂搜索场景情况下的核心发动机。Elasticsearch也使用Java开发并使用<code>Lucene</code>作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的<code>RESTful API</code>来<strong>隐藏Lucene的复杂性</strong>，从而让全文搜索变得简单。</p><p><img src="3.jpg" alt></p><p>ElasticSearch就是为<code>高可用</code>和<code>可扩展</code>而生的。可以通过购置性能更强的服务器或者升级硬件来完成系统扩展，称为<strong>垂直或向上扩展</strong>（Vertical Scale/Scaling Up）。另一方面，增加更多的服务器来完成系统扩展，称为<strong>水平扩展或者向外扩展</strong>（Horizontal Scale/Scaling Out）。尽管ES能够利用更强劲的硬件，垂直扩展毕竟还是有它的极限。真正的可扩展性来自于水平扩展，通过向集群中添加更多的节点来分担负载，增加可靠性。ES天生就是分布式的：它知道如何管理多个节点来完成扩展和实现高可用性。这也意味你的应用不需要做任何的改动。</p><h2 id="Lucene与ES关系"><a href="#Lucene与ES关系" class="headerlink" title="Lucene与ES关系"></a>Lucene与ES关系</h2><ol><li>Lucene只是一个库。想要使用它，你必须使用Java来作为开发语言并将其直接集成到你的应用中，更糟糕的是，Lucene非常复杂，你需要深入了解检索的相关知识来理解它是如何工作的。</li><li>Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。</li></ol><h2 id="ES主要解决问题"><a href="#ES主要解决问题" class="headerlink" title="ES主要解决问题"></a>ES主要解决问题</h2><p>1）检索相关数据；<br>2）返回统计结果；<br>3）速度要快。</p><h2 id="ES工作原理"><a href="#ES工作原理" class="headerlink" title="ES工作原理"></a>ES工作原理</h2><p>当ElasticSearch的节点启动后，它会利用多播(multicast)(或者单播，如果用户更改了配置)寻找集群中的其它节点，并与之建立连接。这个过程如下图所示：<br><img src="4.jpg" alt="这里写图片描述"></p><h2 id="ES数据架构的主要概念（与关系数据库Mysql对比）"><a href="#ES数据架构的主要概念（与关系数据库Mysql对比）" class="headerlink" title="ES数据架构的主要概念（与关系数据库Mysql对比）"></a>ES数据架构的主要概念（与关系数据库Mysql对比）</h2><p><img src alt="这里写图片描述"><br>（1）关系型数据库中的数据库（DataBase），等价于ES中的索引（Index）<br>（2）一个数据库下面有N张表（Table），等价于1个索引Index下面有N多类型（Type），<br>（3）一个数据库表（Table）下的数据由多行（ROW）多列（column，属性）组成，等价于1个Type由多个文档（Document）和多Field组成。<br>（4）在一个关系型数据库里面，schema定义了表、每个表的字段，还有表和字段之间的关系。 与之对应的，在ES中：Mapping定义索引下的Type的字段处理规则，即索引如何建立、索引类型、是否保存原始索引JSON文档、是否压缩原始JSON文档、是否需要分词处理、如何进行分词处理等。<br>（5）在数据库中的增insert、删delete、改update、查search操作等价于ES中的增PUT/POST、删Delete、改_update、查GET.</p><h2 id="ES核心概念"><a href="#ES核心概念" class="headerlink" title="ES核心概念"></a>ES核心概念</h2><h3 id="Near-Realtime-NRT-几乎实时"><a href="#Near-Realtime-NRT-几乎实时" class="headerlink" title="Near Realtime(NRT) 几乎实时"></a>Near Realtime(NRT) 几乎实时</h3><p>Elasticsearch是一个几乎实时的搜索平台。意思是，从索引一个文档到这个文档可被搜索只需要一点点的延迟，这个时间一般为毫秒级。</p><h3 id="Cluster：集群"><a href="#Cluster：集群" class="headerlink" title="Cluster：集群"></a>Cluster：集群</h3><p>ES可以作为一个独立的单个搜索服务器。不过，为了处理大型数据集，实现容错和高可用性，ES可以运行在许多互相合作的服务器上。这些服务器的集合称为集群。</p><p>群集是一个或多个节点（服务器）的集合， 这些节点共同保存整个数据，并在所有节点上提供联合索引和搜索功能。一个集群由一个唯一集群ID确定，并指定一个集群名（默认为“elasticsearch”）。该集群名非常重要，因为节点可以通过这个集群名加入群集，一个节点只能是群集的一部分。</p><p>确保在不同的环境中不要使用相同的群集名称，否则可能会导致连接错误的群集节点。例如，你可以使用logging-dev、logging-stage、logging-prod分别为开发、阶段产品、生产集群做记录。</p><h3 id="Node：节点"><a href="#Node：节点" class="headerlink" title="Node：节点"></a>Node：节点</h3><p>形成集群的每个服务器称为节点。</p><p>节点是单个服务器实例，它是群集的一部分，可以存储数据，并参与群集的<strong>索引</strong>和<strong>搜索</strong>功能。就像一个集群，节点的名称默认为一个随机的通用唯一标识符（UUID），确定在启动时分配给该节点。如果不希望默认，可以定义任何节点名。这个名字对管理很重要，目的是要确定你的网络服务器对应于你的ElasticSearch群集节点。</p><p>我们可以通过群集名配置节点以连接特定的群集。默认情况下，每个节点设置加入名为“<code>elasticSearch</code>”的集群。这意味着如果你启动多个节点在网络上，假设他们能发现彼此都会自动形成和加入一个名为“elasticsearch”的集群。</p><p>在单个群集中，您可以拥有尽可能多的节点。此外，如果“elasticsearch”在同一个网络中，没有其他节点正在运行，从单个节点的默认情况下会形成一个新的单节点名为”elasticsearch”的集群。</p><h3 id="Shard：分片-amp-Replia：副本"><a href="#Shard：分片-amp-Replia：副本" class="headerlink" title="Shard：分片 &amp; Replia：副本"></a>Shard：分片 &amp; Replia：副本</h3><p>索引可以存储大量的数据，这些数据可能超过单个节点的硬件限制。例如，十亿个文件占用磁盘空间1TB的单指标可能不适合对单个节点的磁盘或可能太慢服务仅从单个节点的搜索请求。</p><p>为了解决这一问题，Elasticsearch提供细分你的指标分成多个块称为分片的能力。<strong>当你创建一个索引，你可以简单地定义你想要的分片数量</strong>。每个分片本身是一个全功能的、独立的“指数”，可以托管在集群中的任何节点。</p><p>Shards分片的重要性主要体现在以下两个特征：</p><ul><li>分片允许您水平拆分或缩放内容的大小</li><li>分片允许你分配和并行操作的碎片（可能在多个节点上）从而提高性能/吞吐量</li></ul><p>这个机制中的碎片是分布式的以及其文件汇总到搜索请求是完全由ElasticSearch管理，对用户来说是透明的。</p><p>在同一个集群网络或云环境上，故障是任何时候都会出现的，拥有一个故障转移机制以防分片和结点因为某些原因离线或消失是非常有用的，并且被强烈推荐。为此，Elasticsearch允许你创建一个或多个拷贝，你的索引分片进入所谓的副本或称作复制品的分片，简称Replicas。</p><p>Replicas的重要性主要体现在以下两个特征：</p><ul><li>副本为分片或节点失败提供了高可用性。为此，需要注意的是，一个副本的分片不会分配在同一个节点作为原始的或主分片，副本是从主分片那里复制过来的。</li><li>副本允许用户扩展你的搜索量或吞吐量，因为搜索可以在所有副本上并行执行。</li></ul><blockquote><p>当有大量的文档时，由于内存的限制、磁盘处理能力不足、无法足够快的响应客户端的请求等，一个节点可能不够。这种情况下，数据可以分为较小的分片。每个分片放到不同的服务器上。<br>当你查询的索引分布在多个分片上时，ES会把查询发送给每个相关的分片，并将结果组合在一起，而应用程序并不知道分片的存在。即：这个过程对用户来说是透明的。</p><p>为提高查询吞吐量或实现高可用性，可以使用分片副本。<br>副本是一个分片的精确复制，每个分片可以有零个或多个副本。ES中可以有许多相同的分片，其中之一被选择更改索引操作，这种特殊的分片称为主分片。<br>当主分片丢失时，如：该分片所在的数据不可用时，集群将副本提升为新的主分片。</p></blockquote><h3 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h3><p>全文检索就是对一篇文章进行索引，可以根据关键字搜索，类似于mysql里的like语句。<br>全文索引就是把内容根据词的意义进行分词，然后分别创建索引，例如”你们的激情是因为什么事情来的” 可能会被分词成：“你们“，”激情“，“什么事情“，”来“ 等token，这样当你搜索“你们” 或者 “激情” 都会把这句搜出来。</p><h3 id="Index索引"><a href="#Index索引" class="headerlink" title="Index索引"></a>Index索引</h3><p><strong>索引是具有相似特性的文档集合</strong>。例如，可以为客户数据提供索引，为产品目录建立另一个索引，以及为订单数据建立另一个索引。索引由名称（必须全部为小写）标识，该名称用于在对其中的文档执行索引、搜索、更新和删除操作时引用索引。在单个群集中，您可以定义尽可能多的索引。</p><h3 id="Type类型"><a href="#Type类型" class="headerlink" title="Type类型"></a>Type类型</h3><p>在索引中，可以定义一个或多个类型。类型是索引的逻辑类别/分区，其语义完全取决于您。一般来说，类型定义为具有公共字段集的文档。例如，假设你运行一个博客平台，并将所有数据存储在一个索引中。在这个索引中，您可以为用户数据定义一种类型，为博客数据定义另一种类型，以及为注释数据定义另一类型。</p><h3 id="Document文档"><a href="#Document文档" class="headerlink" title="Document文档"></a>Document文档</h3><p><strong>文档是可以被索引的信息的基本单位</strong>。例如，您可以为单个客户提供一个文档，单个产品提供另一个文档，以及单个订单提供另一个文档。本文件的表示形式为JSON（JavaScript Object Notation）格式，这是一种非常普遍的互联网数据交换格式。</p><p>在索引/类型中，您可以存储尽可能多的文档。请注意，尽管文档物理驻留在索引中，文档实际上必须索引或分配到索引中的类型。</p><h2 id="Elasticsearch可以做什么"><a href="#Elasticsearch可以做什么" class="headerlink" title="Elasticsearch可以做什么?"></a>Elasticsearch可以做什么?</h2><p>当你经营一家网上商店，你可以让你的客户搜索你卖的商品。在这种情况下，你可以使用ElasticSearch来存储你的整个产品目录和库存信息，为客户提供精准搜索，可以为客户推荐相关商品。</p><p>当你想收集日志或者交易数据的时候，需要分析和挖掘这些数据，寻找趋势，进行统计，总结，或发现异常。在这种情况下，你可以使用Logstash或者其他工具来进行收集数据，当这引起数据存储到ElasticsSearch中。你可以搜索和汇总这些数据，找到任何你感兴趣的信息。</p><p>对于程序员来说，比较有名的案例是<strong>GitHub</strong>，GitHub的搜索是基于ElasticSearch构建的，在github.com/search页面，你可以搜索项目、用户、issue、pull request，还有代码。共有40~50个索引库，分别用于索引网站需要跟踪的各种数据。虽然只索引项目的主分支（master），但这个数据量依然巨大，包括20亿个索引文档，30TB的索引文件。</p><h2 id="ELK是什么？"><a href="#ELK是什么？" class="headerlink" title="ELK是什么？"></a>ELK是什么？</h2><p><code>ELK=elasticsearch+Logstash+kibana</code><br>elasticsearch：<strong>后台分布式存储以及全文检索</strong><br>logstash: 日志加工、“搬运工”<br>kibana：数据可视化展示。<br>ELK架构为数据分布式存储、可视化查询和日志解析创建了一个功能强大的管理链。 三者相互配合，取长补短，共同完成分布式大数据处理工作。</p><h1 id="ES特点和优势"><a href="#ES特点和优势" class="headerlink" title="ES特点和优势"></a>ES特点和优势</h1><p>1）<strong>分布式实时文件存储</strong>，可将每一个字段存入索引，使其可以被检索到。<br>2）实时分析的分布式搜索引擎。 </p><blockquote><p>分布式：索引分拆成多个分片，每个分片可有零个或多个副本。集群中的每个数据节点都可承载一个或多个分片，并且协调和处理各种操作；<br>负载再平衡和路由在大多数情况下自动完成。 </p></blockquote><p>3）可以扩展到上百台服务器，处理PB级别的结构化或非结构化数据。也可以运行在单台PC上（已测试）<br>4）支持插件机制，分词插件、同步插件、Hadoop插件、可视化插件等。</p><blockquote><p>参考：<br><a href="https://blog.csdn.net/makang110/article/details/80596017" target="_blank" rel="noopener">Elasticsearch学习，请先看这一篇！</a><br><a href="https://blog.csdn.net/deliciousion/article/details/78050251" target="_blank" rel="noopener">ElasticSearch介绍和基本概念</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;没有ES之前&quot;&gt;&lt;a href=&quot;#没有ES之前&quot; class=&quot;headerlink&quot; title=&quot;没有ES之前&quot;&gt;&lt;/a&gt;没有ES之前&lt;/h1&gt;&lt;h2 id=&quot;思考：大规模数据如何检索？&quot;&gt;&lt;a href=&quot;#思考：大规模数据如何检索？&quot; class=&quot;headerlink&quot; title=&quot;思考：大规模数据如何检索？&quot;&gt;&lt;/a&gt;思考：大规模数据如何检索？&lt;/h2&gt;&lt;p&gt;当系统数据量上了10亿、100亿条的时候，我们在做系统架构的时候通常会从以下角度去考虑问题：&lt;br&gt;1）用什么数据库好？(mysql、sybase、oracle、达梦、神通、mongodb、hbase…)&lt;br&gt;2）如何解决单点故障；(lvs、F5、A10、Zookeeper、MQ)&lt;br&gt;3）如何保证数据安全性；(热备、冷备、异地多活)&lt;br&gt;4）如何解决检索难题；(数据库代理中间件：mysql-proxy、Cobar、MaxScale等;)&lt;br&gt;5）如何解决统计分析问题；(离线、近实时)&lt;/p&gt;
    
    </summary>
    
    
      <category term="ElasticSearch" scheme="http://changsk.top/tags/ElasticSearch/"/>
    
      <category term="搜索" scheme="http://changsk.top/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>Java中遍历HashMap的5种方式</title>
    <link href="http://changsk.top/2019/06/27/java-HashMap-access/"/>
    <id>http://changsk.top/2019/06/27/java-HashMap-access/</id>
    <published>2019-06-27T05:08:50.000Z</published>
    <updated>2019-06-27T05:18:33.006Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://blog.csdn.net/w605283073/article/details/80708943" target="_blank" rel="noopener">Java中遍历HashMap的5种方式</a></p></blockquote><p>本教程将为你展示Java中<code>HashMap</code>的几种典型遍历方式。</p><p>如果你使用<code>Java8</code>，由于该版本<code>JDK</code>支持<code>lambda</code>表达式，可以采用第5种方式来遍历。</p><p>如果你想使用泛型，可以参考方法3。如果你使用旧版JDK不支持泛型可以参考方法4。</p><a id="more"></a><h3 id="通过ForEach循环进行遍历"><a href="#通过ForEach循环进行遍历" class="headerlink" title="通过ForEach循环进行遍历"></a>通过ForEach循环进行遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mport java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Iterating entries using a For Each loop</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">System.out.println(<span class="string">"Key = "</span> + entry.getKey() + <span class="string">", Value = "</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ForEach迭代键值对方式"><a href="#ForEach迭代键值对方式" class="headerlink" title="ForEach迭代键值对方式"></a>ForEach迭代键值对方式</h3><p>如果你只想使用键或者值，推荐使用如下方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 迭代键</span></span><br><span class="line"><span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">System.out.println(<span class="string">"Key = "</span> + key);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 迭代值</span></span><br><span class="line"><span class="keyword">for</span> (Integer value : map.values()) &#123;</span><br><span class="line">System.out.println(<span class="string">"Value = "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用带泛型的迭代器进行遍历"><a href="#使用带泛型的迭代器进行遍历" class="headerlink" title="使用带泛型的迭代器进行遍历"></a>使用带泛型的迭代器进行遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line"> </span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (entries.hasNext()) &#123;</span><br><span class="line">Map.Entry&lt;Integer, Integer&gt; entry = entries.next();</span><br><span class="line">System.out.println(<span class="string">"Key = "</span> + entry.getKey() + <span class="string">", Value = "</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用不带泛型的迭代器进行遍历"><a href="#使用不带泛型的迭代器进行遍历" class="headerlink" title="使用不带泛型的迭代器进行遍历"></a>使用不带泛型的迭代器进行遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"> </span><br><span class="line">Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line"> </span><br><span class="line">Iterator&lt;Map.Entry&gt; entries = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (entries.hasNext()) &#123;</span><br><span class="line">Map.Entry entry = (Map.Entry) entries.next();</span><br><span class="line">Integer key = (Integer) entry.getKey();</span><br><span class="line">Integer value = (Integer) entry.getValue();</span><br><span class="line">System.out.println(<span class="string">"Key = "</span> + key + <span class="string">", Value = "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过Java8-Lambda表达式遍历"><a href="#通过Java8-Lambda表达式遍历" class="headerlink" title="通过Java8 Lambda表达式遍历"></a>通过Java8 Lambda表达式遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"> </span><br><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line">map.forEach((k, v) -&gt; System.out.println(<span class="string">"key: "</span> + k + <span class="string">" value:"</span> + v));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>输出</strong> </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">key</span>: 1 <span class="selector-tag">value</span><span class="selector-pseudo">:10</span></span><br><span class="line"><span class="selector-tag">key</span>: 2 <span class="selector-tag">value</span><span class="selector-pseudo">:20</span></span><br></pre></td></tr></table></figure><p>英文原文：<a href="https://www.javatips.net/blog/iterate-hashmap-using-java" target="_blank" rel="noopener">https://www.javatips.net/blog/iterate-hashmap-using-java</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://blog.csdn.net/w605283073/article/details/80708943&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java中遍历HashMap的5种方式&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本教程将为你展示Java中&lt;code&gt;HashMap&lt;/code&gt;的几种典型遍历方式。&lt;/p&gt;
&lt;p&gt;如果你使用&lt;code&gt;Java8&lt;/code&gt;，由于该版本&lt;code&gt;JDK&lt;/code&gt;支持&lt;code&gt;lambda&lt;/code&gt;表达式，可以采用第5种方式来遍历。&lt;/p&gt;
&lt;p&gt;如果你想使用泛型，可以参考方法3。如果你使用旧版JDK不支持泛型可以参考方法4。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://changsk.top/categories/Java/"/>
    
    
      <category term="HashMap" scheme="http://changsk.top/tags/HashMap/"/>
    
      <category term="java" scheme="http://changsk.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>数据库范式</title>
    <link href="http://changsk.top/2019/06/26/database-paradigms/"/>
    <id>http://changsk.top/2019/06/26/database-paradigms/</id>
    <published>2019-06-26T14:04:21.000Z</published>
    <updated>2019-06-27T06:02:29.712Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载自：<a href="https://blog.csdn.net/tkzc_csk/article/details/88684166" target="_blank" rel="noopener">[数据库] 理解数据库范式-通俗易懂</a></p></blockquote><p>​        <strong>数据库范式</strong>是数据库设计中必不可少的知识，没有对范式的理解，就无法设计出<code>高效率</code>、<code>优雅</code>的数据库。甚至设计出错误的数据库。而想要理解并掌握范式却并不是那么容易。教科书中一般以<strong>关系代数</strong>的方法来解释数据库范式。这样做虽然能够<strong>十分准确</strong>的表达数据库范式，但<strong>比较抽象</strong>，<strong>不太直观，不便于理解，更难以记忆</strong>。　　本文用较为<strong>直白</strong>的语言介绍范式，旨在<strong>便于理解和记忆</strong>，这样做可能会出现一些<strong>不精确的表述</strong>。但对于初学者应该是个不错的入门。我写下这些的目的主要是为了<strong>加强记忆</strong>，其实我也比较菜，我希望当我对一些概念生疏的时候，回过头来看看自己写的笔记，可以快速地进入状态。如果你发现其中用错误，请指正。</p><a id="more"></a><p>下面开始进入正题：</p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>要理解范式，首先必须对知道什么是关系数据库，如果你不知道，我可以简单的不能再简单的说一下：<strong>关系数据库就是用二维表来保存数据</strong>。表和表之间可以……（省略10W字）。</p><p>然后你应该理解以下概念：</p><p><strong>实体</strong>：现实世界中客观存在并可以被区别的事物。比如“一个学生”、“一本书”、“一门课”等等。值得强调的是这里所说的“事物”不仅仅是看得见摸得着的“东西”，它也可以是虚拟的，比如说“老师与学校的关系”。</p><p><strong>属性</strong>：教科书上解释为：“实体所具有的某一特性”，由此可见，属性一开始是个逻辑概念，比如说，“性别”是“人”的一个属性。在关系数据库中，属性又是个物理概念，<strong>属性可以看作是“表的一列”</strong>。</p><p><strong>元组</strong>：<strong>表中的一行就是一个元组。</strong></p><p><strong>分量</strong>：<strong>元组的某个属性值</strong>。在一个关系数据库中，它是一个操作原子，即关系数据库在做任何操作的时候，属性是“<strong>不可分的</strong>”。否则就不是关系数据库了。</p><p><strong>码</strong>：<strong>表中可以唯一确定一个元组的某个属性（或者属性组）</strong>，如果这样的码有不止一个，那么大家都叫<strong>候选码</strong>，我们从候选码中挑一个出来做老大，它就叫<strong>主码</strong>。</p><p><strong>全码</strong>：如果一个码包含了所有的属性，这个码就是全码。</p><p><strong>主属性</strong>：<strong>一个属性只要在任何一个候选码中出现过，这个属性就是主属性</strong>。</p><p><strong>非主属性</strong>：与上面相反，没有在任何候选码中出现过，这个属性就是非主属性。</p><p><strong>外码</strong>：一个属性（或属性组），它不是码，但是它别的表的码，它就是外码。</p><h2 id="六个范式"><a href="#六个范式" class="headerlink" title="六个范式"></a>六个范式</h2><p>好了，上面已经介绍了我们掌握范式所需要的全部基础概念，下面我们就来讲范式。首先要明白，范式的包含关系。一个数据库设计如果符合第二范式，一定也符合第一范式。如果符合第三范式，一定也符合第二范式……</p><h3 id="第一范式（1NF）：属性不可分"><a href="#第一范式（1NF）：属性不可分" class="headerlink" title="第一范式（1NF）：属性不可分"></a>第一范式（1NF）：属性不可分</h3><p>在前面已经介绍了属性值的概念，我们说，它是“<strong>不可分的</strong>”。而第一范式要求<strong>属性也不可分</strong>。那么它和属性值不可分有什么区别呢？给一个例子：</p><p><img src="1.jpg" alt="在这里插入图片描述"></p><p>这个表中，属性值“分”了。“电话”这个属性里对于“小明”属性值分成了两个。<br><img src="2.jpg" alt="在这里插入图片描述"></p><p>这两种情况都不满足第一范式。<strong>不满足第一范式的数据库，不是关系数据库！</strong>所以，我们在任何关系数据库管理系统中，做不出这样的“表”来。针对上述情况可以做成这样的表：这个表中，属性 “分”了。也就是“电话”分为了“手机”和“座机”两个属性。</p><p><img src="3.jpg" alt="在这里插入图片描述"></p><h3 id="第二范式（2NF）：符合1NF，并且，非主属性完全依赖于码。（注意是完全依赖不能是部分依赖，设有函数依赖W→A，若存在XW，有X→A成立，那么称W→A是局部依赖，否则就称W→A是完全函数依赖）"><a href="#第二范式（2NF）：符合1NF，并且，非主属性完全依赖于码。（注意是完全依赖不能是部分依赖，设有函数依赖W→A，若存在XW，有X→A成立，那么称W→A是局部依赖，否则就称W→A是完全函数依赖）" class="headerlink" title="第二范式（2NF）：符合1NF，并且，非主属性完全依赖于码。（注意是完全依赖不能是部分依赖，设有函数依赖W→A，若存在XW，有X→A成立，那么称W→A是局部依赖，否则就称W→A是完全函数依赖）"></a>第二范式（2NF）：符合1NF，并且，非主属性完全依赖于码。（注意是完全依赖不能是部分依赖，设有函数依赖W→A，若存在XW，有X→A成立，那么称W→A是局部依赖，否则就称W→A是完全函数依赖）</h3><p><img src="4.jpg" alt="在这里插入图片描述"></p><p>一个学生上一门课，一定是特定某个老师教。所以有（学生，课程）－&gt;老师；</p><p>一个学生上一门课，一定在特定某个教室。所以有（学生，课程）－&gt;教室；</p><p>一个学生上一门课，他老师的职称可以确定。所以有（学生，课程）－&gt;老师职称；</p><p>一个学生上一门课，一定是特定某个教材。所以有（学生，课程）－&gt;教材</p><p>一个学生上一门课，一定在特定时间。所以有（学生，课程）－&gt;上课时间</p><p>因此（学生，课程）是一个码。</p><p>然而，一个课程，一定指定了某个教材，一年级语文肯定用的是《小学语文1》，那么就有课程－&gt;教材。（学生，课程）是个码，课程却决定了教材，这就叫做不完全依赖，或者说部分依赖。出现这样的情况，就不满足第二范式！</p><p>有什么不好吗？你可以想想：</p><p>1、校长要新增加一门课程叫“微积分”，教材是《大学数学》，怎么办？学生还没选课，而学生又是主属性，主属性不能空，课程怎么记录呢，教材记到哪呢? ……郁闷了吧?(插入异常)</p><p>2、下学期没学生学一年级语文（上）了，学一年级语文（下）去了，那么表中将不存在一年级语文（上），也就没了《小学语文1》。这时候，校长问：一年级语文（上）用的什么教材啊？……郁闷了吧?(删除异常)</p><p>3、校长说：一年级语文（上）换教材，换成《大学语文》。有10000个学生选了这门课，改动好大啊！改累死了……郁闷了吧？（修改/更新异常，在这里你可能觉得直接把教材《小学语文1》替换成《大学语文》不就可以了，但是替换操作虽然计算机运行速度很快，但是毕竟也要替换10000次，造成了很大的时间开销）</p><p>那应该怎么解决呢？投影分解，将一个表分解成两个或若干个表</p><p><img src="5.jpg" alt="在这里插入图片描述"><br><img src="6.jpg" alt="在这里插入图片描述"></p><h3 id="第三范式（3NF）：符合2NF，并且，消除传递依赖（也就是每个非主属性都不传递依赖于候选键，判断传递函数依赖，指的是如果存在”A-→-B-→-C”的决定关系，则C传递函数依赖于A。）"><a href="#第三范式（3NF）：符合2NF，并且，消除传递依赖（也就是每个非主属性都不传递依赖于候选键，判断传递函数依赖，指的是如果存在”A-→-B-→-C”的决定关系，则C传递函数依赖于A。）" class="headerlink" title="第三范式（3NF）：符合2NF，并且，消除传递依赖（也就是每个非主属性都不传递依赖于候选键，判断传递函数依赖，指的是如果存在”A → B → C”的决定关系，则C传递函数依赖于A。）"></a>第三范式（3NF）：符合2NF，并且，消除传递依赖（也就是每个非主属性都不传递依赖于候选键，判断传递函数依赖，指的是如果存在”A → B → C”的决定关系，则C传递函数依赖于A。）</h3><p>上面的“学生上课新表”符合2NF，但是它有传递依赖！在哪呢？问题就出在“老师”和“老师职称”这里。一个老师一定能确定一个老师职称。（学生，课程）-&gt;老师-&gt;职称。</p><p>有什么问题吗？想想：</p><p>1、老师升级了，变教授了，要改数据库，表中有N条，改了N次……（修改异常）<br>2、没人选这个老师的课了，老师的职称也没了记录……（删除异常）<br>3、新来一个老师，还没分配教什么课，他的职称记到哪？……（插入异常）<br>那应该怎么解决呢？和上面一样，投影分解：</p><p><img src="7.jpg" alt="在这里插入图片描述"><br><img src="8.jpg" alt="在这里插入图片描述"></p><h3 id="BC范式（BCNF）：符合3NF，并且，主属性不依赖于主属性-也就是不存在任何字段对任一候选关键字段的传递函数依赖"><a href="#BC范式（BCNF）：符合3NF，并且，主属性不依赖于主属性-也就是不存在任何字段对任一候选关键字段的传递函数依赖" class="headerlink" title="BC范式（BCNF）：符合3NF，并且，主属性不依赖于主属性(也就是不存在任何字段对任一候选关键字段的传递函数依赖)"></a>BC范式（BCNF）：符合3NF，并且，主属性不依赖于主属性(也就是不存在任何字段对任一候选关键字段的传递函数依赖)</h3><p><strong>BC范式既检查非主属性，又检查主属性。</strong>当只检查非主属性时，就成了第三范式。满足BC范式的关系都必然满足第三范式。</p><p>还可以这么说：<strong>若一个关系达到了第三范式，并且它只有一个候选码，或者它的每个候选码都是单属性，则该关系自然达到BC范式</strong>。</p><p>给你举个例子：假设仓库管理关系表 (仓库ID, 存储物品ID, 管理员ID, 数量)，且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品。</p><p>这个数据库表中存在如下决定关系：</p><p>(仓库ID, 存储物品ID) →(管理员ID, 数量)</p><p>(管理员ID, 存储物品ID) → (仓库ID, 数量)</p><p>所以，(仓库ID, 存储物品ID)和(管理员ID, 存储物品ID)都是StorehouseManage的候选关键字，表中的唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系：</p><p>(仓库ID) → (管理员ID)</p><p>(管理员ID) → (仓库ID)</p><p>即存在<strong>关键字段决定关键字段</strong>的情况，所以其不符合BCNF范式。它会出现如下异常情况：</p><p>(1) 删除异常：</p><p>当仓库被清空后，所有”存储物品ID”和”数量”信息被删除的同时，”仓库ID”和”管理员ID”信息也被删除了。</p><p>(2) 插入异常：</p><p>当仓库没有存储任何物品时，无法给仓库分配管理员。</p><p>(3) 更新异常：</p><p>如果仓库换了管理员，则表中所有行的管理员ID都要修改。</p><p>把仓库管理关系表分解为二个关系表：</p><p>仓库管理：StorehouseManage(仓库ID, 管理员ID)；</p><p>仓库：Storehouse(仓库ID, 存储物品ID, 数量)。</p><p>这样的数据库表是符合BCNF范式的，消除了删除异常、插入异常和更新异常。</p><p>一般，一个数据库设计符合3NF或BCNF就可以了。在BC范式以上还有第四范式、第五范式。</p><h3 id="第四范式：要求把同一表内的多对多关系删除"><a href="#第四范式：要求把同一表内的多对多关系删除" class="headerlink" title="第四范式：要求把同一表内的多对多关系删除"></a>第四范式：要求把同一表内的多对多关系删除</h3><h3 id="第五范式：从最终结构重新建立原始结构"><a href="#第五范式：从最终结构重新建立原始结构" class="headerlink" title="第五范式：从最终结构重新建立原始结构"></a>第五范式：从最终结构重新建立原始结构</h3><p>其实数据库设计范式这方面重点掌握的就是<code>1NF、2NF、3NF、BCNF</code></p><p>四种范式之间存在如下关系：</p><p><img src="9.png" alt="1561558192833"></p><p>这里主要区别<code>3NF</code>和<code>BCNF</code>，一句话就是<code>3NF</code>是要满足不存在非主属性对候选码的传递函数依赖，<code>BCNF</code>是要满足不存在任一属性（包含非主属性和主属性）对候选码的传递函数依赖。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载自：&lt;a href=&quot;https://blog.csdn.net/tkzc_csk/article/details/88684166&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[数据库] 理解数据库范式-通俗易懂&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​        &lt;strong&gt;数据库范式&lt;/strong&gt;是数据库设计中必不可少的知识，没有对范式的理解，就无法设计出&lt;code&gt;高效率&lt;/code&gt;、&lt;code&gt;优雅&lt;/code&gt;的数据库。甚至设计出错误的数据库。而想要理解并掌握范式却并不是那么容易。教科书中一般以&lt;strong&gt;关系代数&lt;/strong&gt;的方法来解释数据库范式。这样做虽然能够&lt;strong&gt;十分准确&lt;/strong&gt;的表达数据库范式，但&lt;strong&gt;比较抽象&lt;/strong&gt;，&lt;strong&gt;不太直观，不便于理解，更难以记忆&lt;/strong&gt;。
　　本文用较为&lt;strong&gt;直白&lt;/strong&gt;的语言介绍范式，旨在&lt;strong&gt;便于理解和记忆&lt;/strong&gt;，这样做可能会出现一些&lt;strong&gt;不精确的表述&lt;/strong&gt;。但对于初学者应该是个不错的入门。我写下这些的目的主要是为了&lt;strong&gt;加强记忆&lt;/strong&gt;，其实我也比较菜，我希望当我对一些概念生疏的时候，回过头来看看自己写的笔记，可以快速地进入状态。如果你发现其中用错误，请指正。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://changsk.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql的优化问题</title>
    <link href="http://changsk.top/2019/06/26/mysql-optimize/"/>
    <id>http://changsk.top/2019/06/26/mysql-optimize/</id>
    <published>2019-06-26T13:13:38.000Z</published>
    <updated>2019-06-27T06:03:14.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL表设计原则"><a href="#MySQL表设计原则" class="headerlink" title="MySQL表设计原则"></a>MySQL表设计原则</h1><h2 id="表结构设计满足三大范式"><a href="#表结构设计满足三大范式" class="headerlink" title="表结构设计满足三大范式"></a>表结构设计满足三大范式</h2><h3 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h3><p>◆ 第一范式（1NF）：强调的是<strong>列的原子性</strong>，即列不能够再分成其他几列。 </p><p>◆ 第二范式（2NF）：<strong>首先是 1NF，另外包含两部分内容，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。</strong> </p><p>◆ 第三范式（3NF）：<strong>首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。</strong> </p><a id="more"></a><p>第二范式（2NF）和第三范式（3NF）的概念很容易混淆，区分它们的关键点在于</p><blockquote><p>2NF：非主键列是否完全依赖于主键，还是依赖于主键的一部分；</p><p>3NF：非主键列是直接依赖于主键，还是直接依赖于非主键列。</p></blockquote><h3 id="范式的优点"><a href="#范式的优点" class="headerlink" title="范式的优点"></a>范式的优点</h3><ol><li>范式化的数据库更新起来更加快；</li><li>范式化之后，只有很少的重复数据，只需要修改更少的数据；</li><li>范式化的表更小，可以在内存中执行；</li><li>很少的冗余数据，在查询的时候需要更少的distinct或者group by语句。</li></ol><h3 id="范式的缺点"><a href="#范式的缺点" class="headerlink" title="范式的缺点"></a>范式的缺点</h3><p>范式化的表，<strong>在查询的时候经常需要很多的关联，因为单独一个表内不存在冗余和重复数据</strong>。这导致，稍微复杂一些的查询语句在查询范式的schema上都可能需要较多次的关联。这会增加让查询的代价，也可能使一些索引策略无效。因为范式化将列存放在不同的表中，而这些列在一个表中本可以属于同一个索引。</p><h2 id="适度冗余，-让query尽量减少join"><a href="#适度冗余，-让query尽量减少join" class="headerlink" title="适度冗余， 让query尽量减少join"></a>适度冗余， 让query尽量减少join</h2><p>虽然<code>optimizer</code>会对<code>query</code>进行一定的优化，但有时候遇见复杂的join，优化效果并不令人满意，再加上本来join的性能开销，所以需要尽量的减少join，而<strong>需要通过冗余来实现</strong>。比如：有两个数据表分别为用户信息表和用户发帖表，在展示发帖列表时，如果没有冗余的话，两个表要join以取得想要的发帖信息和用户昵称，但如果考虑冗余，用户昵称占用空间不大，如果在发帖表里增加这么一个字段的话，在展示列表时就不用做join操作了，性能会得到很大的改善。</p><p>但冗余也会带来一些问题，比如在发帖表里增加了用户昵称字段，就得维护两份用户昵称数据，为了保证数据的一致性，在用户昵称发生改变时，就<strong>得向两个表做更新操作</strong>，程序中就得做更多的处理。但相比的话，<strong>更新频率显然不及查询频率</strong>，这样通过增加少量的更新操作会换来更大的性能提升，这也是在项目中经常采用的优化手段。</p><h2 id="大字段垂直分拆"><a href="#大字段垂直分拆" class="headerlink" title="大字段垂直分拆"></a>大字段垂直分拆</h2><p>所谓的大字段，没有一个很严格的标准，常用的是<strong>如果一个字段的大小占整条记录的50%以上，我们就视为其为大字段。</strong>大字段垂直分拆相比适度冗余是完全相反的操作，适度冗余是将别的表中的字段放进一个表中，而大字段分拆是将自身的大字段拆分出去放进另一个表中。</p><p>这两个优化策略貌似是矛盾的，但要<strong>根据具体的应用场景来分析</strong>，<code>适度冗余是因为在频率较高的查询中要使用该字段，为了减少join的性能开销。而大字段垂直分拆是将在查询中不使用的大字段拿出去，</code>虽然不使用该字段但mysql在查询时并不是只需要访问需要查询的那几个字段，而是读取所有的字段，所以即使不使用字段，mysql也会读取该字段，为了节省IO开销，所以将查询中不常使用的大字段分拆出去。比如：拿博客系统为例，常用的作法是将博客内容从博客列表里分拆出去建立一个博客内容表，因为访问博客列表时并不需要读取博客内容，分拆出去之后，访问博客列表的性能将会大大的提升。但同时访问博客内容时就得做一次join操作了，性能对比的话，join操作两个表是一对一的关系，性能开销会很低。</p><h2 id="大表水平分拆"><a href="#大表水平分拆" class="headerlink" title="大表水平分拆"></a>大表水平分拆</h2><p>举例说明：在一个论坛系统里，管理员经常会发一些帖子，这些帖子要求在每个分类列表里都要置顶。</p><p>设计方案一：在发帖表里增加一列用来标示是否是管理员发帖，这样在每个分类列表展示时就需要对发帖表查询两次，一次是置顶帖，一次是普通帖，然后将两次结果合并。如果发帖表内容较大时，查询置顶帖的性能开销会比较大。</p><p>设计方案二：将置顶帖存放在一个单独的置顶表里。因为置顶帖数量相比会很少，但访问频率很高，这样从发帖表里分拆开来，访问的性能开销会少很多。</p><h2 id="选择合适的数据类型"><a href="#选择合适的数据类型" class="headerlink" title="选择合适的数据类型"></a>选择合适的数据类型</h2><p>要选择合适的数据类型必须要先了解不同数据类型间的差异。</p><p>数字类型有整数类型和浮点数类型，还有一类是通过二进制格式以字符串来存放的数字类型，如DECIMAL(size,d)，其存放长度主要通过定义的size决定，size定义多大，则实际存放就有多长。默认的size为10，d为0。这种类型的存放长度较长而且完全可以用整形来代替实现，所以不推荐使用。</p><p>时间类型主要使用<code>DATE</code>，<code>DATETIME</code>和<code>TIMESTAMP</code>三种类型，<strong>TIMESTAMP占用存储空间最少，只要4个字节</strong>，其它两种类型都要占用8个字节。从存储内容来看，<strong>TIMESTAMP只能存储1970年之后的时间</strong>，另外两种都能存储从1001开始的时间。</p><p>特别要说明的是<code>varchar</code>类型，varchar(size)，在mysql5.0.3之前size表示的是字节数，mysql5.0.3之后size表示的是字符数。这里我们只关注mysql5.0.3之后的表示，size表示的字符数最大限制和字符集有关，如果是gbk编码，最大长度为(65535-1-2)/2=32766，减1的原因是实际行存储从第二个字节开始，减2的原因是varchar头部的2个字节表示长度，除2因为是gbk编码；如果是utf8编码，最大长度为(65535-1-2)/3=21844。 </p><p>如果数据量一样，但数据类型更小的话，数据存放同样的数据就会占用更少的空间，这样检索同样的数据所带来的IO消耗自然会降低，性能也就很自然的得到提升。此外，mysql对不同类型的数据，处理方式也不一样，比如在运算或者排序操作中，越简单的数据类型操作性能越高，所以对于要频繁进行运算或者排序的字段尽量选择简单的数据类型。</p><blockquote><p>参考：<br><a href="https://www.cnblogs.com/wzj4858/p/7910084.html" target="_blank" rel="noopener">mysql表设计原则</a> </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MySQL表设计原则&quot;&gt;&lt;a href=&quot;#MySQL表设计原则&quot; class=&quot;headerlink&quot; title=&quot;MySQL表设计原则&quot;&gt;&lt;/a&gt;MySQL表设计原则&lt;/h1&gt;&lt;h2 id=&quot;表结构设计满足三大范式&quot;&gt;&lt;a href=&quot;#表结构设计满足三大范式&quot; class=&quot;headerlink&quot; title=&quot;表结构设计满足三大范式&quot;&gt;&lt;/a&gt;表结构设计满足三大范式&lt;/h2&gt;&lt;h3 id=&quot;三大范式&quot;&gt;&lt;a href=&quot;#三大范式&quot; class=&quot;headerlink&quot; title=&quot;三大范式&quot;&gt;&lt;/a&gt;三大范式&lt;/h3&gt;&lt;p&gt;◆ 第一范式（1NF）：强调的是&lt;strong&gt;列的原子性&lt;/strong&gt;，即列不能够再分成其他几列。 &lt;/p&gt;
&lt;p&gt;◆ 第二范式（2NF）：&lt;strong&gt;首先是 1NF，另外包含两部分内容，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;◆ 第三范式（3NF）：&lt;strong&gt;首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。&lt;/strong&gt; &lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://changsk.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Mysql" scheme="http://changsk.top/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Redis内部数据结构详解——skiplist</title>
    <link href="http://changsk.top/2019/06/26/redis-skiplist/"/>
    <id>http://changsk.top/2019/06/26/redis-skiplist/</id>
    <published>2019-06-26T12:50:52.000Z</published>
    <updated>2019-06-26T13:58:37.550Z</updated>
    
    <content type="html"><![CDATA[<p>本文是《<a href="http://zhangtielei.com/posts/blog-redis-dict.html" target="_blank" rel="noopener">Redis内部数据结构详解</a>》系列的第六篇。在本文中，我们围绕一个<code>Redis</code>的内部数据结构——<strong>skiplist</strong>展开讨论。</p><p>Redis里面使用skiplist是为了实现<code>sorted set</code>这种对外的数据结构。<code>sorted set</code>提供的操作非常丰富，可以满足非常多的应用场景。这也意味着，sorted set相对来说实现比较复杂。同时，<code>skiplist</code>这种数据结构对于很多人来说都比较陌生，因为大部分学校里的算法课都没有对这种数据结构进行过详细的介绍。因此，为了介绍得足够清楚，本文会比这个系列的其它几篇花费更多的篇幅。</p><a id="more"></a><p>我们将大体分成三个部分进行介绍：</p><ol><li>介绍经典的<code>skiplist</code>数据结构，并进行简单的算法分析。这一部分的介绍，与Redis没有直接关系。我会尝试尽量使用通俗易懂的语言进行描述。</li><li>讨论Redis里的<code>skiplist</code>的具体实现。为了支持sorted set本身的一些要求，在经典的<code>skiplist</code>基础上，Redis里的相应实现做了若干改动。</li><li>讨论sorted set是如何在<code>skiplist</code>, dict和ziplist基础上构建起来的。</li></ol><p>我们在讨论中还会涉及到两个Redis配置（在<code>redis.conf</code>中的<code>ADVANCED CONFIG</code>部分）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zset-max-ziplist-entries <span class="number">128</span></span><br><span class="line">zset-max-ziplist-value <span class="number">64</span></span><br></pre></td></tr></table></figure><p>我们在讨论中会详细解释这两个配置的含义。</p><blockquote><p>注：本文讨论的代码实现基于Redis源码的3.2分支。</p></blockquote><h2 id="skiplist数据结构简介"><a href="#skiplist数据结构简介" class="headerlink" title="skiplist数据结构简介"></a>skiplist数据结构简介</h2><p><code>skiplist</code>本质上也是一种查找结构，用于解决算法中的查找问题（<strong>Searching</strong>），即根据给定的key，快速查到它所在的位置（或者对应的value）。</p><p>我们在《Redis内部数据结构详解》系列的<a href="http://zhangtielei.com/posts/blog-redis-dict.html" target="_blank" rel="noopener">第一篇</a>中介绍dict的时候，曾经讨论过：一般查找问题的解法分为两个大类：一个是基于各种<strong>平衡树</strong>，一个是基于<strong>哈希表</strong>。但<code>skiplist</code>却比较特殊，它没法归属到这两大类里面。</p><p>这种数据结构是由<a href="https://en.wikipedia.org/wiki/William_Pugh" target="_blank" rel="noopener">William Pugh</a>发明的，最早出现于他在1990年发表的论文《<a href="ftp://ftp.cs.umd.edu/pub/skipLists/skiplists.pdf" target="_blank" rel="noopener">Skip Lists: A Probabilistic Alternative to Balanced Trees</a>》。对细节感兴趣的同学可以下载论文原文来阅读。</p><p><code>skiplist</code>，顾名思义，首先它是一个list。实际上，它是在有序链表的基础上发展起来的。</p><p>我们先来看一个有序链表，如下图（最左侧的灰色节点表示一个空的头结点）：</p><p><img src="1.jpg" alt="有序链表结构图"></p><p>在这样一个链表中，如果我们要查找某个数据，那么需要从头开始逐个进行比较，直到找到包含数据的那个节点，或者找到第一个比给定数据大的节点为止（没找到）。也就是说，<strong>时间复杂度为O(n)</strong>。同样，当我们要插入新数据的时候，也要经历同样的查找过程，从而确定插入位置。</p><p>假如我们每相邻两个节点增加一个指针，让指针指向下下个节点，如下图：</p><p><img src="2.jpg" alt="每两个节点增加一个跳跃指针的有序链表"></p><p>这样所有新增加的指针连成了一个新的链表，但它包含的节点个数只有原来的一半（上图中是7, 19, 26）。现在当我们想查找数据的时候，可以先沿着这个新链表进行查找。当碰到比待查数据大的节点时，再回到原来的链表中进行查找。比如，我们想查找23，查找的路径是沿着下图中标红的指针所指向的方向进行的：</p><p><img src="3.jpg" alt="一个搜索路径的例子"></p><ul><li>23首先和7比较，再和19比较，比它们都大，继续向后比较。</li><li>但23和26比较的时候，比26要小，因此回到下面的链表（原链表），与22比较。</li><li>23比22要大，沿下面的指针继续向后和26比较。23比26小，说明待查数据23在原链表中不存在，而且它的插入位置应该在22和26之间。</li></ul><p>在这个查找过程中，由于新增加的指针，我们不再需要与链表中每个节点逐个进行比较了。需要比较的节点数大概只有原来的一半。</p><p>利用同样的方式，我们可以在上层新产生的链表上，继续为每相邻的两个节点增加一个指针，从而产生第三层链表。如下图：</p><p><img src="4.jpg" alt="两层跳跃指针"></p><p>在这个新的三层链表结构上，如果我们还是查找23，那么沿着最上层链表首先要比较的是19，发现23比19大，接下来我们就知道只需要到19的后面去继续查找，从而一下子跳过了19前面的所有节点。可以想象，当链表足够长的时候，这种多层链表的查找方式能让我们跳过很多下层节点，大大加快查找的速度。</p><p><code>skiplist</code>正是受这种<strong>多层链表</strong>的想法的启发而设计出来的。实际上，按照上面生成链表的方式，<strong>上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常类似于一个二分查找，使得查找的时间复杂度可以降低到O(log n)。</strong>但是，这种方法在插入数据的时候有很大的问题。新插入一个节点之后，就会打乱上下相邻两层链表上节点个数<strong>严格的2:1的对应关系</strong>。如果要维持这种对应关系，就必须把新插入的节点后面的所有节点（也包括新插入的节点）重新进行调整，这会让时间复杂度重新蜕化成O(n)。删除数据也有同样的问题。</p><p><code>skiplist</code>为了避免这一问题，它<strong>不要求上下相邻两层链表之间的节点个数有严格的对应关系</strong>，而是<strong>为每个节点随机出一个层数(level)。</strong>比如，一个节点随机出的层数是3，那么就把它链入到第1层到第3层这三层链表中。为了表达清楚，下图展示了如何通过一步步的插入操作从而形成一个skiplist的过程：</p><p><img src="5.jpg" alt="skiplist插入形成过程"></p><p>从上面<code>skiplist</code>的创建和插入过程可以看出，<strong>每一个节点的层数（level）是随机出来的</strong>，<strong>而且新插入一个节点不会影响其它节点的层数</strong>。因此，插入操作只需要修改插入节点前后的指针，而不需要对很多节点都进行调整。这就降低了插入操作的复杂度。实际上，这是<code>skiplist</code>的一个很重要的特性，这让它在<strong>插入性能上明显优于平衡树的方案</strong>。这在后面我们还会提到。</p><p>根据上图中的<code>skiplist</code>结构，我们很容易理解这种数据结构的名字的由来。skiplist，翻译成中文，可以翻译成“<strong>跳表</strong>”或“<strong>跳跃表</strong>”，指的就是除了最下面第1层链表之外，它会产生<strong>若干层稀疏的链表</strong>，<strong>这些链表里面的指针故意跳过了一些节点（而且越高层的链表跳过的节点越多）。</strong>这就使得我们在查找数据的时候能够先在高层的链表中进行查找，然后逐层降低，<strong>最终降到第1层链表来精确地确定数据位置</strong>。在这个过程中，我们跳过了一些节点，从而也就加快了查找速度。</p><p>刚刚创建的这个<code>skiplist</code>总共包含4层链表，现在假设我们在它里面依然查找23，下图给出了查找路径：</p><p><img src="6.jpg" alt="skiplist上的查找路径展示"></p><p>需要注意的是，前面演示的各个节点的插入过程，实际上在插入之前也要先经历一个类似的查找过程，在确定插入位置后，再完成插入操作。</p><p>至此，<code>skiplist</code>的查找和插入操作，我们已经很清楚了。而删除操作与插入操作类似，我们也很容易想象出来。这些操作我们也应该能很容易地用代码实现出来。</p><p>当然，实际应用中的<code>skiplist</code>每个节点应该包含<strong>key</strong>和<strong>value</strong>两部分。前面的描述中我们没有具体区分key和value，但实际上<strong>列表中是按照key进行排序的</strong>，查找过程也是根据key在比较。</p><p>但是，如果你是第一次接触<code>skiplist</code>，那么一定会产生一个疑问：节点插入时随机出一个层数，仅仅依靠这样一个简单的随机数操作而构建出来的多层链表结构，能保证它有一个良好的查找性能吗？为了回答这个疑问，我们需要分析<code>skiplist</code>的统计性能。</p><p>在分析之前，我们还需要着重指出的是，执行插入操作时计算随机数的过程，是一个很关键的过程，它对<code>skiplist</code>的统计特性有着很重要的影响。<strong>这并不是一个普通的服从均匀分布的随机数</strong>，它的计算过程如下：</p><ul><li>首先，每个节点肯定都有第1层指针（每个节点都在第1层链表里）。</li><li>如果一个节点有第i层(i&gt;=1)指针（即节点已经在第1层到第i层链表中），那么它有第(i+1)层指针的概率为p。</li><li>节点最大的层数不允许超过一个最大值，记为<strong>MaxLevel</strong>。</li></ul><p>这个计算随机层数的伪码如下所示：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">randomLevel()</span><br><span class="line">    level := <span class="number">1</span></span><br><span class="line">    <span class="comment">// random()返回一个[0...1)的随机数</span></span><br><span class="line">    <span class="built_in">while</span> <span class="built_in">random</span>() &lt; p <span class="keyword">and</span> level &lt; MaxLevel <span class="built_in">do</span></span><br><span class="line">        level := level + <span class="number">1</span></span><br><span class="line">    <span class="built_in">return</span> level</span><br></pre></td></tr></table></figure><p><code>randomLevel()</code>的伪码中包含两个参数，一个是p，一个是MaxLevel。在Redis的skiplist实现中，这两个参数的取值为：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">p</span> = <span class="number">1</span>/<span class="number">4</span></span><br><span class="line"><span class="attr">MaxLevel</span> = <span class="number">32</span></span><br></pre></td></tr></table></figure><h3 id="skiplist的算法性能分析"><a href="#skiplist的算法性能分析" class="headerlink" title="skiplist的算法性能分析"></a>skiplist的算法性能分析</h3><p>在这一部分，我们来简单分析一下<code>skiplist</code>的时间复杂度和空间复杂度，以便对于<code>skiplist</code>的性能有一个直观的了解。如果你不是特别偏执于算法的性能分析，那么可以暂时跳过这一小节的内容。</p><p>我们先来计算一下每个节点所包含的平均指针数目（概率期望）。节点包含的指针数目，相当于这个算法在空间上的额外开销(overhead)，可以用来度量空间复杂度。</p><p>根据前面randomLevel()的伪码，我们很容易看出，产生越高的节点层数，概率越低。定量的分析如下：</p><ul><li>节点层数至少为1。而大于1的节点层数，满足一个概率分布。</li><li>节点层数恰好等于1的概率为1-p。</li><li>节点层数大于等于2的概率为p，而节点层数恰好等于2的概率为p(1-p)。</li><li>节点层数大于等于3的概率为p2，而节点层数恰好等于3的概率为p2(1-p)。</li><li>节点层数大于等于4的概率为p3，而节点层数恰好等于4的概率为p3(1-p)。</li><li>……</li></ul><p>因此，一个节点的平均层数（也即包含的平均指针数目），计算如下：</p><p><img src="7.jpg" alt="skiplist平均层数计算"></p><p>现在很容易计算出：</p><ul><li>当p=1/2时，每个节点所包含的平均指针数目为2；</li><li>当p=1/4时，每个节点所包含的平均指针数目为1.33。这也是Redis里的skiplist实现在空间上的开销。</li></ul><p>接下来，为了分析时间复杂度，我们计算一下skiplist的平均查找长度。查找长度指的是查找路径上跨越的跳数，而查找过程中的比较次数就等于查找长度加1。以前面图中标出的查找23的查找路径为例，从左上角的头结点开始，一直到结点22，查找长度为6。</p><p>为了计算查找长度，这里我们需要利用一点小技巧。我们注意到，每个节点插入的时候，它的层数是由随机函数randomLevel()计算出来的，而且随机的计算不依赖于其它节点，每次插入过程都是完全独立的。所以，从统计上来说，一个skiplist结构的形成与节点的插入顺序无关。</p><p>这样的话，为了计算查找长度，我们可以将查找过程倒过来看，从右下方第1层上最后到达的那个节点开始，沿着查找路径向左向上回溯，类似于爬楼梯的过程。我们假设当回溯到某个节点的时候，它才被插入，这虽然相当于改变了节点的插入顺序，但从统计上不影响整个skiplist的形成结构。</p><p>现在假设我们从一个层数为i的节点x出发，需要向左向上攀爬k层。这时我们有两种可能：</p><ul><li>如果节点x有第(i+1)层指针，那么我们需要向上走。这种情况概率为p。</li><li>如果节点x没有第(i+1)层指针，那么我们需要向左走。这种情况概率为(1-p)。</li></ul><p>这两种情形如下图所示：</p><p><img src="8.jpg" alt="skiplist沿查找路径回溯"></p><p>用C(k)表示向上攀爬k个层级所需要走过的平均查找路径长度（概率期望），那么：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">C</span><span class="params">(<span class="number">0</span>)</span></span>=<span class="number">0</span></span><br><span class="line"><span class="function"><span class="title">C</span><span class="params">(k)</span></span>=(<span class="number">1</span>-p)×(上图中情况b的查找长度) + p×(上图中情况c的查找长度)</span><br></pre></td></tr></table></figure><p>代入，得到一个差分方程并化简：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C(<span class="name">k</span>)=(<span class="number">1</span>-p)(<span class="name">C</span>(<span class="name">k</span>)<span class="number">+1</span>) + p(<span class="name">C</span>(<span class="name">k-1</span>)<span class="number">+1</span>)</span><br><span class="line">C(<span class="name">k</span>)=1/p+C(<span class="name">k-1</span>)</span><br><span class="line">C(<span class="name">k</span>)=k/p</span><br></pre></td></tr></table></figure><p>这个结果的意思是，我们每爬升1个层级，需要在查找路径上走1/p步。而我们总共需要攀爬的层级数等于整个skiplist的总层数-1。</p><p>那么接下来我们需要分析一下当skiplist中有n个节点的时候，它的总层数的概率均值是多少。这个问题直观上比较好理解。根据节点的层数随机算法，容易得出：</p><ul><li>第1层链表固定有n个节点；</li><li>第2层链表平均有n*p个节点；</li><li>第3层链表平均有n*p2个节点；</li><li>…</li></ul><p>所以，从第1层到最高层，各层链表的平均节点数是一个指数递减的等比数列。容易推算出，总层数的均值为log1/pn，而最高层的平均节点数为1/p。</p><p>综上，粗略来计算的话，平均查找长度约等于：</p><ul><li>C(log1/pn-1)=(log1/pn-1)/p</li></ul><p>即，平均时间复杂度为O(log n)。</p><p>当然，这里的时间复杂度分析还是比较粗略的。比如，沿着查找路径向左向上回溯的时候，可能先到达左侧头结点，然后沿头结点一路向上；还可能先到达最高层的节点，然后沿着最高层链表一路向左。但这些细节不影响平均时间复杂度的最后结果。另外，这里给出的时间复杂度只是一个概率平均值，但实际上计算一个精细的概率分布也是有可能的。详情还请参见<a href="https://en.wikipedia.org/wiki/William_Pugh" target="_blank" rel="noopener">William Pugh</a>的论文《<a href="ftp://ftp.cs.umd.edu/pub/skipLists/skiplists.pdf" target="_blank" rel="noopener">Skip Lists: A Probabilistic Alternative to Balanced Trees</a>》。</p><h3 id="skiplist与平衡树、哈希表的比较"><a href="#skiplist与平衡树、哈希表的比较" class="headerlink" title="skiplist与平衡树、哈希表的比较"></a>skiplist与平衡树、哈希表的比较</h3><ul><li><code>skiplist</code>和各种平衡树（如<strong>AVL</strong>、<strong>红黑树</strong>等）的元素是有序排列的，而哈希表不是有序的。因此，<strong>在哈希表上只能做单个key的查找，不适宜做范围查找。</strong>所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。</li><li>在做范围查找的时候，<strong>平衡树比skiplist操作要复杂</strong>。在平衡树上，我们找到指定范围的小值之后，还需要以<strong>中序遍历</strong>的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在<code>skiplist</code>上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。</li><li>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而<code>skiplist</code>的插入和删除只需要修改相邻节点的指针，操作简单又快速。</li><li>从内存占用上来说，<code>skiplist</code>比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</li><li>查找单个key，<strong>skiplist和平衡树的时间复杂度都为O(log n)</strong>，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。</li><li>从算法实现难度上来比较，skiplist比平衡树要简单得多。</li></ul><h2 id="Redis中的skiplist实现"><a href="#Redis中的skiplist实现" class="headerlink" title="Redis中的skiplist实现"></a>Redis中的skiplist实现</h2><p>在这一部分，我们讨论<code>Redis</code>中的<code>skiplist</code>实现。</p><p>在Redis中，skiplist被用于实现暴露给外部的一个数据结构：<strong>sorted set</strong>。准确地说，<strong>sorted set底层不仅仅使用了skiplist，还使用了ziplist和dict。</strong>这几个数据结构的关系，我们下一章再讨论。现在，我们先花点时间把sorted set的关键命令看一下。这些命令对于Redis里skiplist的实现，有重要的影响。</p><h3 id="sorted-set的命令举例"><a href="#sorted-set的命令举例" class="headerlink" title="sorted set的命令举例"></a>sorted set的命令举例</h3><p><strong>sorted set是一个有序的数据集合，对于像类似排行榜这样的应用场景特别适合。</strong></p><p>现在我们来看一个例子，用sorted set来存储代数课（algebra）的成绩表。原始数据如下：</p><ul><li>Alice 87.5</li><li>Bob 89.0</li><li>Charles 65.5</li><li>David 78.0</li><li>Emily 93.5</li><li>Fred 87.5</li></ul><p>这份数据给出了每位同学的名字和分数。下面我们将这份数据存储到sorted set里面去：</p><p>[<img src="8.jpg" alt="sorted set命令举例"></p><p>对于上面的这些命令，我们需要的注意的地方包括：</p><ul><li>前面的6个<code>zadd</code>命令，将6位同学的名字和分数(<code>score</code>)都输入到一个key值为algebra的sorted set里面了。注意Alice和Fred的分数相同，都是87.5分。</li><li><code>zrevrank</code>命令查询Alice的排名（命令中的rev表示<strong>按照倒序排列</strong>，也就是从大到小），返回3。排在Alice前面的分别是Emily、Bob、Fred，而排名(rank)从0开始计数，所以Alice的排名是3。注意，其实Alice和Fred的分数相同，这种情况下sorted set会把分数相同的元素，按照字典顺序来排列。按照倒序，Fred排在了Alice的前面。</li><li><code>zscore</code>命令查询了Charles对应的分数。</li><li><code>zrevrange</code>命令查询了从大到小排名为0~3的4位同学。</li><li><code>zrevrangebyscore</code>命令查询了分数在80.0和90.0之间的所有同学，并按分数从大到小排列。</li></ul><p>总结一下，<code>sorted set</code>中的每个元素主要表现出3个属性：</p><ul><li>数据本身（在前面的例子中我们把名字存成了数据）。</li><li>每个数据对应一个分数(score)。</li><li>根据分数大小和数据本身的字典排序，每个数据会产生一个排名(rank)。可以<strong>按正序或倒序。</strong></li></ul><h3 id="Redis中skiplist实现的特殊性"><a href="#Redis中skiplist实现的特殊性" class="headerlink" title="Redis中skiplist实现的特殊性"></a>Redis中skiplist实现的特殊性</h3><p>我们简单分析一下前面出现的几个查询命令：</p><ul><li>zrevrank由数据查询它对应的排名，这在前面介绍的skiplist中并不支持。</li><li>zscore由数据查询它对应的分数，这也不是skiplist所支持的。</li><li>zrevrange根据一个排名范围，查询排名在这个范围内的数据。这在前面介绍的skiplist中也不支持。</li><li>zrevrangebyscore根据分数区间查询数据集合，是一个skiplist所支持的典型的范围查找（score相当于key）。</li></ul><p>实际上，Redis中sorted set的实现是这样的：</p><ul><li>当数据较少时，sorted set是由一个<code>ziplist</code>来实现的。</li><li>当数据多的时候，sorted set是由<code>一个dict + 一个skiplist</code>来实现的。简单来讲，<strong>dict用来查询数据到分数的对应关系，而skiplist用来根据分数查询数据（可能是范围查找）。</strong></li></ul><p>这里sorted set的构成我们在下一章还会再详细地讨论。现在我们集中精力来看一下sorted set与skiplist的关系，：</p><ul><li>zscore的查询，不是由skiplist来提供的，而是由那个dict来提供的。</li><li>为了支持排名(rank)，Redis里对skiplist做了扩展，使得根据排名能够快速查到数据，或者根据分数查到数据之后，也同时很容易获得排名。而且，根据排名的查找，时间复杂度也为O(log n)。</li><li>zrevrange的查询，是根据排名查数据，由扩展后的skiplist来提供。</li><li>zrevrank是先在dict中由数据查到分数，再拿分数到skiplist中去查找，查到后也同时获得了排名。</li></ul><p>前述的查询过程，也暗示了各个操作的时间复杂度：</p><ul><li>zscore只用查询一个dict，所以时间复杂度为O(1)</li><li>zrevrank, zrevrange, zrevrangebyscore由于要查询skiplist，所以zrevrank的时间复杂度为O(log n)，而zrevrange, zrevrangebyscore的时间复杂度为O(log(n)+M)，其中M是当前查询返回的元素个数。</li></ul><p>总结起来，Redis中的skiplist跟前面介绍的经典的skiplist相比，有如下不同：</p><ul><li>分数(score)允许重复，<strong>即skiplist的key允许重复</strong>。这在最开始介绍的经典skiplist中是不允许的。</li><li>在比较时，不仅比较分数（相当于skiplist的key），还比较数据本身。在Redis的skiplist实现中，数据本身的内容唯一标识这份数据，而不是由key来唯一标识。另外，<strong>当多个元素分数相同的时候，还需要根据数据内容来进字典排序。</strong></li><li>第1层链表不是一个单向链表，而是一个<strong>双向链表</strong>。这是为了方便<strong>以倒序方式获取一个范围内的元素。</strong></li><li>在skiplist中可以很方便地计算出每个元素的排名(rank)。</li></ul><h4 id="skiplist的数据结构定义"><a href="#skiplist的数据结构定义" class="headerlink" title="skiplist的数据结构定义"></a>skiplist的数据结构定义</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_MAXLEVEL 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_P 0.25</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><p>这段代码出自server.h，我们来简要分析一下：</p><ul><li>开头定义了两个常量，ZSKIPLIST_MAXLEVEL和ZSKIPLIST_P，分别对应我们前面讲到的skiplist的两个参数：一个是MaxLevel，一个是p。</li><li>zskiplistNode定义了skiplist的节点结构。<ul><li>obj字段存放的是节点数据，它的类型是一个string robj。本来一个string robj可能存放的不是sds，而是long型，但zadd命令在将数据插入到skiplist里面之前先进行了解码，所以这里的obj字段里存储的一定是一个sds。有关robj的详情可以参见系列文章的第三篇：《<a href="http://zhangtielei.com/posts/blog-redis-robj.html" target="_blank" rel="noopener">Redis内部数据结构详解(3)——robj</a>》。这样做的目的应该是为了方便在查找的时候对数据进行字典序的比较，而且，skiplist里的数据部分是数字的可能性也比较小。</li><li>score字段是数据对应的分数。</li><li>backward字段是指向链表前一个节点的指针（前向指针）。节点只有1个前向指针，所以只有第1层链表是一个双向链表。</li><li>level[]存放指向各层链表后一个节点的指针（后向指针）。每层对应1个后向指针，用forward字段表示。另外，每个后向指针还对应了一个span值，它表示当前的指针跨越了多少个节点。span用于计算元素排名(rank)，这正是前面我们提到的Redis对于skiplist所做的一个扩展。需要注意的是，level[]是一个柔性数组（<a href="https://en.wikipedia.org/wiki/Flexible_array_member" target="_blank" rel="noopener">flexible array member</a>），因此它占用的内存不在zskiplistNode结构里面，而需要插入节点的时候单独为它分配。也正因为如此，skiplist的每个节点所包含的指针数目才是不固定的，我们前面分析过的结论——skiplist每个节点包含的指针数目平均为1/(1-p)——才能有意义。</li></ul></li><li>zskiplist定义了真正的skiplist结构，它包含：<ul><li>头指针header和尾指针tail。</li><li>链表长度length，即链表包含的节点总数。注意，新创建的skiplist包含一个空的头指针，这个头指针不包含在length计数中。</li><li>level表示skiplist的总层数，即所有节点层数的最大值。</li></ul></li></ul><p>下图以前面插入的代数课成绩表为例，展示了Redis中一个skiplist的可能结构：</p><p><img src="9.jpg" alt="Redis skiplist结构举例"></p><p>注意：图中前向指针上面括号中的数字，表示对应的span的值。即当前指针跨越了多少个节点，这个计数不包括指针的起点节点，但包括指针的终点节点。</p><p>假设我们在这个skiplist中查找score=89.0的元素（即Bob的成绩数据），在查找路径中，我们会跨域图中标红的指针，这些指针上面的span值累加起来，就得到了Bob的排名(2+2+1)-1=4（减1是因为rank值以0起始）。需要注意这里算的是从小到大的排名，而如果要算从大到小的排名，只需要用skiplist长度减去查找路径上的span累加值，即6-(2+2+1)=1。</p><p>可见，在查找skiplist的过程中，通过累加span值的方式，我们就能很容易算出排名。相反，如果指定排名来查找数据（类似zrange和zrevrange那样），也可以不断累加span并时刻保持累加值不超过指定的排名，通过这种方式就能得到一条O(log n)的查找路径。</p><h2 id="Redis中的sorted-set"><a href="#Redis中的sorted-set" class="headerlink" title="Redis中的sorted set"></a>Redis中的sorted set</h2><p>我们前面提到过，Redis中的sorted set，是在<strong>skiplist, dict和ziplist</strong>基础上构建起来的:</p><ul><li>当数据较少时，sorted set是由一个<code>ziplist</code>来实现的。</li><li>当数据多的时候，sorted set是由一个叫zset的数据结构来实现的，这个zset包含一个<code>dict + 一个skiplist</code>。<strong>dict用来查询数据到分数(score)的对应关系，而skiplist用来根据分数查询数据（可能是范围查找）。</strong></li></ul><p>在这里我们先来讨论一下前一种情况——基于ziplist实现的sorted set。在本系列前面<a href="http://zhangtielei.com/posts/blog-redis-ziplist.html" target="_blank" rel="noopener">关于ziplist的文章</a>里，我们介绍过，<strong>ziplist就是由很多数据项组成的一大块连续内存</strong>。由于sorted set的每一项元素都由数据和score组成，因此，<strong>当使用zadd命令插入一个(数据, score)对的时候，底层在相应的ziplist上就插入两个数据项：数据在前，score在后。</strong></p><p><strong>ziplist的主要优点是节省内存</strong>，但它上面的查找操作只能<strong>按顺序查找</strong>（可以正序也可以倒序）。因此，sorted set的各个查询操作，就是在ziplist上从前向后（或从后向前）一步步查找，每一步前进两个数据项，跨域一个(数据, score)对。</p><p>随着数据的插入，sorted set底层的这个ziplist就可能会转成zset的实现（转换过程详见t_zset.c的zsetConvert）。那么到底插入多少才会转呢？</p><p>还记得本文开头提到的两个Redis配置吗？</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zset-<span class="built_in">max</span>-ziplist-entries <span class="number">128</span></span><br><span class="line">zset-<span class="built_in">max</span>-ziplist-<span class="built_in">value</span> <span class="number">64</span></span><br></pre></td></tr></table></figure><p>这个配置的意思是说，在如下两个条件之一满足的时候，ziplist会转成zset（具体的触发条件参见t_zset.c中的zaddGenericCommand相关代码）：</p><ul><li>当sorted set中的元素个数，即(数据, score)对的数目超过128的时候，<strong>也就是ziplist数据项超过256的时候。</strong></li><li>当sorted set中插入的任意一个数据的长度超过了64的时候。</li></ul><p>最后，zset结构的代码定义如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zset &#123;</span><br><span class="line">    <span class="keyword">dict </span>*<span class="keyword">dict;</span></span><br><span class="line"><span class="keyword"> </span>   zskiplist *zsl<span class="comment">;</span></span><br><span class="line">&#125; zset<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="Redis为什么用skiplist而不用平衡树？"><a href="#Redis为什么用skiplist而不用平衡树？" class="headerlink" title="Redis为什么用skiplist而不用平衡树？"></a>Redis为什么用skiplist而不用平衡树？</h3><p>在前面我们对于skiplist和平衡树、哈希表的比较中，其实已经不难看出Redis里使用skiplist而不用平衡树的原因了。现在我们看看，对于这个问题，Redis的作者 @antirez 是怎么说的：</p><blockquote><p>There are a few reasons:</p><p>1) They are not very memory intensive. It’s up to you basically. Changing parameters about the probability of a node to have a given number of levels will make then less memory intensive than btrees.</p><p>2) A sorted set is often target of many ZRANGE or ZREVRANGE operations, that is, traversing the skip list as a linked list. With this operation the cache locality of skip lists is at least as good as with other kind of balanced trees.</p><p>3) They are simpler to implement, debug, and so forth. For instance thanks to the skip list simplicity I received a patch (already in Redis master) with augmented skip lists implementing ZRANK in O(log(N)). It required little changes to the code.</p></blockquote><p>这段话原文出处：</p><blockquote><p><a href="https://news.ycombinator.com/item?id=1171423" target="_blank" rel="noopener">https://news.ycombinator.com/item?id=1171423</a></p></blockquote><p>这里从内存占用、对范围查找的支持和实现难易程度这三方面总结的原因，我们在前面其实也都涉及到了。</p><hr><p>系列下一篇我们将介绍intset，以及它与Redis对外暴露的数据类型set的关系，敬请期待。</p><p><strong>其它精选文章</strong>：</p><ul><li><a href="http://zhangtielei.com/posts/blog-redis-quicklist.html" target="_blank" rel="noopener">Redis内部数据结构详解(5)——quicklist</a></li><li><a href="http://zhangtielei.com/posts/blog-redis-ziplist.html" target="_blank" rel="noopener">Redis内部数据结构详解(4)——ziplist</a></li><li><a href="http://zhangtielei.com/posts/blog-redis-robj.html" target="_blank" rel="noopener">Redis内部数据结构详解(3)——robj</a></li><li><a href="http://zhangtielei.com/posts/blog-redis-sds.html" target="_blank" rel="noopener">Redis内部数据结构详解(2)——sds</a></li><li><a href="http://zhangtielei.com/posts/blog-redis-dict.html" target="_blank" rel="noopener">Redis内部数据结构详解(1)——dict</a></li><li><a href="http://zhangtielei.com/posts/blog-neural-nets.html" target="_blank" rel="noopener">你需要了解深度学习和神经网络这项技术吗？</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=2657261357&idx=1&sn=ebb11a1623e00ca8e6ad55c9ad6b2547#rd" target="_blank" rel="noopener">技术的正宗与野路子</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=2657261385&idx=1&sn=56b335b4f33546c5baa41a1c7f1b6551#rd" target="_blank" rel="noopener">论人生之转折</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=2657261372&idx=1&sn=89c5b0fa1e9e339ee220d0c30001d01a#rd" target="_blank" rel="noopener">编程世界的熵增原理</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=2657261350&idx=1&sn=6cea730ef5a144ac243f07019fb43076#rd" target="_blank" rel="noopener">Android端外推送到底有多烦？</a></li><li><a href="http://zhangtielei.com/posts/blog-series-async-task-4.html" target="_blank" rel="noopener">Android和iOS开发中的异步处理（四）——异步任务和队列</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=2657261255&idx=1&sn=01ab92edada77803fc4ab7a575453d97&scene=19#wechat_redirect" target="_blank" rel="noopener">用树型模型管理App数字和红点提示</a></li></ul><p><strong>原创文章，转载请注明出处，并包含下面的二维码！否则拒绝转载！</strong><br><a href="http://zhangtielei.com/posts/blog-redis-skiplist.html" target="_blank" rel="noopener">http://zhangtielei.com/posts/blog-redis-skiplist.html</a></p><p><img src="10.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是《&lt;a href=&quot;http://zhangtielei.com/posts/blog-redis-dict.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Redis内部数据结构详解&lt;/a&gt;》系列的第六篇。在本文中，我们围绕一个&lt;code&gt;Redis&lt;/code&gt;的内部数据结构——&lt;strong&gt;skiplist&lt;/strong&gt;展开讨论。&lt;/p&gt;
&lt;p&gt;Redis里面使用skiplist是为了实现&lt;code&gt;sorted set&lt;/code&gt;这种对外的数据结构。&lt;code&gt;sorted set&lt;/code&gt;提供的操作非常丰富，可以满足非常多的应用场景。这也意味着，sorted set相对来说实现比较复杂。同时，&lt;code&gt;skiplist&lt;/code&gt;这种数据结构对于很多人来说都比较陌生，因为大部分学校里的算法课都没有对这种数据结构进行过详细的介绍。因此，为了介绍得足够清楚，本文会比这个系列的其它几篇花费更多的篇幅。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://changsk.top/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://changsk.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>BitMap对海量无重复的整数排序</title>
    <link href="http://changsk.top/2019/06/26/bitmap/"/>
    <id>http://changsk.top/2019/06/26/bitmap/</id>
    <published>2019-06-26T12:28:52.000Z</published>
    <updated>2019-06-26T12:40:53.973Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载自：<a href="https://blog.csdn.net/tkzc_csk/article/details/88661393" target="_blank" rel="noopener">bitmap对海量无重复的整数排序</a></p></blockquote><p>现在有n个<strong>无重复</strong>的正整数（n 小于10的7次方），如果内存限制在<code>1.5M</code>以内，要求对着n个数进行排序。【编程珠玑第一章题目】</p><blockquote><p>很显然，10的7次方个整数占用的空间为10 ^ 7 * 4字节，大约等于40M，而内存限制为1.5M，因此，无法将所有数字加载到内存，所以快速排序、堆排序等高效的排序算法就没法使用。这里可以使用bitmap方式，用1bit表示一个整数，那么，10^7个整数需要10^7位，也就是大约1.25M空间。</p></blockquote><p>如下是bitmap对无重复整数的排序过程。</p><a id="more"></a><h1 id="一次bitmap就可以将所有数据排完"><a href="#一次bitmap就可以将所有数据排完" class="headerlink" title="一次bitmap就可以将所有数据排完"></a>一次bitmap就可以将所有数据排完</h1><p>如果每个整数占一位，可以将所有的整数在内存中表示（如上述提到的那样），那么可以直接一次bitmap排序就完成了，<strong>时间复杂度为O(n)，空间复杂度为O(n位)</strong>。下面分别给出<code>C</code>和<code>C++</code>的bitset方式：</p><h2 id="C语言方式"><a href="#C语言方式" class="headerlink" title="C语言方式"></a>C语言方式</h2><blockquote><p>下面代码以n = 100为例子；n是海量时，只要每个整数1bit可以一次在内存中表示所有整数的情况下，方法一样，将宏定义N的值改为海量数据的上限（比如10^7）即可：</p></blockquote><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位图排序</span></span><br><span class="line"><span class="meta">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#include &lt;bitset&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDTHWORD 32 //一个整数的宽度是32bit</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHIFT 5      </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MASK 0x1F    //0x1f == 31</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100        //对100个无重复的整数排序</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//申请一个N位的bitmap</span></span><br><span class="line"><span class="keyword">int</span> bitmap[<span class="number">1</span> + N / WIDTHWORD];</span><br><span class="line"> </span><br><span class="line"><span class="comment">//将bitmap的第value设置为1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">bitmap[<span class="keyword">value</span> &gt;&gt; SHIFT] |= (<span class="number">1</span> &lt;&lt; (<span class="keyword">value</span> &amp; MASK));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//清除bitmap第value位上的1:设置为0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">bitmap[<span class="keyword">value</span> &gt;&gt; SHIFT] &amp;= ~(<span class="number">1</span> &lt;&lt; (<span class="keyword">value</span> &amp; MASK));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//测试bitmap第value位是否为1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> bitmap[<span class="keyword">value</span> &gt;&gt; SHIFT] &amp; (<span class="number">1</span> &lt;&lt; (<span class="keyword">value</span> &amp; MASK));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">12</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">89</span>, <span class="number">64</span>, <span class="number">49</span>, <span class="number">77</span>, <span class="number">91</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">32</span>, <span class="number">50</span>, <span class="number">99</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//将bitmap所有位设置为0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">clear(i);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//bitmap中将待排序数组中值所在的位设置为1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line"><span class="keyword">set</span>(a[i]);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//输出排序后的结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (test(i))</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码中：<br>N表示待排序整数的上限，例如本题要求的10^7。那么申请一个N位大小的bitmap：</p><p><code>int bitmap[1 + N / WIDTHWORD];</code><br>设置、清除、测试函数的含义可以参考文章：<a href="http://blog.163.com/xb_stone_yinyang/blog/static/2118160372013625112558579/，" target="_blank" rel="noopener">http://blog.163.com/xb_stone_yinyang/blog/static/2118160372013625112558579/，</a><br>下面给出这几个函数的简要解释：</p><ul><li>对于一个整数value，要将其对应到bitmap中的第value位，如果设置第value位为1呢？</li></ul><p>看设置函数：<code>value &gt;&gt; SHIFT 是找到value在bitmap中对应的是第几个int型数的位置</code>，例如整数100，它对应的是int数组（也就是bitmap）的第 100 &gt;&gt; 5 == 100 / 32 == 3个int型的位置（从0开始计数，每个int型占据32位）；<code>然后再在int数组（也就是bitmap）的第3个位置中寻找需要将第几位设置为1</code>： 1 &lt;&lt; (value &amp; 0x1f) == 1 &lt;&lt; 100 &amp; 31 == 1 &lt;&lt; 4，即要将1左移四位就是要设置为1的那一位；bitmap[value &gt;&gt; SHIFT] |= (1 &lt;&lt; (value &amp; MASK)); 最终完成将bitmap的第100位设置为1。</p><ul><li>对于一个整数value，如何将其对应到bitmap中的那位的上的1清除掉呢？</li></ul><p>看清除函数，和设置函数一样，value &gt;&gt; SHIFT 是找到value在bitmap中对应的是第几个整型的位置；然后，1 &lt;&lt; (value &amp; 0x1f)在找到的那个整型的位置中判断要将该字节的哪一位设置为0；bitmap[value &gt;&gt; SHIFT] &amp;= ~(1 &lt;&lt; (value &amp; MASK));完成最终清除工作。</p><ul><li>对于一个整数value，如何测试在bitmap中是否包含该数，也就是bitmap中第value位上是否为1？</li></ul><p>也是先找到value对应bitmap中第几个整型位置，然后在该位置中找到对应的位，再看该位上是否为1，为1表示bitmap中包含value。</p><p>程序排序结果：<br><img src="1.jpg" alt="在这里插入图片描述"></p><h2 id="使用C-的bitset"><a href="#使用C-的bitset" class="headerlink" title="使用C++的bitset"></a>使用C++的bitset</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> a[] = &#123;<span class="number">12</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">89</span>, <span class="number">64</span>, <span class="number">49</span>, <span class="number">77</span>, <span class="number">91</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">32</span>, <span class="number">50</span>, <span class="number">99</span>&#125;;</span><br><span class="line">       <span class="keyword">int</span> length = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">       <span class="comment">//直接使用C++bitset，申请Nbit的空间，每一位均设置为0</span></span><br><span class="line">       <span class="built_in">bitset</span>&lt;N&gt; bitmap; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">       <span class="comment">//遍历待排序数组，将bitmap中对应位设置为1</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">            bitmap.<span class="built_in">set</span>(a[i], <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">       <span class="comment">//输入排序结果</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bitmap[i])</span><br><span class="line">               <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="需要多次bitmap排序"><a href="#需要多次bitmap排序" class="headerlink" title="需要多次bitmap排序"></a>需要多次bitmap排序</h1><blockquote><p>如果上限N更大或者进一步限制内存大小（例如，将内存限制在0.5M之内），那么一次bitmap就不能将所有数据排序。需要多次bitmap排序。</p><p>例如上面排序小于100的一些数，我们上面的一次bitmap，是申请100位的bitmap；但是，如果限制我们只能使用30位bitmap，那么就需要排序100 / 30 + 1次：第一次排序0 ~ 29之间的数，第二次排序30 ~ 59之间的数，第三次排序60 ~ 89之间的数，第四次排序90 ~ 100之间的数。如果是k次bitmap排序，那么时间复杂度为O(kn)，空间开销为O(n / k 位).</p></blockquote><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">下面只给出C++方式，C方式类似：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">int main() &#123;</span><br><span class="line">      int a[] = &#123;<span class="number">12</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">89</span>, <span class="number">64</span>, <span class="number">49</span>, <span class="number">77</span>, <span class="number">91</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">32</span>, <span class="number">50</span>, <span class="number">99</span>&#125;;</span><br><span class="line">      int length = sizeof(a) / sizeof(int);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//假设还是有小于100的不重复整数需要排序，但是</span></span><br><span class="line">      <span class="comment">//不能申请100位空间，只能申请30位空间，那么，需要</span></span><br><span class="line">      <span class="comment">//排序的次数如下：</span></span><br><span class="line">      int sort_times = N / <span class="number">30</span> + <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">      <span class="comment">//那么，第一趟先排序0-29，第二趟排序30-59，</span></span><br><span class="line">      <span class="comment">//第三趟排序60-89，第四趟排序剩下的</span></span><br><span class="line">      bitset&lt;<span class="number">30</span>&gt; bitmap;             <span class="comment">//只能申请30位的bitmap</span></span><br><span class="line">      for (int times = <span class="number">0</span>; times &lt; sort_times; ++times) &#123;   <span class="comment">//一共进行四趟排序</span></span><br><span class="line">           bitmap.reset();                             <span class="comment">//记得每次排序前将bitmap清空为0</span></span><br><span class="line">           for (int i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                  if (a[i] &gt;= <span class="number">30</span> * times &amp;&amp; a[i] &lt; <span class="number">30</span> * (times + <span class="number">1</span>))  </span><br><span class="line">                         bitmap.set(a[i] - <span class="number">30</span> * times);</span><br><span class="line">           &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">           for (int i = <span class="number">0</span>; i &lt; <span class="number">30</span>; ++i) &#123;</span><br><span class="line">                if (bitmap[i])</span><br><span class="line">                      cout &lt;&lt; i + <span class="number">30</span> * times &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">           &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="如果每个整数最多出现m次，如何排序"><a href="#如果每个整数最多出现m次，如何排序" class="headerlink" title="如果每个整数最多出现m次，如何排序?"></a>如果每个整数最多出现m次，如何排序?</h1><p>上述两部分讨论的是如果整数是不重复时的排序，那么，如果海量整数，每个整数<strong>允许重复</strong>，但是重复次数不超过m（例如m == 10），如何排序？<br>方法：如果每个整数重复出现次数不超过10次，那么，可以用4位表示一个整数，<strong>用这四位统计该数出现次数</strong>，然后排序后输出该数时，输出m次即可。</p><h1 id="除了排序，bitmap的其他用途"><a href="#除了排序，bitmap的其他用途" class="headerlink" title="除了排序，bitmap的其他用途"></a>除了排序，bitmap的其他用途</h1><p>如上，bitmap可以用于不重复正整数排序，那么，bitmap其他用途：<br>1、找出不重复数：<br><a href="https://blog.csdn.net/v_july_v/article/details/7382693" target="_blank" rel="noopener">在2.5亿个整数中找出不重复的整数，内存不足以容纳这2.5亿个整数。</a><br>2、判断某数是否存在于海量整数中：<br><a href="https://blog.csdn.net/v_july_v/article/details/7382693" target="_blank" rel="noopener">给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载自：&lt;a href=&quot;https://blog.csdn.net/tkzc_csk/article/details/88661393&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;bitmap对海量无重复的整数排序&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在有n个&lt;strong&gt;无重复&lt;/strong&gt;的正整数（n 小于10的7次方），如果内存限制在&lt;code&gt;1.5M&lt;/code&gt;以内，要求对着n个数进行排序。【编程珠玑第一章题目】&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;很显然，10的7次方个整数占用的空间为10 ^ 7 * 4字节，大约等于40M，而内存限制为1.5M，因此，无法将所有数字加载到内存，所以快速排序、堆排序等高效的排序算法就没法使用。这里可以使用bitmap方式，用1bit表示一个整数，那么，10^7个整数需要10^7位，也就是大约1.25M空间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如下是bitmap对无重复整数的排序过程。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://changsk.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="BitMap" scheme="http://changsk.top/tags/BitMap/"/>
    
  </entry>
  
  <entry>
    <title>java中创建实例对象的方式</title>
    <link href="http://changsk.top/2019/06/26/java-create-instance/"/>
    <id>http://changsk.top/2019/06/26/java-create-instance/</id>
    <published>2019-06-26T10:00:34.000Z</published>
    <updated>2019-06-26T10:08:53.262Z</updated>
    
    <content type="html"><![CDATA[<p>1、关键字 <strong>new</strong>。<strong>工厂模式</strong>是对这种方式的包装；</p><p>2、类实现克隆接口，克隆一个实例。<strong>原型模式</strong>是一个应用实例；</p><p>3、用该类的加载器，newInstance。<strong>java的反射</strong>，反射使用实例：Spring的依赖注入、切面编程中动态代理</p><p>4、sun.misc.Unsafe类，allocateInstance方法创建一个实例。（Java官方也不建议直接使用的Unsafe类，据说Oracle正在计划从Java 9中去掉Unsafe类）</p><p>5、实现序列化接口的类，通过IO流<strong>反序列化</strong>读取一个类，获得实例。</p><blockquote><p>参考：<br><a href="https://blog.csdn.net/lizhen54/article/details/74544801/" target="_blank" rel="noopener">Java创建类的实例的几种方法</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、关键字 &lt;strong&gt;new&lt;/strong&gt;。&lt;strong&gt;工厂模式&lt;/strong&gt;是对这种方式的包装；&lt;/p&gt;
&lt;p&gt;2、类实现克隆接口，克隆一个实例。&lt;strong&gt;原型模式&lt;/strong&gt;是一个应用实例；&lt;/p&gt;
&lt;p&gt;3、用该类的加载器，newInst
      
    
    </summary>
    
      <category term="Java" scheme="http://changsk.top/categories/Java/"/>
    
    
      <category term="java" scheme="http://changsk.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Redis中基本数据类型与内部存储结构</title>
    <link href="http://changsk.top/2019/06/26/redis-storage-structure/"/>
    <id>http://changsk.top/2019/06/26/redis-storage-structure/</id>
    <published>2019-06-26T08:04:44.000Z</published>
    <updated>2019-06-26T09:09:31.855Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="https://www.jianshu.com/p/f09480c05e42" target="_blank" rel="noopener">Redis-基本数据类型与内部存储结构</a></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><code>Redis</code>是典型的<code>Key-Value</code>类型数据库，<strong>Key为字符类型</strong>，<strong>Value的类型常用的为五种类型：String、Hash 、List 、 Set 、 Ordered Set</strong></p><a id="more"></a><h2 id="Redis内部内存管理"><a href="#Redis内部内存管理" class="headerlink" title="Redis内部内存管理"></a>Redis内部内存管理</h2><p><img src="1.jpg" alt="img"></p><h3 id="redisObject-核心对象"><a href="#redisObject-核心对象" class="headerlink" title="redisObject 核心对象"></a>redisObject 核心对象</h3><blockquote><p>Redis 内部使用一个 redisObject 对象来表示所有的 key 和 value。</p></blockquote><ol><li>type ：代表一个 value 对象具体是何种数据类型。</li><li>encoding ：是不同数据类型在 redis 内部的存储方式，比如：type=string 代表 value 存储的是一个普通字符串，那么对应的 encoding 可以是 raw 或者是 int，<strong>如果是 int 则代表实际 redis 内部是按数值型类存储和表示这个字符串的，当然前提是这个字符串本身可以用数值表示，比如：”123” “456”这样的字符串。</strong></li><li>vm 字段：只有打开了 Redis 的虚拟内存功能，此字段才会真正的分配内存，该功能默认是关闭状态的。 Redis 使用 redisObject 来表示所有的 key/value 数据是比较浪费内存的，当然这些内存管理成本的付出主要也是为了给 Redis 不同数据类型提供一个统一的管理接口，实际作者也提供了多种方法帮助我们尽量节省内存使用。</li></ol><h2 id="Key（键值）"><a href="#Key（键值）" class="headerlink" title="Key（键值）"></a>Key（键值）</h2><blockquote><p>官网Key链接：<a href="https://link.jianshu.com?t=https://redis.io/commands#generic" target="_blank" rel="noopener">https://redis.io/commands#generic</a></p></blockquote><h3 id="过期删除"><a href="#过期删除" class="headerlink" title="过期删除"></a>过期删除</h3><p>过期数据的清除从来不容易，为每一条key设置一个timer，到点立刻删除的消耗太大，每秒遍历所有数据消耗也大，<strong>Redis使用了一种相对务实的做法： 当client主动访问key会先对key进行超时判断，过时的key会立刻删除。 如果clien永远都不再get那条key呢？ 它会在Master的后台，每秒10次的执行如下操作： 随机选取100个key校验是否过期，如果有25个以上的key过期了，立刻额外随机选取下100个key(不计算在10次之内)。</strong>可见，如果过期的key不多，它最多每秒回收200条左右，如果有超过25%的key过期了，它就会做得更多，但只要key不被主动get，它占用的内存什么时候最终被清理掉只有天知道。</p><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><ol><li>Key的长度限制：<strong>Key的最大长度不能超过1024字节</strong>，在实际开发时不要超过这个长度，但是Key的命名不能太短，要能唯一标识缓存的对，作者建议<strong>按照在关系型数据库中的库表唯一标识字段的方式来命令Key的值，用分号分割不同数据域，用点号作为单词连接。</strong></li><li>Key的查询：<strong>Keys</strong>，返回匹配的key，支持通配符如 “<code>keys a*</code>” 、 “<code>keys a?c</code>”，<strong>但不建议在生产环境大数据量下使用</strong>。</li><li>对Key对应的Value进行的排序：<strong>Sort命令对集合按数字或字母顺序排序后返回或另存为list</strong>，还可以关联到外部key等。因为<em>复杂度是最高的O(N+Mlog(M))*</em>(N是集合大小，M 为返回元素的数量)，有时会安排到slave上执行。官网链接<a href="https://link.jianshu.com?t=https://redis.io/commands/sort" target="_blank" rel="noopener">https://redis.io/commands/sort</a></li><li>Key的超时操作：Expire（指定失效的秒数）/ExpireAt（指定失效的时间戳）/Persist（持久化）/TTL（返回还可存活的秒数），关于Key超时的操作。默认以秒为单位，也有p字头的以毫秒为单位的版本</li></ol><h2 id="String（字符串类型的Value）"><a href="#String（字符串类型的Value）" class="headerlink" title="String（字符串类型的Value）"></a>String（字符串类型的Value）</h2><blockquote><p>可以是String，也可是是任意的byte[]类型的数组，如图片等。<strong>String 在 redis 内部存储默认就是一个字符串，被 redisObject 所引用，当遇到 incr,decr 等操作时会转成数值型进行计算，此时 redisObject 的 encoding 字段为int。</strong><br> <a href="https://link.jianshu.com?t=https://redis.io/commands#string" target="_blank" rel="noopener">https://redis.io/commands#string</a></p></blockquote><ol><li>大小限制：最大为<strong>512Mb</strong>，基本可以<strong>存储任意图片</strong>啦。</li><li>常用命令的<strong>时间复杂度为O(1)，读写一样的快。</strong></li><li><strong>对String代表的数字进行增减操作</strong>（没有指定的Key则设置为0值，然后在进行操作）：Incr/IncrBy/IncrByFloat/Decr/DecrBy（原子性），** 可以用来做计数器，做自增序列，也可以用于限流，令牌桶计数等**。key不存在时会创建并贴心的设原值为0。IncrByFloat专门针对float。。</li><li>设置Value的安全性：SetNx命令仅当key不存在时才Set（原子性操作）。<strong>可以用来选举Master或做分布式锁：所有Client不断尝试使用SetNx master myName抢注Master，成功的那位不断使用Expire刷新它的过期时间。如果Master倒掉了key就会失效，剩下的节点又会发生新一轮抢夺。</strong>SetEx， Set + Expire 的简便写法，p字头版本以毫秒为单位。</li><li>获取：GetSet（原子性）， 设置新值，返回旧值。比如一个按小时计算的计数器，可以用GetSet获取计数并重置为0。这种指令在服务端做起来是举手之劳，客户端便方便很多。MGet/MSet/MSetNx， 一次get/set多个key。</li><li>其他操作：Append/SetRange/GetRange/StrLen，对文本进行扩展、替换、截取和求长度，只对特定数据格式如字段定长的有用，json就没什么用。</li><li>BitMap的用法：GetBit/SetBit/BitOp,与或非/BitCount， <strong>BitMap的玩法，比如统计今天的独立访问用户数时，每个注册用户都有一个offset，他今天进来的话就把他那个位设为1，用BitCount就可以得出今天的总人数</strong>。</li></ol><h2 id="Hash（HashMap，哈希映射表）"><a href="#Hash（HashMap，哈希映射表）" class="headerlink" title="Hash（HashMap，哈希映射表）"></a>Hash（HashMap，哈希映射表）</h2><blockquote><p>Redis 的 Hash 实际是内部存储的 Value 为一个 HashMap，并提供了直接存取这个 Map 成员的接口。Hash将对象的各个属性存入Map里，可以只读取/更新对象的某些属性。另外不同的模块可以只更新自己关心的属性而不会互相并发覆盖冲突。</p></blockquote><blockquote><p><img src="2.jpg" alt="img"></p></blockquote><blockquote><p> 不同程序通过 key（用户 ID） + field（属性标签）就可以并发操作各自关心的属性数据</p><p><a href="https://redis.io/commands#hash" target="_blank" rel="noopener">https://redis.io/commands#hash</a></p></blockquote><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>Redis Hash 对应 Value 内部实际就是一个 HashMap，实际这里会有2种不同实现，** 这个 Hash 的成员比较少时 Redis <strong>为了节省内存会采用类似一维数组的方式来紧凑存储</strong>，而不会采用真正的 HashMap 结构，对应的 value redisObject 的 encoding 为 <code>zipmap</code>，<strong>当成员数量增大时会自动转成真正的 HashMap</strong>，此时 encoding 为 ht**。一般操作复杂度是O(1)，要同时操作多个field时就是O(N)，N是field的数量。</p><h3 id="常用操作-1"><a href="#常用操作-1" class="headerlink" title="常用操作"></a>常用操作</h3><ol><li><p>O(1)操作：<strong>hget</strong>、<strong>hset</strong>等等</p></li><li><p>O(n)操作：<strong>hgetallRedis</strong> 可以直接取到全部的属性数据，但是如果内部 Map 的成员很多，那么涉及到遍历整个内部 Map 的操作，</p><p>由于 <strong>Redis 单线程模型</strong>的缘故，这个遍历操作可能会比较耗时，而另其它客户端的请求完全不响应，这点需要格外注意。</p></li></ol><p>   <img src="3.jpg" alt="img"></p><h2 id="List（双向链表）"><a href="#List（双向链表）" class="headerlink" title="List（双向链表）"></a>List（双向链表）</h2><blockquote><p>Redis list 的应用场景非常多，也是 Redis 最重要的数据结构之一，<strong>比如 twitter 的关注列表，粉丝列表等都可以用 Redis 的 list 结构来实现，还提供了生产者消费者阻塞模式（B开头的命令,block,表示阻塞），常用于任务队列，消息队列等</strong>。</p></blockquote><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>Redis list 的实现为一个<strong>双向链表</strong>，即可以支持<strong>反向查找和遍历</strong>，更方便操作，不过带来了部分额外的内存开销，Redis 内部的很多实现，包括<strong>发送缓冲队列等</strong>也都是用的这个数据结构。</p><h3 id="用作消息队列中防止数据丢失的解决方法"><a href="#用作消息队列中防止数据丢失的解决方法" class="headerlink" title="用作消息队列中防止数据丢失的解决方法"></a>用作消息队列中防止数据丢失的解决方法</h3><blockquote><p>如果消费者把job给Pop走了又没处理完就死机了怎么办？</p></blockquote><ol><li>消息生产者保证不丢失</li></ol><blockquote><p>加多一个sorted set，分发的时候同时发到list与sorted set，以分发时间为score，用户把job做完了之后要用ZREM消掉sorted set里的job，并且定时从sorted set中取出超时没有完成的任务，重新放回list。 如果发生重复可以在sorted set中在查询确认一遍，或者将消息的消费接口设计成幂等性。</p></blockquote><ol start="2"><li>消息消费者保证不丢失</li></ol><blockquote><p>为每个worker多加一个的list，弹出任务时改用RPopLPush，将job同时放到worker自己的list中，完成时用LREM消掉。如果集群管理(如zookeeper)发现worker已经挂掉，就将worker的list内容重新放回主list</p></blockquote><h3 id="常用操作-2"><a href="#常用操作-2" class="headerlink" title="常用操作"></a>常用操作</h3><ol><li><p>复合操作：RPopLPush/ BRPopLPush，弹出来返回给client的同时，把自己又推入另一个list，是原子操作。</p><blockquote><p><strong>RPUSH key value [value …]</strong></p><p>将一个或多个值 <code>value</code> 插入到列表 <code>key</code> 的表尾(最右边)。</p></blockquote><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> LRANGE KEY_NAME START END</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>Redis Lrange 返回列表中指定区间内的元素，区间以偏移量 START 和 END(从0开始) 指定。 其中 0 表示列表的第一个元素， 1 表示列表的第二个元素，以此类推。 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</p></blockquote></li></ol><p>   <img src="3.jpg" alt="img"></p><ol start="2"><li>按值进行的操作：<strong>LRem</strong>(按值删除元素)、<strong>LInsert</strong>(插在某个值的元素的前后)，<strong>复杂度是O(N)</strong>，N是List长度，因为List的值不唯一，所以要遍历全部元素，而Set只要O(log(N))。</li></ol><p>   <img src="4.jpg" alt="img"></p><ol start="3"><li>按下表进行操作（下标从0开始，队列从左到右算，下标为负数时则从右到左，-1为右端第一个元素）</li></ol><blockquote><p>时间复杂度为O(N)</p></blockquote><ul><li><p>LSet ：按下标设置元素值。（N为List的长度）</p></li><li><p>LIndex：按下标返回元素。（N为index的值）</p></li><li><p>LTrim：限制List的大小，保留指定范围的元素。（N是移除元素的个数）</p></li></ul><p>  <img src="5.jpg" alt="img"></p><ul><li>LRange：返回列表内指定范围下标的元素，常用于分页。（N = start+range）</li></ul><p>  <img src="6.jpg" alt="img"></p><h2 id="set（HashSet）"><a href="#set（HashSet）" class="headerlink" title="set（HashSet）"></a>set（HashSet）</h2><blockquote><p>Set就是HashSet，可以将重复的元素随便放入而Set会自动去重，底层实现也是HashMap，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。</p></blockquote><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p>set 的内部实现是一个 <strong>value 永远为 null 的 HashMap</strong>，实际就是通过计算 hash 的方式来快速排重的，这也是 set 能提供判断一个成员是否在集合内的原因。</p><h3 id="常用操作-3"><a href="#常用操作-3" class="headerlink" title="常用操作"></a>常用操作</h3><ol><li>增删改查：<code>SAdd/SRem/SIsMember/SCard/SMove/SMembers</code>等等。除了SMembers都是O(1)。</li><li>集合操作：<code>SInter/SInterStore/SUnion/SUnionStore/SDiff/SDiffStore</code>，各种集合操作。交集运算可以用来<strong>显示在线好友(在线用户 交集 好友列表)，共同关注(两个用户的关注列表的交集)</strong>。O(N)，并集和差集的N是集合大小之和，交集的N是小的那个集合的大小的2倍。</li></ol><h2 id="Sorted-Set（插入有序Set集合）"><a href="#Sorted-Set（插入有序Set集合）" class="headerlink" title="Sorted Set（插入有序Set集合）"></a>Sorted Set（插入有序Set集合）</h2><blockquote><p>set 不是自动有序的，而** sorted set 可以通过用户额外提供一个优先级（score）的参数来为成员排序<strong>，</strong>并且是插入有序的，即自动排序<strong>。当你需要一个有序的并且不重复的集合列表，那么可以选择 sorted set 数据结构，比如 twitter 的 public **timeline 可以以发表时间作为 score 来存储，这样获取时就是自动按时间排好序的</strong>。</p></blockquote><h3 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h3><blockquote><p><strong>内部使用 HashMap 和跳跃表（SkipList）来保证数据的存储和有序</strong></p></blockquote><p><code>Sorted Set</code>的实现是<strong>HashMap(element-&gt;score, 用于实现ZScore及判断element是否在集合内)，和SkipList(score-&gt;element,按score排序)的混合体</strong>。<code>SkipList有点像平衡二叉树那样，不同范围的score被分成一层一层，每层是一个按score排序的链表。</code></p><h3 id="常用操作-4"><a href="#常用操作-4" class="headerlink" title="常用操作"></a>常用操作</h3><blockquote><p>ZAdd/ZRem是O(log(N))；ZRangeByScore/ZRemRangeByScore是O(log(N)+M)，N是Set大小，M是结果/操作元素的个数。复杂度的log取对数很关键，可以使，1000万大小的Set，复杂度也只是几十不到。但是，如果一次命中很多元素M很大则复杂度很高。</p></blockquote><ol><li><code>ZRange/ZRevRange</code>，按排序结果的范围返回元素列表，可以为正数与倒数。</li><li><code>ZRangeByScore/ZRevRangeByScore</code>，按score的范围返回元素，可以为正数与倒数。</li><li><code>ZRemRangeByRank/ZRemRangeByScore</code>，按排序/按score的范围限删除元素。</li><li><code>ZCount</code>，统计按score的范围的元素个数。</li><li><code>ZRank/ZRevRank</code> ，显示某个元素的正/倒序的排名。</li><li><code>ZScore/ZIncrby</code>，显示元素的Score值/增加元素的Score。</li><li><code>ZAdd(Add)/ZRem(Remove)/ZCard(Count)</code>，ZInsertStore(交集)/ZUnionStore(并集)，与Set相比，少了IsMember和差集运算。</li></ol><h2 id="Redis使用与内存优化"><a href="#Redis使用与内存优化" class="headerlink" title="Redis使用与内存优化"></a>Redis使用与内存优化</h2><blockquote><p>上面的一些实现上的分析可以看出 redis 实际上的内存管理成本非常高，即占用了过多的内存，属于用<strong>空间换时间</strong>。作者对这点也非常清楚，所以提供了一系列的参数和手段来控制和节省内存</p></blockquote><h3 id="建议不要开启VM（虚拟内存）选项"><a href="#建议不要开启VM（虚拟内存）选项" class="headerlink" title="建议不要开启VM（虚拟内存）选项"></a>建议不要开启VM（虚拟内存）选项</h3><blockquote><p>VM 选项是作为 Redis 存储超出物理内存数据的一种数据在内存与磁盘换入换出的一个持久化策略，将严重地拖垮系统的运行速度，所以要关闭 VM 功能，请检查你的 redis.conf 文件中 vm-enabled 为 no。</p></blockquote><h3 id="设置最大内存选项"><a href="#设置最大内存选项" class="headerlink" title="设置最大内存选项"></a>设置最大内存选项</h3><p>最好设置下 redis.conf 中的 <code>maxmemory</code> 选项，该选项是告诉 Redis <strong>当使用了多少物理内存后就开始拒绝后续的写入请求</strong>，<strong>该参数能很好的保护好你的 Redis 不会因为使用了过多的物理内存而导致 swap，最终严重影响性能甚至崩溃。</strong></p><blockquote><p>一般还需要设置内存饱和回收策略</p></blockquote><ol><li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li>no-enviction（驱逐）：禁止驱逐数据</li></ol><h3 id="控制内存使用的参数"><a href="#控制内存使用的参数" class="headerlink" title="控制内存使用的参数"></a>控制内存使用的参数</h3><blockquote><p>Redis 为不同数据类型分别提供了一组参数来控制内存使用</p></blockquote><ol><li>Hash</li></ol><blockquote><p>redis.conf 配置文件中下面2项</p></blockquote><ul><li>*<em>hash-max-zipmap-entries 64 *</em></li></ul><blockquote><p>含义是当 value 这个 Map 内部不超过多少个成员时会采用<strong>线性紧凑格式</strong>存储，默认是64，即 <strong>value 内部有64个以下的成员就是使用线性紧凑存储zipmap，超过该值自动转成真正的 HashMap(ht)。</strong></p></blockquote><ul><li><strong>hash-max-zipmap-value 512</strong></li></ul><blockquote><p>hash-max-zipmap-value 含义是当 value 这个 Map 内部的每个成员值长度不超过<br> 多少字节就会采用线性紧凑存储zipmap来节省空间。</p></blockquote><p><strong>以上2个条件任意一个条件超过设置值都会转换成真正的 HashMap</strong>，也就不会再节省内存了，但是也不是越大越好（空间和查改效率需要根据实际情况来权衡）</p><ol start="2"><li>List</li></ol><blockquote></blockquote><ul><li><strong>list-max-ziplist-entries 512</strong><br>list 数据类型多少节点以下会采用去指针的紧凑存储格式ziplist</li><li><strong>list-max-ziplist-value 64</strong><br>list 数据类型节点值大小小于多少字节会采用紧凑存储格式ziplist。</li></ul><ol start="3"><li>Set</li></ol><blockquote></blockquote><ul><li><strong>set-max-intset-entries 512</strong><br>set 数据类型内部数据如果全部是数值型，且包含多少节点以下会采用紧凑格式存储</li></ul><h3 id="Redis内部的优化"><a href="#Redis内部的优化" class="headerlink" title="Redis内部的优化"></a>Redis内部的优化</h3><ol><li>Redis 内部实现没有对内存分配方面做过多的优化，在一定程度上会存在<strong>内存碎片</strong>，不过大多数情况下这个不会成为 Redis 的性能瓶颈。</li><li>Redis 缓存了<strong>一定范围的常量数字</strong>作为资源共享，在很多数据类型是数值型则能极大减少内存开销，默认为1-10000，可以重新编译配置修改源代码中的一行宏定义 <code>REDIS_SHARED_INTEGERS</code>。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>根据业务需要选择合适的数据类型，并为不同的应用场景<strong>设置相应的紧凑存储参数</strong>。</li><li><strong>当业务场景不需要数据持久化时，关闭所有的持久化方式可以获得最佳的性能以及最大的内存使用量。</strong></li><li>如果需要使用持久化，<strong>根据是否可以容忍重启丢失部分数据在快照方式与语句追加方式之间选择其一</strong>，不要使用虚拟内存以及 diskstore 方式。</li><li><strong>不要让你的 Redis 所在机器物理内存使用超过实际内存总量的3/5</strong>。</li></ol><blockquote><p>Redis 的持久化使用了 Buffer IO ，所谓 Buffer IO 是指 Redis 对持久化文件的写入和读取操作都会使用物理内存的 Page Cache，而当 Redis 的持久化文件过大操作系统会进行Swap，这时你的系统就会有内存还有余量但是系统不稳定或者崩溃的风险。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自：&lt;a href=&quot;https://www.jianshu.com/p/f09480c05e42&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Redis-基本数据类型与内部存储结构&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Redis&lt;/code&gt;是典型的&lt;code&gt;Key-Value&lt;/code&gt;类型数据库，&lt;strong&gt;Key为字符类型&lt;/strong&gt;，&lt;strong&gt;Value的类型常用的为五种类型：String、Hash 、List 、 Set 、 Ordered Set&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://changsk.top/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://changsk.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Nagle算法</title>
    <link href="http://changsk.top/2019/06/26/nagle/"/>
    <id>http://changsk.top/2019/06/26/nagle/</id>
    <published>2019-06-26T03:27:37.000Z</published>
    <updated>2019-06-26T03:44:50.969Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Nagle算法</strong>用于<code>对缓冲区内的一定数量的消息进行自动连接</code>。该处理过程(称为Nagling)，通过<code>减少必须发送的封包的数量</code>，提高了网络应用程序系统的效率。</p><a id="more"></a><h2 id="Nagle算法的规则"><a href="#Nagle算法的规则" class="headerlink" title="Nagle算法的规则"></a>Nagle算法的规则</h2><p>  （可参考<code>tcp_output.c</code>文件里<code>tcp_nagle_check</code>函数注释）：</p><ol><li><p>如果包长度达到<strong>MSS</strong>，则允许发送；</p><blockquote><p>MSS是最大分段大小Maxitum Segment Size ，TCP双方建立连接的时候可以协商<br>MTU是最大传输单元Maxitum Transmission Unit</p></blockquote></li><li><p>如果该包含有FIN，则允许发送；</p></li><li><p>设置了TCP_NODELAY选项，则允许发送；</p></li><li><p>未设置TCP_CORK选项时，若所有发出去的包均被确认，或所有发出去的小数据包(包长度小于MSS)均被确认，则允许发送。</p><blockquote><p>对于规则4，就是说一个TCP连接上最多只能有一个未被确认的小数据包，在该分组的确认到达之前，不能发送其他的小数据包。如果某个小分组的确认被延迟了，那么后续小分组的发送就会相应的延迟。也就是说延迟确认影响的并不只是被延迟确认的那个数据包，而是后续所有的应答包。</p></blockquote></li></ol><h2 id="Nagle算法的门槛"><a href="#Nagle算法的门槛" class="headerlink" title="Nagle算法的门槛"></a>Nagle算法的门槛</h2><p>实际上<code>Nagle</code>算法并不是很复杂，他的主要职责是<code>数据的累积</code>，实际上有三个门槛：</p><ol><li>缓冲区中的字节数达到了一定量；</li><li>等待了一定的时间（一般的Nagle算法都是等待200ms）；</li><li>紧急数据发送。</li></ol><p>这三个门槛的任何一个达到都必须发送数据了。一般情况下，如果数据流量很大，第二个条件是永远不会起作用的，但当发送小的数据包时，第二个门槛就发挥作用了，防止数据被无限的缓存在缓冲区不是好事情哦。 </p><h2 id="Nagle算法的选项配置"><a href="#Nagle算法的选项配置" class="headerlink" title="Nagle算法的选项配置"></a>Nagle算法的选项配置</h2><p><code>TCP_NODELAY</code>和<code>TCP_CORK</code>都是<strong>禁用Nagle算法</strong>，只不过<code>NODELAY</code>完全关闭而<code>TCP_CORK</code>完全由自己决定发送时机。<strong>Linux文档上说两者不要同时设置。</strong></p><h3 id="TCP-NODELAY-选项"><a href="#TCP-NODELAY-选项" class="headerlink" title="TCP_NODELAY 选项"></a>TCP_NODELAY 选项</h3><p>设置该选项: <code>setsockopt(s,IPPRO_TCP,TCP_NODELAY,(const char*)&amp;on,sizeof(int));</code><br>读取该选项: <code>getsockopt(s,IPPRO_TCP,TCP_NODELAY,(char*)&amp;on,&amp;optlen);</code></p><p>   默认情况下, 发送数据采用<code>Nagle 算法</code>。<strong>Nagle 算法是指发送方发送的数据不会立即发出,而是先放在缓冲区, 等缓存区满了再发出. 发送完一批数据后, 会等待接收方对这批数据的回应,然后再发送下一批数据。</strong> </p><blockquote><p>Nagle 算法适用于发送方需要发送大批量数据, 并且接收方会及时作出回应的场合, 这种算法通过减少传输数据的次数来提高通信效率。如果发送方持续地发送小批量的数据, 并且接收方不一定会立即发送响应数据, 那么Nagle算法会使发送方运行很慢。</p></blockquote><h3 id="TCP-CORK选项"><a href="#TCP-CORK选项" class="headerlink" title="TCP_CORK选项"></a>TCP_CORK选项</h3><p>   <code>TCP链接的过程中，默认开启Nagle算法</code>，进行<strong>小包发送的优化</strong>。优化网络传输，兼顾网络延时和网络拥塞。这个时候可以置位<code>TCP_NODELAY关闭Nagle算法</code>，<strong>有数据包的话直接发送保证网络时效性</strong>。</p><p> 在进行大量数据发送的时候可以<code>置位TCP_CORK关闭Nagle算法保证网络利用性</code>。尽可能的进行数据的组包，以最大mtu传输，如果发送的数据包大小过小则如果在0.6 到 0.8S范围内都没能组装成一个MTU时，直接发送。如果发送的数据包大小足够间隔在0.45内时，每次组装一个MTU进行发送。如果间隔大于0.4 到 0.8S则，每过来一个数据包就直接发送。</p><p>Nagle组织包的长度是由系统决定的，有时候我们知道我们会每个1分钟产生1字节，共1000字节。如果完全由Nagle算法来发送的话，可能还是会1字节1字节发送[这是一种极端情况，假设返回ACK时间不是很长]。这个时候首先设置TCP_CORK能够阻塞住TCP[尽量阻塞住]，等我们write完1000字节之后，取消TCP_CORK，这个时候就能够将1000字节一次发出。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>   <code>TCP_CORK</code>选项与<code>TCP_NODELAY</code>一样，是控制Nagle化的。      </p><ol><li>打开TCP_NODELAY选项，则意味着无论数据包是多么的小，都立即发送（不考虑拥塞窗口）。</li><li>如果将TCP连接比喻为一个管道，那TCP_CORK选项的作用就像一个塞子。            </li></ol><blockquote><p>设置TCP_CORK选项，就是用塞子塞住管道，而取消TCP_CORK选项，就是将塞子拔掉。<br>当TCP_CORK选项被设置时，TCP链接不会发送任何的小包，即只有当数据量达到MSS时，才会被发送。<br>一般当数据传输完成时，通常需要取消该选项，以防被塞住，这样才可以让不够MSS大小的包能及时发出去。</p></blockquote><blockquote><p>参考：<br><a href="https://blog.csdn.net/libinjlu/article/details/42366757" target="_blank" rel="noopener">Nagle算法–TCP缓冲区管理算法</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Nagle算法&lt;/strong&gt;用于&lt;code&gt;对缓冲区内的一定数量的消息进行自动连接&lt;/code&gt;。该处理过程(称为Nagling)，通过&lt;code&gt;减少必须发送的封包的数量&lt;/code&gt;，提高了网络应用程序系统的效率。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://changsk.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Nagle" scheme="http://changsk.top/tags/Nagle/"/>
    
  </entry>
  
  <entry>
    <title>为什么单线程的redis这么快</title>
    <link href="http://changsk.top/2019/06/25/why-redis-quick/"/>
    <id>http://changsk.top/2019/06/25/why-redis-quick/</id>
    <published>2019-06-25T12:31:34.000Z</published>
    <updated>2019-06-25T12:34:41.501Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>纯内存访问，redis将所有数据都放在内存中，内存响应时间大约为100纳秒，这是redis达到每秒万级级别访问的重要基础。完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</p><a id="more"></a></li><li><p>数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</p></li><li><p>非阻塞IO，redis使用epoll作为IO多路复用技术的实现，再加上redis自身事件处理模型将epoll中的链接、读写、关闭都转换为事件，不在网络IO上浪费过多的事件。</p><p><img src="1.jpg" alt="img"></p></li></ol><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">多路<span class="keyword">I</span>/<span class="keyword">O</span>复用模型是利用 select、poll、epoll 可以同时监察多个流的 <span class="keyword">I</span>/<span class="keyword">O</span> 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 <span class="keyword">I</span>/<span class="keyword">O</span> 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</span><br><span class="line"></span><br><span class="line">这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 <span class="keyword">I</span>/<span class="keyword">O</span> 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快。</span><br></pre></td></tr></table></figure><ol start="4"><li>单线程避免了线程切换和竟态产生的消耗。避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；<br>1.单线程简化数据结构和算法的实现。<br>2.单线程避免线程切换和竟态产生的消耗。<br>缺点：如果命令执行时间过程，会导致其它命令阻塞。</li></ol><blockquote><p>参考：</p><p><a href="https://www.cnblogs.com/oskyhg/p/7856043.html" target="_blank" rel="noopener">单线程的redis为什么达到每秒万级的处理速度？</a><br><a href="https://blog.csdn.net/chenyao1994/article/details/79491337" target="_blank" rel="noopener">为什么说Redis是单线程的以及Redis为什么这么快！</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;纯内存访问，redis将所有数据都放在内存中，内存响应时间大约为100纳秒，这是redis达到每秒万级级别访问的重要基础。完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://changsk.top/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://changsk.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>MSS和MTU的关系</title>
    <link href="http://changsk.top/2019/06/24/mss-mtu/"/>
    <id>http://changsk.top/2019/06/24/mss-mtu/</id>
    <published>2019-06-24T14:17:47.000Z</published>
    <updated>2019-06-24T14:29:01.279Z</updated>
    
    <content type="html"><![CDATA[<p><code>MSS</code>，Maxitum Segment Size 最大分段大小，是TCP协议定义的一个选项。MSS选项用于在TCP连接建立时，收发双方协商通信时每一个报文段所能承载的最大数据长度。建立tcp连接的两端在三次握手时会协商<code>tcp mss</code>大小。</p><p><code>MTU</code>，Maxitum Transmission Unit ，最大传输单元，是指ip层数据包的最大字节数，因为ip数据报要在数据链路层传输，所以也是数据链路层所能传输的的最大字节数，不同链路层的MTU可能不同。</p><blockquote><p>举个例子：如果你要搬家，需要把东西打包，用车运走。这样的情况下，车的大小受路的宽度限制；箱子的大小受车限制；能够搬运的东西的大小受箱子的限制。这时可以将路的宽度理解成第二层的MTU，车的大小理解成第三层的MTU，箱子的大小理解成第四层的MTU，搬运的东西理解成MSS。</p></blockquote><p><strong>MTU= MSS+TCP层头部长度+IP层头部长度</strong></p><blockquote><p>参考: <a href="https://blog.csdn.net/aiaiai010101/article/details/82984940" target="_blank" rel="noopener">MSS和MTU的关系</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;MSS&lt;/code&gt;，Maxitum Segment Size 最大分段大小，是TCP协议定义的一个选项。MSS选项用于在TCP连接建立时，收发双方协商通信时每一个报文段所能承载的最大数据长度。建立tcp连接的两端在三次握手时会协商&lt;code&gt;tcp mss&lt;/
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://changsk.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="MSS" scheme="http://changsk.top/tags/MSS/"/>
    
      <category term="MTU" scheme="http://changsk.top/tags/MTU/"/>
    
  </entry>
  
</feed>
