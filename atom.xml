<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>changsk&#39;s blogs</title>
  
  <subtitle>chang.sk@foxmail.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://changsk.top/"/>
  <updated>2020-08-01T14:09:32.963Z</updated>
  <id>http://changsk.top/</id>
  
  <author>
    <name>changsk</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iptables详解（4）：iptables匹配条件总结之一</title>
    <link href="http://changsk.top/2020/08/01/iptables-4/"/>
    <id>http://changsk.top/2020/08/01/iptables-4/</id>
    <published>2020-08-01T12:25:06.000Z</published>
    <updated>2020-08-01T14:09:32.963Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="http://www.zsythink.net/archives/1544" target="_blank" rel="noopener">iptables详解（4）：iptables匹配条件总结之一</a></p><a id="more"></a><p><strong>注意：在参照本文进行iptables实验时，请务必在个人的测试机上进行，因为如果iptables规则设置不当，有可能使你无法连接到远程主机中。</strong></p><h2 id="匹配条件的更多用法"><a href="#匹配条件的更多用法" class="headerlink" title="匹配条件的更多用法"></a>匹配条件的更多用法</h2><p>还是从我们最常用的”源地址”说起吧，我们知道，<strong>使用-s选项作为匹配条件</strong>，可以匹配报文的源地址，但是之前的示例中，我们每次指定源地址，都只是指定单个IP，示例如下。</p><p><img src="1.png" alt="iptables详解（4）：iptables匹配条件总结之一"></p><p>其实，我们也可以在指定源地址时，一次指定多个，<strong>用”逗号”隔开即可</strong>，示例如下。</p><p><img src="2.png" alt="iptables详解（4）：iptables匹配条件总结之一"></p><p>可以看出，上例中，一次添加了两条规则，两条规则只是源地址对应的IP不同，注意，<strong>上例中的”逗号”两侧均不能包含空格，多个IP之间必须与逗号相连。</strong></p><p>除了能指定具体的IP地址，还能指定某个网段，示例如下</p><p><img src="3.png" alt="iptables详解（4）：iptables匹配条件总结之一"></p><p>上例表示，如果报文的源地址IP在10.6.0.0/16网段内，当报文经过INPUT链时就会被DROP掉。</p><p>其实，我们还可以对匹配条件取反，先看示例，如下。</p><p><img src="4.png" alt="iptables详解（4）：iptables匹配条件总结之一"></p><p>上图中，<strong>使用”! -s 192.168.1.146”表示对 -s 192.168.1.146这个匹配条件取反</strong>， -s 192.168.1.146表示报文源IP地址为192.168.1.146即可满足匹配条件，使用 “!” 取反后则表示，报文源地址IP只要不为192.168.1.146即满足条件，那么，上例中规则表达的意思就是，只要发往本机的报文的源地址不是192.168.1.146，就接受报文。</p><p>此刻，你猜猜，按照上例中的配置，如果此时从146主机上向<a href="http://www.zsythink.net/archives/tag/防火墙/" target="_blank" rel="noopener">防火墙</a>所在的主机发送ping请求，146主机能得到回应吗？（此处不考虑其他链，只考虑filter表的INPUT链）</p><p>为了给你思考的空间，我把答案写的远一点。</p><p>答案是：能，也就是说，按照上例的配置，146主机仍然能够ping通当前主机，为什么呢？我们来分析一下。</p><p>上例中，filter表的INPUT链中只有一条规则，这条规则要表达的意思就是：</p><p>只要报文的源IP不是192.168.1.146，那么就接受此报文，但是，某些小伙伴可能会误会，把上例中的规则理解成如下含义：只要报文的源IP是192.168.1.146，那么就不接受此报文，这种理解与上述理解看似差别不大，其实完全不一样，这样理解是错误的，上述理解才是正确的。</p><p><strong>换句话说就是，报文的源IP不是192.168.1.146时，会被接收，并不能代表，报文的源IP是192.168.1.146时，会被拒绝。</strong></p><p>上例中，因为并没有任何一条规则指明源IP是192.168.1.146时，该执行怎样的动作，所以，当来自192.168.1.146的报文经过INPUT链时，并不能匹配上例中的规则，于是，此报文就继续匹配后面的规则，可是，上例中只有一条规则，这条规则后面没有其他可以匹配的规则，于是，此报文就会去匹配<strong>当前链的默认动作(默认策略)</strong>，而上例中，INPUT链的默认动作为ACCEPT，所以，来自146的ping报文就被接收了，如果，把上例中INPUT链的默认策略改为DROP，那么，146的报文将会被丢弃，146上的ping命令将得不到任何回应，但是<strong>如果将INPUT链的默认策略设置为DROP，当INPUT链中没有任何规则时，所有外来报文将会被丢弃，包括我们ssh远程连接。</strong></p><p>好了，我们通过上例，不仅了解到了怎样对匹配条件取反，还加深了我们对默认策略的了解，一举两得，我们继续聊。</p><h3 id="匹配条件：目标IP地址"><a href="#匹配条件：目标IP地址" class="headerlink" title="匹配条件：目标IP地址"></a>匹配条件：目标IP地址</h3><p>除了可以通过-s选项指定源地址作为匹配条件，我们还可以使用-d选项指定”目标地址”作为匹配条件。</p><p>源地址表示报文从哪里来，目标地址表示报文要到哪里去。</p><p>除了127.0.0.1回环地址以外，当前机器有两个IP地址，IP如下。</p><p><img src="5.png" alt="iptables详解（4）：iptables匹配条件总结之一"></p><p>假设，我们想要拒绝146主机发来的报文，但是我们只想拒绝146向156这个IP发送报文，并不想要防止146向101这个IP发送报文，我们就可以指定目标地址作为匹配条件，示例如下。</p><p><img src="6.png" alt="iptables详解（4）：iptables匹配条件总结之一"></p><p>上例表示只丢弃从146发往156这个IP的报文，但是146发往101这个IP的报文并不会被丢弃，<strong>如果我们不指定任何目标地址，则目标地址默认为0.0.0.0/0，同理，如果我们不指定源地址，源地址默认为0.0.0.0/0，0.0.0.0/0表示所有IP</strong>，示例如下。</p><p><img src="7.png" alt="iptables详解（4）：iptables匹配条件总结之一"></p><p>上例表示，所有IP发送往101的报文都将被丢弃。</p><p>与-s选项一样，<strong>-d选项也可以使用”叹号”进行取反，也能够同时指定多个IP地址，使用”逗号”隔开即可。</strong></p><p>但是请注意，不管是-s选项还是-d选项，<strong>取反操作与同时指定多个IP的操作不能同时使用。</strong></p><p><strong>需要明确的一点就是：当一条规则中有多个匹配条件时，这多个匹配条件之间，默认存在”与”的关系。</strong></p><p><strong>说白了就是，当一条规则中存在多个匹配条件时，报文必须同时满足这些条件，才算做被规则匹配。</strong></p><p>就如下例所示，下图中的规则包含有两个匹配条件，源地址与目标地址，报文必须同时能被这两个条件匹配，才算作被当前规则匹配，也就是说，下例中，报文必须来自146，同时报文的目标地址必须为101，才会被如下规则匹配，两个条件必须同时满足。</p><p><img src="8.png" alt="iptables详解（4）：iptables匹配条件总结之一"></p><p>我们除了能够使用-s选项和-d选项匹配源IP与目标IP以外，还能够匹配”源端口”与”目标端口”，但是我们一会儿再聊怎样匹配端口，我们先聊聊其他选项。</p><h3 id="匹配条件：协议类型"><a href="#匹配条件：协议类型" class="headerlink" title="匹配条件：协议类型"></a>匹配条件：协议类型</h3><p>我们可以<strong>使用-p选项，指定需要匹配的报文的协议类型。</strong></p><p>假设，我们只想要拒绝来自146的tcp类型的请求，那么可以进行如下设置</p><p><img src="9.png" alt="iptables详解（4）：iptables匹配条件总结之一"></p><p>上图中，防火墙拒绝了来自146的tcp报文发往156这个IP，那么我们来测试一下，我们在146上使用ssh连接101这个IP试试（<strong>ssh协议的传输层协议属于tcp协议类型</strong>）</p><p><img src="10.png" alt="iptables详解（4）：iptables匹配条件总结之一"></p><p>如上图所示，ssh连接被拒绝了，那么我们使用ping命令试试 (ping命令使用icmp协议)，看看能不能ping通156。</p><p><img src="11.png" alt="iptables详解（4）：iptables匹配条件总结之一"></p><p>可以看到，PING命令可以ping通156，证明icmp协议并没有被规则匹配到，只有tcp类型的报文被匹配到了。</p><p>那么，-p选项都支持匹配哪些协议呢？我们总结一下</p><p><strong>centos6中，-p选项支持如下协议类型</strong></p><p><strong>tcp, udp, udplite, icmp, esp, ah, sctp</strong></p><p><strong>centos7中，-p选项支持如下协议类型</strong></p><p><strong>tcp, udp, udplite, icmp, icmpv6,esp, ah, sctp, mh</strong></p><p><strong>当不使用-p指定协议类型时，默认表示所有类型的协议都会被匹配到，与使用-p all的效果相同。</strong></p><h3 id="匹配条件：网卡接口"><a href="#匹配条件：网卡接口" class="headerlink" title="匹配条件：网卡接口"></a>匹配条件：网卡接口</h3><p>我们再来认识一个新的匹配条件，当本机有多个网卡时，我们可以<strong>使用 -i 选项去匹配报文是通过哪块网卡流入本机的。</strong></p><p>我们先动手做个小例子，对-i选项有一个初步的了解以后，再结合理论去看。</p><p>当前主机的<strong>网卡名称为eth4</strong>，如下图</p><p><img src="12.png" alt="iptables详解（4）：iptables匹配条件总结之一"></p><p>假设想要拒绝由网卡eth4流入的ping请求报文，则可以进行如下设置。</p><p><img src="13.png" alt="iptables详解（4）：iptables匹配条件总结之一"></p><p>上图中，<strong>使用-i选项，指定网卡名称</strong>，使用-p选项，指定了需要匹配的报文协议类型，上例表示丢弃由eth4网卡流入的icmp类型的报文。</p><p>是不是很容易理解，但是，我们需要考虑一个问题，-i选项是用于匹配报文流入的网卡的，也就是说，从本机发出的报文是不可能会使用到-i选项的，因为这些由本机发出的报文压根不是从网卡流入的，而是要通过网卡发出的，从这个角度考虑，-i选项的使用是有限制的。</p><p>为了更好的解释-i选项，我们回顾一下在理论总结中的一张iptables全局报文流向图，如下。</p><p><img src="14.png" alt="iptables详解（4）：iptables匹配条件总结之一"></p><p>既然-i选项是用于判断报文是从哪个网卡流入的，那么，-i选项只能用于上图中的PREROUTING链、INPUT链、FORWARD链，这是-i选项的特殊性，因为它只是用于判断报文是从哪个网卡流入的，所以只能在上图中”数据流入流向”的链中与FORWARD链中存在，而上图中的”数据发出流向”经过的链中，是不可能使用-i选项的，比如上图中的<strong>OUTPUT链与POSTROUTING链，他们都不能使用-i选项。</strong></p><p>理解完-i选项，再来理解-o选项就好办了。</p><p>当主机有多块网卡时，可以使用-o选项，匹配报文将由哪块网卡流出，没错，-o选项与-i选项是相对的，<strong>-i选项用于匹配报文从哪个网卡流入，-o选项用于匹配报文将从哪个网卡流出。</strong></p><p>聪明如你，一定想到了，<strong>-i选项只能用于PREROUTING链、INPUT链、FORWARD链，那么-o选项只能用于FORWARD链、OUTPUT链、POSTROUTING链。</strong></p><p>因为-o选项是用于匹配报文将由哪个网卡”流出”的，所以与上图中的”数据进入流向”中的链没有任何缘分，所以，-o选项只能用于FORWARD链、OUTPUT链、POSTROUTING链中。</p><p>看来，<strong>FORWARD链属于”中立国”，它能同时使用-i选项与-o选项。</strong></p><h2 id="扩展匹配条件"><a href="#扩展匹配条件" class="headerlink" title="扩展匹配条件"></a>扩展匹配条件</h2><p>好了，现在，我们就要聊聊，怎样匹配报文的”源端口”与”目标端口”。</p><p>在上文中，我们总结了”源地址”与”目标地址”以后，就顺便提到了”源端口”与”目标端口”，但是，为什么刚才不介绍”源端口”与”目标端口”，非要现在介绍呢？这是<strong>因为”源端口”与”目标端口”属于扩展匹配条件，”源地址”与”目标地址”属于基本匹配条件</strong>，上文中介绍到的匹配条件，都属于基本匹配条件，所以，我们单独把”源端口”与”目标端口”，放在后面总结，是为了引出扩展匹配条件的概念。</p><p>那么，先来了解一下，什么是扩展匹配条件。</p><p>不是基本匹配条件的就是扩展匹配条件，这样说好像是句废话，我们可以这样理解，<strong>基本匹配条件我们可以直接使用，而如果想要使用扩展匹配条件，则需要依赖一些扩展模块</strong>，或者说，<strong>在使用扩展匹配条件之前，需要指定相应的扩展模块才行</strong>，这样说不容易明白，我们做个例子，就能够明白。</p><p>我们知道，<strong>sshd服务的默认端口为22</strong>，当我们使用ssh工具远程连接主机时，默认会连接服务端的22号端口，假设，我们现在想要使用iptables设置一条规则，拒绝来自192.168.1.146的ssh请求，我们就可以拒绝146上的报文能够发往本机的22号端口，这个时候，就需要用到”目标端口”选项。</p><p><strong>使用选项–dport可以匹配报文的目标端口，–dport意为destination-port，即表示目标端口。</strong></p><p><strong>注意，与之前的选项不同，–dport前有两条”横杠”，而且，使用–dport选项时，必须事先指定了使用哪种协议</strong>，即必须先使用-p选项，示例如下</p><p><img src="15.png" alt="iptables详解（4）：iptables匹配条件总结之一"></p><p>上图中，我们就使用了<strong>扩展匹配条件–dport</strong>，指定了匹配报文的目标端口，如果外来报文的目标端口为本机的22号端口（ssh默认端口），则拒绝之，<strong>而在使用–dport之前，我们使用-m选项，指定了对应的扩展模块为tcp，也就是说，如果想要使用–dport这个扩展匹配条件，则必须依靠某个扩展模块完成</strong>，上例中，这个扩展模块就是tcp扩展模块，最终，我们使用的是<strong>tcp扩展模块中的dport扩展匹配条件。</strong></p><p>现在，我们再回过头来看看扩展匹配条件的概念，就更加明白了。</p><p><strong>扩展匹配条件被使用时，则需要依赖一些扩展模块，或者说，在使用扩展匹配条件之前，需要指定相应的扩展模块才行。</strong></p><p>现在你明白了吗？ <strong>-m tcp表示使用tcp扩展模块，–dport表示tcp扩展模块中的一个扩展匹配条件，可用于匹配报文的目标端口。</strong></p><p>注意，<strong>-p tcp与 -m tcp并不冲突，-p用于匹配报文的协议，-m 用于指定扩展模块的名称，正好，这个扩展模块也叫tcp。</strong></p><p>其实，上例中，我们可以省略-m选项，示例如下。</p><p><img src="16.png" alt="iptables详解（4）：iptables匹配条件总结之一"></p><p><strong>当使用-p选项指定了报文的协议时，如果在没有使用-m指定对应的扩展模块名称的情况下，使用了扩展匹配条件，  iptables默认会调用与-p选项对应的协议名称相同的模块。</strong></p><p>上例中，我们使用-p选项指定了协议名称，使用扩展匹配条件–dport指定了目标端口，在使用扩展匹配条件的时候，如果没有使用-m指定使用哪个扩展模块，iptables会默认使用”-m 协议名”，而协议名就是-p选项对应的协议名，上例中，-p 对应的值为tcp，所以默认调用的扩展模块就为-m tcp，如果-p对应的值为udp，那么默认调用的扩展模块就为-m udp。</p><p>所以，上例中，<strong>其实”隐式”的指定了扩展模块</strong>，只是没有表现出来罢了。</p><p>所以，在使用扩展匹配条件时，一定要注意，<strong>如果这个扩展匹配条件所依赖的扩展模块名正好与-p对应的协议名称相同，那么则可省略-m选项，否则则不能省略-m选项，必须使用-m选项指定对应的扩展模块名称</strong>，这样说可能还是不是特别明了，在后续的举例中，我们会更加明了的理解这些概念。</p><p>有”目标端口”，就有”源端口”，<strong>代表”源端口”的扩展匹配条件为–sport</strong></p><p>使用–sport可以判断报文是否从指定的端口发出，即匹配报文的源端口是否与指定的端口一致，–sport表示source-port，即表示源端口之意。</p><p>因为我们已经搞明白了dport，那么sport我就不再赘述了，示例如下</p><p><img src="17.png" alt="iptables详解（4）：iptables匹配条件总结之一"></p><p>上例中，隐含了”-m tcp”之意，表示使用了tcp扩展模块的–sport扩展匹配条件。</p><p><strong>扩展匹配条件是可以取反的，同样是使用”!”进行取反</strong>，比如 “! –dport 22”，表示目标端口不是22的报文将会被匹配到。</p><p>不管是–sport还是–dsport，都能够指定一个端口范围，比如，<strong>–dport 22:25表示目标端口为22到25之间的所有端口</strong>，即22端口、23端口、24端口、25端口，示例如下</p><p><img src="18.png" alt="iptables详解（4）：iptables匹配条件总结之一"></p><p>也可以写成如下图中的模样，下图中第一条规则表示匹配0号到22号之间的所有端口，下图中的第二条规则表示匹配80号端口以及其以后的所有端口（直到65535）。</p><p><img src="19.png" alt="iptables详解（4）：iptables匹配条件总结之一"></p><p>刚才聊到的两个扩展匹配条件都是tcp扩展模块的，其实，tcp扩展模块还有一个比较有用的扩展匹配条件叫做”–tcp-flags”，但是由于篇幅原因，以后再对这个扩展匹配条件进行总结。</p><p>借助tcp扩展模块的–sport或者–dport都可以指定一个连续的端口范围，但是无法同时指定多个离散的、不连续的端口，<strong>如果想要同时指定多个离散的端口，需要借助另一个扩展模块，”multiport”模块。</strong></p><p><strong>我们可以使用multiport模块的–sports扩展条件同时指定多个离散的源端口。</strong></p><p><strong>我们可以使用multiport模块的–dports扩展条件同时指定多个离散的目标端口。</strong></p><p>示例如下</p><p><img src="20.png" alt="iptables详解（4）：iptables匹配条件总结之一"></p><p>上图示例表示，禁止来自146的主机上的tcp报文访问本机的22号端口、36号端口以及80号端口。</p><p>上图中，”-m multiport –dports 22,36,80”表示使用了multiport扩展模块的–dports扩展条件，以同时指定了多个离散的端口，每个端口之间用逗号隔开。</p><p>上图中的-m multiport是不能省略的，如果你省略了-m multiport，就相当于在没有指定扩展模块的情况下，使用了扩展条件（”–dports”），那么上例中，iptables会默认调用”-m tcp”，但是，<strong>“–dports扩展条件”并不属于”tcp扩展模块”,而是属于”multiport扩展模块”</strong>，所以，这时就会报错。</p><p>综上所述，<strong>当使用–dports或者–sports这种扩展匹配条件时，必须使用-m指定模块的名称。</strong></p><p>其实，<strong>使用multiport模块的–sports与–dpors时，也可以指定连续的端口范围，并且能够在指定连续的端口范围的同时，指定离散的端口号</strong>，示例如下。</p><p><img src="21.png" alt="iptables详解（4）：iptables匹配条件总结之一"></p><p>上例中的命令表示拒绝来自192.168.1.146的tcp报文访问当前主机的22号端口以及80到88之间的所有端口号，是不是很方便？有没有很灵活？</p><p>不过需要注意，<strong>multiport扩展只能用于tcp协议与udp协议，即配合-p tcp或者-p udp使用。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自：&lt;a href=&quot;http://www.zsythink.net/archives/1544&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iptables详解（4）：iptables匹配条件总结之一&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://changsk.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="iptables" scheme="http://changsk.top/tags/iptables/"/>
    
  </entry>
  
  <entry>
    <title>VPN原理</title>
    <link href="http://changsk.top/2020/07/31/VPN-principle/"/>
    <id>http://changsk.top/2020/07/31/VPN-principle/</id>
    <published>2020-07-31T15:28:18.000Z</published>
    <updated>2020-07-31T15:35:35.987Z</updated>
    
    <content type="html"><![CDATA[<p>本文参考：<a href="https://yuerblog.cc/" target="_blank" rel="noopener">鱼儿的博客</a></p><a id="more"></a><h2 id="VPN原理"><a href="#VPN原理" class="headerlink" title="VPN原理"></a>VPN原理</h2><p>vpn：英文<em>全称</em>是<code>“Virtual Private Network”</code>，翻译过来就是“<strong>虚拟专用网络</strong>”。vpn通常拿来做两个事情，一个是可以<strong>让世界上任意2台机器进入一个虚拟的局域网中</strong>（当然这个局域网的数据通讯是<strong>加密</strong>的，很安全，用起来和一个家庭局域网没有区别），一个是可以用来翻墙。</p><p>vpn通过操作系统的接口直接<strong>虚拟出一张网卡</strong>，后续整个操作系统的网络通讯都将通过这张虚拟的网卡进行收发。这和任何一个代理的实现思路都差不多，<strong>应用层并不知道网卡是虚拟的</strong>，这样vpn虚拟网卡将以中间人的身份对数据进行加工，从而实现各种神奇的效果。具体来说，<strong>vpn是通过编写一套网卡驱动并注册到操作系统实现的虚拟网卡，这样数据只要经过网卡收发就可以进行拦截处理。</strong>vpn在IP层工作。</p><h2 id="翻墙用途"><a href="#翻墙用途" class="headerlink" title="翻墙用途"></a>翻墙用途</h2><p><img src="1.png" alt="1"></p><p>需要在vps上部署<code>vpn server</code>，<strong>客户端所有数据将经过虚拟网卡的加密封装后都转发给vps上的vpn server</strong>，由它来转发给目标服务器。下面将以pptp vpn协议为例说明。</p><p>假设要访问谷歌，那么客户端发出的数据包首先通过协议栈处理封装成IP包，其源地址是虚拟网卡的地址，例如：192.168.0.2，而目标地址是谷歌的IP。</p><p>原始IP包交给虚拟网卡发送时，PPTP网卡驱动会按PPP协议对这个IP包整体加密封装作为新的payload，用一层新的IP头封装这个payload发送出去，这个新IP头的目标地址是vpn server，源地址是客户端的外网IP。</p><p>vpn server的协议栈会剥离掉新IP头，将内部PPP协议的payload交给pptpd进程处理，pptpd进程会按PPP协议解包得到原始的IP包，我们知道这个IP包的源地址是192.168.0.2，目标地址google。因此，pptpd进程需要做的是将这个IP包的源IP地址改为vps的地址，然后将IP包发给谷歌，从而和谷歌进行数据交换。最终，pptpd理所应当将谷歌的应答IP包的目标IP地址换成192.168.0.2，然后经过PPP协议封装并添加新的IP头后发回给客户端既可。</p><p>不过要注意在pptpd的实现里，这个源地址修改是通过<code>iptables</code>实现的，也就是添加通过iptables添加一个NAT规则，实现来源地址的映射转换，这个在你配置pptp的过程中就会看到。</p><h2 id="局域网用途"><a href="#局域网用途" class="headerlink" title="局域网用途"></a>局域网用途</h2><p><img src="2.png" alt="2"></p><p>大家知道，玩CS的时候都是局域网搜索房间的，要求大家坐在一个网吧里连着一台交换机。如果大家各自坐在家里玩CS想联机，通常要登录一个对战平台，其实<strong>对战平台做的事情就是VPN，也就是虚拟一个局域网</strong>，大家感受起来就和坐在一起一样。</p><p><strong>虚拟网卡的驱动会尽力伪装成一个物理网卡的样子</strong>，我们知道DHCP协议是局域网动态分配客户端IP的协议，那么<strong>VPN的虚拟网卡其实也会和vpn server进行一些协商得到一个虚拟局域网的IP</strong>，比如192.168.0.2。得到虚拟IP后，后续数据将通过虚拟网卡发送至vpn server所在的IP，最终被pptpd进程处理。</p><p>既然各个客户端的虚拟网卡都是和同一个pptpd进程交互，那么这个pptpd进程自然知道这个虚拟的局域网内有哪些局域网用户，因此当2个虚拟局域网用户192.168.0.2和192.168.0.3之间想互相通讯的时候，<strong>pptpd会完成数据的中转</strong>。不过要注意，<strong>虚拟局域网用户间的通讯是不需要像访问谷歌那样修改数据包的源IP地址的</strong>，这个很容易想明白。</p><p>上面只是站在一个小白的角度理解这个过程，真实的pptp协议还用到了GRE协议，但并不是理解的重点。<strong>一个真实的pptpd进程包含一个在端口1723上tcp监听的父进程用来与各vpn client协商隧道信息，pptpd后续会给每个client创建一个子进程专门负责client的数据交互，而这个交互的协议就是GRE协议。</strong></p><p>GRE直接在IP层之上实现，内核剥离IP之后会解析GRE协议并根据GRE中的隧道ID将数据包分派给对应的pptpd子进程。子进程则通过raw socket对GRE包进行读写，利用raw socket可以方便的向任何隧道写出数据和读入数据，可以说pptpd的vpn隧道是直接依赖GRE协议的，有了GRE协议可以很方便的实现不同隧道间的数据交互，因为每个隧道的数据在GRE头中都有唯一ID标识（ID是1723端协商而来的），这就是虚拟局域网的大概实现原理。</p><p>当然，就像上面的图片描述的那样，VPN也常用于在家连接办公网，这是因为VPN server有另外一张网卡与办公网是局域网的关系，因此可以通过VPN server间接的访问到办公网，此时vpn server的帐号密码鉴权系统就显得尤为重要了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文参考：&lt;a href=&quot;https://yuerblog.cc/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;鱼儿的博客&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://changsk.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="VPN" scheme="http://changsk.top/tags/VPN/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-292:Nim Game</title>
    <link href="http://changsk.top/2020/07/31/leetcode-292/"/>
    <id>http://changsk.top/2020/07/31/leetcode-292/</id>
    <published>2020-07-31T14:04:32.000Z</published>
    <updated>2020-07-31T14:57:06.218Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/nim-game/" target="_blank" rel="noopener">Nim Game</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。</p><p>你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。</p><p><strong>示例:</strong></p><p>输入: 4<br>输出: false<br>解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；<br>     因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>参考：<a href="https://leetcode-cn.com/problems/nim-game/solution/nimyou-xi-by-leetcode/" target="_blank" rel="noopener">Nim 游戏</a></p><p>如果堆中石头的数量 n 不能被 44 整除，那么你总是可以赢得 Nim 游戏的胜利。</p><p><strong>推理</strong></p><p>让我们考虑一些小例子。显而易见的是，如果石头堆中只有一块、两块、或是三块石头，那么在你的回合，你就可以把全部石子拿走，从而在游戏中取胜。而如果就像题目描述那样，堆中恰好有四块石头，你就会失败。因为在这种情况下不管你取走多少石头，总会为你的对手留下几块，使得他可以在游戏中打败你。<strong>因此，要想获胜，在你的回合中，必须避免石头堆中的石子数为 4 的情况。</strong></p><p>同样地，如果有五块、六块、或是七块石头，你可以控制自己拿取的石头数，<strong>总是恰好给你的对手留下四块石头</strong>，使他输掉这场比赛。但是如果石头堆里有八块石头，你就不可避免地会输掉，因为<strong>不管你从一堆石头中挑出一块、两块还是三块，你的对手都可以选择三块、两块或一块，以确保在再一次轮到你的时候，你会面对四块石头。</strong></p><p>显然，它以相同的模式不断重复 n=4,8,12,16,…，基本可以看出是 4 的倍数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n % <span class="number">4</span> != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode-cn.com/problems/nim-game/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Nim Game&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-299:Bulls and Cows(猜数字游戏)</title>
    <link href="http://changsk.top/2020/07/31/leetcode-299/"/>
    <id>http://changsk.top/2020/07/31/leetcode-299/</id>
    <published>2020-07-31T14:03:58.000Z</published>
    <updated>2020-07-31T14:10:50.770Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/bulls-and-cows/" target="_blank" rel="noopener">Bulls and Cows</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>你在和朋友一起玩 猜数字（Bulls and Cows）游戏，该游戏规则如下：</p><p>你写出一个秘密数字，并请朋友猜这个数字是多少。<br>朋友每猜测一次，你就会给他一个提示，告诉他的猜测数字中有多少位属于数字和确切位置都猜对了（称为“Bulls”, 公牛），有多少位属于数字猜对了但是位置不对（称为“Cows”, 奶牛）。<br>朋友根据提示继续猜，直到猜出秘密数字。<br>请写出一个根据秘密数字和朋友的猜测数返回提示的函数，返回字符串的格式为 xAyB ，x 和 y 都是数字，A 表示公牛，用 B 表示奶牛。</p><p>xA 表示有 x 位数字出现在秘密数字中，且位置都与秘密数字一致。<br>yB 表示有 y 位数字出现在秘密数字中，但位置与秘密数字不一致。<br>请注意秘密数字和朋友的猜测数都可能含有重复数字，每位数字只能统计一次。</p><p><strong>示例 1:</strong></p><p>输入: secret = “1807”, guess = “7810”<br>输出: “1A3B”<br>解释: 1 公牛和 3 奶牛。公牛是 8，奶牛是 0, 1 和 7。<br><strong>示例 2:</strong></p><p>输入: secret = “1123”, guess = “0111”<br>输出: “1A1B”<br>解释: 朋友猜测数中的第一个 1 是公牛，第二个或第三个 1 可被视为奶牛。</p><p>说明: 你可以假设秘密数字和朋友的猜测数都只包含数字，并且它们的长度永远相等。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHint</span><span class="params">(String secret, String guess)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nums[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> bulls = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cows = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; secret.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (secret.charAt(i) != guess.charAt(i)) &#123;</span><br><span class="line">                nums[secret.charAt(i) - <span class="string">'0'</span>]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                bulls++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; guess.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (secret.charAt(i) != guess.charAt(i)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[guess.charAt(i) - <span class="string">'0'</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">                    cows++;</span><br><span class="line">                    nums[guess.charAt(i) - <span class="string">'0'</span>]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bulls + <span class="string">"A"</span> + cows + <span class="string">"B"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode-cn.com/problems/bulls-and-cows/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Bulls and Cows&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>N进制小数</title>
    <link href="http://changsk.top/2020/07/31/N-decimal/"/>
    <id>http://changsk.top/2020/07/31/N-decimal/</id>
    <published>2020-07-31T13:57:42.000Z</published>
    <updated>2020-07-31T14:54:31.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写程序实现将任意10进制正小数m转换成n进制的正小数，小数点后保留10位小数。</p><p>输入包含两个整数m,n，用空格隔开。输入包含多组测试，当m,n都为0时输入结束。</p><a id="more"></a><p><strong>Limits:</strong></p><p>0.0000009&lt;m&lt;1<br>1&lt;n&lt;10<br>输出<br>输出10进制正小数m的n进制小数。结果保留10位小数。</p><p><strong>样例</strong><br>输入样例</p><blockquote><p>0.795 3<br>0 0</p></blockquote><p>输出样例</p><blockquote><p>0.2101101122</p></blockquote><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    Double m = scanner.nextDouble();</span><br><span class="line">    <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">    <span class="comment">//System.out.println(m + "\t" + n);</span></span><br><span class="line">    <span class="keyword">while</span>(m != <span class="number">0</span>d || n != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> int_part = <span class="number">0</span>; <span class="comment">//整数部分</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">"0."</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            int_part = (<span class="keyword">int</span>)(m * n);</span><br><span class="line">            m = m * n - int_part;</span><br><span class="line">            sb.append(int_part);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">        m = scanner.nextDouble();</span><br><span class="line">        n = scanner.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;编写程序实现将任意10进制正小数m转换成n进制的正小数，小数点后保留10位小数。&lt;/p&gt;
&lt;p&gt;输入包含两个整数m,n，用空格隔开。输入包含多组测试，当m,n都为0时输入结束。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>iptables详解（3）：iptables规则管理</title>
    <link href="http://changsk.top/2020/07/29/iptables-3/"/>
    <id>http://changsk.top/2020/07/29/iptables-3/</id>
    <published>2020-07-29T15:01:08.000Z</published>
    <updated>2020-07-29T15:35:59.030Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="http://www.zsythink.net/archives/1517" target="_blank" rel="noopener">iptables详解（3）：iptables规则管理</a></p><a id="more"></a><p><strong>注意：在参照本文进行iptables实验时，请务必在个人的测试机上进行，因为如果iptables规则设置不当，有可能使你无法连接到远程主机中。</strong></p><p><img src="1.png" alt="iptables详解（3）：iptables规则管理"></p><p>首先，我们来回顾一下什么是iptables的规则。</p><p>之前打过一个比方，<strong>每条”链”都是一个”关卡”</strong>，每个通过这个”关卡”的报文都要匹配这个关卡上的规则，如果匹配，则对报文进行对应的处理，比如说，你我二人此刻就好像两个”报文”，你我二人此刻都要入关，可是城主有命，只有器宇轩昂之人才能入关，不符合此条件的人不能入关，于是守关将士按照城主制定的”规则”，开始打量你我二人，最终，你顺利入关了，而我已被拒之门外，因为你符合”器宇轩昂”的标准，所以把你”放行”了，而我不符合标准，所以没有被放行，其实，”器宇轩昂”就是一种”匹配条件”，”放行”就是一种”动作”，”匹配条件”与”动作”组成了规则。</p><p>只不过，在iptables的世界中，最常用的匹配条件并不是”器宇轩昂”，而是报文的<strong>“源地址”、”目标地址”、”源端口”、”目标端口”</strong>等，在iptables的世界中，最常用的动作有<strong>ACCEPT（接受）、DROP（丢弃）、REJECT（拒绝）</strong>，其中ACCEPT就与我们举例中的”放行”类似，但是，我们刚才提到的这些并不是全部的匹配条件与动作，只是最常用的一些罢了，具体的匹配条件与动作不是我们今天讨论的重点，我们会在以后的文章中再做总结。</p><p>好了，我们已经回顾了规则的概念，并且已经明白了，规则大致由两个逻辑单元组成，<strong>匹配条件与动作</strong>，那么多说无益，我们来动手定义一条规则，此处仍然以filter表中的INPUT链为例，因为<strong>filter表负责”过滤”功能</strong>，而所有发往本机的报文如果需要被过滤，首先会经过INPUT链（<strong>PREROUTING链没有过滤功能</strong>），这与我们所比喻的”入关”场景非常相似，所以，使用filter表的INPUT链为例，有助于我们进行理解。</p><p>首先，查看一下filter表中的INPUT链中的规则，查看规则的相关命令在前文已经总结了，此处不再赘述，如果你忘了，请回顾前文。</p><p>使用如下命令查看filter表INPUT链的规则，下图中的规则为centos6默认添加的规则。</p><p><img src="2.png" alt="iptables详解（3）：iptables规则管理"></p><p>注意：在参照本文进行iptables实验时，请务必在个人的测试机上进行。</p><p>为了准备一个从零开始的环境，我们将centos6默认提供的规则清空，以便我们进行实验，使用<strong>iptables -F INPUT</strong>命令清空filter表INPUT链中的规则，后面我们会单独对清除规则的相关命令进行总结，此处不用纠结此命令。</p><p><img src="3.png" alt="iptables详解（3）：iptables规则管理"></p><p>清空INPUT链以后，filter表中的INPUT链已经不存在任何的规则，但是可以看出，INPUT链的默认策略是ACCEPT，也就是说，INPUT链默认”放行”所有发往本机的报文，当没有任何规则时，会接受所有报文，当报文没有被任何规则匹配到时，也会默认放行报文。</p><p>那么此刻，我们就在另外一台机器上，使用ping命令，向当前机器发送报文，如下图所示，ping命令可以得到回应，证明ping命令发送的报文已经正常的发送到了防火墙所在的主机，ping命令所在机器IP地址为146，当前测试防火墙主机的IP地址为156，我们就用这样的环境，对iptables进行操作演示。</p><p><img src="4.png" alt="iptables详解（3）：iptables规则管理"></p><h2 id="增加规则"><a href="#增加规则" class="headerlink" title="增加规则"></a>增加规则</h2><p>那么此处，我们就在156上配置一条规则，拒绝192.168.1.146上的所有报文访问当前机器，之前一直在说，规则由匹配条件与动作组成，那么”拒绝192.168.1.146上的所有报文访问当前机器”这条规则中，报文的”源地址为192.168.1.146”则属于匹配条件，如果报文来自”192.168.1.146”，则表示满足匹配条件，而”拒绝”这个报文，就属于对应的动作，好了，那么怎样用命令去定义这条规则呢？使用如下命令即可</p><p><img src="5.png" alt="iptables详解（3）：iptables规则管理"></p><p>上图中，使用 <strong>-t选项指定了要操作的表</strong>，此处指定了操作filter表，与之前的查看命令一样，不使用-t选项指定表时，<strong>默认为操作filter表</strong>。</p><p><strong>使用-I选项，指明将”规则”插入至哪个链中，-I表示insert，即插入的意思，所以-I INPUT表示将规则插入于INPUT链中，即添加规则之意。</strong></p><p><strong>使用-s选项，指明”匹配条件”中的”源地址”</strong>，即如果报文的源地址属于-s对应的地址，那么报文则满足匹配条件，-s为source之意，表示源地址。</p><p>使用-j选项，指明当”匹配条件”被满足时，所对应的动作，上例中指定的动作为DROP，在上例中，当报文的源地址为192.168.1.146时，报文则被DROP（丢弃）。</p><p>再次查看filter表中的INPUT链，发现规则已经被添加了，在iptables中，动作被称之为”target”，所以，上图中taget字段对应的动作为DROP。</p><p>那么此时，我们再通过192.168.1.146去ping主机156，看看能否ping通。</p><p><img src="6.png" alt="iptables详解（3）：iptables规则管理"></p><p>如上图所示，ping 156主机时，PING命令一直没有得到回应，看来我们的iptables规则已经生效了，ping发送的报文压根没有被156主机接受，而是被丢弃了，所以更不要说什么回应了，好了，我们已经成功的配置了一条iptables规则，看来，我们已经入门了。</p><p>还记得我们在前文中说过的”计数器”吗？此时，我们再次查看iptables中的规则，可以看到，已经有24个包被对应的规则匹配到，总计大小2016bytes。</p><p><img src="7.png" alt="iptables详解（3）：iptables规则管理"></p><p>此刻，我们来做一个实验。</p><p>现在INPUT链中已经存在了一条规则，它拒绝了所有来自192.168.1.146主机中的报文，如果此时，我们在这条规则之后再配置一条规则，后面这条规则规定，接受所有来自192.168.1.146主机中的报文，那么，iptables是否会接受来自146主机的报文呢？我们动手试试。</p><p>使用如下命令在filter表的INPUT链中追加一条规则，这条规则表示接受所有来自192.168.1.146的发往本机的报文。</p><p><img src="8.png" alt="iptables详解（3）：iptables规则管理"></p><p>上图中的命令并没有使用-t选项指定filter表，我们一直在说，<strong>不使用-t选项指定表时表示默认操作filter表。</strong></p><p>上图中，使用-A选项，表示在对应的链中”追加规则”，-A为append之意，所以，-A INPUT则表示在INPUT链中追加规则，而之前示例中使用的-I选项则表示在链中”插入规则”，聪明如你一定明白了，它们的本意都是添加一条规则，只是<strong>-A表示在链的尾部追加规则，-I表示在链的首部插入规则</strong>而已。</p><p>使用-j选项，指定当前规则对应的动作为ACCEPT。</p><p>执行完添加规则的命令后，再次查看INPUT链，发现规则已经成功”追加”至INPUT链的末尾，那么现在，第一条规则指明了丢弃所有来自192.168.1.146的报文，第二条规则指明了接受所有来自192.168.1.146的报文，那么结果到底是怎样的呢？实践出真知，在146主机上再次使用ping命令向156主机发送报文，发现仍然是ping不通的，看来第二条规则并没有生效。</p><p><img src="9.png" alt="iptables详解（3）：iptables规则管理"></p><p>而且从上图中第二条规则的计数器可以看到，根本没有任何报文被第二条规则匹配到。</p><p>聪明如你一定在猜想，发生上述情况，会不会与规则的先后顺序有关呢？测试一下不就知道了，我们再添加一条规则，新规则仍然规定接受所有来自192.168.1.146主机中的报文，只是这一次，我们将新规则添加至INPUT链的最前面试试。</p><p>在添加这条规则之前，我们先把146上的ping命令强制停止了，然后使用如下命令，在filter表的INPUT链的前端添加新规则。</p><p><img src="10.png" alt="iptables详解（3）：iptables规则管理"></p><p>好了，现在第一条规则就是接受所有来自192.168.1.146的报文，而且此时计数是0，此刻，我们再从146上向156发起ping请求。</p><p><img src="11.png" alt="iptables详解（3）：iptables规则管理"></p><p>146上已经可以正常的收到响应报文了，那么回到156查看INPUT链的规则，第一条规则的计数器已经显示出了匹配到的报文数量。</p><p><img src="12.png" alt="iptables详解（3）：iptables规则管理"></p><p>看来，规则的顺序很重要。</p><p><strong>如果报文已经被前面的规则匹配到，iptables则会对报文执行对应的动作，即使后面的规则也能匹配到当前报文，很有可能也没有机会再对报文执行相应的动作了</strong>，就以上图为例，报文先被第一条规则匹配到了，于是当前报文被”放行”了，因为报文已经被放行了，所以，即使上图中的第二条规则即使能够匹配到刚才”放行”的报文，也没有机会再对刚才的报文进行丢弃操作了。<strong>这就是iptables的工作机制。</strong></p><p>之前在总结查看命令时提到过，<strong>使用–line-number选项可以列出规则的序号</strong>，如下图所示</p><p><img src="13.png" alt="iptables详解（3）：iptables规则管理"></p><p>我们也可以在添加规则时，指定新增规则的编号，这样我们就能在任意位置插入规则了，我们只要把刚才的命令稍作修改即可，如下。</p><p><img src="14.png" alt="iptables详解（3）：iptables规则管理"></p><p>仍然使用-I选项进行插入规则操作，-I INPUT 2表示在INPUT链中新增规则，新增的规则的编号为2，好了，自己动手试试吧。</p><h2 id="删除规则"><a href="#删除规则" class="headerlink" title="删除规则"></a>删除规则</h2><p>注意：在参照本文进行iptables实验时，请务必在个人的测试机上进行。</p><p>此刻，如果我们想要删除filter表中INPUT中的一条规则，该怎么做呢？</p><p>有两种办法</p><p>方法一：根据规则的编号去删除规则</p><p>方法二：根据具体的匹配条件与动作删除规则</p><p>那么我们先看看方法一，先查看一下filter表中INPUT链中的规则</p><p><img src="15.png" alt="iptables详解（3）：iptables规则管理"></p><p>假如我们想要删除上图中的第3条规则，则可以使用如下命令。</p><p><img src="16.png" alt="iptables详解（3）：iptables规则管理"></p><p>上例中，使用了-t选项指定了要操作的表（没错，省略-t默认表示操作filter表），使用-D选项表示删除指定链中的某条规则，-D INPUT 3表示删除INPUT链中的第3条规则。</p><p>当然，我们也可以根据具体的匹配条件与动作去删除规则，比如，删除下图中源地址为192.168.1.146，动作为ACCEPT的规则，于是，删除规则的命令如下。</p><p><img src="17.png" alt="iptables详解（3）：iptables规则管理"></p><p>上图中，删除对应规则时，仍然使用-D选项，<strong>-D INPUT表示删除INPUT链中的规则</strong>，剩下的选项与我们添加规则时一毛一样，-s表示以对应的源地址作为匹配条件，-j ACCEPT表示对应的动作为接受，所以，上述命令表示删除INPUT链中源地址为192.168.1.146，动作为ACCEPT的规则。</p><p>而删除指定表中某条链中的所有规则的命令，我们在一开始就使用到了，就是”iptables -t 表名 -F 链名”</p><p><strong>-F选项为flush之意，即冲刷指定的链，即删除指定链中的所有规则，但是注意，此操作相当于删除操作</strong>，在没有保存iptables规则的情况下，请慎用。</p><p>其实，<strong>-F选项不仅仅能清空指定链上的规则，其实它还能清空整个表中所有链上的规则，不指定链名，只指定表名即可删除表中的所有规则</strong>，命令如下</p><p><strong>iptables -t 表名 -F</strong></p><p>不过再次强调，在没有保存iptables规则时，请勿随便清空链或者表中的规则，除非你明白你在干什么。</p><h2 id="修改规则"><a href="#修改规则" class="headerlink" title="修改规则"></a>修改规则</h2><p>注意：在参照本文进行iptables实验时，请务必在个人的测试机上进行。</p><p>那么，我们怎样修改某条规则中的动作呢？比如，我想把如下规则中的动作从DROP改为REJECT，改怎么办呢？</p><p><img src="18.png" alt="iptables详解（3）：iptables规则管理"></p><p>我们可以<strong>使用-R选项修改指定的链中的规则</strong>，在修改规则时指定规则对应的编号即可(有坑，慎行)，示例命令如下</p><p><img src="19.png" alt="iptables详解（3）：iptables规则管理"></p><p>上例中，-R选项表示修改指定的链，使用<strong>-R INPUT 1表示修改INPUT链的第1条规则</strong>，使用-j REJECT表示将INPUT链中的第一条规则的动作修改为REJECT，<strong>注意：上例中， -s选项以及对应的源地址不可省略</strong>，即使我们已经指定了规则对应的编号，但是<strong>在使用-R选项修改某个规则时，必须指定规则对应的原本的匹配条件（如果有多个匹配条件，都需要指定）。</strong></p><p>如果上例中的命令没有使用-s指定对应规则中原本的源地址，那么在修改完成后，你修改的规则中的源地址会自动变为0.0.0.0/0（此IP表示匹配所有网段的IP地址），而此时，-j对应的动作又为REJECT，所以在执行上述命令时如果没有指明规则原本的源地址，那么所有IP的请求都被拒绝了（<strong>因为没有指定原本的源地址，当前规则的源地址自动变为0.0.0.0/0</strong>），如果你正在使用ssh远程到服务器上进行iptables设置，那么你的ssh请求也将会被阻断。</p><p><strong>既然使用-R选项修改规则时，必须指明规则原本的匹配条件，那么我们则可以理解为，只能通过-R选项修改规则对应的动作了，所以我觉得，如果你想要修改某条规则，还不如先将这条规则删除，然后在同样位置再插入一条新规则，这样更好，当然，如果你只是为了修改某条规则的动作，那么使用-R选项时，不要忘了指明规则原本对应的匹配条件。</strong></p><p>好了，上例中，我们已经将规则中的动作从DROP改为了REJECT，那么DROP与REJECT有什么不同呢？从字面上理解，DROP表示丢弃，REJECT表示拒绝，REJECT表达的意思好像更坚决一点，我们再次从146主机上向156主机上发起ping请求，看看与之前动作为DROP时有什么不同。</p><p><img src="20.png" alt="iptables详解（3）：iptables规则管理"></p><p>如上图所示，当156主机中的iptables规则对应的动作为REJECT时，从146上进行ping操作时，<strong>直接就提示”目标不可达”</strong>，并没有像之前那样卡在那里，看来，<strong>REJECT比DROP更加”干脆”。</strong></p><p>其实，我们还可以修改指定链的”默认策略”，没错，就是下图中标注的默认策略。</p><p><img src="21.png" alt="iptables详解（3）：iptables规则管理"></p><p>每张表的每条链中，都有自己的默认策略，我们也可以理解为默认”动作”。</p><p><strong>当报文没有被链中的任何规则匹配到时，或者，当链中没有任何规则时，防火墙会按照默认动作处理报文</strong>，我们可以修改指定链的默认策略，使用如下命令即可。</p><p><img src="22.png" alt="iptables详解（3）：iptables规则管理"></p><p>使用-t指定要操作的表，<strong>使用-P选项指定要修改的链</strong>，上例中，-P FORWARD DROP表示将表中FORWRD链的默认策略改为DROP。</p><h2 id="保存规则"><a href="#保存规则" class="headerlink" title="保存规则"></a>保存规则</h2><p><strong>在默认的情况下，我们对”防火墙”所做出的修改都是”临时的”，换句话说就是，当重启iptables服务或者重启服务器以后，我们平常添加的规则或者对规则所做出的修改都将消失</strong>，为了防止这种情况的发生，我们需要将规则”保存”。</p><p>centos7与centos6中的情况稍微有些不同，我们先说centos6中怎样保存iptables规则。</p><p><strong>centos6中</strong>，使用”<strong>service iptables save</strong>“命令即可保存规则，规则默认保存在<strong>/etc/sysconfig/iptables</strong>文件中，如果你刚刚安装完centos6，在刚开始使用iptables时，会发现filter表中会有一些默认的规则，这些默认提供的规则其实就保存在/etc/sysconfig/iptables中，  保存规则的示例如下。</p><p><img src="23.png" alt="iptables详解（3）：iptables规则管理"></p><p>如上图所示，文件中保存了filter表中每条链的默认策略，以及每条链中的规则，由于其他表中并没有设置规则，也没有使用过其他表，所以文件中只保存了filter表中的规则。</p><p>当我们对规则进行了修改以后，如果想要修改永久生效，必须使用<strong>service iptables save</strong>保存规则，当然，如果你误操作了规则，但是并没有保存，那么使用<strong>service iptables restart</strong>命令重启iptables以后，规则会再次回到上次保存/etc/sysconfig/iptables文件时的模样。</p><p>从现在开始，最好养成及时保存规则的好习惯。</p><p><strong>centos7中</strong>，已经不再使用init风格的脚本启动服务，而是使用unit文件，所以，在centos7中已经不能再使用类似service iptables start这样的命令了，所以service iptables save也无法执行，同时，在centos7中，使用<strong>firewall</strong>替代了原来的iptables service，不过不用担心，我们只要通过yum源安装iptables与iptables-services即可（iptables一般会被默认安装，但是iptables-services在centos7中一般不会被默认安装），在centos7中安装完iptables-services后，即可像centos6中一样，通过service iptables save命令保存规则了，规则同样保存在/etc/sysconfig/iptables文件中。</p><p>此处给出centos7中配置iptables-service的步骤</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">配置好yum源以后安装iptables-service</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> yum install -y iptables-services</span></span><br><span class="line"><span class="meta">#</span><span class="bash">停止firewalld</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl stop firewalld</span></span><br><span class="line"><span class="meta">#</span><span class="bash">禁止firewalld自动启动</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl <span class="built_in">disable</span> firewalld</span></span><br><span class="line"><span class="meta">#</span><span class="bash">启动iptables</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl start iptables</span></span><br><span class="line"><span class="meta">#</span><span class="bash">将iptables设置为开机自动启动，以后即可通过iptables-service控制iptables服务</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl <span class="built_in">enable</span> iptables</span></span><br></pre></td></tr></table></figure><p>上述配置过程只需一次，以后即可在centos7中愉快的使用service iptables save命令保存iptables规则了。</p><p><strong>其他通用方法</strong></p><p>还可以使用另一种方法保存iptables规则，就是使用<strong>iptables-save</strong>命令</p><p>使用iptables-save并不能保存当前的iptables规则，但是<strong>可以将当前的iptables规则以”保存后的格式”输出到屏幕上。</strong></p><p>所以，我们可以使用iptables-save命令，再配合重定向，将规则重定向到/etc/sysconfig/iptables文件中即可。</p><p><strong>iptables-save &gt; /etc/sysconfig/iptables</strong></p><p>我们也可以将/etc/sysconfig/iptables中的规则重新载入为当前的iptables规则，但是注意，未保存入/etc/sysconfig/iptables文件中的修改将会丢失或者被覆盖。</p><p>使用iptables-restore命令可以从指定文件中重载规则，示例如下</p><p>iptables-restore &lt; /etc/sysconfig/iptables</p><p>再次提醒：重载规则时，现有规则将会被覆盖。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自：&lt;a href=&quot;http://www.zsythink.net/archives/1517&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iptables详解（3）：iptables规则管理&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://changsk.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="iptables" scheme="http://changsk.top/tags/iptables/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-232:Implement Queue using Stacks(用栈实现队列)</title>
    <link href="http://changsk.top/2020/07/29/leetcode-232/"/>
    <id>http://changsk.top/2020/07/29/leetcode-232/</id>
    <published>2020-07-29T14:57:30.000Z</published>
    <updated>2020-07-29T15:00:05.295Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">Implement Queue using Stacks</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>题目难度：Easy</strong></p><p><strong>Implement the following operations of a queue using stacks.</strong></p><p>push(x) – Push element x to the back of queue.<br>pop() – Removes the element from in front of queue.<br>peek() – Get the front element.<br>empty() – Return whether the queue is empty.<br><strong>Example:</strong></p><p>MyQueue queue = new MyQueue();</p><p>queue.push(1);<br>queue.push(2);<br>queue.peek();  // returns 1<br>queue.pop();   // returns 1<br>queue.empty(); // returns false<br><strong>Notes:</strong></p><ul><li><p>You must use only standard operations of a stack – which means only push to top, peek/pop from top, size, and is empty operations are valid.</p></li><li><p>Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.</p></li><li><p>You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).</p></li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; inStack;</span><br><span class="line">    Stack&lt;Integer&gt; outStack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        outStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        inStack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (outStack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!inStack.isEmpty()) &#123;</span><br><span class="line">                outStack.push(inStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (outStack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!inStack.isEmpty()) &#123;</span><br><span class="line">                outStack.push(inStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> outStack.isEmpty() &amp;&amp; inStack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode-cn.com/problems/implement-queue-using-stacks/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Implement Queue using Stacks&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>iptables命令总结</title>
    <link href="http://changsk.top/2020/07/29/iptables-cmd/"/>
    <id>http://changsk.top/2020/07/29/iptables-cmd/</id>
    <published>2020-07-28T16:16:50.000Z</published>
    <updated>2020-08-01T14:09:29.891Z</updated>
    
    <content type="html"><![CDATA[<p>本文参考自：<a href="[http://www.zsythink.net/archives/category/%e8%bf%90%e7%bb%b4%e7%9b%b8%e5%85%b3/iptables/](http://www.zsythink.net/archives/category/运维相关/iptables/)">iptables</a></p><a id="more"></a><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t 表名 -L</span><br></pre></td></tr></table></figure><p>查看对应表的所有规则，-t选项指定要操作的表，省略”-t 表名”时，默认表示操作filter表，-L表示列出规则，即查看规则。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t 表名 -L 链名</span><br></pre></td></tr></table></figure><p>查看指定表的指定链中的规则。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t 表名 -v -L</span><br></pre></td></tr></table></figure><p>查看指定表的所有规则，并且显示更详细的信息（更多字段），-v表示verbose，表示详细的，冗长的，当使用-v选项时，会显示出”计数器”的信息，由于上例中使用的选项都是短选项，所以一般简写为iptables -t 表名 -vL</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t 表名 -n -L</span><br></pre></td></tr></table></figure><p>表示查看表的所有规则，并且在显示规则时，不对规则中的IP或者端口进行名称反解，-n选项表示不解析IP地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables --line-numbers -t 表名 -L</span><br></pre></td></tr></table></figure><p>表示查看表的所有规则，并且显示规则的序号，–line-numbers选项表示显示规则的序号，注意，此选项为长选项，不能与其他短选项合并，不过此选项可以简写为–line，注意，简写后仍然是两条横杠，仍然是长选项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t 表名 -v -x -L</span><br></pre></td></tr></table></figure><p>表示查看表中的所有规则，并且显示更详细的信息(-v选项)，不过，计数器中的信息显示为精确的计数值，而不是显示为经过可读优化的计数值，-x选项表示显示计数器的精确值。</p><h2 id="添加规则"><a href="#添加规则" class="headerlink" title="添加规则"></a>添加规则</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命令语法：iptables -t 表名 -A 链名 匹配条件 -j 动作</span><br><span class="line">示例：iptables -t filter -A INPUT -s 192.168.1.146 -j DROP</span><br></pre></td></tr></table></figure><p>在指定表的指定链的尾部添加一条规则，-A选项表示在对应链的末尾添加规则，省略-t选项时，表示默认操作filter表中的规则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命令语法：iptables -t 表名 -I 链名 匹配条件 -j 动作</span><br><span class="line">示例：iptables -t filter -I INPUT -s 192.168.1.146 -j ACCEPT</span><br></pre></td></tr></table></figure><p>在指定表的指定链的首部添加一条规则，-I选型表示在对应链的开头添加规则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命令语法：iptables -t 表名 -I 链名 规则序号 匹配条件 -j 动作</span><br><span class="line">示例：iptables -t filter -I INPUT 5 -s 192.168.1.146 -j REJECT</span><br></pre></td></tr></table></figure><p>在指定表的指定链的指定位置添加一条规则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命令语法：iptables -t 表名 -P 链名 动作</span><br><span class="line">示例：iptables -t filter -P FORWARD ACCEPT</span><br></pre></td></tr></table></figure><p>设置指定表的指定链的默认策略（默认动作），并非添加规则。<br>上例表示将filter表中FORWARD链的默认策略设置为ACCEPT</p><h2 id="删除规则"><a href="#删除规则" class="headerlink" title="删除规则"></a>删除规则</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命令语法：iptables -t 表名 -D 链名 规则序号</span><br><span class="line">示例：iptables -t filter -D INPUT 3</span><br></pre></td></tr></table></figure><p>按照规则序号删除规则，删除指定表的指定链的指定规则，-D选项表示删除对应链中的规则。<br>上述示例表示删除filter表中INPUT链中序号为3的规则。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命令语法：iptables -t 表名 -D 链名 匹配条件 -j 动作</span><br><span class="line">示例：iptables -t filter -D INPUT -s 192.168.1.146 -j DROP</span><br></pre></td></tr></table></figure><p>按照具体的匹配条件与动作删除规则，删除指定表的指定链的指定规则。<br>上述示例表示删除filter表中INPUT链中源地址为192.168.1.146并且动作为DROP的规则。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命令语法：iptables -t 表名 -F 链名</span><br><span class="line">示例：iptables -t filter -F INPUT</span><br></pre></td></tr></table></figure><p>删除指定表的指定链中的所有规则，-F选项表示清空对应链中的规则，执行时需三思。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命令语法：iptables -t 表名 -F</span><br><span class="line">示例：iptables -t filter -F</span><br></pre></td></tr></table></figure><p>删除指定表中的所有规则，执行时需三思。</p><h2 id="修改规则"><a href="#修改规则" class="headerlink" title="修改规则"></a>修改规则</h2><p>注意点：如果使用-R选项修改规则中的动作，那么必须指明原规则中的原匹配条件，例如源IP，目标IP等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命令语法：iptables -t 表名 -R 链名 规则序号 规则原本的匹配条件 -j 动作</span><br><span class="line">示例：iptables -t filter -R INPUT 3 -s 192.168.1.146 -j ACCEPT</span><br></pre></td></tr></table></figure><p>修改指定表中指定链的指定规则，-R选项表示修改对应链中的规则，使用-R选项时要同时指定对应的链以及规则对应的序号，并且规则中原本的匹配条件不可省略。<br>上述示例表示修改filter表中INPUT链的第3条规则，将这条规则的动作修改为ACCEPT， -s 192.168.1.146为这条规则中原本的匹配条件，如果省略此匹配条件，修改后的规则中的源地址可能会变为0.0.0.0/0。</p><p>其他修改规则的方法：先通过编号删除规则，再在原编号位置添加一条规则。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命令语法：iptables -t 表名 -P 链名 动作</span><br><span class="line">示例：iptables -t filter -P FORWARD ACCEPT</span><br></pre></td></tr></table></figure><p>修改指定表的指定链的默认策略（默认动作），并非修改规则，可以使用如下命令。<br>上例表示将filter表中FORWARD链的默认策略修改为ACCEPT</p><h2 id="保存规则"><a href="#保存规则" class="headerlink" title="保存规则"></a>保存规则</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service iptables save</span><br></pre></td></tr></table></figure><p>保存规则命令如上，表示将iptables规则保存至/etc/sysconfig/iptables文件中</p><p>注意点：centos7中使用默认使用firewalld，如果想要使用上述命令保存规则，需要安装iptables-services。</p><p>或者使用如下方法保存规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables-save &gt; /etc/sysconfig/iptables</span><br></pre></td></tr></table></figure><p>可以使用如下命令从指定的文件载入规则，注意：重载规则时，文件中的规则将会覆盖现有规则。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables-restore &lt; /etc/sysconfig/iptables</span><br></pre></td></tr></table></figure><h2 id="基本匹配条件总结"><a href="#基本匹配条件总结" class="headerlink" title="基本匹配条件总结"></a>基本匹配条件总结</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -I INPUT -s 192.168.1.111,192.168.1.118 -j DROP</span><br><span class="line">iptables -t filter -I INPUT -s 192.168.1.0/24 -j ACCEPT</span><br><span class="line">iptables -t filter -I INPUT ! -s 192.168.1.0/24 -j ACCEPT</span><br></pre></td></tr></table></figure><p>-s用于匹配报文的源地址,可以同时指定多个源地址，每个IP之间用逗号隔开，也可以指定为一个网段。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -I OUTPUT -d 192.168.1.111,192.168.1.118 -j DROP</span><br><span class="line">iptables -t filter -I INPUT -d 192.168.1.0/24 -j ACCEPT</span><br><span class="line">iptables -t filter -I INPUT ! -d 192.168.1.0/24 -j ACCEPT</span><br></pre></td></tr></table></figure><p>-d用于匹配报文的目标地址,可以同时指定多个目标地址，每个IP之间用逗号隔开，也可以指定为一个网段。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -I INPUT -p tcp -s 192.168.1.146 -j ACCEPT</span><br><span class="line">iptables -t filter -I INPUT ! -p udp -s 192.168.1.146 -j ACCEPT</span><br></pre></td></tr></table></figure><p>-p用于匹配报文的协议类型,可以匹配的协议类型tcp、udp、udplite、icmp、esp、ah、sctp等（centos7中还支持icmpv6、mh）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -I INPUT -p icmp -i eth4 -j DROP</span><br><span class="line">iptables -t filter -I INPUT -p icmp ! -i eth4 -j DROP</span><br></pre></td></tr></table></figure><p>-i用于匹配报文是从哪个网卡接口流入本机的，由于匹配条件只是用于匹配报文流入的网卡，所以在OUTPUT链与POSTROUTING链中不能使用此选项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -I OUTPUT -p icmp -o eth4 -j DROP</span><br><span class="line">iptables -t filter -I OUTPUT -p icmp ! -o eth4 -j DROP</span><br></pre></td></tr></table></figure><p>-o用于匹配报文将要从哪个网卡接口流出本机，于匹配条件只是用于匹配报文流出的网卡，所以在INPUT链与PREROUTING链中不能使用此选项。</p><h2 id="扩展匹配条件总结"><a href="#扩展匹配条件总结" class="headerlink" title="扩展匹配条件总结"></a>扩展匹配条件总结</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -I OUTPUT -d 192.168.1.146 -p tcp -m tcp --sport 22 -j REJECT</span><br><span class="line">iptables -t filter -I INPUT -s 192.168.1.146 -p tcp -m tcp --dport 22:25 -j REJECT</span><br><span class="line">iptables -t filter -I INPUT -s 192.168.1.146 -p tcp -m tcp --dport :22 -j REJECT</span><br><span class="line">iptables -t filter -I INPUT -s 192.168.1.146 -p tcp -m tcp --dport 80: -j REJECT</span><br><span class="line">iptables -t filter -I OUTPUT -d 192.168.1.146 -p tcp -m tcp ! --sport 22 -j ACCEPT</span><br></pre></td></tr></table></figure><p>tcp扩展模块</p><p>常用的扩展匹配条件如下：</p><p>-p tcp -m tcp –sport 用于匹配tcp协议报文的源端口，可以使用冒号指定一个连续的端口范围</p><p>-p tcp -m tcp –dport 用于匹配tcp协议报文的目标端口，可以使用冒号指定一个连续的端口范围</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -I OUTPUT -d 192.168.1.146 -p udp -m multiport --sports 137,138 -j REJECT</span><br><span class="line">iptables -t filter -I INPUT -s 192.168.1.146 -p tcp -m multiport --dports 22,80 -j REJECT</span><br><span class="line">iptables -t filter -I INPUT -s 192.168.1.146 -p tcp -m multiport ! --dports 22,80 -j REJECT</span><br><span class="line">iptables -t filter -I INPUT -s 192.168.1.146 -p tcp -m multiport --dports 80:88 -j REJECT</span><br><span class="line">iptables -t filter -I INPUT -s 192.168.1.146 -p tcp -m multiport --dports 22,80:88 -j REJECT</span><br></pre></td></tr></table></figure><p>multiport扩展模块</p><p>常用的扩展匹配条件如下：</p><p>-p tcp -m multiport –sports 用于匹配报文的源端口，可以指定离散的多个端口号,端口之间用”逗号”隔开</p><p>-p udp -m multiport –dports 用于匹配报文的目标端口，可以指定离散的多个端口号，端口之间用”逗号”隔开</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文参考自：&lt;a href=&quot;[http://www.zsythink.net/archives/category/%e8%bf%90%e7%bb%b4%e7%9b%b8%e5%85%b3/iptables/](http://www.zsythink.net/archives/category/运维相关/iptables/)&quot;&gt;iptables&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://changsk.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="iptables" scheme="http://changsk.top/tags/iptables/"/>
    
  </entry>
  
  <entry>
    <title>iptables详解（2）：iptables实际操作之规则查询</title>
    <link href="http://changsk.top/2020/07/29/iptables-2/"/>
    <id>http://changsk.top/2020/07/29/iptables-2/</id>
    <published>2020-07-28T16:05:13.000Z</published>
    <updated>2020-07-28T16:25:52.333Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="http://www.zsythink.net/archives/1493" target="_blank" rel="noopener">iptables详解（2）：iptables实际操作之规则查询</a></p><a id="more"></a><p>在进行iptables实验时，请务必在测试机上进行。</p><p>之前在iptables的概念中已经提到过，在实际操作iptables的过程中，是<strong>以”表”作为操作入口的</strong>，如果你经常操作关系型数据库，那么当你听到”表”这个词的时候，你可能会联想到另一个词—-“增删改查”，当我们定义iptables规则时，所做的操作其实类似于”增删改查”，那么，我们就先从最简单的”查”操作入手，开始实际操作iptables。</p><p>在之前的文章中，我们已经总结过，iptables为我们预定义了4张表，它们分别是<strong>raw表、mangle表、nat表、filter</strong>表，不同的表拥有不同的功能。</p><p><strong>filter负责过滤功能，比如允许哪些IP地址访问，拒绝哪些IP地址访问，允许访问哪些端口，禁止访问哪些端口</strong>，filter表会根据我们定义的规则进行过滤，filter表应该是我们最常用到的表了，所以此处，我们以filter表为例，开始学习怎样实际操作iptables。</p><p>怎样查看filter表中的规则呢？使用如下命令即可查看。</p><p><img src="1.png" alt="iptables详解（2）：iptables实际操作之规则查询"></p><p>上例中，我们<strong>使用-t选项，指定要操作的表，使用-L选项，查看-t选项对应的表的规则，-L选项的意思是，列出规则</strong>，所以，上述命令的含义为列出filter表的所有规则，注意，上图中显示的规则（绿色标注的部分为规则）是Centos6启动iptables以后默认设置的规则，我们暂且不用在意它们，上图中，显示出了3条链（蓝色标注部分为链），INPUT链、FORWARD链、OUTPUT链，每条链中都有自己的规则，前文中，我们打过一个比方，把”链”比作”关卡”，不同的”关卡”拥有不同的能力，所以，从上图中可以看出，INPUT链、FORWARD链、OUTPUT链都拥有”过滤”的能力，所以，<strong>当我们要定义某条”过滤”的规则时，我们会在filter表中定义，但是具体在哪条”链”上定义规则呢？这取决于我们的工作场景。</strong>比如，我们需要禁止某个IP地址访问我们的主机，我们则需要在INPUT链上定义规则。因为，我们在理论总结中已经提到过，报文发往本机时，会经过PREROUTING链与INPUT链（如果你没有明白，请回顾前文），所以，如果我们想要禁止某些报文发往本机，我们只能在PREROUTING链和INPUT链中定义规则，但是<strong>PREROUTING链并不存在于filter表</strong>中，换句话说就是，<strong>PREROUTING关卡天生就没有过滤的能力</strong>，所以，我们只能在INPUT链中定义，当然，如果是其他工作场景，可能需要在FORWARD链或者OUTPUT链中定义过滤规则。</p><p>话说回来，我们继续聊怎样查看某张表中的规则。</p><p>刚才提到，我们可以使用iptables -t filter -L命令列出filter表中的所有规则，那么举一反三，我们也可以查看其它表中的规则，示例如下。</p><p>iptables -t raw -L</p><p>iptables -t mangle -L</p><p>iptables -t nat -L</p><p>其实，我们可以省略-t filter，<strong>当没有使用-t选项指定表时，默认为操作filter表</strong>，即iptables -L表示列出filter表中的所有规则。</p><p>我们还可以只查看指定表中的指定链的规则，比如，我们只查看filter表中INPUT链的规则，示例如下（注意大小写）。</p><p><img src="2.png" alt="iptables详解（2）：iptables实际操作之规则查询"></p><p>上图中只显示了filter表中INPUT链中的规则（省略-t选项默认为filter表），当然，你也可以指定只查看其他链，其实，我们查看到的信息还不是最详细的信息，我们可以<strong>使用-v选项，查看出更多的、更详细的信息</strong>，示例如下。</p><p><img src="3.png" alt="iptables详解（2）：iptables实际操作之规则查询"></p><p>可以看到，使用-v选项后，iptables为我们展示的信息更多了，那么，这些字段都是什么意思呢？我们来总结一下，看不懂没关系，等到实际使用的时候，自然会明白，此处大概了解一下即可。</p><p>其实，这些字段就是规则对应的属性，说白了就是规则的各种信息，那么我们来总结一下这些字段的含义。</p><p><strong>pkts</strong>:对应规则匹配到的报文的个数。</p><p><strong>bytes</strong>:对应匹配到的报文包的大小总和。</p><p><strong>target</strong>:规则对应的target，往往表示规则对应的”动作”，即<strong>规则匹配成功后需要采取的措施。</strong></p><p><strong>prot</strong>:表示规则对应的协议，是否只针对某些协议应用此规则。</p><p><strong>opt</strong>:表示规则对应的选项。</p><p><strong>in</strong>:<strong>表示数据包由哪个接口(网卡)流入</strong>，我们可以设置通过哪块网卡流入的报文需要匹配当前规则。</p><p><strong>out</strong>:<strong>表示数据包由哪个接口(网卡)流出</strong>，我们可以设置通过哪块网卡流出的报文需要匹配当前规则。</p><p><strong>source</strong>:表示规则对应的源头地址，<strong>可以是一个IP，也可以是一个网段。</strong></p><p><strong>destination</strong>:表示规则对应的目标地址。可以是一个IP，也可以是一个网段。</p><p>细心如你一定发现了，上图中的源地址与目标地址都为anywhere，看来，iptables默认为我们进行了名称解析，但是在规则非常多的情况下如果进行名称解析，效率会比较低，所以，在没有此需求的情况下，我们可以<strong>使用-n选项，表示不对IP地址进行名称反解，直接显示IP地址</strong>，示例如下。</p><p><img src="4.png" alt="iptables详解（2）：iptables实际操作之规则查询"></p><p>如上图所示，规则中的源地址与目标地址已经显示为IP，而非转换后的名称。</p><p>当然，我们也可以只查看某个链的规则，并且不让IP进行反解，这样更清晰一些，比如 iptables -nvL INPUT</p><p>如果你习惯了查看有序号的列表，你在查看iptables表中的规则时肯定会很不爽，没有关系，满足你，<strong>使用–line-numbers即可显示规则的编号</strong>，示例如下。</p><p><img src="5.png" alt="iptables详解（2）：iptables实际操作之规则查询"></p><p>–line-numbers选项并没有对应的短选项，不过我们缩写成–line时，centos中的iptables也可以识别。</p><p>我知道你目光如炬，你可能早就发现了，表中的每个链的后面都有一个括号，括号里面有一些信息，如下图红色标注位置，那么这些信息都代表了什么呢？我们来看看。</p><p><img src="6.png" alt="iptables详解（2）：iptables实际操作之规则查询"></p><p>上图中INPUT链后面的括号中包含policy ACCEPT ，0 packets，0bytes 三部分。</p><p><strong>policy</strong>表示<strong>当前链的默认策略</strong>，policy ACCEPT表示上图中INPUT的链的默认动作为ACCEPT，换句话说就是，默认接受通过INPUT关卡的所有请求，所以我们在配置INPUT链的具体规则时，应该将需要拒绝的请求配置到规则中，说白了就是”<strong>黑名单</strong>“机制，默认所有人都能通过，只有指定的人不能通过，当我们把INPUT链默认动作设置为接受(ACCEPT)，就表示所有人都能通过这个关卡，此时就应该在具体的规则中指定需要拒绝的请求，就表示只有指定的人不能通过这个关卡，这就是黑名单机制，<strong>但是</strong>，你一定发现了，上图中所显示出的规则，大部分都是接受请求(ACCEPT)，并不是想象中的拒绝请求(DROP或者REJECT)，这与我们所描述的黑名单机制不符啊，按照道理来说，默认动作为接受，就应该在具体的规则中配置需要拒绝的人，但是上图中并不是这样的，之所以出现上图中的情况，是因为IPTABLES的工作机制导致到，上例其实是利用了这些”机制”，完成了所谓的”白名单”机制，并不是我们所描述的”黑名单”机制，我们此处暂时不用关注这一点，之后会进行详细的举例并解释，此处我们只要明白policy对应的动作为链的默认动作即可，或者换句话说，我们只要理解，policy为链的默认策略即可。</p><p><strong>packets</strong>表示当前链（上例为INPUT链）默认策略匹配到的包的数量，0 packets表示默认策略匹配到0个包。</p><p><strong>bytes</strong>表示当前链默认策略匹配到的所有包的大小总和。</p><p>其实，我们可以<strong>把packets与bytes称作”计数器”</strong>，上图中的计数器记录了默认策略匹配到的报文数量与总大小，<strong>“计数器”只会在使用-v选项时，才会显示出来。</strong></p><p><strong>当被匹配到的包达到一定数量时，计数器会自动将匹配到的包的大小转换为可读性较高的单位</strong>，如下图所示。</p><p><img src="7.png" alt="iptables详解（2）：iptables实际操作之规则查询"></p><p>如果你想要查看精确的计数值，而不是经过可读性优化过的计数值，那么你可以<strong>使用-x选项，表示显示精确的计数值</strong>，示例如下。</p><p><img src="8.png" alt="iptables详解（2）：iptables实际操作之规则查询"></p><p>每张表中的每条链都有自己的计数器，链中的每个规则也都有自己的计数器，没错，就是每条规则对应的pkts字段与bytes字段的信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自：&lt;a href=&quot;http://www.zsythink.net/archives/1493&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iptables详解（2）：iptables实际操作之规则查询&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://changsk.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="iptables" scheme="http://changsk.top/tags/iptables/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-1292:Maximum Side Length of a Square with Sum Less than or Equal to Threshold(元素和小于等于阈值的正方形的最大边长)</title>
    <link href="http://changsk.top/2020/07/28/leetcode-1292/"/>
    <id>http://changsk.top/2020/07/28/leetcode-1292/</id>
    <published>2020-07-28T15:17:56.000Z</published>
    <updated>2020-07-28T15:44:24.984Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/" target="_blank" rel="noopener">Maximum Side Length of a Square with Sum Less than or Equal to Threshold</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>题目难度：Medium</strong></p><p>Given a m x n matrix mat and an integer threshold. Return the maximum side-length of a square with a sum less than or equal to threshold or return 0 if there is no such square.</p><p><strong>Example 1:</strong></p><p>Input: mat = [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold = 4<br><strong>Output: 2</strong><br>Explanation: The maximum side length of square with sum less than 4 is 2 as shown.</p><p><strong>Example 2:</strong></p><p>Input: mat = [[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]], threshold = 1<br><strong>Output: 0</strong></p><p><strong>Example 3:</strong></p><p>Input: mat = [[1,1,1,1],[1,0,0,0],[1,0,0,0],[1,0,0,0]], threshold = 6<br><strong>Output: 3</strong></p><p><strong>Example 4:</strong></p><p>Input: mat = [[18,70],[61,1],[25,85],[14,40],[11,96],[97,96],[63,45]], threshold = 40184<br><strong>Output: 2</strong></p><p><strong>Constraints:</strong></p><ul><li>1 &lt;= m, n &lt;= 300</li><li>m == mat.length</li><li>n == mat[i].length</li><li>0 &lt;= mat[i][j] &lt;= 10000</li><li>0 &lt;= threshold &lt;= 10^5</li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>参考自：<a href="https://leetcode-cn.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/solution/jian-dan-qian-zhui-he-bi-xu-miao-dong-by-li-zhuo-2/" target="_blank" rel="noopener">简单前缀和</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSideLength</span><span class="params">(<span class="keyword">int</span>[][] mat, <span class="keyword">int</span> threshold)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = mat.length;</span><br><span class="line">        <span class="keyword">int</span> m = mat[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> [][]dp = <span class="keyword">new</span> <span class="keyword">int</span> [n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                dp[i][j] = mat[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>] - dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = ans; (i + k &lt;= n) &amp;&amp; (j + k &lt;= m);)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = dp[i + k][j + k] - dp[i - <span class="number">1</span>][j + k] - </span><br><span class="line">                           dp[i + k][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(temp &lt;= threshold) &#123;</span><br><span class="line">                        ans++;</span><br><span class="line">                        k++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Maximum Side Length of a Square with Sum Less than or Equal to Threshold&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-870:advantage-shuffle(优势洗牌)</title>
    <link href="http://changsk.top/2020/07/27/leetcode-870/"/>
    <id>http://changsk.top/2020/07/27/leetcode-870/</id>
    <published>2020-07-27T14:34:38.000Z</published>
    <updated>2020-07-27T14:38:40.731Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/advantage-shuffle/" target="_blank" rel="noopener"><a href="https://leetcode-cn.com/problems/advantage-shuffle/" target="_blank" rel="noopener">优势洗牌</a></a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>题目难度：Medium</strong></p><p>给定两个大小相等的数组 A 和 B，A 相对于 B 的优势可以用满足 <code>A[i] &gt; B[i]</code>的索引 i 的数目来描述。</p><p>返回 A 的任意排列，使其相对于 B 的优势最大化。</p><p><strong>示例 1：</strong></p><p>输入：A = [2,7,11,15], B = [1,10,4,11]<br>输出：[2,11,7,15]<br><strong>示例 2：</strong></p><p>输入：A = [12,24,8,32], B = [13,25,32,11]<br>输出：[24,32,8,12]</p><p><strong>提示：</strong></p><ul><li>1 &lt;= A.length = B.length &lt;= 10000</li><li>0 &lt;= A[i] &lt;= 10^9</li><li>0 &lt;= B[i] &lt;= 10^9</li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>参考自：<a href="https://leetcode-cn.com/problems/advantage-shuffle/solution/tian-ji-sai-ma-kan-de-bie-ren-de-ti-jie-by-wang-22/" target="_blank" rel="noopener">田忌赛马</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] advantageCount(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = b.length;</span><br><span class="line">        Arrays.sort(a);</span><br><span class="line">        <span class="keyword">int</span>[][] pair = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">            pair[i] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;b[i], i&#125;;<span class="comment">//把下标保存下来</span></span><br><span class="line">        Arrays.sort(pair, (x, y)-&gt;x[<span class="number">0</span>] - y[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, r = n - <span class="number">1</span>, l = <span class="number">0</span>; i &lt; n; i ++)<span class="comment">//r最大值，l标明最小值；</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt;= pair[l][<span class="number">0</span>]) res[pair[r --][<span class="number">1</span>]] = a[i];<span class="comment">//要放到原数组对应的位置上</span></span><br><span class="line">            <span class="keyword">else</span> res[pair[l ++][<span class="number">1</span>]] = a[i];<span class="comment">////要放到原数组对应的位置上</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode-cn.com/problems/advantage-shuffle/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/advantage-shuffle/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;优势洗牌&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-225:implement-stack-using-queues(用队列实现栈)</title>
    <link href="http://changsk.top/2020/07/24/leetcode-225/"/>
    <id>http://changsk.top/2020/07/24/leetcode-225/</id>
    <published>2020-07-23T16:40:21.000Z</published>
    <updated>2020-07-23T16:43:43.527Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">225. 用队列实现栈</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>题目难度：Easy</strong></p><p>使用队列实现栈的下列操作：</p><p>push(x) – 元素 x 入栈<br>pop() – 移除栈顶元素<br>top() – 获取栈顶元素<br>empty() – 返回栈是否为空<br><strong>注意:</strong></p><p>你只能使用队列的基本操作– 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。<br>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</p><blockquote><p>只能使用队列的基本操作，也就是说只能用往尾巴push，从头peek或者pop，以及判断的操作</p></blockquote><p>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; list;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list = <span class="keyword">new</span>  LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = list.size();</span><br><span class="line">        list.addLast(x);</span><br><span class="line">        <span class="keyword">while</span> (len != <span class="number">0</span>) &#123;</span><br><span class="line">            list.addLast(list.removeFirst());</span><br><span class="line">            len --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.peekFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode-cn.com/problems/implement-stack-using-queues/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;225. 用队列实现栈&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>iptables与netfilter</title>
    <link href="http://changsk.top/2020/07/23/iptables-netfilter/"/>
    <id>http://changsk.top/2020/07/23/iptables-netfilter/</id>
    <published>2020-07-23T15:10:07.000Z</published>
    <updated>2020-07-24T15:32:41.454Z</updated>
    
    <content type="html"><![CDATA[<p><code>netfilter</code>是 Linux 内置的一种防火墙机制，我们一般也称之为<strong>数据包过滤机制</strong>。<code>iptables</code>则是一个<strong>命令行工具，用来配置 netfilter 防火墙</strong>。下图展示了一个带有防火墙的简单网络拓扑结构：</p><a id="more"></a><p><img src="1.png" alt="img"></p><p>图中的 Linux 主机既充当了路由器的角色，同时又充当了防火墙的角色。</p><h1 id="netfilter-与-iptables-的关系"><a href="#netfilter-与-iptables-的关系" class="headerlink" title="netfilter 与 iptables 的关系"></a>netfilter 与 iptables 的关系</h1><p><code>netfilter</code>指整个项目，其官网叫 <a href="https://netfilter.org/" target="_blank" rel="noopener">netfilter.org</a>。在这个项目里面，<code>netfilter</code> 特指内核中的 <strong>netfilter 框架</strong>，iptables 指运行在<strong>用户态</strong>的<strong>配置工具</strong>。</p><p>netfilter在协议栈中添加了5个<strong>钩子</strong>，允许内核模块在这些钩子的地方<strong>注册回调函数</strong>，这样经过钩子的所有数据包都会被注册在相应钩子上的函数所处理，包括<strong>修改数据包内容、给数据包打标记或者丢掉数据包</strong>等。</p><p><strong>netfilter框架负责维护钩子上注册的处理函数或者模块</strong>，以及它们的优先级。</p><p><strong>iptables是用户空间的一个程序，通过netlink和内核的netfilter框架打交道，负责往钩子上配置回调函数。</strong></p><p>netfilter框架负责在需要的时候动态加载其它的内核模块，比如 ip_conntrack、nf_conntrack、NAT subsystem等。</p><blockquote><p>Netlink是linux提供的用于内核和用户态进程之间的通信方式。</p><p>虽然Netlink主要用于用户空间和内核空间的通信，但是也能用于用户空间的两个进程通信。只是进程间通信有其他很多方式，一般不用Netlink。除非需要用到Netlink的广播特性时。</p><p>netlink具有以下特点：支持全双工、异步通信(当然同步也支持)、支持多播(因此支持“总线”式通信，可实现消息订阅)</p></blockquote><h1 id="netfilter-防火墙原理"><a href="#netfilter-防火墙原理" class="headerlink" title="netfilter 防火墙原理"></a>netfilter 防火墙原理</h1><p>简单说 <code>netfilter</code> 机制就是<strong>对进出主机的数据包进行过滤</strong>。 我们可以通过<code>iptables</code> 设置一些规则(rules)。所有进出主机的数据包都会按照一定的顺序匹配这些规则，如果匹配到某条规则，就执行这条规则对应的行为，比如抛弃该数据包或接受该数据包。下图展示了 <code>netfilter</code> 依据 <code>iptables</code>     规则对数据包过滤的大致过程：</p><p><img src="2.png" alt="img"></p><p>对数据包进行过滤。检查通过则接受(ACCEPT)数据包进入主机获取资源，如果检查不通过，则予以丢弃(DROP)！如果所有的规则都没有匹配上，就通过<strong>默认的策略</strong>(Policy)决定数据包的去向。注意，上图中的规则是有顺序的！</p><p>下面我们看一个例子。假设我们的 Linux 主机提供了 web 服务，所以需要放行访问 80 端口的数据包。<br>但是你发现来自 <code>13.76.1.65</code> 的数据包总是恶意的尝试入侵我们的 web 服务器，所以需要丢弃来自 <code>13.76.1.65</code>数据包。<br>我们的 web 服务器并不提供 web 服务之外的其它服务，所以直接丢弃所有的非 web 请求的数据包。<br>总结后就是我们需要下面三条规则：</p><ul><li>rule1 丢弃来自 13.76.1.65 数据包</li><li>rule2 接受访问 web 服务的数据包</li><li>rule3 丢弃所有的数据包</li></ul><p>如果我们不小心把上面的规则顺序写错了，比如写成了下面的样子：</p><ul><li>rule1 接受访问 web 服务的数据包</li><li>rule2 丢弃来自 13.76.1.65 数据包</li><li>rule3 丢弃所有的数据包</li></ul><p>这时来自 13.76.1.65 的数据包是可以访问 web 服务的，因为来自 13.76.1.65 的数据包是符合第一条规则的，所以会被接受，此时就不会再考虑第二条规则了。</p><h1 id="iptables-中的-table-与-chain"><a href="#iptables-中的-table-与-chain" class="headerlink" title="iptables 中的 table 与 chain"></a>iptables 中的 table 与 chain</h1><p><code>iptables</code> 用表(table)来分类管理它的规则(rule)，这也是 <code>iptables</code> 名称的由来。根据 rule 的作用分成了好几个表，比如<strong>用来过滤数据包的 rule 就会放到 filter 表中，用于处理地址转换的 rule 就会放到 nat 表中</strong>，其中 <strong>rule 就是应用在 netfilter 钩子上的函数</strong>，用来修改数据包的内容或过滤数据包。下面简单的介绍下常用的表。Filter</p><p>从名字就可以看出，这个表里面的rule主要用来过滤数据，用来控制让哪些数据可以通过，哪些数据不能通过，它是最常用的表。</p><h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p>里面的rule都是用来处理网络地址转换的，控制要不要进行地址转换，以及怎样修改源地址或目的地址，从而影响数据包的路由，达到连通的目的，这是家用路由器必备的功能。</p><h2 id="Mangle"><a href="#Mangle" class="headerlink" title="Mangle"></a>Mangle</h2><p>里面的rule主要用来修改IP数据包头，比如修改TTL值，同时也用于给数据包添加一些标记，从而便于后续其它模块对数据包进行处理（这里的添加标记是指往内核skb结构中添加标记，而不是往真正的IP数据包上加东西）。</p><h2 id="Raw"><a href="#Raw" class="headerlink" title="Raw"></a>Raw</h2><p>在netfilter里面有一个叫做connection tracking的功能（后面会介绍到），主要用来追踪所有的连接，而raw表里的rule的功能是给数据包打标记，从而控制哪些数据包不被connection tracking所追踪。</p><h2 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h2><p>里面的rule跟SELinux有关，主要是在数据包上设置一些SELinux的标记，便于跟SELinux相关的模块来处理该数据包。</p><p>下图展示了 iptables 中常用的 tables 及其 rule chains：</p><p><img src="3.png" alt="img"></p><p>从上图可以看出，filter 和 nat 表中默认都存在着数条 rule chain。也就是说表中的规则(rule)又被编入了不同的链(chain)，<strong>由 chain 来决定什么时候触发 chain 上的这些规则</strong>。iptables 里面有 5 个内置的 chain：</p><ul><li>PREROUTING：<strong>接收的数据包刚进来，还没有经过路由选择，即还不知道数据包是要发给本机还是其它机器</strong>。这时会触发该 chain 上的规则。</li><li>INPUT：<strong>已经经过路由选择，并且该数据包的目的 IP 是本机</strong>，进入本地数据包处理流程。此时会触发该 chain 上的规则。</li><li>FORWARD：<strong>已经经过路由选择，但该数据包的目的 IP 不是本机</strong>，而是其它机器，进入 forward 流程。此时会触发该 chain 上的规则。</li><li>OUTPUT：<strong>本地程序要发出去的数据包刚到 IP 层，还没进行路由选择</strong>。此时会触发该 chain 上的规则。</li><li>POSTROUTING：<strong>本地程序发出去的数据包，或者转发(forward)的数据包已经经过了路由选择</strong>，即将交由下层发送出去。此时会触发该 chain 上的规则。</li></ul><p>每个表里面都可以包含多个chains，但并不是每个表都能包含所有的chains，因为某些表在某些chain上没有意义或者有些多余，比如说raw表，它只有在connection tracking之前才有意义，所以它里面包含connection tracking之后的chain就没有意义。</p><h1 id="iptables-中的规则-rules"><a href="#iptables-中的规则-rules" class="headerlink" title="iptables 中的规则(rules)"></a>iptables 中的规则(rules)</h1><p>规则(rules)存放在特定表的特定 chain 上，每条 rule 包含下面两部分信息：</p><p><strong>Matching</strong><br>Matching 就是如何匹配一个数据包，匹配条件很多，比如协议类型、源/目的IP、源/目的端口、in/out接口、包头里面的数据以及连接状态等，这些条件可以任意组合从而实现复杂情况下的匹配。</p><p><strong>Targets</strong><br>Targets 就是找到匹配的数据包之后怎么办，常见的有下面几种：</p><ul><li>DROP：直接将数据包丢弃，不再进行后续的处理</li><li>RETURN： 跳出当前 chain，该 chain 里后续的 rule 不再执行</li><li>QUEUE： 将数据包放入用户空间的队列，供用户空间的程序处理</li><li>ACCEPT： 同意数据包通过，继续执行后续的 rule</li><li>跳转到其它用户自定义的 chain 继续执行</li></ul><p>比如下面的规则，只要是来自内网的(192.168.1.0/24)数据包都被接受：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo iptables -A INPUT -i eth0 -s 192.168.1.0/24 -j ACCEPT</span><br></pre></td></tr></table></figure><h1 id="连接追踪（Connection-Tracking）"><a href="#连接追踪（Connection-Tracking）" class="headerlink" title="连接追踪（Connection Tracking）"></a>连接追踪（Connection Tracking）</h1><p>一旦开启该功能，Connection Tracking模块将会追踪每个数据包（被raw表中的rule标记过的除外），维护所有的连接状态，然后这些状态可以供其它表中的rule引用，用户空间的程序也可以通过/proc/net/ip_conntrack来获取连接信息。下面是所有的连接状态：</p><blockquote><p>这里的连接不仅仅是TCP的连接，两台设备的进程用UDP和ICMP（ping）通信也会被认为是一个连接</p></blockquote><ul><li>NEW: 当检测到一个不和任何现有连接关联的新包时，如果该包是一个合法的建立连接的数据包（比如TCP的sync包或者任意的UDP包），一个新的连接将会被保存，并且标记为状态NEW。</li><li>ESTABLISHED: 对于状态是NEW的连接，当检测到一个相反方向的包时，连接的状态将会由NEW变成ESTABLISHED，表示连接成功建立。对于TCP连接，意味着收到了一个SYN/ACK包， 对于UDP和ICMP，任何反方向的包都可以。</li><li>RELATED: 数据包不属于任何现有的连接，但它跟现有的状态为ESTABLISHED的连接有关系，对于这种数据包，将会创建一个新的连接，且状态被标记为RELATED。这种连接一般是辅助连接，比如FTP的数据传输连接（FTP有两个连接，另一个是控制连接），或者和某些连接有关的ICMP报文。</li><li>INVALID: 数据包不和任何现有连接关联，并且不是一个合法的建立连接的数据包，对于这种连接，将会被标记为INVALID，一般这种都是垃圾数据包，比如收到一个TCP的RST包，但实际上没有任何相关的TCP连接，或者别的地方误发过来的ICMP包。</li><li>UNTRACKED: 被raw表里面的rule标记为不需要tracking的数据包，这种连接将会标记成UNTRACKED。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>netfilter/iptables 是当前 Linux 系统的主要防火墙机制，学习并掌握它可以为我们使用 Linux 系统打下坚实的基础。</p><blockquote><p>参考：<br><a href="https://www.cnblogs.com/sparkdev/p/9328713.html" target="_blank" rel="noopener">netfilter/iptables 简介</a><br><a href="https://segmentfault.com/a/1190000009043962" target="_blank" rel="noopener">netfilter/iptables简介</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;netfilter&lt;/code&gt;是 Linux 内置的一种防火墙机制，我们一般也称之为&lt;strong&gt;数据包过滤机制&lt;/strong&gt;。&lt;code&gt;iptables&lt;/code&gt;则是一个&lt;strong&gt;命令行工具，用来配置 netfilter 防火墙&lt;/strong&gt;。下图展示了一个带有防火墙的简单网络拓扑结构：&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://changsk.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="iptables" scheme="http://changsk.top/tags/iptables/"/>
    
      <category term="netfilter" scheme="http://changsk.top/tags/netfilter/"/>
    
  </entry>
  
  <entry>
    <title>ipsec介绍</title>
    <link href="http://changsk.top/2020/07/23/ipsec-introduction/"/>
    <id>http://changsk.top/2020/07/23/ipsec-introduction/</id>
    <published>2020-07-23T14:40:49.000Z</published>
    <updated>2020-07-23T15:09:21.839Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IPSec简介"><a href="#IPSec简介" class="headerlink" title="IPSec简介"></a>IPSec简介</h2><p>IPSec的英文是<code>Internet Protocol Security</code>，是一个协议包，通过对<strong>IP协议的分组</strong>进行<strong>加密</strong>和<strong>认证</strong>来保护IP协议的网络传输协议族（一些相互关联的协议的集合）。</p><a id="more"></a><p>IPsec主要由以下协议组成：</p><ul><li>认证头（AH），报文头验证协议，主要提供的功能有数据源验证、<strong>数据完整性校验</strong>和<strong>防报文重放</strong>功能；然而，<strong>AH并不加密所保护的数据报文。</strong></li><li>封装安全载荷（ESP），提供<strong>机密性</strong>、数据源认证、无连接完整性、防重放和有限的传输流（traffic-flow）机密性。除提供AH协议的所有功能外（但其数据完整性校验不包括IP头），<strong>还可提供对IP报文的加密功能</strong>。</li><li>安全关联（SA），提供算法和数据包，<strong>提供AH、ESP操作所需的参数</strong>。SA是通信对等体间对某些要素的约定 ,通信的双方符合SA约定的内容,就可以建立SA。</li></ul><p>IPSec通过AH（Authentication Header）和ESP（Encapsulating Security Payload）这两个安全协议来实现数据报文在网络上传输时的<strong>私有性、完整性、真实性和防重放</strong>。</p><p>IPSec特性：<br><strong>机密性、完整性、真实性、防重放。</strong></p><p>IPSec安全防护场景（端到端的应用场景）：<br>安全网关（如防火墙）之间（典型场景）、主机与安全网关之间、主机与主机之间。</p><h2 id="IPSec-VPN应用场景"><a href="#IPSec-VPN应用场景" class="headerlink" title="IPSec VPN应用场景"></a>IPSec VPN应用场景</h2><p><img src="1.jpg" alt="img"></p><p>IPSec VPN的应用场景分为3种：</p><ol><li><strong>Site-to-Site</strong>（站点到站点或者网关到网关）：如上图所示，3个机构分布在互联网的3个不同的地方，各使用一个网关相互建立VPN隧道，企业内网（若干PC）之间的数据通过这些网关建立的IPSec隧道实现安全互联。</li><li><strong>End-to-End</strong>（端到端或者PC到PC）： 两个PC之间的通信由两个PC之间的IPSec会话保护，而不是网关。</li><li><strong>End-to-Site</strong>（端到站点或者PC到网关）：两个PC之间的通信由网关和异地PC之间的IPSec进行保护。</li></ol><p>VPN只是IPSec的一种应用方式，IPSec其实是<strong>IP Security</strong>的简称，它的目的是<strong>为IP提供高安全性特性</strong>，VPN则是在实现这种安全特性的方式下产生的解决方案。IPSec是一个框架性架构，具体由两类协议组成：</p><ol><li><strong>AH协议</strong>（Authentication Header，使用较少）：可以同时提供<strong>数据完整性确认、数据来源确认、防重放</strong>等安全特性；AH常用摘要算法（单向Hash函数）<strong>MD5和SHA1</strong>实现该特性。</li><li><strong>ESP协议</strong>（Encapsulated Security Payload，使用较广）：可以同时提供数据完整性确认、<strong>数据加密</strong>、防重放等安全特性；ESP通常使用<strong>DES、3DES、AES</strong>等加密算法实现数据加密，使用MD5或SHA1来实现数据完整性。</li></ol><p>为何AH使用较少呢？<strong>因为AH无法提供数据加密，所有数据在传输时以明文传输，而ESP提供数据加密</strong>；其次AH因为提供数据来源确认（源IP地址一旦改变，AH校验失败），所以<strong>无法穿越NAT</strong>。当然，IPSec在极端的情况下可以同时使用AH和ESP实现最完整的安全特性，但是此种方案极其少见。</p><h2 id="IPSec封装模式"><a href="#IPSec封装模式" class="headerlink" title="IPSec封装模式"></a>IPSec封装模式</h2><p>介绍完IPSec VPN的场景和IPSec协议组成，再来看一下IPSec提供的两种封装模式（传输Transport模式和隧道Tunnel模式）</p><p><img src="2.jpg" alt="img"></p><p>上图是传输模式的封装结构，再来对比一下隧道模式：</p><p><img src="3.jpg" alt="img"></p><p>可以发现传输模式和隧道模式的区别：</p><ol><li>传输模式在AH、ESP处理前后<strong>IP头部保持不变</strong>，主要用于End-to-End的应用场景。</li><li>隧道模式则在AH、ESP处理之后<strong>再封装了一个外网IP头</strong>，主要用于Site-to-Site的应用场景。<br>从上图我们还可以验证上一节所介绍AH和ESP的差别。下图是对传输模式、隧道模式适用于何种场景的说明。</li></ol><p><img src="4.jpg" alt="img"></p><p>从这张图的对比可以看出：</p><ol><li>隧道模式可以适用于任何场景</li><li>传输模式只能适合PC到PC的场景</li></ol><p>隧道模式虽然可以适用于任何场景，但是<strong>隧道模式需要多一层IP头（通常为20字节长度）开销</strong>，所以在PC到PC的场景，建议还是使用传输模式。</p><p>为了使大家有个更直观的了解，我们看看下图，分析一下为何在Site-to-Site场景中只能使用隧道模式：</p><p><img src="5.jpg" alt="img"></p><p>如上图所示，如果发起方内网PC发往响应方内网PC的流量满足网关的兴趣流匹配条件，发起方使用传输模式进行封装：</p><ol><li>IPSec会话建立在发起方、响应方两个网关之间。</li><li>由于使用传输模式，所以<strong>IP头部并不会有任何变化</strong>，IP源地址是192.168.1.2，目的地址是10.1.1.2。</li><li>这个数据包发到互联网后，其命运注定是杯具的，为什么这么讲，就因为其目的地址是10.1.1.2吗？这并不是根源，根源在于互联网并不会维护企业网络的路由，所以丢弃的可能性很大。</li><li>即使数据包没有在互联网中丢弃，并且幸运地抵达了响应方网关，那么我们指望响应方网关进行解密工作吗？凭什么，的确没什么好的凭据，数据包的目的地址是内网PC的10.1.1.2，所以直接转发了事。</li><li>最杯具的是响应方内网PC收到数据包了，因为没有参与IPSec会话的协商会议，没有对应的SA，这个数据包无法解密，而被丢弃。</li></ol><p>我们利用这个反证法，巧妙地解释了在Site-to-Site情况下不能使用传输模式的原因。并且提出了使用传输模式的充要条件：兴趣流必须完全在发起方、响应方IP地址范围内的流量。比如在图中，发起方IP地址为6.24.1.2，响应方IP地址为2.17.1.2，那么兴趣流可以是源6.24.1.2/32、目的是2.17.1.2/32，协议可以是任意的，倘若数据包的源、目的IP地址稍有不同，对不起，请使用隧道模式。<br>   IPSec协商</p><p><img src="6.jpg" alt="img"></p><p>IPSec除了一些协议原理外，我们更关注的是协议中涉及到方案制定的内容：</p><ol><li>兴趣流：IPSec是需要消耗资源的保护措施，并非所有流量都需要IPSec进行处理，而<strong>需要IPSec进行保护的流量就称为兴趣流</strong>，<strong>最后协商出来的兴趣流是由发起方和响应方所指定兴趣流的交集</strong>。</li><li>发起方：Initiator，IPSec会话协商的触发方，IPSec会话通常是由指定兴趣流触发协商，触发的过程通常是将数据包中的源、目的地址、协议以及源、目的端口号与提前指定的IPSec兴趣流匹配模板如ACL进行匹配，如果匹配成功则属于指定兴趣流。指定兴趣流只是用于触发协商，至于是否会被IPSec保护要看是否匹配协商兴趣流，但是在通常实施方案过程中，通常会设计成发起方指定兴趣流属于协商兴趣流。</li><li>响应方：Responder，IPSec会话协商的接收方，响应方是被动协商，响应方可以指定兴趣流，也可以不指定（完全由发起方指定）。</li><li>发起方和响应方协商的内容主要包括：双方身份的确认和密钥种子刷新周期、AH/ESP的组合方式及各自使用的算法，还包括兴趣流、封装模式等。</li><li>SA：发起方、响应方协商的结果就是曝光率很高的SA，SA通常是包括密钥及密钥生存期、算法、封装模式、发起方、响应方地址、兴趣流等内容。</li></ol><p>我们以最常见的IPSec隧道模式为例，解释一下IPSec的协商过程：</p><p><img src="7.gif" alt="img"></p><p>上图描述了由兴趣流触发的IPSec协商流程，原生IPSec并无身份确认等协商过程，在方案上存在诸多缺陷，如无法支持发起方地址动态变化情况下的身份确认、密钥动态更新等。伴随IPSec出现的IKE（Internet Key Exchange）协议专门用来弥补这些不足：</p><ol><li>发起方定义的兴趣流是源192.168.1.0/24目的10.0.0.0/8，所以在接口发送发起方内网PC发给响应方内网PC的数据包，能够得以匹配。</li><li>满足兴趣流条件，在转发接口上检查SA不存在、过期或不可用，都会进行协商，否则使用当前SA对数据包进行处理。</li><li>协商的过程通常分为两个阶段，第一阶段是为第二阶段服务，第二阶段是真正的为兴趣流服务的SA，两个阶段协商的侧重有所不同，第一阶段主要确认双方身份的正确性，第二阶段则是为兴趣流创建一个指定的安全套件，其最显著的结果就是第二阶段中的兴趣流在会话中是密文。<br>IPSec中安全性还体现在第二阶段SA永远是单向的：</li></ol><p><img src="8.jpg" alt="img"></p><p>从上图可以发现，在协商第二阶段SA时，SA是分方向性的，发起方到响应方所用SA和响应放到发起方SA是单独协商的，这样做的好处在于即使某个方向的SA被破解并不会波及到另一个方向的SA。这种设计类似于双向车道设计。</p><blockquote><p>参考：</p><p><a href="https://www.cnblogs.com/xiaohuamao/p/8021850.html" target="_blank" rel="noopener">ipsec原理(转载)</a></p><p><a href="https://blog.csdn.net/weixin_43996007/article/details/104087278?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">IPSec技术的基本原理详解及应用场景</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;IPSec简介&quot;&gt;&lt;a href=&quot;#IPSec简介&quot; class=&quot;headerlink&quot; title=&quot;IPSec简介&quot;&gt;&lt;/a&gt;IPSec简介&lt;/h2&gt;&lt;p&gt;IPSec的英文是&lt;code&gt;Internet Protocol Security&lt;/code&gt;，是一个协议包，通过对&lt;strong&gt;IP协议的分组&lt;/strong&gt;进行&lt;strong&gt;加密&lt;/strong&gt;和&lt;strong&gt;认证&lt;/strong&gt;来保护IP协议的网络传输协议族（一些相互关联的协议的集合）。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://changsk.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="ipsec" scheme="http://changsk.top/tags/ipsec/"/>
    
  </entry>
  
  <entry>
    <title>可重入函数与不可重入函数</title>
    <link href="http://changsk.top/2020/07/22/Reentrant-function/"/>
    <id>http://changsk.top/2020/07/22/Reentrant-function/</id>
    <published>2020-07-22T07:03:12.000Z</published>
    <updated>2020-07-22T15:25:24.077Z</updated>
    
    <content type="html"><![CDATA[<p>在实时系统的设计中，经常会出现多个任务调用同一个函数的情况。如果有一个函数不幸被设计成为这样：不同任务调用这个函数时可能修改其他任务调用这个函数的数据，从而导致不可预料的后果。这样的函数是不安全的函数，也叫不可重入函数。</p><p>相反，肯定有一个安全的函数，这个安全的函数又叫可重入函数。那么什么是可重入函数呢？所谓可重入是指一个可以被多个任务调用的过程，任务在调用时不必担心数据是否会出错。</p><a id="more"></a><p>一个可重入的函数简单来说就是<strong>可以被中断的函数</strong>，也就是说，可以在这个函数执行的任何时刻中断它，转入OS调度下去执行另外一段代码，而返回控制时不会出现什么错误；而不可重入的函数由于使用了一些<strong>系统资源</strong>，比如<strong>全局变量区，中断向量表</strong>等，所以它如果被中断的话，可能会出现问题，<strong>这类函数是不能运行在多任务环境下的</strong>。</p><p>也可以这样理解，重入即表示重复进入，首先它意味着这个函数<strong>可以被中断</strong>，其次意味着它<strong>除了使用自己栈上的变量以外不依赖于任何环境</strong>（包括 static），这样的函数就是purecode（纯代码）可重入，可以允许有该函数的多个副本在运行，由于它们使用的是<strong>分离的栈</strong>，所以不会互相干扰。如果确实需要访问全局变量（包括 static），一定要注意实施<strong>互斥手段</strong>。可重入函数在并行运行环境中非常重要，但是一般要为访问全局变量付出一些<strong>性能代价</strong>。</p><p>编写可重入函数时，若使用全局变量，则应通过<strong>关中断、信号量</strong>（即P、V操作）等手段对其加以保护。</p><p>说明：若对所使用的全局变量不加以保护，则此函数就不具有可重入性，即当多个进程调用此函数时，很有可能使有关全局变量变为不可知状态。</p><p>在多任务系统当中，在任务执行期间捕捉到信号并对其进行处理时，进程正在执行的指令序列就被信号处理程序临时中断。如果从信号处理程序返回，则继续执行进程断点处的正常指令序列，从中断产生到断点重新执行的过程中，<strong>函数所依赖的环境没有发生改变</strong>，就说这个函数是可重入的，反之就是不可重入的。<br>众所周知，在进程中断期间，系统会<strong>保存和恢复进程的上下文</strong>，然而恢复的上下文仅限于<strong>返回地址，cpu寄存器</strong>等之类的少量上下文，而函数内部使用的诸如<strong>全局或静态变量，buffer等并不在保护之列</strong>，所以如果这些值在函数被中断期间发生了改变，那么当函数回到断点继续执行时，其结果就不可预料了。打个比方，比如malloc，假如一个进程此时正在执行malloc分配堆空间，此时程序捕捉到信号发生中断，执行信号处理程序中恰好也有一个malloc，这样就会对进程的环境造成破坏，因为malloc通常为它所分配的存储区维护一个链接表，插入执行信号处理函数时，进程可能正在对这张表进行操作，而信号处理函数的调用刚好覆盖了进程的操作，造成错误。</p><p>满足下面条件之一的多数是不可重入函数：</p><ul><li>使用了<strong>静态数据结构</strong>;</li><li>调用了<strong>malloc或free</strong>;</li><li>调用了<strong>标准I/O函数，如printf</strong>;标准io库很多实现都以不可重入的方式使用<strong>全局数据结构</strong>。</li><li>进行了浮点运算.许多的处理器/编译器中，浮点一般都是不可重入的 (浮点运算大多使用协处理器或者软件模拟来实现。</li></ul><blockquote><p>参考：</p><p><a href="https://blog.csdn.net/tennysonsky/article/details/45127125" target="_blank" rel="noopener">浅谈可重入函数与不可重入函数</a><br><a href="https://yq.aliyun.com/articles/380473" target="_blank" rel="noopener">可重入和不可重入【转】</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在实时系统的设计中，经常会出现多个任务调用同一个函数的情况。如果有一个函数不幸被设计成为这样：不同任务调用这个函数时可能修改其他任务调用这个函数的数据，从而导致不可预料的后果。这样的函数是不安全的函数，也叫不可重入函数。&lt;/p&gt;
&lt;p&gt;相反，肯定有一个安全的函数，这个安全的函数又叫可重入函数。那么什么是可重入函数呢？所谓可重入是指一个可以被多个任务调用的过程，任务在调用时不必担心数据是否会出错。&lt;/p&gt;
    
    </summary>
    
      <category term="C语言" scheme="http://changsk.top/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="可重入函数" scheme="http://changsk.top/tags/%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0/"/>
    
      <category term="不可重入函数" scheme="http://changsk.top/tags/%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式手册</title>
    <link href="http://changsk.top/2020/07/21/regex-manual/"/>
    <id>http://changsk.top/2020/07/21/regex-manual/</id>
    <published>2020-07-21T15:40:47.000Z</published>
    <updated>2020-07-21T15:46:42.666Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="https://tool.oschina.net/uploads/apidocs/jquery/regexp.html" target="_blank" rel="noopener">表达式全集</a></p><a id="more"></a><table><thead><tr><th align="center">字符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">\</td><td align="center">将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“<code>n</code>”匹配字符“<code>n</code>”。“<code>\n</code>”匹配一个换行符。串行“<code>\\</code>”匹配“<code>\</code>”而“<code>\(</code>”则匹配“<code>(</code>”。</td></tr><tr><td align="center">^</td><td align="center">匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“<code>\n</code>”或“<code>\r</code>”之后的位置。</td></tr><tr><td align="center">$</td><td align="center">匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“<code>\n</code>”或“<code>\r</code>”之前的位置。</td></tr><tr><td align="center">*</td><td align="center">匹配前面的子表达式零次或多次。例如，zo<em>能匹配“<code>z</code>”以及“<code>zoo</code>”。</em>等价于{0,}。</td></tr><tr><td align="center">+</td><td align="center">匹配前面的子表达式一次或多次。例如，“<code>zo+</code>”能匹配“<code>zo</code>”以及“<code>zoo</code>”，但不能匹配“<code>z</code>”。+等价于{1,}。</td></tr><tr><td align="center">?</td><td align="center">匹配前面的子表达式零次或一次。例如，“<code>do(es)?</code>”可以匹配“<code>does</code>”或“<code>does</code>”中的“<code>do</code>”。?等价于{0,1}。</td></tr><tr><td align="center">{<em>n</em>}</td><td align="center"><em>n</em>是一个非负整数。匹配确定的<em>n</em>次。例如，“<code>o{2}</code>”不能匹配“<code>Bob</code>”中的“<code>o</code>”，但是能匹配“<code>food</code>”中的两个o。</td></tr><tr><td align="center">{<em>n</em>,}</td><td align="center"><em>n</em>是一个非负整数。至少匹配<em>n</em>次。例如，“<code>o{2,}</code>”不能匹配“<code>Bob</code>”中的“<code>o</code>”，但能匹配“<code>foooood</code>”中的所有o。“<code>o{1,}</code>”等价于“<code>o+</code>”。“<code>o{0,}</code>”则等价于“<code>o*</code>”。</td></tr><tr><td align="center">{<em>n</em>,<em>m</em>}</td><td align="center"><em>m</em>和<em>n</em>均为非负整数，其中<em>n</em>&lt;=<em>m</em>。最少匹配<em>n</em>次且最多匹配<em>m</em>次。例如，“<code>o{1,3}</code>”将匹配“<code>fooooood</code>”中的前三个o。“<code>o{0,1}</code>”等价于“<code>o?</code>”。请注意在逗号和两个数之间不能有空格。</td></tr><tr><td align="center">?</td><td align="center">当该字符紧跟在任何一个其他限制符（<em>,+,?，{</em>n<em>}，{</em>n<em>,}，{</em>n<em>,</em>m*}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“<code>oooo</code>”，“<code>o+?</code>”将匹配单个“<code>o</code>”，而“<code>o+</code>”将匹配所有“<code>o</code>”。</td></tr><tr><td align="center">.</td><td align="center">匹配除“<code>\</code><em><code>n</code></em>”之外的任何单个字符。要匹配包括“<code>\</code><em><code>n</code></em>”在内的任何字符，请使用像“`(.</td></tr><tr><td align="center">(pattern)</td><td align="center">匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“<code>\(</code>”或“<code>\)</code>”。</td></tr><tr><td align="center">(?:pattern)</td><td align="center">匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“`(</td></tr><tr><td align="center">(?=pattern)</td><td align="center">正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“`Windows(?=95</td></tr><tr><td align="center">(?!pattern)</td><td align="center">正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“`Windows(?!95</td></tr><tr><td align="center">(?&lt;=pattern)</td><td align="center">反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“`(?&lt;=95</td></tr><tr><td align="center">(?&lt;!pattern)</td><td align="center">反向否定预查，与正向否定预查类拟，只是方向相反。例如“`(?&lt;!95</td></tr><tr><td align="center">x|y</td><td align="center">匹配x或y。例如，“`z</td></tr><tr><td align="center">[xyz]</td><td align="center">字符集合。匹配所包含的任意一个字符。例如，“<code>[abc]</code>”可以匹配“<code>plain</code>”中的“<code>a</code>”。</td></tr><tr><td align="center">[^xyz]</td><td align="center">负值字符集合。匹配未包含的任意字符。例如，“<code>[^abc]</code>”可以匹配“<code>plain</code>”中的“<code>p</code>”。</td></tr><tr><td align="center">[a-z]</td><td align="center">字符范围。匹配指定范围内的任意字符。例如，“<code>[a-z]</code>”可以匹配“<code>a</code>”到“<code>z</code>”范围内的任意小写字母字符。</td></tr><tr><td align="center">[^a-z]</td><td align="center">负值字符范围。匹配任何不在指定范围内的任意字符。例如，“<code>[^a-z]</code>”可以匹配任何不在“<code>a</code>”到“<code>z</code>”范围内的任意字符。</td></tr><tr><td align="center">\b</td><td align="center">匹配一个单词边界，也就是指单词和空格间的位置。例如，“<code>er\b</code>”可以匹配“<code>never</code>”中的“<code>er</code>”，但不能匹配“<code>verb</code>”中的“<code>er</code>”。</td></tr><tr><td align="center">\B</td><td align="center">匹配非单词边界。“<code>er\B</code>”能匹配“<code>verb</code>”中的“<code>er</code>”，但不能匹配“<code>never</code>”中的“<code>er</code>”。</td></tr><tr><td align="center">\cx</td><td align="center">匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“<code>c</code>”字符。</td></tr><tr><td align="center">\d</td><td align="center">匹配一个数字字符。等价于[0-9]。</td></tr><tr><td align="center">\D</td><td align="center">匹配一个非数字字符。等价于[^0-9]。</td></tr><tr><td align="center">\f</td><td align="center">匹配一个换页符。等价于\x0c和\cL。</td></tr><tr><td align="center">\n</td><td align="center">匹配一个换行符。等价于\x0a和\cJ。</td></tr><tr><td align="center">\r</td><td align="center">匹配一个回车符。等价于\x0d和\cM。</td></tr><tr><td align="center">\s</td><td align="center">匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。</td></tr><tr><td align="center">\S</td><td align="center">匹配任何非空白字符。等价于[^ \f\n\r\t\v]。</td></tr><tr><td align="center">\t</td><td align="center">匹配一个制表符。等价于\x09和\cI。</td></tr><tr><td align="center">\v</td><td align="center">匹配一个垂直制表符。等价于\x0b和\cK。</td></tr><tr><td align="center">\w</td><td align="center">匹配包括下划线的任何单词字符。等价于“<code>[A-Za-z0-9_]</code>”。</td></tr><tr><td align="center">\W</td><td align="center">匹配任何非单词字符。等价于“<code>[^A-Za-z0-9_]</code>”。</td></tr><tr><td align="center">\x<em>n</em></td><td align="center">匹配<em>n</em>，其中<em>n</em>为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“<code>\x41</code>”匹配“<code>A</code>”。“<code>\x041</code>”则等价于“<code>\x04&amp;1</code>”。正则表达式中可以使用ASCII编码。.</td></tr><tr><td align="center">*num*</td><td align="center">匹配<em>num</em>，其中<em>num</em>是一个正整数。对所获取的匹配的引用。例如，“<code>(.)\1</code>”匹配两个连续的相同字符。</td></tr><tr><td align="center">*n*</td><td align="center">标识一个八进制转义值或一个向后引用。如果*n<em>之前至少</em>n<em>个获取的子表达式，则</em>n<em>为向后引用。否则，如果</em>n<em>为八进制数字（0-7），则</em>n*为一个八进制转义值。</td></tr><tr><td align="center">*nm*</td><td align="center">标识一个八进制转义值或一个向后引用。如果*nm<em>之前至少有</em>nm<em>个获得子表达式，则</em>nm<em>为向后引用。如果\</em>nm<em>之前至少有</em>n<em>个获取，则</em>n<em>为一个后跟文字</em>m<em>的向后引用。如果前面的条件都不满足，若</em>n<em>和</em>m<em>均为八进制数字（0-7），则\</em>nm<em>将匹配八进制转义值</em>nm*。</td></tr><tr><td align="center">*nml*</td><td align="center">如果<em>n</em>为八进制数字（0-3），且<em>m和l</em>均为八进制数字（0-7），则匹配八进制转义值<em>nm</em>l。</td></tr><tr><td align="center">\u<em>n</em></td><td align="center">匹配<em>n</em>，其中<em>n</em>是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（©）。</td></tr></tbody></table><h2 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h2><table><thead><tr><th align="center">用户名</th><th>/^[a-z0-9_-]{3,16}$/</th></tr></thead><tbody><tr><td align="center">密码</td><td>/^[a-z0-9_-]{6,18}$/</td></tr><tr><td align="center">十六进制值</td><td>/^#?([a-f0-9]{6}|[a-f0-9]{3})$/</td></tr><tr><td align="center">电子邮箱</td><td>/^([a-z0-9_.-]+)@([\da-z.-]+).([a-z.]{2,6})$/ /^[a-z\d]+(.[a-z\d]+)*@([\da-z](-[\da-z])?)+(.{1,2}[a-z]+)+$/</td></tr><tr><td align="center">URL</td><td>/^(https?://)?([\da-z.-]+).([a-z.]{2,6})([/\w .-]<em>)</em>/?$/</td></tr><tr><td align="center">IP 地址</td><td>/((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)/ /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/</td></tr><tr><td align="center">HTML 标签</td><td>/^&lt;([a-z]+)([^&lt;]+)<em>(?:&gt;(.</em>)&lt;/\1&gt;|\s+/&gt;)$/</td></tr><tr><td align="center">删除代码\\注释</td><td>(?&lt;!http:|\S)//.*$</td></tr><tr><td align="center">Unicode编码中的汉字范围</td><td>/^[\u2E80-\u9FFF]+$/</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自：&lt;a href=&quot;https://tool.oschina.net/uploads/apidocs/jquery/regexp.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;表达式全集&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="正则表达式" scheme="http://changsk.top/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    
      <category term="正则表达式" scheme="http://changsk.top/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>字节对齐</title>
    <link href="http://changsk.top/2020/07/21/byte-alignment/"/>
    <id>http://changsk.top/2020/07/21/byte-alignment/</id>
    <published>2020-07-20T16:02:31.000Z</published>
    <updated>2020-07-21T15:37:33.341Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="https://cloud.tencent.com/developer/article/1631792" target="_blank" rel="noopener">字节对齐，看这篇就懂了</a></p><p>字节对齐是我们初学C语言就会接触到的一个概念，但是到底什么是字节对齐？对齐准则又是什么？为什么要字节对齐呢？字节对齐对我们编程有什么启示？本文将简单理一理字节对齐的那些事。</p><a id="more"></a><h2 id="什么是字节对齐"><a href="#什么是字节对齐" class="headerlink" title="什么是字节对齐"></a><strong>什么是字节对齐</strong></h2><p>计算机中内存大小的基本单位是字节（byte），理论上来讲，可以从任意地址访问某种基本数据类型，但是实际上，计算机并非逐字节大小读写内存，而是以2、4或8的倍数的字节块来读写内存，如此一来就会对基本数据类型的合法地址作出一些限制，即它的地址必须是2，4或8的倍数。那么就要求各种数据类型按照一定的规则在空间上排列，这就是对齐。</p><h2 id="对齐准则是什么"><a href="#对齐准则是什么" class="headerlink" title="对齐准则是什么"></a><strong>对齐准则是什么</strong></h2><p>总的来说，字节对齐有以下准则：</p><ul><li><strong>结构体变量的首地址能够被其对齐字节数大小所整除</strong>。</li><li><strong>结构体每个成员相对结构体首地址的偏移都是成员大小的整数倍</strong>，如不满足，对前一个成员填充字节以满足。</li><li><strong>结构体的总大小为结构体对最大成员大小的整数倍</strong>，如不满足，最后填充字节以满足。</li></ul><p>我们通过一个小例子来说明是如何对齐的。 考虑下面的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*================================================================</span></span><br><span class="line"><span class="comment">*   Copyright (C) 2018  Ltd. All rights reserved.</span></span><br><span class="line"><span class="comment">*   </span></span><br><span class="line"><span class="comment">*   文件名称：testByteAlign.c</span></span><br><span class="line"><span class="comment">*   创 建 者：shouwang</span></span><br><span class="line"><span class="comment">*   创建日期：2018年09月15日</span></span><br><span class="line"><span class="comment">*   描    述：</span></span><br><span class="line"><span class="comment">*   公众号：编程珠玑</span></span><br><span class="line"><span class="comment">================================================================*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">short</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*在32位和64位的机器上，size_t的大小不同*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the size of struct test is %zu\n"</span>,<span class="keyword">sizeof</span>(struct test));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译成32位程序并运行（<strong>默认四字节自然对齐</strong>），可以看到，结构体test 的大小为16字节，而不是11字节（a占4字节，b占1字节，c占4字节，d占2字节）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//64位机器上编译32位程序可能需要安装一个库</span><br><span class="line"><span class="meta">#</span>sudo apt-get install gcc-multilib</span><br><span class="line">gcc -m32 -o testByteAlign testByteAlign.c #编译程序</span><br><span class="line">chmod +x testByteAlign  #赋执行权限</span><br><span class="line">./testByteAlign  #运行</span><br><span class="line">the size of struct test is 16</span><br></pre></td></tr></table></figure><p>实际上，结构体test的成员在内存中可能是像下面这样分布的（数值为偏移量） 未对齐时:</p><table><thead><tr><th align="left">0~3</th><th align="left">4</th><th align="left">5~9</th><th align="left">10~11</th></tr></thead><tbody><tr><td align="left">a</td><td align="left">b</td><td align="left">c</td><td align="left">d</td></tr></tbody></table><p>对齐时:</p><table><thead><tr><th align="left">0~3</th><th align="left">4</th><th align="left">5~7</th><th align="left">8~11</th><th align="left">12~13</th><th align="left">14~15</th></tr></thead><tbody><tr><td align="left">a</td><td align="left">b</td><td align="left">填充内容</td><td align="left">c</td><td align="left">d</td><td align="left">填充内容</td></tr></tbody></table><p>   从上面可以看出，c的偏移为5，不满足对齐要求（它的偏移量应该能够被sizeof（int）大小整除），因此在b后面填充了3个字节，使得c的偏移为8。在b后面填充后，d已经满足对齐要求了，为什么最后还要填充字节呢？或者说，为什么需要满足第三条准则呢？ 考虑下面的声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> <span class="title">teArray</span>[2];</span></span><br></pre></td></tr></table></figure><p>   我们不难知道，teArray[0]的d如果不填充字节，那么teArray[1]的a偏移为14，不满足对齐要求，因此d后面也需要填充字节。</p><h2 id="为什么要字节对齐"><a href="#为什么要字节对齐" class="headerlink" title="为什么要字节对齐"></a><strong>为什么要字节对齐</strong></h2><p>​        无论数据是否对齐，大多数计算机还是能够正确工作，而且从前面可以看到，结构体test本来只需要11字节的空间，最后却占用了16字节，很明显<strong>浪费了空间</strong>，那么为什么还要进行字节对齐呢？最重要的考虑是<strong>提高内存系统性能</strong>。我们也说到，计算机每次读写一个字节块，例如，假设计算机总是从内存中取8个字节，如果一个double数据的地址对齐成8的倍数，那么一个内存操作就可以读或者写，但是如果这个double数据的地址没有对齐，数据就可能被放在两个8字节块中，那么我们可能需要执行两次内存访问，才能读写完成。显然在这样的情况下，是低效的。所以<strong>需要字节对齐来提高内存系统性能</strong>。     在有些处理器中，如果使用未对齐的数据，可能不能够正确工作甚至crash，这里我们不多讨论。</p><h2 id="实际编程中的考虑"><a href="#实际编程中的考虑" class="headerlink" title="实际编程中的考虑"></a><strong>实际编程中的考虑</strong></h2><p>实际上，字节对齐的细节都由编译器来完成，我们不需要特意进行字节的对齐，但并不意味着我们不需要关注字节对齐的问题。</p><h4 id="空间存储"><a href="#空间存储" class="headerlink" title="空间存储"></a><strong>空间存储</strong></h4><p>还是考虑前面的结构体test，其占用空间大小为16字节，但是如果我们换一种声明方式，调整变量的顺序，重新运行程序，最后发现结构体test占用大小为<strong>12字节</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">short</span> d;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>空间存储情况如下,b和d存储在了一个字节块中:</p><table><thead><tr><th align="left">0~3</th><th align="left">4</th><th align="left">5</th><th align="left">6~7</th><th align="left">8~11</th></tr></thead><tbody><tr><td align="left">a</td><td align="left">b</td><td align="left">填充内容</td><td align="left">d</td><td align="left">c</td></tr></tbody></table><p>也就是说，如果我们在设计结构的时候，<strong>合理调整成员的位置，可以大大节省存储空间</strong>。但是需要在空间和可读性之间进行权衡。</p><h4 id="跨平台通信"><a href="#跨平台通信" class="headerlink" title="跨平台通信"></a><strong>跨平台通信</strong></h4><p><strong>由于不同平台对齐方式可能不同，如此一来，同样的结构在不同的平台其大小可能不同，在无意识的情况下，互相发送的数据可能出现错乱，甚至引发严重的问题。</strong>因此，为了不同处理器之间能够正确的处理消息，我们有两种可选的处理方法。</p><ul><li>1字节对齐</li><li>自己对结构进行字节填充</li></ul><p>我们可以使用伪指令<code>#pragma pack(n)</code>（n为字节对齐数）来使得结构体字节对齐。 同样是前面的程序，如果在结构体test的前面加上伪指令，即如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1) <span class="comment">/*1字节对齐*/</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">short</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()<span class="comment">/*还原默认对齐*/</span></span></span><br></pre></td></tr></table></figure><p>在这样的声明下，任何平台结构体test的大小都为11字节，<strong>这样做能够保证跨平台的结构大小一致，同时还节省了空间，但不幸的是，降低了效率。</strong></p><p>当然了对于单个结构体，可以使用如下的方法，保证其可以安全的进行跨进程传输</p><ul><li><strong>_<em>attribute_</em>((aligned (n)))</strong>，让所作用的结构成员对齐在n字节自然边界上(n必须是2的正整数倍)。如果结构中有成员的长度大于n，则按照最大成员的长度来对齐。</li><li><strong>_<em>attribute_</em> ((packed))</strong>，取消结构体在编译过程中的优化对齐。</li></ul><p>用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">short</span> d;</span><br><span class="line">&#125;__attribute__ ((packed));</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">short</span> d;</span><br><span class="line">&#125;__attribute__((aligned (<span class="number">64</span>)));</span><br></pre></td></tr></table></figure><p>除了前面的1字节对齐，还可以进行人为的填充，即test结构体声明如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">char</span> reserve[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">short</span> d;</span><br><span class="line">    <span class="keyword">char</span> reserve1[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>访问效率高，但并不节省空间，同时扩展性不是很好</strong>，例如，当字节对齐有变化时，需要填充的字节数可能就会发生变化。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>虽然我们不需要具体关心字节对齐的细节，但是如果不关注字节对齐的问题，可能会在编程中遇到难以理解或解决的问题。因此针对字节对齐，总结了以下处理建议：</p><ul><li>结构体成员合理安排位置，以节省空间</li><li>跨平台数据结构可考虑1字节对齐，节省空间但影响访问效率</li><li>跨平台数据结构人为进行字节填充，提高访问效率但不节省空间</li><li>本地数据采用默认对齐，以提高访问效率</li><li>32位与64位默认对齐数不一样 ，分别是4字节和8字节对齐 </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自：&lt;a href=&quot;https://cloud.tencent.com/developer/article/1631792&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;字节对齐，看这篇就懂了&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;字节对齐是我们初学C语言就会接触到的一个概念，但是到底什么是字节对齐？对齐准则又是什么？为什么要字节对齐呢？字节对齐对我们编程有什么启示？本文将简单理一理字节对齐的那些事。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://changsk.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="字节对齐" scheme="http://changsk.top/tags/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/"/>
    
      <category term="C语言" scheme="http://changsk.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>TCP、UDP的最大包长度</title>
    <link href="http://changsk.top/2020/07/20/TCP-UDP-MAX-PACKAGE/"/>
    <id>http://changsk.top/2020/07/20/TCP-UDP-MAX-PACKAGE/</id>
    <published>2020-07-20T15:17:53.000Z</published>
    <updated>2020-07-20T15:47:19.777Z</updated>
    
    <content type="html"><![CDATA[<p>1、链路层：在链路层，以太网的物理特性决定了数据帧的内容最大为1500(不包括帧头和帧尾)，即MTU(Maximum Transmission Unit，最大传输单元)为1500；</p><a id="more"></a><p>2、网络层： IP头大小最小为20字节。<strong>所以，网络层的MTU=数据链路层的MTU1500-20=1480字节。</strong></p><blockquote><p>在IP头中，用2个字节来描述报文的长度，2个字节所能表达的最大数字就是65535。<strong>所以，IP数据包的最大长度就是64K字节(65535)。</strong>如果IP数据包负载的长度大于1480字节的话，会进行分片传输（前n-1个数据包负载的长度为1480字节），而在接收方IP层则需要进行数据报重组</p></blockquote><p>3、传输层：</p><ul><li><p>依靠IP协议提供的报文分割和重组机制，<strong>TCP包头中就没有“包长度”字段，而完全依靠IP层去处理分帧。这就是为什么TCP常常被称作一种“流协议”的原因</strong>，开发者在使用TCP服务的时候，不必去关心数据包的大小，只需将SOCKET看作一条数据流的入口，往里面放数据就是了，<strong>TCP协议本身会进行拥塞/流量控制</strong>。</p><p>TCP包的首部要占用20字节，所以TCP的MTU为1480-20=1460；</p></li><li><p>UDP则与TCP不同，UDP包头内有总长度字段，同样为两个字节，因此UDP数据包的总长度被限制为65535，这样恰好可以放进一个IP包内，使得 UDP/IP协议栈的实现非常简单和高效。</p><p><strong>所以UDP包的最大值是：IP数据包的最大长度65535-IP头的大小20-UDP头的大小=65507字节。最小值是0。</strong></p><p>UDP包的首部要占用8字节，所以UDP的MTU为1480－8＝1472；<br>当我们的UDP包中的数据多于MTU(1472)时，发送方的IP层需要分片fragmentation进行传输，而在接收方IP层则需要进行数据报重组，由于UDP是不可靠的传输协议，如果分片丢失导致重组失败，将导致UDP数据包被丢弃。<br>从上面的分析来看，在普通的局域网环境下，UDP的数据最大为1472字节最好（避免分片重组）。<br>但在网络编程中，Internet中的路由器可能有设置成不同的值（小于默认值），<strong>Internet上的标准MTU值为576</strong>，所以Internet的UDP编程时数据长度最好在576－20－8＝548字节以内。</p></li></ul><blockquote><p>参考：<a href="https://www.cnblogs.com/sinferwu/articles/7615276.html" target="_blank" rel="noopener">以太网帧（Ethernet）、IP包、TCP、UDP的长度范围</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、链路层：在链路层，以太网的物理特性决定了数据帧的内容最大为1500(不包括帧头和帧尾)，即MTU(Maximum Transmission Unit，最大传输单元)为1500；&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://changsk.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="TCP" scheme="http://changsk.top/tags/TCP/"/>
    
      <category term="UDP" scheme="http://changsk.top/tags/UDP/"/>
    
  </entry>
  
  <entry>
    <title>git学习</title>
    <link href="http://changsk.top/2020/07/19/git-Tutorials/"/>
    <id>http://changsk.top/2020/07/19/git-Tutorials/</id>
    <published>2020-07-19T15:32:18.000Z</published>
    <updated>2020-07-19T15:56:29.082Z</updated>
    
    <content type="html"><![CDATA[<p>git学习</p><a id="more"></a><ol><li><p>Git是先进的分布式版本控制系统</p><ul><li><p>Git最开始由Linux花了两周时间开发而成，用于管理Linux系统的源码</p></li><li><p>Github为开源项目免费提供Git存储</p></li><li><p>CVS及SVN都是集中式的版本控制系统，<strong>版本库是集中存放在中央服务器的</strong>。干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。集中式版本控制系统最大的毛病就是必须联网才能工作。模式类似于星型结构，如下：</p><p><img src="1.jpg" alt="在这里插入图片描述"></p></li><li><p>分布式版本控制系统根本没有“中央服务器”，<strong>每个人的电脑上都是一个完整的版本库</strong>，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。</p><p>在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。模式类似于网状结构，如下：</p><p><img src="2.jpg" alt="在这里插入图片描述"></p></li></ul></li><li></li></ol><blockquote><p>参考：<a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">Git教程</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;git学习&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="http://changsk.top/categories/git/"/>
    
    
      <category term="git" scheme="http://changsk.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-746:min-cost-climbing-stairs(使用最小花费爬楼梯)</title>
    <link href="http://changsk.top/2020/07/16/leetcode-746/"/>
    <id>http://changsk.top/2020/07/16/leetcode-746/</id>
    <published>2020-07-16T15:15:31.000Z</published>
    <updated>2020-07-16T15:17:54.664Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/" target="_blank" rel="noopener">min-cost-climbing-stairs</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>题目难度:Easy</strong></p><p>数组的每个索引作为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost<a href="索引从0开始">i</a>。</p><p>每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。</p><p>您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。</p><p><strong>示例 1:</strong></p><p>输入: cost = [10, 15, 20]<br>输出: 15<br>解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。<br><strong>示例 2:</strong></p><p>输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]<br>输出: 6<br>解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。<br><strong>注意：</strong></p><p>cost 的长度将会在 [2, 1000]。<br>每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不是必要的，因为cost 的长度将会在 [2, 1000]。</span></span><br><span class="line">        <span class="keyword">if</span> (cost == <span class="keyword">null</span> || cost.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; cost.length;i++) &#123;</span><br><span class="line">            cost[i] += Math.min(cost[i - <span class="number">1</span>], cost[i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(cost[cost.length - <span class="number">1</span>], cost[cost.length - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode-cn.com/problems/min-cost-climbing-stairs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;min-cost-climbing-stairs&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
</feed>
