<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>changsk&#39;s blogs</title>
  
  <subtitle>chang.sk@foxmail.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://changsk.top/"/>
  <updated>2020-04-17T09:34:38.082Z</updated>
  <id>http://changsk.top/</id>
  
  <author>
    <name>changsk</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode-148:Sort List</title>
    <link href="http://changsk.top/2020/04/17/leetcode-148/"/>
    <id>http://changsk.top/2020/04/17/leetcode-148/</id>
    <published>2020-04-17T09:28:37.000Z</published>
    <updated>2020-04-17T09:34:38.082Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/sort-list/" target="_blank" rel="noopener">Sort List</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>题目难度：Medium</p></blockquote><p>Sort a linked list in <em>O</em>(<em>n</em> log <em>n</em>) time using constant space complexity.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 4-&gt;2-&gt;1-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3-&gt;4</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: -1-&gt;5-&gt;3-&gt;4-&gt;0</span><br><span class="line">Output: -1-&gt;0-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><p>二路归并排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode prev = <span class="keyword">null</span>, slow = head, fast = head;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            prev = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev.next = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">        ListNode l1 = sortList(head);</span><br><span class="line">        ListNode l2 = sortList(slow);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> merge(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode l1, ListNode l2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val1 = <span class="number">0</span>, val2 = <span class="number">0</span>;</span><br><span class="line">        ListNode fakeHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode curNode = fakeHead;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            val1 = l1.val;</span><br><span class="line">            val2 = l2.val;</span><br><span class="line">            <span class="keyword">if</span>(val1 &lt; val2)</span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                curNode.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                curNode.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            curNode = curNode.next;</span><br><span class="line">            curNode.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="keyword">null</span>) curNode.next = l1;</span><br><span class="line">        <span class="keyword">if</span>(l2 != <span class="keyword">null</span>) curNode.next = l2;</span><br><span class="line">        <span class="keyword">return</span> fakeHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/sort-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Sort List&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-145:Binary Tree Postorder Traversal(后序遍历)</title>
    <link href="http://changsk.top/2020/04/16/leetcode-145/"/>
    <id>http://changsk.top/2020/04/16/leetcode-145/</id>
    <published>2020-04-16T13:45:14.000Z</published>
    <updated>2020-04-16T14:42:53.815Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">Binary Tree Postorder Traversal</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p> 题目难度:Hard</p></blockquote><p>Given a binary tree, return the <em>postorder</em> traversal of its nodes’ values.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [3,2,1]</span><br></pre></td></tr></table></figure><p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p><h2 id="AC代码1"><a href="#AC代码1" class="headerlink" title="AC代码1"></a>AC代码1</h2><p>递归解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; resList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        postorderTraversalCore(resList, root);</span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postorderTraversalCore</span><span class="params">(List&lt;Integer&gt; list, TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>) postorderTraversalCore(list, root.left);</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>) postorderTraversalCore(list, root.right);</span><br><span class="line">        list.add(root.val);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AC代码2"><a href="#AC代码2" class="headerlink" title="AC代码2"></a>AC代码2</h2><p>非递归解法</p><p>思路看<a href="http://changsk.top/2019/07/19/binary-tree-traversal-non-recursive/">这里</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode last = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!s.isEmpty() || root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                s.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!s.isEmpty())&#123;</span><br><span class="line">                TreeNode t = s.pop();</span><br><span class="line">                <span class="keyword">if</span>(t.right == <span class="keyword">null</span> || last == t.right)&#123;</span><br><span class="line">                    list.add(t.val);</span><br><span class="line">                    last = t;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    s.push(t);</span><br><span class="line">                    root = t.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/binary-tree-postorder-traversal/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Binary Tree Postorder Traversal&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-143:Reorder List</title>
    <link href="http://changsk.top/2020/04/16/leetcode-143/"/>
    <id>http://changsk.top/2020/04/16/leetcode-143/</id>
    <published>2020-04-16T13:32:17.000Z</published>
    <updated>2020-04-16T14:16:44.296Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/reorder-list/" target="_blank" rel="noopener">Reorder List</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>题目难度：Medium</p></blockquote><p>Given a singly linked list <em>L</em>: <em>L</em>0→<em>L</em>1→…→<em>L**n</em>-1→<em>L</em>n,<br>reorder it to: <em>L</em>0→<em>L**n</em>→<em>L</em>1→<em>L**n</em>-1→<em>L</em>2→<em>L**n</em>-2→…</p><p>You may <strong>not</strong> modify the values in the list’s nodes, only nodes itself may be changed.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given 1-&gt;2-&gt;3-&gt;4, reorder it to 1-&gt;4-&gt;2-&gt;3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li><p>将整个链表从中间切一刀，得到两个链表：链表1和链表2</p></li><li><p>将链表2翻转，得到链表2’</p></li><li><p>交叉的方式合并链表1和链表2’</p></li></ol><p>如：有一个链表为<code>1-&gt;2-&gt;3-&gt;4-&gt;5</code>,切分得到链表1<code>1-&gt;2-&gt;3</code>和链表2<code>4-&gt;5</code>，翻转链表2，得到链表2’<code>5-&gt;4</code>，合并链表1和链表2’得到<code>1-&gt;5-&gt;2-&gt;4-&gt;3</code>。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        ListNode curNode = head;</span><br><span class="line">        <span class="keyword">while</span>(curNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            curNode = curNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode list1Head = head;</span><br><span class="line">        curNode = head;</span><br><span class="line">        ListNode list2Head = head;</span><br><span class="line">        <span class="keyword">int</span> step = (len / <span class="number">2</span>) + (len % <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; step;i++) </span><br><span class="line">        &#123;</span><br><span class="line">            list2Head = list2Head.next;</span><br><span class="line">            <span class="keyword">if</span>(i == step - <span class="number">1</span>) curNode.next = <span class="keyword">null</span>;</span><br><span class="line">            curNode = curNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        list2Head = reverse(list2Head);</span><br><span class="line">        ListNode list2TmpNode = list2Head;</span><br><span class="line">        <span class="comment">//合并两链表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len / <span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            list2TmpNode = list2Head;</span><br><span class="line">            list2Head = list2Head.next;</span><br><span class="line">            list2TmpNode.next = list1Head.next;</span><br><span class="line">            list1Head.next = list2TmpNode;</span><br><span class="line">            list1Head = list1Head.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//翻转链表</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode newHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode curNode = head;</span><br><span class="line">        ListNode nextNode = head.next;</span><br><span class="line">        <span class="keyword">while</span>(curNode != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nextNode = curNode.next;</span><br><span class="line">            curNode.next = newHead.next;</span><br><span class="line">            newHead.next = curNode;</span><br><span class="line">            curNode = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/reorder-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Reorder List&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-144:Binary Tree Preorder Traversal(先序遍历)</title>
    <link href="http://changsk.top/2020/04/16/leetcode-144/"/>
    <id>http://changsk.top/2020/04/16/leetcode-144/</id>
    <published>2020-04-16T12:54:22.000Z</published>
    <updated>2020-04-16T14:21:51.671Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">leetcode-144:Binary Tree Preorder Traversal</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>题目难度：Medium</p></blockquote><p>Given a binary tree, return the <em>preorder</em> traversal of its nodes’ values.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,2,3]</span><br></pre></td></tr></table></figure><p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p><h2 id="AC代码1"><a href="#AC代码1" class="headerlink" title="AC代码1"></a>AC代码1</h2><p>递归解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; resList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        preorderTraversalCore(resList, root);</span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preorderTraversalCore</span><span class="params">(List&lt;Integer&gt; list, TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>) preorderTraversalCore(list, root.left);</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>) preorderTraversalCore(list, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AC代码2"><a href="#AC代码2" class="headerlink" title="AC代码2"></a>AC代码2</h2><p>非递归解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; resList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> resList;</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!s.isEmpty() || root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                resList.add(root.val);</span><br><span class="line">                s.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!s.isEmpty())&#123;</span><br><span class="line">                TreeNode t = s.pop();</span><br><span class="line">                root = t.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/binary-tree-preorder-traversal/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leetcode-144:Binary Tree Preorder Traversal&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>伽罗华域运算及C语言实现</title>
    <link href="http://changsk.top/2020/04/16/Galois-Field/"/>
    <id>http://changsk.top/2020/04/16/Galois-Field/</id>
    <published>2020-04-16T03:14:51.000Z</published>
    <updated>2020-04-16T05:19:21.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="伽罗华域（Galois-Field）简介"><a href="#伽罗华域（Galois-Field）简介" class="headerlink" title="伽罗华域（Galois Field）简介"></a>伽罗华域（Galois Field）简介</h2><p>在数学中，<strong>有限域</strong>（或称伽罗华域）是一个包含有限元素的域。与其他域一样，有限域是进行加减乘除运算都有定义并且满足特定规则的集合。其中加法和乘法必须满足交换、结合和分配的规律。加法和乘法具有封闭性，即加法和乘法结果仍然是域中的元素。</p><p>伽罗华域一般用<strong><em>GF(2<sup>M</sup>)</em></strong>表示，这个域中含有<strong><em>2<sup>M</sup></em></strong>个元素。<strong><em>GF(2<sup>M</sup>)</em></strong>上的四则运算是基于多项式运算的，一般都是这种结构<strong><em>f(x) = x<sup>6</sup> + x<sup>4</sup> + x<sup>2</sup> + x + 1</em></strong>。</p><a id="more"></a><p><strong>本原多项式</strong> （primitive polynomial）是一种特殊的不可约多项式。当一个域上的本原多项式确定了，这个域上的运算也就确定了。本原多项式一般通过查表得知，同一个域往往有<strong>多个本原多项式</strong>。</p><p>当M=8时，即<strong><em>GF(2<sup>M</sup>)</em></strong>域，其中比较常见的一个本原多项式为<strong><em>P(x) = x<sup>8</sup> + x<sup>4</sup> + x<sup>3</sup>  + x<sup>2</sup>  + 1</em></strong>。<strong><em>GF(2<sup>8</sup>)</em></strong>域也是计算机领域用的比较多的一种域，因为一字节等于8比特。<strong>AES加密</strong>中列混合变换中用到了伽罗华域运算。 AES加解密算法中，使用的不可约多项式（irreducible polynomial）为<strong><em>P(x) = x<sup>8</sup> + x<sup>4</sup> + x<sup>3</sup>  + x + 1</em></strong>，所以下面主要讨论AES算法中用到的<strong><em>GF(2<sup>8</sup>)</em></strong>域，多项式为<strong><em>P(x) = x<sup>8</sup> + x<sup>4</sup> + x<sup>3</sup>  + x + 1</em></strong>乘法的实现。</p><h2 id="运算规则"><a href="#运算规则" class="headerlink" title="运算规则"></a>运算规则</h2><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><p>在伽罗华域中，加法是模2运算，也就是忽略进位的加法，等同于计算机中的XOR异或，即<code>1^1=0, 1^0=1, 0^0=0</code>。</p><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><p>伽罗华域中的乘法是基于多项式运算的，比如：<strong><em>5=00000101b=(2<sup>2</sup>+1)</em></strong>，对应多项式为 <strong><em>x<sup>2</sup> + 1</em></strong>。</p><p>举例：<br><strong>3*7=(x+1)(x<sup>2</sup>+x+1)=x<sup>3</sup>+x<sup>2</sup>+x+x<sup>2</sup>+ x + 1= x<sup>3</sup>+(x<sup>2</sup>+x<sup>2</sup>)+(x+x)+1=x<sup>3</sup>+1</strong></p><blockquote><p><strong>模2加法中相同项相加为0</strong>。</p></blockquote><p><strong>在相乘得到的多项式结果中，如果x的次数大于7，就需要对多项式在GF(2<sup>8</sup>)上关于本原多项式P(x)求余数，即modP(x)。</strong><br>因为加法为模2加法，相同项相加为0，所以加法可以当成减法来计算。</p><p>基于多项式<strong><em>P(x) = x<sup>8</sup> + x<sup>4</sup> + x<sup>3</sup>  + x<sup>2</sup> + 1</em></strong></p><ul><li><strong>129  * 5 = (x<sup>7</sup> + 1)(x<sup>2</sup>  + 1) = (x<sup>9</sup> + x<sup>7</sup> + x<sup>2</sup> + 1) = (x<sup>9</sup> + x<sup>7</sup> + x<sup>2</sup> + 1) + (x *P(x)) =  (x<sup>9</sup> + x<sup>7</sup> + x<sup>2</sup> + 1) + (x<sup>9</sup> + x<sup>5</sup> + x<sup>4</sup> + x<sup>3</sup> + x) =  (x<sup>7</sup> + x<sup>5</sup> + x<sup>4</sup> +  x<sup>3</sup> + x<sup>2</sup> + x + 1) = 10111111b = 0xBF = 191</strong></li></ul><p>基于多项式<strong><em>P(x) = x<sup>8</sup> + x<sup>4</sup> + x<sup>3</sup>  + x + 1</em></strong></p><ul><li><strong>129  * 5 = (x<sup>7</sup> + 1)(x<sup>2</sup>  + 1) = (x<sup>9</sup> + x<sup>7</sup> + x<sup>2</sup> + 1) = (x<sup>9</sup> + x<sup>7</sup> + x<sup>2</sup> + 1) + (x *P(x)) =  (x<sup>9</sup> + x<sup>7</sup> + x<sup>2</sup> + 1) + (x<sup>9</sup> + x<sup>5</sup> + x<sup>4</sup> + x<sup>2</sup> + x) =  (x<sup>7</sup> + x<sup>5</sup> + x<sup>4</sup> + x + 1) = 10110011b = 0xB3 = 179</strong></li></ul><h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p>因为在AES算法列混合环节中用到了伽罗华域乘法，所以接下来的代码实现使用AES算法指定的不可约多项式<strong><em>P(x) = x<sup>8</sup> + x<sup>4</sup> + x<sup>3</sup>  + x + 1</em></strong>进行分析。</p><h3 id="GMul-2-v"><a href="#GMul-2-v" class="headerlink" title="GMul(2, v)"></a>GMul(2, v)</h3><p>为了方便编程我们先找找规律，假设函数GMul(u, v)表示伽罗华域乘法，先看与2相乘的伽罗华域计算，即GMul(2, v)，v、u不分左右：</p><ul><li><strong>2∗7=(<em>x</em>) * (<em>x</em><sup>2</sup>+<em>x</em>+1)=<em>x</em><sup>3</sup>+<em>x</em><sup>2</sup><em>+</em>x</strong></li></ul><blockquote><p><strong>可以看出伽罗华域中一个数与2相乘等于这个数左移一位</strong></p></blockquote><p>看上式，假如v对应的多项式x的次数大于7，即v的最高位为1，也就是<code>v&gt;&gt;7 == 1</code>的话就进行 modP(x) 化简，比如：</p><ul><li><p><strong>2 * 129 = (x) * (x<sup>7</sup> + 1) = (x<sup>8</sup> + x) = (x<sup>8</sup> + x)+  P(x) = (x<sup>8</sup> + x) + (x<sup>8</sup> + x<sup>4</sup> + x<sup>3</sup>  + x + 1) = (x<sup>4</sup> + x<sup>3</sup> + 1  ) = 00011001b = 0x19 = 00000010^ 00011011 = 0x02 ^ 0x1b = (129 &lt;&lt; 1) ^ 0x1b</strong></p></li><li><p><strong>2 * 176= (x) * (x<sup>7</sup> + x<sup>5</sup> + x<sup>4</sup>) = (x<sup>8</sup> + x<sup>6</sup> + x<sup>5</sup>) =  (x<sup>8</sup> + x<sup>6</sup> + x<sup>5</sup>) + (P(x)) =  (x<sup>8</sup> + x<sup>6</sup> + x<sup>5</sup>) + (x<sup>8</sup> + x<sup>4</sup> + x<sup>3</sup>  + x + 1) = (x<sup>6</sup> + x<sup>5</sup> + x<sup>4</sup>  + x<sup>3</sup> + x + 1) = 01111011b= 0x7B = 01100000^ 00011011 = 0x60 ^ 0x1b = (176 &lt;&lt; 1) ^ 0x1b</strong></p></li></ul><p>从上面的3个例子可以总结一个规律：</p><p><img src="1.jpg" alt="img"></p><h3 id="GMul-3-v"><a href="#GMul-3-v" class="headerlink" title="GMul(3, v)"></a>GMul(3, v)</h3><p>3∗<em>v</em>=(2+1)∗<em>v</em>=GMul<em>(2,</em>v<em>) + *v</em>= GMul(2,<em>v</em>) ^ <em>v</em></p><h3 id="GMul-4-v"><a href="#GMul-4-v" class="headerlink" title="GMul(4, v)"></a>GMul(4, v)</h3><p>4∗<em>v</em>=2∗2∗<em>v</em>= GMul(2, GMul(2, v))</p><h3 id="GMul-7-v"><a href="#GMul-7-v" class="headerlink" title="GMul(7, v)"></a>GMul(7, v)</h3><p>7∗<em>v</em>=00000111=(2∗2+2+1)= GMul(2, GMul(2, v)) ^ GMul(2, v) ^ v</p><h3 id="GMul-8-v"><a href="#GMul-8-v" class="headerlink" title="GMul(8, v)"></a>GMul(8, v)</h3><p>8∗<em>v</em>=(2∗2∗2)∗<em>v</em>=GMul(2, GMul(2, GMul(2, v)))<br>8=2^3，循环3次GMul(2,v)</p><h3 id="GMul-11111111b-v"><a href="#GMul-11111111b-v" class="headerlink" title="GMul(11111111b, v)"></a>GMul(11111111b, v)</h3><p>11111111<em>b</em>=2<sup>7</sup>+2<sup>6</sup>+2<sup>5</sup>+2<sup>4</sup>+2<sup>3</sup>+2<sup>2</sup>+2<sup>1</sup>+1<br>所以相当于：GMul(2,v)循环7次 ^ GMul(2,v)循环6次 … GMul(2,v)循环1次 ^ v</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="GMul-2-v-1"><a href="#GMul-2-v-1" class="headerlink" title="GMul(2, v)"></a>GMul(2, v)</h3><p>根据上面总结的公式可以很容易用代码实现GMul(2, v)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> GMul2(<span class="keyword">uint8_t</span> v)&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = (v &amp; <span class="number">0x80</span>);</span><br><span class="line">    v &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        v ^= <span class="number">0x1B</span>; <span class="comment">/* P(x) = x^8 + x^4 + x^3 + x + 1 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GMul-u-v"><a href="#GMul-u-v" class="headerlink" title="GMul(u, v)"></a>GMul(u, v)</h3><p>根据上述对GMul(u, v)的总结，可以用以下代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> GMul(<span class="keyword">uint8_t</span> u, <span class="keyword">uint8_t</span> v) &#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> p = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u &amp; <span class="number">0x01</span>) &#123;</span><br><span class="line">            p ^= v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        v = GMul2(v); <span class="comment">//调用GMul(2，v)</span></span><br><span class="line"></span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了代码整洁可以写成一个通用的函数，AES算法实现中列混合环节可以直接调用下面的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> GMul(<span class="keyword">uint8_t</span> u, <span class="keyword">uint8_t</span> v) &#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> p = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u &amp; <span class="number">0x01</span>) &#123;</span><br><span class="line">            p ^= v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> flag = (v &amp; <span class="number">0x80</span>);</span><br><span class="line">        v &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            v ^= <span class="number">0x1B</span>;  <span class="comment">/* P(x) = x^8 + x^4 + x^3 + x + 1 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的思路和快速幂的解法类似。</p><p>快速幂代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 求 num 的 n 次方*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mypow</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((n % <span class="number">2</span>) == <span class="number">1</span>) ans = ans * num;</span><br><span class="line">        num = num * num;</span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考</strong></p><blockquote><p>版权声明：本文为CSDN博主「Coder Liming」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/shaosunrise/article/details/80174210" target="_blank" rel="noopener">https://blog.csdn.net/shaosunrise/article/details/80174210</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;伽罗华域（Galois-Field）简介&quot;&gt;&lt;a href=&quot;#伽罗华域（Galois-Field）简介&quot; class=&quot;headerlink&quot; title=&quot;伽罗华域（Galois Field）简介&quot;&gt;&lt;/a&gt;伽罗华域（Galois Field）简介&lt;/h2&gt;&lt;p&gt;在数学中，&lt;strong&gt;有限域&lt;/strong&gt;（或称伽罗华域）是一个包含有限元素的域。与其他域一样，有限域是进行加减乘除运算都有定义并且满足特定规则的集合。其中加法和乘法必须满足交换、结合和分配的规律。加法和乘法具有封闭性，即加法和乘法结果仍然是域中的元素。&lt;/p&gt;
&lt;p&gt;伽罗华域一般用&lt;strong&gt;&lt;em&gt;GF(2&lt;sup&gt;M&lt;/sup&gt;)&lt;/em&gt;&lt;/strong&gt;表示，这个域中含有&lt;strong&gt;&lt;em&gt;2&lt;sup&gt;M&lt;/sup&gt;&lt;/em&gt;&lt;/strong&gt;个元素。&lt;strong&gt;&lt;em&gt;GF(2&lt;sup&gt;M&lt;/sup&gt;)&lt;/em&gt;&lt;/strong&gt;上的四则运算是基于多项式运算的，一般都是这种结构&lt;strong&gt;&lt;em&gt;f(x) = x&lt;sup&gt;6&lt;/sup&gt; + x&lt;sup&gt;4&lt;/sup&gt; + x&lt;sup&gt;2&lt;/sup&gt; + x + 1&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="mathematics" scheme="http://changsk.top/categories/mathematics/"/>
    
    
      <category term="伽罗华域" scheme="http://changsk.top/tags/%E4%BC%BD%E7%BD%97%E5%8D%8E%E5%9F%9F/"/>
    
      <category term="Galois_Field" scheme="http://changsk.top/tags/Galois-Field/"/>
    
  </entry>
  
  <entry>
    <title>AES加密算法的介绍与C实现</title>
    <link href="http://changsk.top/2020/04/16/AES128/"/>
    <id>http://changsk.top/2020/04/16/AES128/</id>
    <published>2020-04-16T01:37:08.000Z</published>
    <updated>2020-04-16T07:44:06.016Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h1><h2 id="1、什么是对称加密？"><a href="#1、什么是对称加密？" class="headerlink" title="1、什么是对称加密？"></a>1、什么是对称加密？</h2><p>对称加密就是指，<strong>加密和解密使用同一个密钥的加密方式。</strong></p><h2 id="2、对称加密的工作过程"><a href="#2、对称加密的工作过程" class="headerlink" title="2、对称加密的工作过程"></a>2、对称加密的工作过程</h2><p>发送方使用密钥将明文数据加密成密文，然后发送出去，接收方收到密文后，使用同一个密钥将密文解密成明文读取。</p><h2 id="3、对称加密的优点"><a href="#3、对称加密的优点" class="headerlink" title="3、对称加密的优点"></a>3、对称加密的优点</h2><p><strong>加密计算量小、速度块，适合对大量数据进行加密的场景。</strong></p><a id="more"></a><h2 id="4、对称加密的两大不足"><a href="#4、对称加密的两大不足" class="headerlink" title="4、对称加密的两大不足"></a>4、对称加密的两大不足</h2><ul><li><strong>密钥传输问题</strong>：如上所说，由于对称加密的加密和解密使用的是同一个密钥，所以对称加密的安全性就不仅仅取决于加密算法本身的强度，更取决于密钥是否被安全的保管，因此<strong>加密者如何把密钥安全的传递到解密者手里，就成了对称加密面临的关键问题。</strong>（比如，我们客户端肯定不能直接存储对称加密的密钥，因为被反编译之后，密钥就泄露了，数据安全性就得不到保障，所以<strong>实际中我们一般都是客户端向服务端请求对称加密的密钥，而且密钥还得用非对称加密算法加密后再传输。</strong>）</li><li><strong>密钥管理问题</strong>：<strong>随着密钥数量的增多，密钥的管理问题会逐渐显现出来。</strong>比如我们在加密用户的信息时，不可能所有用户都用同一个密钥加密解密。这样一旦密钥泄漏，就相当于泄露了所有用户的信息，因此需要为每一个用户单独的生成一个密钥并且管理，这样密钥管理的代价也会非常大。</li></ul><h1 id="AES加密算法简介"><a href="#AES加密算法简介" class="headerlink" title="AES加密算法简介"></a>AES加密算法简介</h1><p>如今有很多的对称加密算法，如<strong>DES加密算法</strong>、<strong>3DES加密算法</strong>等，但是因为<strong>AES加密算法</strong>的安全性要高于DES和3DES，所以AES已经成为了主要的对称加密算法。</p><p>AES加密算法就是众多对称加密算法中的一种，它的英文全称是<strong>Advanced Encryption Standard</strong>，翻译过来是高级加密标准，它是用来替代之前的DES加密算法的。AES算法是当前最流行的对称加密算法，也是一种分组加密算法，分组密码就是把明文分为固定长度的一组一组，每次加密一组数据，直到加密完整个明文数据。AES算法根据分组长度可以分为<strong>AES128, AES192，AES256</strong>，其所要求的秘钥长度和加密轮数也各不相同。</p><p>对称加密算法也就是加密和解密用相同的密钥，具体的加密流程如下图：</p><p><img src="1.jpg" alt="img"></p><p>下面简单介绍下各个部分的作用与意义：</p><ul><li>明文P</li></ul><blockquote><p>没有经过加密的数据。</p></blockquote><ul><li>密钥K</li></ul><blockquote><p>用来加密明文的密码，在对称加密算法中，加密与解密的密钥是相同的。密钥为接收方与发送方协商产生，但不可以直接在网络上传输，否则会导致密钥泄漏，通常是通过非对称加密算法加密密钥，然后再通过网络传输给对方，或者直接面对面商量密钥。密钥是绝对不可以泄漏的，否则会被攻击者还原密文，窃取机密数据。</p></blockquote><ul><li>AES加密函数</li></ul><blockquote><p>设AES加密函数为E，则 C = E(K, P),其中P为明文，K为密钥，C为密文。也就是说，把明文P和密钥K作为加密函数的参数输入，则加密函数E会输出密文C。</p></blockquote><ul><li><p>密文C</p><blockquote><p>经加密函数处理后的数据</p></blockquote></li><li><p>AES解密函数</p><blockquote><p>设AES解密函数为D，则 P = D(K, C),其中C为密文，K为密钥，P为明文。也就是说，把密文C和密钥K作为解密函数的参数输入，则解密函数会输出明文P。</p></blockquote></li></ul><p>在这里简单介绍下对称加密算法与非对称加密算法的区别。</p><ul><li><p>对称加密算法</p><blockquote><p>加密和解密用到的密钥是相同的，这种加密方式加密速度非常快，适合经常发送数据的场合。缺点是密钥的传输比较麻烦。</p></blockquote></li><li><p>非对称加密算法</p><blockquote><p>加密和解密用的密钥是不同的，这种加密方式是用数学上的难解问题构造的，通常加密解密的速度比较慢，适合偶尔发送数据的场合。优点是密钥传输方便。常见的非对称加密算法为RSA、ECC和EIGamal。</p></blockquote></li></ul><p>实际中，一般是通过<strong>RSA</strong>加密AES的密钥，传输到接收方，接收方解密得到AES密钥，然后发送方和接收方用AES密钥来通信。</p><h1 id="AES的基本结构"><a href="#AES的基本结构" class="headerlink" title="AES的基本结构"></a>AES的基本结构</h1><p>AES为分组密码，分组密码也就是把明文分成一组一组的，每组长度相等，每次加密一组数据，直到加密完整个明文。在AES标准规范中，<strong>分组长度只能是128位</strong>，也就是说，每个分组为16个字节（每个字节8位）。密钥的长度可以使用128位、192位或256位。密钥的长度不同，推荐加密轮数也不同，如下表所示：</p><table><thead><tr><th>AES</th><th>密钥长度（32位比特字)</th><th>分组长度(32位比特字)</th><th>加密轮数</th></tr></thead><tbody><tr><td>AES-128</td><td>4</td><td>4</td><td>10</td></tr><tr><td>AES-192</td><td>6</td><td>4</td><td>12</td></tr><tr><td>AES-256</td><td>8</td><td>4</td><td>14</td></tr></tbody></table><p>轮数在下面介绍，这里实现的是AES-128，也就是密钥的长度为128位，加密轮数为10轮。</p><p>AES算法主要可以分为<strong>秘钥扩展、字节替换、行移位、列混合和轮秘钥加</strong>这5个步骤。</p><ul><li>秘钥扩展（KeyExpansions：给定的初始秘钥一般比较短，比如16字节，而算法如果进行10轮运算的话就需要16x(10+1)字节长度的秘钥，需要对原始秘钥进行秘钥扩展。</li><li>字节替换（SubBytes）：一个非线性的替换步骤，根据查表把一个字节替换为另一个字节。</li><li>行移位（ShiftRows）：将数据矩阵的每一行循环移位一定长度。</li><li>列混合（MixColumns）：将数据矩阵乘以一个固定的矩阵（不是普通的矩阵相乘，而是伽罗华域中的乘法运算），增加混淆程度。</li><li>轮秘钥加（AddRoundKey）:将数据矩阵与秘钥矩阵进行异或操作。</li></ul><p>上面说到，AES的加密公式为C = E(K,P)，在加密函数E中，会执行一个轮函数，并且执行10次这个轮函数。这个轮函数的前9次执行的操作是一样的，只有第10次有所不同。也就是说，一个明文分组会被加密10轮。AES的核心就是实现一轮中的所有操作。</p><p>AES的处理单位是字节，128位的输入明文分组P和输入密钥K都被分成16个字节，分别记为P = P0 P1 … P15 和 K = K0 K1 … K15。如，明文分组为P = abcdefghijklmnop,其中的字符a对应P0，p对应P15。一般地，明文分组用字节为单位的正方形矩阵描述，称为<strong>状态矩阵</strong>。在算法的每一轮中，状态矩阵的内容不断发生变化，最后的结果作为密文输出。该矩阵中字节的排列顺序为从上到下、从左至右依次排列，如下图所示：</p><p><img src="2.jpg" alt="img"></p><p>现在假设明文分组P为”abcdefghijklmnop”，则对应上面生成的状态矩阵图如下：</p><p><img src="3.jpg" alt="img"></p><p>上图中，0x61为字符a的十六进制表示。可以看到，明文经过AES加密后，已经面目全非。</p><p>类似地，128位密钥也是用字节为单位的矩阵表示，矩阵的每一列被称为1个32位比特字。通过密钥编排函数该密钥矩阵被扩展成一个44个字组成的序列W[0],W[1], … ,W[43],该序列的前4个元素W[0],W[1],W[2],W[3]是原始密钥，用于加密运算中的初始密钥加;后面40个字分为10组，每组4个字（128比特）分别用于10轮加密运算中的轮密钥加，如下图所示：</p><p><img src="4.jpg" alt="img"></p><p>上图中，设K = “abcdefghijklmnop”，则K0 = a, K15 = p, W[0] = K0 K1 K2 K3 = “abcd”。</p><p>AES的整体结构如下图所示，其中的W[0,3]是指W[0]、W[1]、W[2]和W[3]串联组成的128位密钥。加密的第1轮到第9轮的轮函数一样，包括4个操作：<strong>字节代换、行位移、列混合和轮密钥加</strong>。最后一轮迭代不执行列混合。另外，在第一轮迭代之前，先将明文和原始密钥进行一次异或加密操作。<br><img src="5.jpg" alt="img"></p><p>上图也展示了AES解密过程，解密过程仍为10轮，<strong>每一轮的操作是加密操作的逆操作</strong>。由于AES的4个轮操作都是可逆的，因此，解密操作的一轮就是<strong>顺序执行逆行移位、逆字节代换、轮密钥加和逆列混合</strong>。同加密操作类似，最后一轮不执行逆列混合，在第1轮解密之前，要执行1次密钥加操作。</p><p>下面分别介绍AES中一轮的4个操作阶段，这4分操作阶段使输入位得到充分的混淆。</p><h2 id="一、字节代换"><a href="#一、字节代换" class="headerlink" title="一、字节代换"></a>一、字节代换</h2><h3 id="1-字节代换操作"><a href="#1-字节代换操作" class="headerlink" title="1.字节代换操作"></a>1.字节代换操作</h3><p>AES的字节代换其实就是一个简单的查表操作。AES定义了一个S盒和一个逆S盒。<br>AES的S盒：</p><p><img src="6.jpg" alt="img"></p><p>状态矩阵中的元素按照下面的方式映射为一个新的字节：把该字节的高4位作为行值，低4位作为列值，取出S盒或者逆S盒中对应的行的元素作为输出。例如，加密时，输出的字节S1为0x12,则查S盒的第0x01行和0x02列，得到值0xc9,然后替换S1原有的0x12为0xc9。状态矩阵经字节代换后的图如下：</p><p><img src="7.jpg" alt="img"></p><h3 id="2-字节代换逆操作"><a href="#2-字节代换逆操作" class="headerlink" title="2.字节代换逆操作"></a>2.字节代换逆操作</h3><p>逆字节代换也就是查逆S盒来变换，逆S盒如下：</p><p><img src="8.jpg" alt="img"></p><h2 id="二、行移位"><a href="#二、行移位" class="headerlink" title="二、行移位"></a>二、行移位</h2><h3 id="1-行移位操作"><a href="#1-行移位操作" class="headerlink" title="1.行移位操作"></a>1.行移位操作</h3><p>行移位是一个简单的左循环移位操作。当密钥长度为128比特时，状态矩阵的第0行左移0字节，第1行左移1字节，第2行左移2字节，第3行左移3字节，如下图所示：</p><p><img src="9.jpg" alt="img"></p><h3 id="2-行移位的逆变换"><a href="#2-行移位的逆变换" class="headerlink" title="2.行移位的逆变换"></a>2.行移位的逆变换</h3><p>行移位的逆变换是将状态矩阵中的每一行执行相反的移位操作，例如AES-128中，状态矩阵的第0行右移0字节，第1行右移1字节，第2行右移2字节，第3行右移3字节。</p><h2 id="三、列混合"><a href="#三、列混合" class="headerlink" title="三、列混合"></a>三、列混合</h2><h3 id="1-列混合操作"><a href="#1-列混合操作" class="headerlink" title="1.列混合操作"></a>1.列混合操作</h3><p>列混合变换是通过<strong>矩阵相乘</strong>来实现的，经行移位后的状态矩阵与固定的矩阵相乘，得到混淆后的状态矩阵，如下图的公式所示：</p><p><img src="10.jpg" alt="img"></p><p>状态矩阵中的第j列(0 ≤j≤3)的列混合可以表示为下图所示：</p><p><img src="11.jpg" alt="img"></p><p>其中，矩阵元素的乘法和加法都是定义在基于伽罗华域GF(2^8)上的二元运算,并不是通常意义上的乘法和加法。有关伽罗华域请点击<a href="http://changsk.top/2020/04/16/Galois-Field/">这里</a>查看。这里涉及到一些信息安全上的数学知识，不过不懂这些知识也行。<strong>其实这种二元运算的加法等价于两个字节的异或，乘法则复杂一点。</strong>对于一个8位的二进制数来说，使用域上的乘法乘以(00000010)等价于左移1位(低位补0)后，再根据情况同(00011011)进行异或运算，设S1 = (a7 a6 a5 a4 a3 a2 a1 a0)，刚0x02 * S1如下图所示：<br><img src="12.jpg" alt="img"></p><p>也就是说，如果a7为1，则进行异或运算，否则不进行。<br>类似地，乘以(00000100)可以拆分成两次乘以(00000010)的运算：</p><p><img src="13.jpg" alt="img"></p><p>乘以(0000 0011)可以拆分成先分别乘以(0000 0001)和(0000 0010)，再将两个乘积异或：</p><p><img src="14.jpg" alt="img"></p><p>因此，我们只需要实现乘以2的函数，其他数值的乘法都可以通过组合来实现。<br>下面举个具体的例子,输入的状态矩阵如下：</p><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>C9</td><td>E5</td><td>FD</td><td>2B</td></tr><tr><td>7A</td><td>F2</td><td>78</td><td>6E</td></tr><tr><td>63</td><td>9C</td><td>26</td><td>67</td></tr><tr><td>B0</td><td>A7</td><td>82</td><td>E5</td></tr></tbody></table><p>下面，进行列混合运算：<br>以第一列的运算为例：</p><p><img src="15.jpg" alt="img"></p><p>其它列的计算就不列举了，列混合后生成的新状态矩阵如下：</p><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>D4</td><td>E7</td><td>CD</td><td>66</td></tr><tr><td>28</td><td>02</td><td>E5</td><td>BB</td></tr><tr><td>BE</td><td>C6</td><td>D6</td><td>BF</td></tr><tr><td>22</td><td>0F</td><td>DF</td><td>A5</td></tr></tbody></table><h3 id="2-列混合逆运算"><a href="#2-列混合逆运算" class="headerlink" title="2.列混合逆运算"></a>2.列混合逆运算</h3><p>逆向列混合变换可由下图的矩阵乘法定义：<br><img src="16.jpg" alt="img"><br>可以验证，逆变换矩阵同正变换矩阵的乘积恰好为单位矩阵。</p><h2 id="四、轮密钥加"><a href="#四、轮密钥加" class="headerlink" title="四、轮密钥加"></a>四、轮密钥加</h2><p>轮密钥加是将128位轮密钥Ki同状态矩阵中的数据进行逐位异或操作，如下图所示。其中，密钥Ki中每个字W[4i],W[4i+1],W[4i+2],W[4i+3]为32位比特字，包含4个字节，他们的生成算法下面在下面介绍。轮密钥加过程可以看成是字逐位异或的结果，也可以看成字节级别或者位级别的操作。也就是说，可以看成S0 S1 S2 S3 组成的32位字与W[4i]的异或运算。</p><p><img src="17.jpg" alt="img"></p><p>轮密钥加的逆运算同正向的轮密钥加运算完全一致，这是因为异或的逆操作是其自身。轮密钥加非常简单，但却能够影响S数组中的每一位。</p><h2 id="密钥扩展"><a href="#密钥扩展" class="headerlink" title="密钥扩展"></a>密钥扩展</h2><p>AES首先将初始密钥输入到一个44的状态矩阵中，如下图所示。</p><p><img src="18.jpg" alt="img"></p><p>这个44矩阵的每一列的4个字节组成一个字，矩阵4列的4个字依次命名为W[0]、W[1]、W[2]和W[3]，它们构成一个以字为单位的数组W。例如，设密钥K为”abcdefghijklmnop”,则K0 = ‘a’,K1 = ‘b’, K2 = ‘c’,K3 = ‘d’,W[0] = “abcd”。<br>接着，对W数组扩充40个新列，构成总共44列的扩展密钥数组。新列以如下的递归方式产生：</p><ol><li>如果i不是4的倍数，那么第i列由如下等式确定：<br>W[i]=W[i-4]⨁W[i-1]</li><li>如果i是4的倍数，那么第i列由如下等式确定：<br>W[i]=W[i-4]⨁T(W[i-1])<br>其中，T是一个有点复杂的函数。<br>函数T由3部分组成：<strong>字循环、字节代换和轮常量异或</strong>，这3部分的作用分别如下。<br>a. 字循环：将1个字中的4个字节循环左移1个字节。即将输入字[b0, b1, b2, b3]变换成[b1,b2,b3,b0]。<br>b. 字节代换：对字循环的结果使用S盒进行字节代换。<br>c. 轮常量异或：将前两步的结果同轮常量Rcon[j]进行异或，其中j表示轮数。<br>轮常量Rcon[j]是一个字，其值见下表。</li></ol><p><img src="19.jpg" alt="img"></p><p>下面举个例子：<br>设初始的128位密钥为：<br>3C A1 0B 21 57 F0 19 16 90 2E 13 80 AC C1 07 BD<br>那么4个初始值为：<br>W[0] = 3C A1 0B 21<br>W[1] = 57 F0 19 16<br>W[2] = 90 2E 13 80<br>W[3] = AC C1 07 BD<br>下面求扩展的第1轮的子密钥(W[4],W[5],W[6],W[7])。<br>由于4是4的倍数，所以：<br>W[4] = W[0] ⨁ T(W[3])<br>T(W[3])的计算步骤如下：</p><ol><li>循环地将W[3]的元素移位：AC C1 07 BD变成C1 07 BD AC;</li><li>将 C1 07 BD AC 作为S盒的输入，输出为78 C5 7A 91;</li><li>将78 C5 7A 91与第一轮轮常量Rcon[1]进行异或运算，将得到79 C5 7A 91，因此，T(W[3])=79 C5 7A 91，故<br>W[4] = 3C A1 0B 21 ⨁ 79 C5 7A 91 = 45 64 71 B0<br>其余的3个子密钥段的计算如下：<br>W[5] = W[1] ⨁ W[4] = 57 F0 19 16 ⨁ 45 64 71 B0 = 12 94 68 A6<br>W[6] = W[2] ⨁ W[5] =90 2E 13 80 ⨁ 12 94 68 A6 = 82 BA 7B 26<br>W[7] = W[3] ⨁ W[6] = AC C1 07 BD ⨁ 82 BA 7B 26 = 2E 7B 7C 9B<br>所以，第一轮的密钥为 45 64 71 B0 12 94 68 A6 82 BA 7B 26 2E 7B 7C 9B。</li></ol><h1 id="AES解密"><a href="#AES解密" class="headerlink" title="AES解密"></a>AES解密</h1><p>在文章开始的图中，有AES解密的流程图，可以对应那个流程图来进行解密。下面介绍的是另一种等价的解密模式，流程图如下图所示。<strong>这种等价的解密模式使得解密过程各个变换的使用顺序同加密过程的顺序一致，只是用逆变换取代原来的变换。</strong></p><p><img src="20.jpg" alt="img"></p><h1 id="AES分组填充模式"><a href="#AES分组填充模式" class="headerlink" title="AES分组填充模式"></a>AES分组填充模式</h1><p>AES采用<strong>分组密码体制</strong>，即AES加密会首先把明文切成一段一段的，而且每段数据的长度要求必须是128位16个字节，如果最后一段不够16个字节了，就需要用Padding来把这段数据填满16个字节，然后分别对每段数据进行加密，最后再把每段加密数据拼起来形成最终的密文。下面介绍几种常用的分组填充模式。</p><h2 id="NoPadding"><a href="#NoPadding" class="headerlink" title="NoPadding"></a><strong>NoPadding</strong></h2><p>NoPadding是指不需要填充，也就是说数据的发送方<strong>肯定会保证最后一段数据也正好是16个字节</strong>。</p><h2 id="ZeroPadding"><a href="#ZeroPadding" class="headerlink" title="ZeroPadding"></a>ZeroPadding</h2><p>ZeroPadding，数据长度不对齐时使用0填充，否则不填充。</p><h2 id="PKCS7Padding"><a href="#PKCS7Padding" class="headerlink" title="PKCS7Padding"></a><strong>PKCS7Padding</strong></h2><p>假设每个区块大小为blockSize（AES当中为16字节，128bit）</p><ul><li>已对齐，填充一个长度为blockSize且每个字节均为blockSize的数据。<blockquote><p>即填充 16 个字节，每个字节的值为 16</p></blockquote></li><li>未对齐，需要补充的字节个数为n，则填充一个长度为n且每个字节均为n的数据。</li></ul><h1 id="AES分组密码工作模式"><a href="#AES分组密码工作模式" class="headerlink" title="AES分组密码工作模式"></a>AES分组密码工作模式</h1><p><strong>AES算法描述怎么加密一个数据块，分组密码工作模式描述了如何重复加密比较长的多个数据块。</strong> 常见的分组密码工作模式有<strong>ECB、CBC、CFB、OFB、CTR</strong>五种，下面通过流程图分别展示了5大模式的分组密码工作加解密的流程。</p><h2 id="ECB"><a href="#ECB" class="headerlink" title="ECB"></a>ECB</h2><p><strong>ECB</strong>(Electronic Codebook, 电子密码本)模式是最简单的加密模式，明文消息被分成固定大小的块（分组），并且每个块被单独加密。每个块的加密和解密都是独立的，且使用相同的方法进行加密，所以<strong>可以进行并行计算</strong>，但是这种方法一旦有一个块被破解，使用相同的方法可以解密所有的明文数据，<strong>安全性比较差。</strong><br>适用于数据较少的情形，加密前需要把明文数据填充到块大小的整倍数。</p><p><img src="21.jpg" alt="img"></p><h2 id="CBC"><a href="#CBC" class="headerlink" title="CBC"></a>CBC</h2><p><strong>CBC</strong>(Cipher Block Chaining, 密码块链)模式中每一个分组要先和前一个分组加密后的数据进行XOR异或操作，然后再进行加密。这样每个密文块依赖该块之前的所有明文块，为了保持每条消息都具有唯一性，第一个数据块进行加密之前需要用初始化向量IV进行异或操作。<strong>CBC模式是一种最常用的加密模式</strong>，它主要缺点是加密是连续的，<strong>不能并行处理</strong>，并且与ECB一样消息块必须填充到块大小的整倍数。</p><p>在链模式如CBC中，每个分组都会影响到下一个分组的加密。这就是为了保证<strong>两个相同的普通文本分组不会生成相同的密文分组</strong>。第一个分组是个特列，因为它前面再没有其他的分组了。链模式允许定义一个额外的称为初始化向量（Initialization Vector, IV）的分组来开始这个链。这个通常会被标成可选的。但你总是需要提供一个。否则，它会用一个全是0的分组，那样会让你的数据<strong>容易受到特定的攻击的侵害</strong>。</p><p><strong>初始向量IV的作用是使加密更加安全可靠，我们使用AES加密时需要主动提供初始向量，而且只需要提供一个初始向量就够了，后面每段数据的加密向量都是前面一段的密文。初始向量IV的长度规定为128位16个字节，初始向量的来源为随机生成。</strong></p><p><img src="22.jpg" alt="img"></p><h2 id="CFB"><a href="#CFB" class="headerlink" title="CFB"></a>CFB</h2><p><strong>CFB</strong>(Cipher Feedback, 密码反馈)模式和CBC模式比较相似，<strong>前一个分组的密文加密后和当前分组的明文XOR异或操作生成当前分组的密文</strong>。CFB模式的解密和CBC模式的加密在流程上其实是非常相似的。</p><p><img src="23.jpg" alt="img"></p><h2 id="OFB"><a href="#OFB" class="headerlink" title="OFB"></a>OFB</h2><p>OFB(Output Feedback, 输出反馈)模式将<strong>分组密码转换为同步流密码</strong>，也就是说可以根据明文长度先独立生成相应长度的流密码。通过流程图可以看出，OFB和CFB非常相似，CFB是前一个分组的密文加密后XOR当前分组明文，OFB是前一个分组与前一个明文块异或之前的流密码XOR当前分组明文。由于异或操作的对称性，OFB模式的解密和加密完全一样的流程。</p><p><img src="24.jpg" alt="img"></p><h2 id="CTR"><a href="#CTR" class="headerlink" title="CTR"></a>CTR</h2><p><strong>CTR</strong>(Counter, 计数器)。在CTR模式中，每次加密时都会生成一个不同的值来作为计数器的初始值，每个分组对应一个逐次累加的计数器，通过对计数器进行加密来生成密钥流，再将密钥流与明文分组进行异或操作得到密文分组。</p><p><img src="25.jpg" alt="img"></p><h1 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h1><p><a href="https://github.com/Tkzccsk/AES128-with-C" target="_blank" rel="noopener">AES-128 C语言实现</a></p><p>秘钥长度为128bit，分组填充模式为PKCS7Padding，提供ECB和CBC两种模式。</p><h1 id="注意的问题"><a href="#注意的问题" class="headerlink" title="注意的问题"></a>注意的问题</h1><p>实际开发中使用AES加密需要注意的地方</p><ul><li>服务端和我们客户端必须使用<strong>一样的密钥和初始向量IV</strong>。</li><li>服务端和我们客户端必须使用<strong>一样的加密模式</strong>。</li><li>服务端和我们客户端必须使用<strong>一样的Padding模式</strong>。</li></ul><p>以上三条有一个不满足，双方就无法完成互相加解密。</p><p>同时针对对称加密<strong>密钥传输问题</strong>这个不足：我们一般采用<strong>RSA+AES加密相结合的方式</strong>，用AES加密数据，而用RSA加密AES的密钥。同时密钥和IV可以随机生成，这要是128位16个字节就行，但是<strong>必须由服务端来生成</strong>，因为如果由我们客户端生成的话，就好比我们客户端存放了非对称加密的私钥一样，这样容易被反编译，不安全，一定要从服务端请求密钥和初始向量IV。</p><p><strong>参考</strong></p><ol><li><a href="https://blog.csdn.net/qq_28205153/article/details/55798628" target="_blank" rel="noopener">AES加密算法的详细介绍与实现</a></li><li><a href="https://blog.csdn.net/shaosunrise/article/details/80219950" target="_blank" rel="noopener">AES算法描述及C语言实现</a></li><li><a href="https://www.jianshu.com/p/3840b344b27c?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation" target="_blank" rel="noopener">第二篇：对称加密及AES加密算法</a></li><li><a href="https://blog.csdn.net/shaosunrise/article/details/80035297" target="_blank" rel="noopener">图解分组密码五大工作模式</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;对称加密&quot;&gt;&lt;a href=&quot;#对称加密&quot; class=&quot;headerlink&quot; title=&quot;对称加密&quot;&gt;&lt;/a&gt;对称加密&lt;/h1&gt;&lt;h2 id=&quot;1、什么是对称加密？&quot;&gt;&lt;a href=&quot;#1、什么是对称加密？&quot; class=&quot;headerlink&quot; title=&quot;1、什么是对称加密？&quot;&gt;&lt;/a&gt;1、什么是对称加密？&lt;/h2&gt;&lt;p&gt;对称加密就是指，&lt;strong&gt;加密和解密使用同一个密钥的加密方式。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;2、对称加密的工作过程&quot;&gt;&lt;a href=&quot;#2、对称加密的工作过程&quot; class=&quot;headerlink&quot; title=&quot;2、对称加密的工作过程&quot;&gt;&lt;/a&gt;2、对称加密的工作过程&lt;/h2&gt;&lt;p&gt;发送方使用密钥将明文数据加密成密文，然后发送出去，接收方收到密文后，使用同一个密钥将密文解密成明文读取。&lt;/p&gt;
&lt;h2 id=&quot;3、对称加密的优点&quot;&gt;&lt;a href=&quot;#3、对称加密的优点&quot; class=&quot;headerlink&quot; title=&quot;3、对称加密的优点&quot;&gt;&lt;/a&gt;3、对称加密的优点&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;加密计算量小、速度块，适合对大量数据进行加密的场景。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="密码学" scheme="http://changsk.top/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="AES128" scheme="http://changsk.top/tags/AES128/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-54:Spiral Matrix(顺时针旋转打印矩阵)</title>
    <link href="http://changsk.top/2020/04/15/leetcode-54/"/>
    <id>http://changsk.top/2020/04/15/leetcode-54/</id>
    <published>2020-04-15T05:05:06.000Z</published>
    <updated>2020-04-15T05:12:01.050Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/spiral-matrix/" target="_blank" rel="noopener">Spiral Matrix</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>题目难度：Medium</p></blockquote><p>Given a matrix of <em>m</em> x <em>n</em> elements (<em>m</em> rows, <em>n</em> columns), return all elements of the matrix in spiral order.</p><p><strong>Example 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line"> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ],</span><br><span class="line"> [ <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ],</span><br><span class="line"> [ <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> ]</span><br><span class="line">]</span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">  [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]</span><br><span class="line">]</span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure><h2 id="AC代码1"><a href="#AC代码1" class="headerlink" title="AC代码1"></a>AC代码1</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; resList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) <span class="keyword">return</span> resList;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length * matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] dr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dc = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">boolean</span>[][] seen = <span class="keyword">new</span> <span class="keyword">boolean</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>, c = <span class="number">0</span>, di = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">            seen[r][c] = <span class="keyword">true</span>;</span><br><span class="line">            resList.add(matrix[r][c]);</span><br><span class="line">            <span class="keyword">int</span> cr = r + dr[di];</span><br><span class="line">            <span class="keyword">int</span> cc = c + dc[di];</span><br><span class="line">            <span class="keyword">if</span>(cr &gt;= <span class="number">0</span> &amp;&amp; cr &lt; matrix.length &amp;&amp; cc &gt;= <span class="number">0</span> &amp;&amp; cc &lt; matrix[<span class="number">0</span>].length &amp;&amp; seen[cr][cc] == <span class="keyword">false</span>)&#123;</span><br><span class="line">                r = cr;</span><br><span class="line">                c = cc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                di = (di + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">                r += dr[di];</span><br><span class="line">                c += dc[di];</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AC代码2"><a href="#AC代码2" class="headerlink" title="AC代码2"></a>AC代码2</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    List&lt;Integer&gt; resList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) <span class="keyword">return</span> resList;</span><br><span class="line">        printMatrixCore(matrix, <span class="number">0</span>, matrix.length - <span class="number">1</span>, <span class="number">0</span>, matrix[<span class="number">0</span>].length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printMatrixCore</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> startRow, <span class="keyword">int</span> endRow, <span class="keyword">int</span> startCol, <span class="keyword">int</span> endCol)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(startRow &lt; endRow &amp;&amp; startCol &lt; endCol)&#123;</span><br><span class="line">            <span class="keyword">for</span>(i = startCol;i &lt;= endCol;i++) resList.add(matrix[startRow][i]);</span><br><span class="line">            <span class="keyword">for</span>(i = startRow + <span class="number">1</span>;i &lt;= endRow;i++) resList.add(matrix[i][endCol]);</span><br><span class="line">            <span class="keyword">for</span>(i = endCol - <span class="number">1</span>;i &gt;= startCol;i--) resList.add(matrix[endRow][i]);</span><br><span class="line">            <span class="keyword">for</span>(i = endRow - <span class="number">1</span>;i &gt; startRow;i--) resList.add(matrix[i][startCol]);</span><br><span class="line">            printMatrixCore(matrix, startRow + <span class="number">1</span>, endRow - <span class="number">1</span>, startCol + <span class="number">1</span>, endCol - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(startRow == endRow &amp;&amp; startCol == endCol) resList.add(matrix[startRow][startCol]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(startRow == endRow &amp;&amp; startCol &lt; endCol)&#123;</span><br><span class="line">            <span class="keyword">for</span>(i = startCol;i &lt;= endCol;i++) resList.add(matrix[startRow][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(startRow &lt; endRow &amp;&amp; startCol == endCol)&#123;</span><br><span class="line">            <span class="keyword">for</span>(i = startRow;i &lt;= endRow;i++) resList.add(matrix[i][startCol]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/spiral-matrix/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spiral Matrix&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-140:Word Break II</title>
    <link href="http://changsk.top/2019/10/01/leetcode-140/"/>
    <id>http://changsk.top/2019/10/01/leetcode-140/</id>
    <published>2019-10-01T01:53:18.000Z</published>
    <updated>2020-03-11T10:35:34.809Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/word-break-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/word-break-ii/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>题目难度：Medium</strong></p><p>Given a <strong>non-empty</strong> string <em>s</em> and a dictionary <em>wordDict</em> containing a list of <strong>non-empty</strong> words, add spaces in <em>s</em> to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.</p><p><strong>Note:</strong></p><ul><li>The same word in the dictionary may be reused multiple times in the segmentation.</li><li>You may assume the dictionary does not contain duplicate words.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;catsanddog&quot;</span><br><span class="line">wordDict = [&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  &quot;cats and dog&quot;,</span><br><span class="line">  &quot;cat sand dog&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;pineapplepenapple&quot;</span><br><span class="line">wordDict = [&quot;apple&quot;, &quot;pen&quot;, &quot;applepen&quot;, &quot;pine&quot;, &quot;pineapple&quot;]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  &quot;pine apple pen apple&quot;,</span><br><span class="line">  &quot;pineapple pen apple&quot;,</span><br><span class="line">  &quot;pine applepen apple&quot;</span><br><span class="line">]</span><br><span class="line">Explanation: Note that you are allowed to reuse a dictionary word.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;catsandog&quot;</span><br><span class="line">wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">Output:</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>代码来自：<a href="https://leetcode.com/problems/word-break-ii/discuss/44167/My-concise-JAVA-solution-based-on-memorized-DFS" target="_blank" rel="noopener">https://leetcode.com/problems/word-break-ii/discuss/44167/My-concise-JAVA-solution-based-on-memorized-DFS</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DFS(s, wordDict, <span class="keyword">new</span> HashMap&lt;String, LinkedList&lt;String&gt;&gt;());</span><br><span class="line">    &#125;       </span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS function returns an array including all substrings derived from s.</span></span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">DFS</span><span class="params">(String s, List&lt;String&gt; wordDict, HashMap&lt;String, LinkedList&lt;String&gt;&gt;map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(s)) </span><br><span class="line">        <span class="keyword">return</span> map.get(s);</span><br><span class="line">        </span><br><span class="line">    LinkedList&lt;String&gt;res = <span class="keyword">new</span> LinkedList&lt;String&gt;();     </span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        res.add(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;               </span><br><span class="line">    <span class="keyword">for</span> (String word : wordDict) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.startsWith(word)) &#123;</span><br><span class="line">            List&lt;String&gt; sublist = DFS(s.substring(word.length()), wordDict, map);</span><br><span class="line">            <span class="keyword">for</span> (String sub : sublist) </span><br><span class="line">                res.add(word + (sub.isEmpty() ? <span class="string">""</span> : <span class="string">" "</span>) + sub);               </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;       </span><br><span class="line">    map.put(s, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/word-break-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/word-break-ii/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-139:Word Break</title>
    <link href="http://changsk.top/2019/09/28/leetcode-139/"/>
    <id>http://changsk.top/2019/09/28/leetcode-139/</id>
    <published>2019-09-28T13:11:54.000Z</published>
    <updated>2019-09-29T11:16:36.256Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/word-break/" target="_blank" rel="noopener">https://leetcode.com/problems/word-break/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>题目难度：Medium</strong></p><p>Given a <strong>non-empty</strong> string <em>s</em> and a dictionary <em>wordDict</em> containing a list of <strong>non-empty</strong> words, determine if <em>s</em> can be segmented into a space-separated sequence of one or more dictionary words.</p><p><strong>Note:</strong></p><ul><li>The same word in the dictionary may be reused multiple times in the segmentation.</li><li>You may assume the dictionary does not contain duplicate words.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;.</span><br><span class="line">             Note that you are allowed to reuse a dictionary word.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; dict)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">boolean</span>[] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//填充数组 f 的 1 到 s.length() 的元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(f[j] &amp;&amp; dict.contains(s.substring(j, i)))&#123;</span><br><span class="line">                    f[i] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> f[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Time: O(MN): N - wordDict length, M - s.length()</span></span><br><span class="line"><span class="comment">//Space: O(M) </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> canBreak(s, <span class="number">0</span>, wordDict, <span class="keyword">new</span> <span class="keyword">int</span>[s.length()]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canBreak</span><span class="params">(String s, <span class="keyword">int</span> index, List&lt;String&gt; wordDict, <span class="keyword">int</span>[] memo)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == s.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(memo[index] != <span class="number">0</span>) <span class="keyword">return</span> memo[index] &gt; <span class="number">0</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(String word : wordDict)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index + word.length() &lt;= s.length() &amp;&amp; s.substring(index, index+word.length()).equals(word))&#123;</span><br><span class="line">                <span class="keyword">if</span>(canBreak(s, index+word.length(), wordDict, memo)) &#123;</span><br><span class="line">                    memo[index] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">        memo[index] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>代码来自：Leetcode</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/word-break/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/word-break/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-134:Gas Station(加油站)</title>
    <link href="http://changsk.top/2019/09/28/leetcode-134/"/>
    <id>http://changsk.top/2019/09/28/leetcode-134/</id>
    <published>2019-09-28T02:43:59.000Z</published>
    <updated>2019-09-28T04:10:09.609Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/gas-station/" target="_blank" rel="noopener">https://leetcode.com/problems/gas-station/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>题目难度：Medium</strong></p><p>There are <em>N</em> gas stations along a circular route, where the amount of gas at station <em>i</em> is <code>gas[i]</code>.</p><p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from station <em>i</em> to its next station (<em>i</em>+1). You begin the journey with an empty tank at one of the gas stations.</p><p>Return the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return -1.</p><p><strong>Note:</strong></p><ul><li>If there exists a solution, it is guaranteed to be unique.</li><li>Both input arrays are non-empty and have the same length.</li><li>Each element in the input arrays is a non-negative integer.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">gas  = [1,2,3,4,5]</span><br><span class="line">cost = [3,4,5,1,2]</span><br><span class="line"></span><br><span class="line">Output: 3</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4</span><br><span class="line">Travel to station 4. Your tank = 4 - 1 + 5 = 8</span><br><span class="line">Travel to station 0. Your tank = 8 - 2 + 1 = 7</span><br><span class="line">Travel to station 1. Your tank = 7 - 3 + 2 = 6</span><br><span class="line">Travel to station 2. Your tank = 6 - 4 + 3 = 5</span><br><span class="line">Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.</span><br><span class="line">Therefore, return 3 as the starting index.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">gas  = [2,3,4]</span><br><span class="line">cost = [3,4,3]</span><br><span class="line"></span><br><span class="line">Output: -1</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">You can&apos;t start at station 0 or 1, as there is not enough gas to travel to the next station.</span><br><span class="line">Let&apos;s start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4</span><br><span class="line">Travel to station 0. Your tank = 4 - 3 + 2 = 3</span><br><span class="line">Travel to station 1. Your tank = 3 - 3 + 3 = 3</span><br><span class="line">You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.</span><br><span class="line">Therefore, you can&apos;t travel around the circuit once no matter where you start.</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>非常经典的一道题。可以转换成求最大连续和做，但是有更简单的方法。基于一个数学定理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果一个数组的总和非负，那么一定可以找到一个起始位置，从他开始绕数组一圈，累加和一直都是非负的</span><br></pre></td></tr></table></figure><p>（证明貌似不难，以后有时间再补）</p><p>有了这个定理，判断到底是否存在这样的解非常容易，只需要把全部的油耗情况计算出来看看是否大于等于0即可。</p><p>那么如何求开始位置在哪？</p><p>注意到这样一个现象：</p><ol><li>假如从位置i开始，i+1，i+2…，一路开过来一路油箱都没有空。说明什么？说明从i到i+1，i+2，…肯定是正积累。</li><li>现在突然发现开往位置j时油箱空了。这说明什么？说明从位置i开始没法走完全程(废话)。那么，我们要从位置i+1开始重新尝试吗？不需要！为什么？因为前面已经知道，位置i肯定是正积累，那么，如果从位置i+1开始走更加没法走完全程了，因为没有位置i的正积累了。同理，也不用从i+2，i+3，…开始尝试。所以我们可以放心地从位置j+1开始尝试。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;gas, vector&lt;<span class="keyword">int</span>&gt; &amp;cost)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> start = <span class="number">0</span>; <span class="comment">// 起始位置</span></span><br><span class="line">  <span class="keyword">int</span> remain = <span class="number">0</span>; <span class="comment">// 当前剩余燃料</span></span><br><span class="line">  <span class="keyword">int</span> debt = <span class="number">0</span>; <span class="comment">// 前面没能走完的路上欠的债</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gas.size(); i++) &#123;</span><br><span class="line">    remain += gas[i] - cost[i];</span><br><span class="line">    <span class="keyword">if</span> (remain &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      debt += remain;</span><br><span class="line">      start = i + <span class="number">1</span>;</span><br><span class="line">      remain = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> remain + debt &gt;= <span class="number">0</span> ? start : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考：</p><h1 id="Leetcode-134-Gas-station"><a href="#Leetcode-134-Gas-station" class="headerlink" title="Leetcode#134 Gas station"></a><a href="https://www.cnblogs.com/boring09/p/4248482.html" target="_blank" rel="noopener">Leetcode#134 Gas station</a></h1></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/gas-station/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/gas-station/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-137:Single Number II</title>
    <link href="http://changsk.top/2019/09/26/leetcode-137/"/>
    <id>http://changsk.top/2019/09/26/leetcode-137/</id>
    <published>2019-09-25T16:03:47.000Z</published>
    <updated>2019-09-27T10:34:44.557Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/single-number-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/single-number-ii/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>题目难度：Medium</strong></p><p>Given a <strong>non-empty</strong> array of integers, every element appears <em>three</em> times except for one, which appears exactly once. Find that single one.</p><p><strong>Note:</strong></p><p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,3,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,0,1,0,1,99]</span><br><span class="line">Output: 99</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>代码来源：<a href="https://leetcode.com/problems/single-number-ii/discuss/43294/Challenge-me-thx" target="_blank" rel="noopener">leetcode</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++)&#123;</span><br><span class="line">        ones = (ones ^ A[i]) &amp; ~twos;</span><br><span class="line">        twos = (twos ^ A[i]) &amp; ~ones;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ones;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心思想：<strong>对一个相同的数字经过三次运算之后，ones 和 twos 的值保持不变</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//第一次</span></span><br><span class="line">ones = (ones ^ a) &amp; ~twos; <span class="comment">// 5</span></span><br><span class="line">twos = (twos ^ a) &amp; ~ones; <span class="comment">// 0</span></span><br><span class="line"><span class="comment">//第二次</span></span><br><span class="line">ones = (ones ^ a) &amp; ~twos; <span class="comment">// 0</span></span><br><span class="line">twos = (twos ^ a) &amp; ~ones; <span class="comment">// 5</span></span><br><span class="line"><span class="comment">//第三次</span></span><br><span class="line">ones = (ones ^ a) &amp; ~twos; <span class="comment">// 0</span></span><br><span class="line">twos = (twos ^ a) &amp; ~ones; <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/single-number-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/single-number-ii/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-132:Palindrome Partitioning II</title>
    <link href="http://changsk.top/2019/09/25/leetcode-132/"/>
    <id>http://changsk.top/2019/09/25/leetcode-132/</id>
    <published>2019-09-25T09:14:24.000Z</published>
    <updated>2019-09-27T10:44:41.693Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/palindrome-partitioning-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/palindrome-partitioning-ii/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>题目难度：Hard</strong></p><p>Given a string <em>s</em>, partition <em>s</em> such that every substring of the partition is a palindrome.</p><p>Return the minimum cuts needed for a palindrome partitioning of <em>s</em>.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;aab&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The palindrome partitioning [&quot;aa&quot;,&quot;b&quot;] could be produced using 1 cut.</span><br></pre></td></tr></table></figure><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p>This can be solved by two points:</p><ol><li><code>cut[i]</code> is the minimum of <code>cut[j - 1] + 1 (j &lt;= i)</code>, if <code>[j, i]</code> is palindrome.</li><li>If <code>[j, i]</code> is palindrome, <code>[j + 1, i - 1]</code> is palindrome, and <code>c[j] == c[i]</code>.</li></ol><p>The 2nd point reminds us of using dp (caching).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a   b   a   |   c  c</span><br><span class="line">                j  i</span><br><span class="line">       j-1  |  [j, i] is palindrome</span><br><span class="line">   cut(j-1) +  1</span><br></pre></td></tr></table></figure><p>代码来自：<a href="https://leetcode.com/problems/palindrome-partitioning-ii/discuss/42213/Easiest-Java-DP-Solution-(97.36)" target="_blank" rel="noopener">Leetcode</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCut</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> n = c.length;</span><br><span class="line">    <span class="comment">// cut[i] 表示下标从 0 到 i 的元素组成的子数组的最小切割数（子问题）</span></span><br><span class="line">    <span class="keyword">int</span>[] cut = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="comment">// pal[i][j] 表示下标从 0 到 i 的元素组成的子数组是否为回文序列</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] pal = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="comment">//j + 1 &gt;= i - 1 相当于 i - j &lt;= 2，即 i 和 j 的距离不超过2</span></span><br><span class="line">            <span class="keyword">if</span>(c[j] == c[i] &amp;&amp; (j + <span class="number">1</span> &gt;= i - <span class="number">1</span> || pal[j + <span class="number">1</span>][i - <span class="number">1</span>])) &#123;</span><br><span class="line">                pal[j][i] = <span class="keyword">true</span>;  </span><br><span class="line">                min = j == <span class="number">0</span> ? <span class="number">0</span> : Math.min(min, cut[j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cut[i] = min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cut[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCut</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s==<span class="keyword">null</span> || s.length()&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="comment">//每个位置的最小切割数</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;dp.length; ++i) &#123;</span><br><span class="line">            <span class="comment">//初始化 dp 为每一个位置的最大切割数</span></span><br><span class="line">            dp[i] = i-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">            <span class="comment">//回文串是奇数的情况</span></span><br><span class="line">            helper(i, i, dp, s);</span><br><span class="line">            <span class="comment">//回文串是偶数的情况</span></span><br><span class="line">            helper(i, i+<span class="number">1</span>, dp, s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span>[] dp, String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (l&gt;=<span class="number">0</span> &amp;&amp; r&lt;s.length() &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class="line">            dp[r+<span class="number">1</span>] = Math.min(dp[r+<span class="number">1</span>], dp[l] + <span class="number">1</span>);</span><br><span class="line">            l--;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/palindrome-partitioning-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/palindrome-partitioning-ii/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="http://changsk.top/2019/09/22/union-find/"/>
    <id>http://changsk.top/2019/09/22/union-find/</id>
    <published>2019-09-22T14:13:32.000Z</published>
    <updated>2019-09-27T11:03:03.310Z</updated>
    
    <content type="html"><![CDATA[<p>来看一个实例，杭电1232畅通工程</p><p>首先在地图上给你若干个城镇，这些城镇都可以看作点，然后告诉你哪些对城镇之间是有道路直接相连的。最后要解决的是整幅图的连通性问题。比如随意给你两个点，让你判断它们是否连通，或者问你整幅图一共有几个连通分支，也就是被分成了几个互相独立的块。像畅通工程这题，问还需要修几条路，实质就是求有几个连通分支。如果是1个连通分支，说明整幅图上的点都连起来了，不用再修路了；如果是2个连通分支，则只要再修1条路，从两个分支中各选一个点，把它们连起来，那么所有的点都是连起来的了；如果是3个连通分支，则只要再修两条路……</p><a id="more"></a><p>以下面这组数据输入数据来说明</p><blockquote><p>4 2<br>1 3<br>4 3</p></blockquote><p>第一行告诉你，一共有4个点，2条路。下面两行告诉你，1、3之间有条路，4、3之间有条路。那么整幅图就被分成了1-3-4和2两部分。只要再加一条路，把2和其他任意一个点连起来，畅通工程就实现了，那么这个这组数据的输出结果就是1。好了，现在编程实现这个功能吧，城镇有几百个，路有不知道多少条，而且可能有回路。 这可如何是好？</p><p>我以前也不会呀，自从用了并查集之后，嗨，效果还真好！我们全家都用它！</p><p>并查集由一个整数型的数组和两个函数构成。数组pre[]记录了每个点的前导点是什么，函数find是查找，join是合并。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pre[<span class="number">1000</span> ];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>                                                                                                         <span class="comment">//查找根节点</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> r=x;</span><br><span class="line">    <span class="keyword">while</span> ( pre[r] != r )                                                                                              <span class="comment">//返回根节点 r</span></span><br><span class="line">          r=pre[r];</span><br><span class="line">    <span class="keyword">int</span> i=x , j ;</span><br><span class="line">    <span class="keyword">while</span>( i != r )                                                                                                        <span class="comment">//路径压缩</span></span><br><span class="line">    &#123;</span><br><span class="line">         j = pre[ i ]; <span class="comment">// 在改变上级之前用临时变量  j 记录下他的值 </span></span><br><span class="line">         pre[ i ]= r ; <span class="comment">//把上级改为根节点</span></span><br><span class="line">         i=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span>                                                                                                    <span class="comment">//判断x y是否连通，                                                                                          //如果已经连通，就不用管了 //如果不连通，就把它们所在的连通分支合并起,</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx=find(x),fy=find(y);</span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)</span><br><span class="line">        pre[fx ]=fy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了解释并查集的原理，我将举一个更有爱的例子。 话说江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉“朋友的朋友就是我的朋友”，只要是能通过朋友关系串联起来的，不管拐了多少个弯，都认为是自己人。这样一来，江湖上就形成了一个一个的群落，通过两两之间的朋友关系串联起来。而不在同一个群落的人，无论如何都无法通过朋友关系连起来，于是就可以放心往死了打。但是两个原本互不相识的人，如何判断是否属于一个朋友圈呢？</p><p>我们可以在每个朋友圈内推举出一个比较有名望的人，作为该圈子的代表人物，这样，每个圈子就可以这样命名“齐达内朋友之队”“罗纳尔多朋友之队”……两人只要互相对一下自己的队长是不是同一个人，就可以确定敌友关系了。</p><p>但是还有问题啊，大侠们只知道自己直接的朋友是谁，很多人压根就不认识队长，要判断自己的队长是谁，只能漫无目的的通过朋友的朋友关系问下去：“你是不是队长？你是不是队长？”这样一来，队长面子上挂不住了，而且效率太低，还有可能陷入无限循环中。于是队长下令，重新组队。队内所有人实行分等级制度，形成树状结构，我队长就是根节点，下面分别是二级队员、三级队员。每个人只要记住自己的上级是谁就行了。遇到判断敌友的时候，只要一层层向上问，直到最高层，就可以在短时间内确定队长是谁了。由于我们关心的只是两个人之间是否连通，至于他们是如何连通的，以及每个圈子内部的结构是怎样的，甚至队长是谁，并不重要。所以我们可以放任队长随意重新组队，只要不搞错敌友关系就好了。于是，门派产生了。</p><p><img src="1.jpg" alt></p><p>下面我们来看并查集的实现。 int pre[1000]; 这个数组，记录了每个大侠的上级是谁。大侠们从1或者0开始编号（依据题意而定），pre[15]=3就表示15号大侠的上级是3号大侠。如果一个人的上级就是他自己，那说明他就是掌门人了，查找到此为止。也有孤家寡人自成一派的，比如欧阳锋，那么他的上级就是他自己。每个人都只认自己的上级。比如胡青牛同学只知道自己的上级是杨左使。张无忌是谁？不认识！要想知道自己的掌门是谁，只能一级级查上去。 find这个函数就是找掌门用的，意义再清楚不过了（路径压缩算法先不论，后面再说）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span>      <span class="comment">//查找我（x）的掌门                                                              </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r=x;     <span class="comment">//委托 r 去找掌门                                                                    </span></span><br><span class="line">    <span class="keyword">while</span> (pre[r]!=r)    <span class="comment">//如果r的上级不是r自己（也就是说找到的大侠他不是掌门 = =）                                                   </span></span><br><span class="line">    r=pre[r] ;    <span class="comment">// r 就接着找他的上级，直到找到掌门为止。                                                                </span></span><br><span class="line">    <span class="keyword">return</span>  r ;     <span class="comment">//掌门驾到~~~                                                            </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看join函数，就是在两个点之间连一条线，这样一来，原先它们所在的两个板块的所有点就都可以互通了。这在图上很好办，画条线就行了。但我们现在是用并查集来描述武林中的状况的，一共只有一个pre[]数组，该如何实现呢？ 还是举江湖的例子，假设现在武林中的形势如图所示。虚竹小和尚与周芷若MM是我非常喜欢的两个人物，他们的终极boss分别是玄慈方丈和灭绝师太，那明显就是两个阵营了。我不希望他们互相打架，就对他俩说：“你们两位拉拉勾，做好朋友吧。”他们看在我的面子上，同意了。这一同意可非同小可，整个少林和峨眉派的人就不能打架了。这么重大的变化，可如何实现呀，要改动多少地方？其实非常简单，我对玄慈方丈说：“大师，麻烦你把你的上级改为灭绝师太吧。这样一来，两派原先的所有人员的终极boss都是师太，那还打个球啊！反正我们关心的只是连通性，门派内部的结构不要紧的。”玄慈一听肯定火大了：“我靠，凭什么是我变成她手下呀，怎么不反过来？我抗议！”抗议无效，上天安排的，最大。反正谁加入谁效果是一样的，我就随手指定了一个。这段函数的意思很明白了吧？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span>    <span class="comment">//我想让虚竹和周芷若做朋友                                                               </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx=find(x),fy=find(y); <span class="comment">//虚竹的老大是玄慈，芷若MM的老大是灭绝                                                      </span></span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)     <span class="comment">//玄慈和灭绝显然不是同一个人                                                                           </span></span><br><span class="line">    pre[fx ]=fy;    <span class="comment">//方丈只好委委屈屈地当了师太的手下啦     </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看路径压缩算法。建立门派的过程是用join函数两个人两个人地连接起来的，谁当谁的手下完全随机。最后的树状结构会变成什么胎唇样，我也完全无法预计，一字长蛇阵也有可能。这样查找的效率就会比较低下。最理想的情况就是所有人的直接上级都是掌门，一共就两级结构，只要找一次就找到掌门了。哪怕不能完全做到，也最好尽量接近。这样就产生了路径压缩算法。 设想这样一个场景：两个互不相识的大侠碰面了，想知道能不能揍。 于是赶紧打电话问自己的上级：“你是不是掌门？” 上级说：“我不是呀，我的上级是谁谁谁，你问问他看看。” 一路问下去，原来两人的最终boss都是东厂曹公公。 “哎呀呀，原来是记己人，西礼西礼，在下三营六组白面葫芦娃!” “幸会幸会，在下九营十八组仙子狗尾巴花！” 两人高高兴兴地手拉手喝酒去了。 “等等等等，两位同学请留步，还有事情没完成呢！”我叫住他俩。 “哦，对了，还要做路径压缩。”两人醒悟。 白面葫芦娃打电话给他的上级六组长：“组长啊，我查过了，其习偶们的掌门是曹公公。不如偶们一起及接拜在曹公公手下吧，省得级别太低，以后查找掌门麻环。” “唔，有道理。” 白面葫芦娃接着打电话给刚才拜访过的三营长……仙子狗尾巴花也做了同样的事情。 这样，查询中所有涉及到的人物都聚集在曹公公的直接领导下。每次查询都做了优化处理，所以整个门派树的层数都会维持在比较低的水平上。路径压缩的代码，看得懂很好，看不懂也没关系，直接抄上用就行了。总之它所实现的功能就是这么个意思。</p><p><img src="2.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来看一个实例，杭电1232畅通工程&lt;/p&gt;
&lt;p&gt;首先在地图上给你若干个城镇，这些城镇都可以看作点，然后告诉你哪些对城镇之间是有道路直接相连的。最后要解决的是整幅图的连通性问题。比如随意给你两个点，让你判断它们是否连通，或者问你整幅图一共有几个连通分支，也就是被分成了几个互相独立的块。像畅通工程这题，问还需要修几条路，实质就是求有几个连通分支。如果是1个连通分支，说明整幅图上的点都连起来了，不用再修路了；如果是2个连通分支，则只要再修1条路，从两个分支中各选一个点，把它们连起来，那么所有的点都是连起来的了；如果是3个连通分支，则只要再修两条路……&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="并查集" scheme="http://changsk.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-130:Surrounded Regions</title>
    <link href="http://changsk.top/2019/09/22/leetcode-130/"/>
    <id>http://changsk.top/2019/09/22/leetcode-130/</id>
    <published>2019-09-22T12:02:08.000Z</published>
    <updated>2019-09-23T05:43:59.651Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/surrounded-regions/" target="_blank" rel="noopener">https://leetcode.com/problems/surrounded-regions/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>题目难度：Medium</strong></p><p>Given a 2D board containing <code>&#39;X&#39;</code> and <code>&#39;O&#39;</code> (<strong>the letter O</strong>), capture all regions surrounded by <code>&#39;X&#39;</code>.</p><p>A region is captured by flipping all <code>&#39;O&#39;</code>s into <code>&#39;X&#39;</code>s in that surrounded region.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure><p>After running your function, the board should be:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure><p><strong>Explanation:</strong></p><p>Surrounded regions shouldn’t be on the border, which means that any <code>&#39;O&#39;</code> on the border of the board are not flipped to <code>&#39;X&#39;</code>. Any <code>&#39;O&#39;</code> that is not on the border and it is not connected to an <code>&#39;O&#39;</code> on the border will be flipped to <code>&#39;X&#39;</code>. Two cells are connected if they are adjacent cells connected horizontally or vertically.</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>思路：从最外围的四个方向当中的<code>&#39;O&#39;</code>出发，用<code>dfs</code>把遇到的<code>&#39;O&#39;</code>都置为<code>true</code>，最后把坐标为<code>false</code>且为<code>&#39;O&#39;</code>的元素置为<code>&#39;X&#39;</code>。</p><p>代码来自<code>Leetcode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> rows = board.length;</span><br><span class="line">        <span class="keyword">int</span> cols = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>; c&lt;cols; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[<span class="number">0</span>][c] == <span class="string">'O'</span> &amp;&amp; !visited[<span class="number">0</span>][c])</span><br><span class="line">                bfs(board, <span class="number">0</span>, c, rows, cols, visited);</span><br><span class="line">            <span class="keyword">if</span>(board[rows-<span class="number">1</span>][c] == <span class="string">'O'</span> &amp;&amp; !visited[rows - <span class="number">1</span>][c])</span><br><span class="line">                bfs(board, rows-<span class="number">1</span>, c, rows, cols, visited);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>; r&lt;rows; r++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[r][<span class="number">0</span>] == <span class="string">'O'</span> &amp;&amp; !visited[r][<span class="number">0</span>])</span><br><span class="line">                bfs(board, r, <span class="number">0</span>, rows, cols, visited);</span><br><span class="line">            <span class="keyword">if</span>(board[r][cols-<span class="number">1</span>] == <span class="string">'O'</span> &amp;&amp; !visited[r][cols - <span class="number">1</span>])</span><br><span class="line">                bfs(board, r, cols-<span class="number">1</span>, rows, cols, visited);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">1</span>; r&lt;rows-<span class="number">1</span>; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">1</span>; c&lt;cols-<span class="number">1</span>; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!visited[r][c] &amp;&amp; board[r][c] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                    board[r][c] = <span class="string">'X'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">boolean</span>[][] visited)</span> </span>&#123;</span><br><span class="line">        visited[r][c] = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(r-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; !visited[r-<span class="number">1</span>][c] &amp;&amp; board[r-<span class="number">1</span>][c] == <span class="string">'O'</span>)</span><br><span class="line">            bfs(board, r-<span class="number">1</span>, c, rows, cols, visited);</span><br><span class="line">        <span class="keyword">if</span>(r+<span class="number">1</span> &lt; rows &amp;&amp; !visited[r+<span class="number">1</span>][c] &amp;&amp; board[r+<span class="number">1</span>][c] == <span class="string">'O'</span>)</span><br><span class="line">            bfs(board, r+<span class="number">1</span>, c, rows, cols, visited);</span><br><span class="line">        <span class="keyword">if</span>(c+<span class="number">1</span> &lt; cols &amp;&amp; !visited[r][c+<span class="number">1</span>] &amp;&amp; board[r][c+<span class="number">1</span>] == <span class="string">'O'</span>)</span><br><span class="line">            bfs(board, r, c+<span class="number">1</span>, rows, cols, visited);</span><br><span class="line">        <span class="keyword">if</span>(c-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; !visited[r][c-<span class="number">1</span>] &amp;&amp; board[r][c-<span class="number">1</span>] == <span class="string">'O'</span>)</span><br><span class="line">            bfs(board, r, c-<span class="number">1</span>, rows, cols, visited);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/surrounded-regions/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/surrounded-regions/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-129:Sum Root to Leaf Numbers</title>
    <link href="http://changsk.top/2019/09/22/leetcode-129/"/>
    <id>http://changsk.top/2019/09/22/leetcode-129/</id>
    <published>2019-09-22T09:01:06.000Z</published>
    <updated>2019-09-22T09:03:11.175Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">https://leetcode.com/problems/sum-root-to-leaf-numbers/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>题目难度：Medium</strong></p><p>Given a binary tree containing digits from <code>0-9</code> only, each root-to-leaf path could represent a number.</p><p>An example is the root-to-leaf path <code>1-&gt;2-&gt;3</code> which represents the number <code>123</code>.</p><p>Find the total sum of all root-to-leaf numbers.</p><p><strong>Note:</strong> A leaf is a node with no children.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line">Output: 25</span><br><span class="line">Explanation:</span><br><span class="line">The root-to-leaf path 1-&gt;2 represents the number 12.</span><br><span class="line">The root-to-leaf path 1-&gt;3 represents the number 13.</span><br><span class="line">Therefore, sum = 12 + 13 = 25.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,9,0,5,1]</span><br><span class="line">    4</span><br><span class="line">   / \</span><br><span class="line">  9   0</span><br><span class="line"> / \</span><br><span class="line">5   1</span><br><span class="line">Output: 1026</span><br><span class="line">Explanation:</span><br><span class="line">The root-to-leaf path 4-&gt;9-&gt;5 represents the number 495.</span><br><span class="line">The root-to-leaf path 4-&gt;9-&gt;1 represents the number 491.</span><br><span class="line">The root-to-leaf path 4-&gt;0 represents the number 40.</span><br><span class="line">Therefore, sum = 495 + 491 + 40 = 1026.</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        sumNumbersCore(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sumNumbersCore</span><span class="params">(TreeNode root, <span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">        cur = cur * <span class="number">10</span> + root.val;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            res += cur;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">            sumNumbersCore(root.left, cur);</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">            sumNumbersCore(root.right, cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/sum-root-to-leaf-numbers/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/sum-root-to-leaf-numbers/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-126:Word Ladder II</title>
    <link href="http://changsk.top/2019/09/18/leetcode-126/"/>
    <id>http://changsk.top/2019/09/18/leetcode-126/</id>
    <published>2019-09-18T14:30:50.000Z</published>
    <updated>2019-09-19T03:17:26.327Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/word-ladder-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/word-ladder-ii/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>题目难度：Hard</strong></p><p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find all shortest transformation sequence(s) from <em>beginWord</em> to <em>endWord</em>, such that:</p><ol><li>Only one letter can be changed at a time</li><li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.</li></ol><p><strong>Note:</strong></p><ul><li>Return an empty list if there is no such transformation sequence.</li><li>All words have the same length.</li><li>All words contain only lowercase alphabetic characters.</li><li>You may assume no duplicates in the word list.</li><li>You may assume <em>beginWord</em> and <em>endWord</em> are non-empty and are not the same.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = &quot;hit&quot;,</span><br><span class="line">endWord = &quot;cog&quot;,</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = &quot;hit&quot;</span><br><span class="line">endWord = &quot;cog&quot;</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line"></span><br><span class="line">Output: []</span><br><span class="line"></span><br><span class="line">Explanation: The endWord &quot;cog&quot; is not in wordList, therefore no possible transformation.</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>代码来自：<code>LeetCode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; dict = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">        <span class="keyword">if</span>(!dict.contains(endWord))&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; begin = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; end = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        begin.add(beginWord);</span><br><span class="line">        end.add(endWord);</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        bfs(begin, end, dict, map, <span class="keyword">false</span>);</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(beginWord);</span><br><span class="line">        dfs(beginWord, endWord, res, list, map);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//function: 从 begin 中的任意元素通过变换为 dict 中的任意元素可到达 end 中的任意元素</span></span><br><span class="line">    <span class="comment">// map 表示从 key 变换一次可达的 list</span></span><br><span class="line">    <span class="comment">//reverse : false 表示从 begin 到达 end， true 表示从 end 到达 begin</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Set&lt;String&gt; begin, Set&lt;String&gt; end, Set&lt;String&gt; dict, Map&lt;String, List&lt;String&gt;&gt; map, <span class="keyword">boolean</span> reverse)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(begin.size() &gt; end.size())&#123;</span><br><span class="line">            bfs(end, begin, dict, map, !reverse);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> finish = <span class="keyword">false</span>;</span><br><span class="line">        Set&lt;String&gt; temp = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        dict.removeAll(begin);</span><br><span class="line">        <span class="keyword">for</span>(String w : begin)&#123;</span><br><span class="line">            <span class="keyword">char</span>[] array = w.toCharArray();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">                <span class="keyword">char</span> old = array[i];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; c++)&#123;</span><br><span class="line">                    array[i] = c;</span><br><span class="line">                    String newWord = <span class="keyword">new</span> String(array);</span><br><span class="line">                    <span class="keyword">if</span>(dict.contains(newWord))&#123;</span><br><span class="line">                        <span class="keyword">if</span>(end.contains(newWord))&#123;</span><br><span class="line">                            finish = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            temp.add(newWord);</span><br><span class="line">                        &#125;</span><br><span class="line">                        String key = reverse ? newWord : w;</span><br><span class="line">                        String val = reverse ? w : newWord;</span><br><span class="line">                        <span class="keyword">if</span>(!map.containsKey(key))&#123;</span><br><span class="line">                            map.put(key, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">                        &#125;</span><br><span class="line">                        map.get(key).add(val);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                array[i] = old;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!finish)&#123;</span><br><span class="line">            bfs(temp, end, dict, map, reverse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//function: 求从 begin 到达 end 的所有路径</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String begin, String end, List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; list, Map&lt;String, List&lt;String&gt;&gt; map)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin.equals(end))&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(begin))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(String str : map.get(begin))&#123;</span><br><span class="line">            list.add(str);</span><br><span class="line">            dfs(str, end, res, list, map);</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/word-ladder-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/word-ladder-ii/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-128:Longest Consecutive Sequence(最长的连续序列)</title>
    <link href="http://changsk.top/2019/09/18/leetcode-128/"/>
    <id>http://changsk.top/2019/09/18/leetcode-128/</id>
    <published>2019-09-18T14:05:02.000Z</published>
    <updated>2019-09-19T03:50:26.432Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-consecutive-sequence/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>题目难度：Hard</strong></p><p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p><p>Your algorithm should run in O(<em>n</em>) complexity.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [100, 4, 200, 1, 3, 2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> preNum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> curLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == preNum) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == preNum + <span class="number">1</span>) curLen++;</span><br><span class="line">            <span class="keyword">else</span> curLen = <span class="number">1</span>;</span><br><span class="line">            preNum = nums[i];</span><br><span class="line">            res = Math.max(res, curLen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/longest-consecutive-sequence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/longest-consecutive-sequence/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-127:Word Ladder</title>
    <link href="http://changsk.top/2019/09/18/leetcode-127/"/>
    <id>http://changsk.top/2019/09/18/leetcode-127/</id>
    <published>2019-09-18T14:00:53.000Z</published>
    <updated>2019-09-18T14:16:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/word-ladder/" target="_blank" rel="noopener">https://leetcode.com/problems/word-ladder/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>题目难度：Medium</strong></p><p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find the length of shortest transformation sequence from <em>beginWord</em> to <em>endWord</em>, such that:</p><ol><li>Only one letter can be changed at a time.</li><li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.</li></ol><p><strong>Note:</strong></p><ul><li>Return 0 if there is no such transformation sequence.</li><li>All words have the same length.</li><li>All words contain only lowercase alphabetic characters.</li><li>You may assume no duplicates in the word list.</li><li>You may assume <em>beginWord</em> and <em>endWord</em> are non-empty and are not the same.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = &quot;hit&quot;,</span><br><span class="line">endWord = &quot;cog&quot;,</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">Output: 5</span><br><span class="line"></span><br><span class="line">Explanation: As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,</span><br><span class="line">return its length 5.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = &quot;hit&quot;</span><br><span class="line">endWord = &quot;cog&quot;</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line"></span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">Explanation: The endWord &quot;cog&quot; is not in wordList, therefore no possible transformation.</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>代码来自：<code>Leetcode</code></p><p>利用<code>BFS</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span></span>&#123;</span><br><span class="line">        Set&lt;String&gt; beginSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; endSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        beginSet.add(beginWord);</span><br><span class="line">        endSet.add(endWord);</span><br><span class="line">        Set&lt;String&gt; dict = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">        <span class="keyword">if</span> (!dict.contains(endWord)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> search(beginSet, endSet, dict,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//function: 从 beginSet 中的任意元素到达 endSet 中的任意元素的最小距离，dict 是中间转换集合， cnt是当前变换次数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">search</span> <span class="params">(Set&lt;String&gt; beginSet, Set&lt;String&gt; endSet, Set&lt;String&gt; dict, <span class="keyword">int</span> cnt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beginSet.isEmpty() || endSet.isEmpty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">        dict.removeAll(beginSet);</span><br><span class="line">        Set&lt;String&gt; nextSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String str : beginSet)&#123;</span><br><span class="line">            <span class="keyword">char</span>[] chs = str.toCharArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++)&#123;</span><br><span class="line">                <span class="keyword">char</span> c = chs[i];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> j = <span class="string">'a'</span>; j &lt; <span class="string">'z'</span>; j++)&#123;</span><br><span class="line">                    chs[i] = j;</span><br><span class="line">                    String tmp = <span class="keyword">new</span> String(chs);</span><br><span class="line">                    <span class="keyword">if</span> (!dict.contains(tmp)) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (endSet.contains(tmp)) <span class="keyword">return</span> cnt;</span><br><span class="line">                    nextSet.add(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                chs[i] = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从 nextSet 中的元素到达 endSet 中的元素，还是反过来效果都是一样的，也就是说 nextSet 和 endSet 可以互换，但是相对来说 nextSet 应该选取元素更少的集合，这样在 search 函数中就可以尽可能的减少string 的创建</span></span><br><span class="line">        <span class="keyword">return</span> endSet.size() &gt; nextSet.size() ? search(nextSet, endSet, dict, cnt) : search(endSet, nextSet, dict, cnt);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/word-ladder/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/word-ladder/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-124:Binary Tree Maximum Path Sum</title>
    <link href="http://changsk.top/2019/09/17/leetcode-124/"/>
    <id>http://changsk.top/2019/09/17/leetcode-124/</id>
    <published>2019-09-17T14:10:04.000Z</published>
    <updated>2019-09-17T15:28:56.561Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-maximum-path-sum/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>题目难度：Hard</strong></p><p>Given a <strong>non-empty</strong> binary tree, find the maximum path sum.</p><p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain <strong>at least one node</strong> and does not need to go through the root.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      / \</span><br><span class="line">     2   3</span><br><span class="line"></span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [-10,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">   -10</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">Output: 42</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>代码来自<code>Leetcode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxValue;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        maxValue = Integer.MIN_VALUE;</span><br><span class="line">        maxPathDown(root);</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//function:求出从 node 结点开始向下延伸所经过结点的最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxPathDown</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = Math.max(<span class="number">0</span>, maxPathDown(node.left));</span><br><span class="line">        <span class="keyword">int</span> right = Math.max(<span class="number">0</span>, maxPathDown(node.right));</span><br><span class="line">        maxValue = Math.max(maxValue, left + right + node.val);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + node.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>题意及代码可参考：<a href="https://segmentfault.com/a/1190000018983149" target="_blank" rel="noopener">https://segmentfault.com/a/1190000018983149</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/binary-tree-maximum-path-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/binary-tree-maximum-path-sum/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-117:Populating Next Right Pointers in Each Node II</title>
    <link href="http://changsk.top/2019/09/16/leetcode-117/"/>
    <id>http://changsk.top/2019/09/16/leetcode-117/</id>
    <published>2019-09-16T15:25:15.000Z</published>
    <updated>2019-09-16T15:29:30.948Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>题目难度：Medium</strong></p><p>Given a binary tree</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p><p>Initially, all next pointers are set to <code>NULL</code>.</p><p><strong>Example:</strong></p><p><img src="1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;val&quot;:3&#125;,&quot;val&quot;:1&#125;</span><br><span class="line"></span><br><span class="line">Output: &#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;5&quot;&#125;,&quot;val&quot;:3&#125;,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;4&quot;&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;6&quot;&#125;,&quot;val&quot;:1&#125;</span><br><span class="line"></span><br><span class="line">Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li>You may only use constant extra space.</li><li>Recursive approach is fine, implicit stack space does not count as extra space for this problem.</li></ul><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val,Node _left,Node _right,Node _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Node head = <span class="keyword">null</span>; <span class="comment">//head of the next level</span></span><br><span class="line">        Node prev = <span class="keyword">null</span>; <span class="comment">//the leading node on the next level</span></span><br><span class="line">        Node cur = root;  <span class="comment">//current node of current level</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123; <span class="comment">//iterate on the current level</span></span><br><span class="line">                <span class="comment">//left child</span></span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prev.next = cur.left;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        head = cur.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    prev = cur.left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//right child</span></span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prev.next = cur.right;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        head = cur.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    prev = cur.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//move to next node</span></span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//move to next level</span></span><br><span class="line">            cur = head;</span><br><span class="line">            head = <span class="keyword">null</span>;</span><br><span class="line">            prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val,Node _left,Node _right,Node _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">       Node iter = root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (iter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node dummy = <span class="keyword">new</span> Node();</span><br><span class="line">            Node current = dummy;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (iter != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (iter.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    current.next = iter.left;</span><br><span class="line">                    current = current.next;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (iter.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    current.next = iter.right;</span><br><span class="line">                    current = current.next;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                iter = iter.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            iter = dummy.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
</feed>
