<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>changsk&#39;s blogs</title>
  
  <subtitle>chang.sk@foxmail.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://changsk.top/"/>
  <updated>2019-07-27T13:34:07.582Z</updated>
  <id>http://changsk.top/</id>
  
  <author>
    <name>changsk</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库两大神器【索引和锁】</title>
    <link href="http://changsk.top/2019/07/27/mysql-index-lock/"/>
    <id>http://changsk.top/2019/07/27/mysql-index-lock/</id>
    <published>2019-07-27T13:08:31.000Z</published>
    <updated>2019-07-27T13:34:07.582Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="https://juejin.im/post/5b55b842f265da0f9e589e79" target="_blank" rel="noopener">数据库两大神器【索引和锁】</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>只有光头才能变强</p></blockquote><p><strong>索引和锁</strong>在数据库中可以说是非常重要的知识点了，在面试中也会经常会被问到的。</p><p>本文<strong>力求简单讲清每个知识点</strong>，希望大家看完能有所收获</p><blockquote><p>声明：如果没有说明具体的数据库和存储引擎，<strong>默认指的是MySQL中的InnoDB存储引擎</strong></p></blockquote><a id="more"></a><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>在之前，我对索引有以下的认知：</p><ul><li><strong>索引可以加快数据库的检索速度</strong></li><li>表<strong>经常</strong>进行<code>INSERT/UPDATE/DELETE</code>操作就不要建立索引了，换言之：<strong>索引会降低</strong>插入、删除、修改等维护任务的速度。</li><li>索引需要<strong>占物理和数据空间</strong>。</li><li>了解过索引的最左匹配原则</li><li>知道索引的分类：聚集索引和非聚集索引</li><li>Mysql支持Hash索引和B+树索引两种</li></ul><p>看起来好像啥都知道，但面试让你说的时候可能就GG了：</p><ul><li>使用索引为什么可以加快数据库的检索速度啊？</li><li>为什么说索引会降低插入、删除、修改等维护任务的速度。</li><li>索引的最左匹配原则指的是什么？</li><li>Hash索引和B+树索引有什么区别？主流的使用哪一个比较多？InnoDB存储都支持吗？</li><li>聚集索引和非聚集索引有什么区别？</li><li>……..</li></ul><h2 id="聊聊索引的基础知识"><a href="#聊聊索引的基础知识" class="headerlink" title="聊聊索引的基础知识"></a>聊聊索引的基础知识</h2><p>首先Mysql的基本存储结构是<strong>页</strong>(记录都存在页里边)：</p><p><img src="1.jpg" alt></p><p><img src="2.jpg" alt></p><ul><li><p><strong>各个数据页</strong>可以组成一个<strong>双向链表</strong></p></li><li><p>而</p><p>每个数据页中的记录</p><p>又可以组成一个</p><p>单向</p><p>链表 </p><ul><li>每个数据页都会为存储在它里边儿的记录生成一个<strong>页目录</strong>，在通过<strong>主键</strong>查找某条记录的时候可以在页目录中使用<strong>二分法快速定位</strong>到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录</li><li>以<strong>其他列</strong>(非主键)作为搜索条件：只能从最小记录开始<strong>依次遍历单链表中的每条记录</strong>。</li></ul></li></ul><p>所以说，如果我们写<code>select * from user where username = &#39;Java3y&#39;</code>这样没有进行任何优化的sql语句，默认会这样做：</p><ul><li>定位到记录所在的页 <ul><li>需要遍历双向链表，找到所在的页</li></ul></li><li>从所在的页内中查找相应的记录 <ul><li>由于不是根据主键查询，只能遍历所在页的单链表了</li></ul></li></ul><p>很明显，在数据量很大的情况下这样查找会<strong>很慢</strong>！</p><h2 id="索引提高检索速度"><a href="#索引提高检索速度" class="headerlink" title="索引提高检索速度"></a>索引提高检索速度</h2><p>索引做了些什么可以让我们查询加快速度呢？</p><p>其实就是<strong>将无序的数据变成有序(相对)</strong>：</p><p><img src="3.jpg" alt></p><p>要找到id为8的记录简要步骤：</p><p><img src="4.jpg" alt></p><p>很明显的是：<strong>没有用索引</strong>我们是需要<strong>遍历双向链表</strong>来定位对应的页，现在通过<strong>“目录”</strong>就可以很快地定位到对应的页上了！</p><p>其实底层结构就是<strong>B+树</strong>，B+树作为树的一种实现，能够让我们<strong>很快地</strong>查找出对应的记录。</p><p>参考资料：</p><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzIxNTQ3NDMzMw%3D%3D%26mid%3D2247483701%26idx%3D1%26sn%3Dbd229dd584f51ef4fe545d44ad8cdbf9%26chksm%3D979688c7a0e101d1b5c752094013b78f5bd50ab905257ba82149d85d35ea07aba1a15b0e52b4%26mpshare%3D1%26scene%3D1%26srcid%3D0409Tn66UYWSWvqEVlOpwGtR%26key%3D6cd553e86912686a47d76f2d900b1b5b388c90b29708f016db3a6e1bcebe032220ba63626095c4298f32cda7d0d7bd11bded2365f05c32e522584dd149b98db0bb8549ef144cdca694665d31d35cfeef%26ascene%3D0%26uin%3DMzAzMjU4NDM3Nw%3D%3D%26devicetype%3DiMac%2BMacBookPro12%2C1%2BOSX%2BOSX%2B10.12.4%2Bbuild(16E195)%26version%3D12020810%26nettype%3DWIFI%26lang%3Dzh_CN%26fontScale%3D100%26pass_ticket%3DYHEmqDDX8hHkj5FiSVpQvjYqIMBDHHDS2po4mfJe%2BqIXlqwJI%2Bg7aJUZq0%2BDwGJ0" target="_blank" rel="noopener">Mysql索引</a></li></ul><h2 id="索引降低增删改的速度"><a href="#索引降低增删改的速度" class="headerlink" title="索引降低增删改的速度"></a>索引降低增删改的速度</h2><p>B+树是<strong>平衡树</strong>的一种。</p><blockquote><p>平衡树：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p></blockquote><p>如果一棵普通的树在<strong>极端</strong>的情况下，是能<strong>退化成链表</strong>的(树的优点就不复存在了)</p><p><img src="5.jpg" alt></p><p>B+树是平衡树的一种，是不会退化成链表的，树的高度都是相对比较低的(基本符合<strong>矮矮胖胖(均衡)的结构</strong>)【这样一来我们检索的时间复杂度就是O(logn)】！从上一节的图我们也可以看见，建立索引实际上就是建立一颗B+树。</p><ul><li>B+树是一颗平衡树，如果我们对这颗树增删改的话，那肯定会<strong>破坏它的原有结构</strong>。</li><li><strong>要维持平衡树，就必须做额外的工作</strong>。正因为这些额外的工作<strong>开销</strong>，导致索引会降低增删改的速度</li></ul><p>B+树删除和修改具体可参考：</p><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Fwade-luffy%2Fp%2F6292784.html" target="_blank" rel="noopener">www.cnblogs.com/wade-luffy/…</a></li></ul><h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><p>除了B+树之外，还有一种常见的是哈希索引。</p><p>哈希索引就是采用一定的<strong>哈希算法</strong>，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可<strong>立刻定位到相应的位置，速度非常快</strong>。</p><ul><li>本质上就是<strong>把键值换算成新的哈希值</strong>，根据这个<strong>哈希值来定位</strong>。</li></ul><p><img src="6.jpg" alt></p><p>看起来哈希索引很牛逼啊，但其实哈希索引有好几个局限(根据他本质的原理可得)：</p><ul><li>哈希索引也没办法利用索引完成<strong>排序</strong></li><li>不支持<strong>最左匹配原则</strong></li><li>在有大量重复键值情况下，哈希索引的效率也是极低的—-&gt;<strong>哈希碰撞</strong>问题。</li><li><strong>不支持范围查询</strong></li></ul><p>参考资料：</p><ul><li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.cnblogs.com%2Fzengkefu%2Fp%2F5647279.html" target="_blank" rel="noopener">www.cnblogs.com/zengkefu/p/…</a>—hash索引和b+tree索引</li></ul><h2 id="InnoDB支持哈希索引吗？"><a href="#InnoDB支持哈希索引吗？" class="headerlink" title="InnoDB支持哈希索引吗？"></a>InnoDB支持哈希索引吗？</h2><p>主流的还是使用<strong>B+树索引比较多</strong>，对于哈希索引，<strong>InnoDB是自适应哈希索引</strong>的（hash索引的创建由InnoDB存储引擎引擎自动优化创建，我们干预不了）！</p><p><img src="7.jpg" alt></p><p>参考资料：</p><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fdoctor_who2004%2Farticle%2Fdetails%2F77414742" target="_blank" rel="noopener">blog.csdn.net/doctor_who2…</a></li></ul><h2 id="聚集和非聚集索引"><a href="#聚集和非聚集索引" class="headerlink" title="聚集和非聚集索引"></a>聚集和非聚集索引</h2><p>简单概括：</p><ul><li>聚集索引就是以<strong>主键</strong>创建的索引</li><li>非聚集索引就是以<strong>非主键</strong>创建的索引</li></ul><p>区别：</p><ul><li>聚集索引在叶子节点存储的是<strong>表中的数据</strong></li><li>非聚集索引在叶子节点存储的是<strong>主键和索引列</strong></li><li>使用非聚集索引查询出数据时，<strong>拿到叶子上的主键再去查到想要查找的数据</strong>。(拿到主键再查找这个过程叫做<strong>回表</strong>)</li></ul><p><strong>非聚集索引也叫做二级索引</strong>，不用纠结那么多名词，将其等价就行了~</p><p>非聚集索引在建立的时候也<strong>未必是单列</strong>的，可以多个列来创建索引。</p><ul><li>此时就涉及到了哪个列会走索引，哪个列不走索引的问题了(最左匹配原则–&gt;后面有说)</li><li><strong>创建多个单列(非聚集)索引的时候，会生成多个索引树</strong>(所以过多创建索引会占用磁盘空间)</li></ul><p><img src="8.jpg" alt></p><p>在创建多列索引中也涉及到了一种特殊的索引–&gt;<strong>覆盖索引</strong></p><ul><li>我们前面知道了，如果不是聚集索引，叶子节点存储的是主键+列值</li><li>最终还是要“回表”，也就是要通过主键<strong>再</strong>查找一次。这样就会比较慢</li><li>覆盖索引就是把要<strong>查询出的列和索引是对应的</strong>，不做回表操作！</li></ul><p>比如说：</p><ul><li>现在我创建了索引<code>(username,age)</code>，在查询数据的时候：<code>select username , age from user where username = &#39;Java3y&#39; and age = 20</code>。</li><li>很明显地知道，我们上边的查询是走索引的，并且，<strong>要查询出的列在叶子节点都存在</strong>！所以，就不用回表了~</li><li>所以，能使用覆盖索引就尽量使用吧~</li></ul><h2 id="索引最左匹配原则"><a href="#索引最左匹配原则" class="headerlink" title="索引最左匹配原则"></a>索引最左匹配原则</h2><p><strong>最左匹配原则</strong>：</p><ul><li>索引可以简单如一个列<code>(a)</code>，也可以复杂如多个列<code>(a, b, c, d)</code>，即<strong>联合索引</strong>。</li><li>如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否<strong>存在（相等）</strong>，遇到范围查询<code>(&gt;、&lt;、between、like</code>左匹配)等就<strong>不能进一步匹配</strong>了，后续退化为线性查找。</li><li>因此，<strong>列的排列顺序决定了可命中索引的列数</strong>。</li></ul><p>例子：</p><ul><li>如有索引<code>(a, b, c, d)</code>，查询条件<code>a = 1 and b = 2 and c &gt; 3 and d = 4</code>，则会在每个节点依次命中a、b、c，无法命中d。(很简单：索引命中只能是<strong>相等</strong>的情况，不能是范围匹配)</li></ul><h2 id="、in自动优化顺序"><a href="#、in自动优化顺序" class="headerlink" title="=、in自动优化顺序"></a>=、in自动优化顺序</h2><p><strong>不需要考虑=、in等的顺序</strong>，mysql会自动优化这些条件的顺序，以匹配尽可能多的索引列。</p><p>例子：</p><ul><li>如有索引<code>(a, b, c, d)</code>，查询条件<code>c &gt; 3 and b = 2 and a = 1 and d &lt; 4</code>与<code>a = 1 and c &gt; 3 and b = 2 and d &lt; 4</code>等顺序都是可以的，MySQL会自动优化为<code>a = 1 and b = 2 and c &gt; 3 and d &lt; 4</code>，依次命中a、b、c。</li></ul><h2 id="索引总结"><a href="#索引总结" class="headerlink" title="索引总结"></a>索引总结</h2><p>索引在数据库中是一个<strong>非常</strong>重要的知识点！上面谈的其实就是索引<strong>最基本</strong>的东西，要创建出好的索引要顾及到很多的方面：</p><ul><li>1，<strong>最左前缀匹配原则</strong>。这是非常重要、非常重要、非常重要（重要的事情说三遍）的原则，MySQL会一直向右匹配直到遇到范围查询<code>（&gt;,&lt;,BETWEEN,LIKE）</code>就停止匹配。</li><li>3，尽量选择<strong>区分度高的列作为索引</strong>，区分度的公式是 <code>COUNT(DISTINCT col) / COUNT(*)</code>。表示字段不重复的比率，比率越大我们扫描的记录数就越少。</li><li>4，<strong>索引列不能参与计算，尽量保持列“干净”</strong>。比如，<code>FROM_UNIXTIME(create_time) = &#39;2016-06-06&#39;</code> 就不能使用索引，原因很简单，<strong>B+树中存储的都是数据表中的字段值</strong>，但是进行检索时，需要把所有元素都应用函数才能比较，显然这样的代价太大。所以语句要写成 ： <code>create_time = UNIX_TIMESTAMP(&#39;2016-06-06&#39;)</code>。</li><li>5，尽可能的<strong>扩展索引</strong>，不要新建立索引。比如表中已经有了a的索引，现在要加（a,b）的索引，那么只需要修改原来的索引即可。</li><li>6，单个多列组合索引和多个单列索引的检索查询效果不同，因为在执行SQL时，<strong>MySQL只能使用一个索引</strong>，会从多个单列索引中选择一个限制最为严格的索引。</li></ul><p>参考资料：</p><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F23624390" target="_blank" rel="noopener">zhuanlan.zhihu.com/p/23624390</a>–简单理解索引</li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fmysteryhaohao%2Farticle%2Fdetails%2F51719871" target="_blank" rel="noopener">blog.csdn.net/mysteryhaoh…</a>– MySQL学习之——索引(普通索引、唯一索引、全文索引、索引匹配原则、索引命中等)</li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fmonkeysayhi.github.io%2F2018%2F03%2F06%2F%E6%B5%85%E8%B0%88MySQL%E7%9A%84B%E6%A0%91%E7%B4%A2%E5%BC%95%E4%B8%8E%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%2F" target="_blank" rel="noopener">monkeysayhi.github.io/2018/03/06/…</a>—浅谈MySQL的B树索引与索引优化</li></ul><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p><img src="9.jpg" alt></p><p>在mysql中的锁<strong>看起来</strong>是很复杂的，因为有<strong>一大堆的东西和名词</strong>：排它锁，共享锁，表锁，页锁，间隙锁，意向排它锁，意向共享锁，行锁，读锁，写锁，乐观锁，悲观锁，死锁。这些名词有的博客又直接写锁的英文的简写—&gt;X锁，S锁，IS锁，IX锁，MMVC…</p><p>锁的相关知识又跟存储引擎，索引，事务的隔离级别都是关联的….</p><p>这就给初学数据库锁的人带来不少的麻烦<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 为什么需要学习数据库锁知识</span><br><span class="line"></span><br><span class="line">不少人在开发的时候，应该**很少会注意到**这些锁的问题，也很少会给程序加锁(除了**库存**这些对数量准确性要求极高的情况下)</span><br><span class="line"></span><br><span class="line">一般也就听过常说的乐观锁和悲观锁，了解过基本的含义之后就没了</span><br></pre></td></tr></table></figure></p><p><strong>定心丸</strong>：即使我们不会这些锁知识，我们的程序在<strong>一般情况下</strong>还是可以跑得好好的。因为这些锁数据库<strong>隐式</strong>帮我们加了</p><ul><li>对于<code>UPDATE、DELETE、INSERT</code>语句，<strong>InnoDB</strong>会<strong>自动</strong>给涉及数据集加排他锁（X)</li><li><strong>MyISAM</strong>在执行查询语句<code>SELECT</code>前，会<strong>自动</strong>给涉及的所有表加<strong>读锁</strong>，在执行更新操作（<code>UPDATE、DELETE、INSERT</code>等）前，会<strong>自动</strong>给涉及的表加<strong>写锁</strong>，这个过程并<strong>不需要用户干预</strong></li></ul><p>只会在某些特定的场景下才需要<strong>手动</strong>加锁，学习数据库锁知识就是为了:</p><ul><li>能让我们在特定的场景下派得上用场</li><li>更好<strong>把控自己写的程序</strong></li><li>在跟别人聊数据库技术的时候可以搭上几句话</li><li><strong>构建自己的知识库体系</strong>！在面试的时候不虚</li></ul><h2 id="表锁简单介绍"><a href="#表锁简单介绍" class="headerlink" title="表锁简单介绍"></a>表锁简单介绍</h2><p>首先，从锁的粒度，我们可以分成两大类：</p><ul><li>表锁<ul><li>开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低</li></ul></li><li>行锁<ul><li>开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高</li></ul></li></ul><p>不同的存储引擎支持的锁粒度是不一样的：</p><ul><li><strong>InnoDB行锁和表锁都支持</strong>！</li><li><strong>MyISAM只支持表锁</strong>！</li></ul><p>InnoDB只有通过<strong>索引条件</strong>检索数据<strong>才使用行级锁</strong>，否则，InnoDB将使用<strong>表锁</strong></p><ul><li>也就是说，<strong>InnoDB的行锁是基于索引的</strong>！</li></ul><p><strong>表锁下又分为两种模式</strong>：</p><ul><li><p>表读锁（Table Read Lock）</p></li><li><p>表写锁（Table Write Lock）</p></li><li><p>从下图可以清晰看到，在表读锁和表写锁的环境下：</p><p>读读不阻塞，读写阻塞，写写阻塞</p><p>！ </p><ul><li>读读不阻塞：当前用户在读数据，其他的用户也在读数据，不会加锁</li><li>读写阻塞：当前用户在读数据，其他的用户<strong>不能修改当前用户读的数据</strong>，会加锁！</li><li>写写阻塞：当前用户在修改数据，其他的用户<strong>不能修改当前用户正在修改的数据</strong>，会加锁！</li></ul></li></ul><p><img src="10.jpg" alt></p><p>从上面已经看到了：<strong>读锁和写锁是互斥的，读写操作是串行</strong>。</p><ul><li>如果某个进程想要获取读锁，<strong>同时</strong>另外一个进程想要获取写锁。在mysql里边，<strong>写锁是优先于读锁的</strong>！</li><li>写锁和读锁优先级的问题是可以通过参数调节的：<code>max_write_lock_count</code>和<code>low-priority-updates</code></li></ul><p>值得注意的是：</p><blockquote><p>The LOCAL modifier enables nonconflicting INSERT statements (concurrent inserts) by other sessions to execute while the lock is held. (See Section 8.11.3, “Concurrent Inserts”.) However, READ LOCAL cannot be used if you are going to manipulate the database using processes external to the server while you hold the lock. <strong>For InnoDB tables, READ LOCAL is the same as READ</strong></p></blockquote><ul><li><strong>MyISAM可以</strong>支持查询和插入操作的<strong>并发</strong>进行。可以通过系统变量<code>concurrent_insert</code>来指定哪种模式，在<strong>MyISAM</strong>中它默认是：如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个进程读表的同时，另一个进程从<strong>表尾</strong>插入记录。</li><li>但是<strong>InnoDB存储引擎是不支持的</strong>！</li></ul><p>参考资料：</p><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F8.0%2Fen%2Flock-tables.html" target="_blank" rel="noopener">dev.mysql.com/doc/refman/…</a>–官方手册</li><li><a href="https://link.juejin.im?target=http%3A%2F%2Fourmysql.com%2Farchives%2F564" target="_blank" rel="noopener">ourmysql.com/archives/56…</a>—几个参数说明</li></ul><h2 id="行锁细讲"><a href="#行锁细讲" class="headerlink" title="行锁细讲"></a>行锁细讲</h2><p>上边简单讲解了表锁的相关知识，我们使用Mysql一般是使用InnoDB存储引擎的。InnoDB和MyISAM有两个本质的区别：</p><ul><li>InnoDB支持行锁</li><li>InnoDB支持事务</li></ul><p>从上面也说了：我们是<strong>很少手动加表锁</strong>的。表锁对我们程序员来说几乎是透明的，即使InnoDB不走索引，加的表锁也是自动的！</p><p>我们应该<strong>更加关注行锁的内容</strong>，因为InnoDB一大特性就是支持行锁！</p><p>InnoDB实现了以下<strong>两种</strong>类型的行锁。</p><ul><li>共享锁（S锁）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。 <ul><li>也叫做<strong>读锁</strong>：读锁是<strong>共享</strong>的，多个客户可以<strong>同时读取同一个</strong>资源，但<strong>不允许其他客户修改</strong>。</li></ul></li><li>排他锁（X锁)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。 <ul><li>也叫做<strong>写锁</strong>：写锁是排他的，<strong>写锁会阻塞其他的写锁和读锁</strong>。</li></ul></li></ul><p>看完上面的有没有发现，在一开始所说的：X锁，S锁，读锁，写锁，共享锁，排它锁其实<strong>总共就两个锁</strong>，只不过它们<strong>有多个名字罢了</strong><del>~</del></p><blockquote><p>Intention locks do not block anything except full table requests (for example, LOCK TABLES … WRITE). The main purpose of intention locks <strong>is to show that someone is locking a row, or going to lock a row in the table</strong>.</p></blockquote><p>另外，<strong>为了允许行锁和表锁共存，实现多粒度锁机制</strong>，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是<strong>表锁</strong>：</p><ul><li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</li><li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</li><li>意向锁也是数据库隐式帮我们做了，<strong>不需要程序员操心</strong>！</li></ul><p>参考资料：</p><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F51513268" target="_blank" rel="noopener">www.zhihu.com/question/51…</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F8.0%2Fen%2Finnodb-locking.html" target="_blank" rel="noopener">dev.mysql.com/doc/refman/…</a></li></ul><h3 id="MVCC和事务的隔离级别"><a href="#MVCC和事务的隔离级别" class="headerlink" title="MVCC和事务的隔离级别"></a>MVCC和事务的隔离级别</h3><p>数据库事务有不同的隔离级别，不同的隔离级别对锁的使用是不同的，<strong>锁的应用最终导致不同事务的隔离级别</strong></p><p>MVCC(Multi-Version Concurrency Control)多版本并发控制，可以简单地认为：<strong>MVCC就是行级锁的一个变种(升级版)</strong>。</p><ul><li>事务的隔离级别就是<strong>通过锁的机制来实现</strong>，只不过<strong>隐藏了加锁细节</strong></li></ul><p>在<strong>表锁中我们读写是阻塞</strong>的，基于提升并发性能的考虑，<strong>MVCC一般读写是不阻塞的</strong>(所以说MVCC很多情况下避免了加锁的操作)</p><ul><li>MVCC实现的<strong>读写不阻塞</strong>正如其名：<strong>多版本</strong>并发控制—&gt;通过一定机制生成一个数据请求<strong>时间点的一致性数据快照（Snapshot)</strong>，并用这个快照来提供一定级别（<strong>语句级或事务级</strong>）的<strong>一致性读取</strong>。从用户的角度来看，好像是<strong>数据库可以提供同一数据的多个版本</strong>。</li></ul><p>快照有<strong>两个级别</strong>：</p><ul><li>语句级 <ul><li>针对于<code>Read committed</code>隔离级别</li></ul></li><li>事务级别 <ul><li>针对于<code>Repeatable read</code>隔离级别</li></ul></li></ul><p>我们在初学的时候已经知道，事务的隔离级别有<strong>4种</strong>：</p><ul><li>Read uncommitted <ul><li>会出现脏读，不可重复读，幻读</li></ul></li><li>Read committed <ul><li>会出现不可重复读，幻读</li></ul></li><li>Repeatable read <ul><li>会出现幻读(但在Mysql实现的Repeatable read配合gap锁不会出现幻读！)</li></ul></li><li>Serializable <ul><li>串行，避免以上的情况！</li></ul></li></ul><hr><p><code>Read uncommitted</code>会出现的现象—&gt;脏读：<strong>一个事务读取到另外一个事务未提交的数据</strong></p><ul><li>例子：A向B转账，<strong>A执行了转账语句，但A还没有提交事务，B读取数据，发现自己账户钱变多了</strong>！B跟A说，我已经收到钱了。A回滚事务【rollback】，等B再查看账户的钱时，发现钱并没有多。</li><li>出现脏读的本质就是因为<strong>操作(修改)完该数据就立马释放掉锁</strong>，导致读的数据就变成了无用的或者是<strong>错误的数据</strong>。</li></ul><hr><p><code>Read committed</code><strong>避免脏读</strong>的做法其实很简单：</p><ul><li>就是把<strong>释放锁的位置调整到事务提交之后</strong>，此时在事务提交前，其他进程是无法对该行数据进行读取的，包括任何操作</li></ul><p>但<code>Read committed</code>出现的现象—&gt;不可重复读：<strong>一个事务读取到另外一个事务已经提交的数据，也就是说一个事务可以看到其他事务所做的修改</strong></p><ul><li>注：<strong>A查询数据库得到数据，B去修改数据库的数据，导致A多次查询数据库的结果都不一样【危害：A每次查询的结果都是受B的影响的，那么A查询出来的信息就没有意思了】</strong></li></ul><hr><p>上面也说了，<code>Read committed</code>是<strong>语句级别</strong>的快照！<strong>每次读取的都是当前最新的版本</strong>！</p><p><code>Repeatable read</code>避免不可重复读是<strong>事务级别</strong>的快照！每次读取的都是当前事务的版本，即使被修改了，也只会读取当前事务版本的数据。</p><p>呃…如果还是不太清楚，我们来看看InnoDB的MVCC是怎么样的吧(摘抄《高性能MySQL》)</p><p><img src="11.jpg" alt></p><p><img src="12.jpg" alt></p><p>至于虚读(幻读)：<strong>是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。</strong></p><ul><li>注：<strong>和不可重复读类似，但虚读(幻读)会读到其他事务的插入的数据，导致前后读取不一致</strong></li><li>MySQL的<code>Repeatable read</code>隔离级别加上GAP间隙锁<strong>已经处理了幻读了</strong>。</li></ul><p>参考资料：</p><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fcb97f76a92fd" target="_blank" rel="noopener">www.jianshu.com/p/cb97f76a9…</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F263820564" target="_blank" rel="noopener">www.zhihu.com/question/26…</a></li></ul><p>扩展阅读：</p><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F67739617" target="_blank" rel="noopener">www.zhihu.com/question/67…</a></li></ul><h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><p>无论是<code>Read committed</code>还是<code>Repeatable read</code>隔离级别，都是为了解决<strong>读写冲突</strong>的问题。</p><p>单纯在<code>Repeatable read</code>隔离级别下我们来考虑一个问题：</p><p><img src="13.jpg" alt></p><p>此时，用户李四的操作就丢失掉了：</p><ul><li><strong>丢失更新</strong>：一个事务的更新<strong>覆盖了其它事务的更新结果</strong>。</li></ul><p>(ps:暂时没有想到比较好的例子来说明更新丢失的问题，虽然上面的例子也是更新丢失，但<strong>一定程度上是可接受的</strong>..不知道有没有人能想到不可接受的更新丢失例子呢…)</p><p>解决的方法：</p><ul><li>使用Serializable隔离级别，事务是串行执行的！</li><li>乐观锁</li><li>悲观锁</li></ul><blockquote><ol><li>乐观锁是一种思想，具体实现是，表中有一个版本字段，第一次读的时候，获取到这个字段。处理完业务逻辑开始更新的时候，需要再次查看该字段的值是否和第一次的一样。如果一样更新，反之拒绝。之所以叫乐观，因为这个模式没有从数据库加锁，等到更新的时候再判断是否可以更新。</li><li>悲观锁是数据库层面加锁，都会阻塞去等待锁。</li></ol></blockquote><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>所以，按照上面的例子。我们使用悲观锁的话其实很简单(手动加行锁就行了)：</p><ul><li><code>select * from xxxx for update</code></li></ul><p>在select 语句后边加了 <code>for update</code>相当于加了排它锁(写锁)，加了写锁以后，其他的事务就不能对它修改了！需要等待当前事务修改完之后才可以修改.</p><ul><li>也就是说，如果张三使用<code>select ... for update</code>，李四就无法对该条记录修改了~</li></ul><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁不是数据库层面上的锁，是需要自己手动去加的锁。一般我们添加一个版本字段来实现：</p><p>具体过程是这样的：</p><p>张三<code>select * from table</code>  —&gt;会查询出记录出来，同时会有一个version字段</p><p><img src="14.jpg" alt></p><p>李四<code>select * from table</code>  —&gt;会查询出记录出来，同时会有一个version字段</p><p><img src="15.jpg" alt></p><p>李四对这条记录做修改：<code>update A set Name=lisi,version=version+1 where ID=#{id} and version=#{version}</code>，判断之前查询到的version与现在的数据的version进行比较，<strong>同时会更新version字段</strong></p><p>此时数据库记录如下：</p><p><img src="16.jpg" alt></p><p>张三也对这条记录修改：<code>update A set Name=lisi,version=version+1 where ID=#{id} and version=#{version}</code>，但失败了！因为<strong>当前数据库中的版本跟查询出来的版本不一致</strong>！</p><p><img src="17.jpg" alt></p><p>参考资料：</p><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F31537871" target="_blank" rel="noopener">zhuanlan.zhihu.com/p/31537871</a>—什么是悲观锁和乐观锁</li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F27876575" target="_blank" rel="noopener">www.zhihu.com/question/27…</a>—乐观锁和 MVCC 的区别？</li></ul><h2 id="间隙锁GAP"><a href="#间隙锁GAP" class="headerlink" title="间隙锁GAP"></a>间隙锁GAP</h2><p>当我们<strong>用范围条件检索数据</strong>而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给<strong>符合范围条件的已有数据记录的索引项加锁</strong>；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”。InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁。</p><p>值得注意的是：间隙锁只会在<code>Repeatable read</code>隔离级别下使用~</p><p>例子：假如emp表中只有101条记录，其empid的值分别是1,2,…,100,101</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span>  emp <span class="keyword">where</span> empid &gt; <span class="number">100</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>上面是一个范围查询，InnoDB<strong>不仅</strong>会对符合条件的empid值为101的记录加锁，也会对<strong>empid大于101（这些记录并不存在）的“间隙”加锁</strong>。</p><p>InnoDB使用间隙锁的目的有两个：</p><ul><li><strong>为了防止幻读</strong>(上面也说了，<code>Repeatable read</code>隔离级别下再通过GAP锁即可避免了幻读)</li><li>满足恢复和复制的需要<ul><li>MySQL的恢复机制要求：<strong>在一个事务未提交前，其他并发事务不能插入满足其锁定条件的任何记录，也就是不允许出现幻读</strong></li></ul></li></ul><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>并发的问题就少不了死锁，在MySQL中同样会存在死锁的问题。</p><p>但一般来说MySQL通过回滚帮我们解决了不少死锁的问题了，但死锁是无法完全避免的，可以通过以下的经验参考，来尽可能少遇到死锁：</p><ul><li>1）以<strong>固定的顺序</strong>访问表和行。比如对两个job批量更新的情形，简单方法是对id列表先排序，后执行，这样就避免了交叉等待锁的情形；将两个事务的sql顺序调整为一致，也能避免死锁。</li><li>2）<strong>大事务拆小</strong>。大事务更倾向于死锁，如果业务允许，将大事务拆小。</li><li>3）在同一个事务中，尽可能做到<strong>一次锁定</strong>所需要的所有资源，减少死锁概率。</li><li>4）<strong>降低隔离级别</strong>。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁。</li><li>5）<strong>为表添加合理的索引</strong>。可以看到如果不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大。</li></ul><p>参考资料：</p><ul><li><a href="https://link.juejin.im?target=http%3A%2F%2Fhedengcheng.com%2F%3Fp%3D771%23_Toc374698322" target="_blank" rel="noopener">hedengcheng.com/?p=771#_Toc…</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2FLBSer%2Fp%2F5183300.html" target="_blank" rel="noopener">www.cnblogs.com/LBSer/p/518…</a></li></ul><h2 id="锁总结"><a href="#锁总结" class="headerlink" title="锁总结"></a>锁总结</h2><p>上面说了一大堆关于MySQL数据库锁的东西，现在来简单总结一下。</p><p>表锁其实我们程序员是很少关心它的：</p><ul><li>在MyISAM存储引擎中，当执行SQL语句的时候是自动加的。</li><li>在InnoDB存储引擎中，如果没有使用索引，表锁也是自动加的。</li></ul><p>现在我们大多数使用MySQL都是使用InnoDB，InnoDB支持行锁：</p><ul><li>共享锁–读锁–S锁</li><li>排它锁–写锁–X锁</li></ul><p>在默认的情况下，<code>select</code>是不加任何行锁的~事务可以通过以下语句显示给记录集加共享锁或排他锁。</p><ul><li>共享锁（S）：<code>SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE</code>。</li><li>排他锁（X)：<code>SELECT * FROM table_name WHERE ... FOR UPDATE</code>。</li></ul><p>InnoDB<strong>基于行锁</strong>还实现了MVCC多版本并发控制，MVCC在隔离级别下的<code>Read committed</code>和<code>Repeatable read</code>下工作。MVCC能够实现<strong>读写不阻塞</strong>！</p><p>InnoDB实现的<code>Repeatable read</code>隔离级别配合GAP间隙锁已经避免了幻读！</p><ul><li>乐观锁其实是一种思想，正如其名：认为不会锁定的情况下去更新数据，如果发现不对劲，才不更新(回滚)。在数据库中往往添加一个version字段来实现。</li><li>悲观锁用的就是数据库的行锁，认为数据库会发生并发冲突，直接上来就把数据锁住，其他事务不能修改，直至提交了当前事务</li></ul><p>参考资料：</p><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F29150809" target="_blank" rel="noopener">zhuanlan.zhihu.com/p/29150809</a>–Mysql锁总结</li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fmysteryhaohao%2Farticle%2Fdetails%2F51669741" target="_blank" rel="noopener">blog.csdn.net/mysteryhaoh…</a>–MySQL学习之——锁(行锁、表锁、页锁、乐观锁、悲观锁等)</li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000015596126" target="_blank" rel="noopener">segmentfault.com/a/119000001…</a>–MySQL InnoDB引擎锁的总结</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要介绍了数据库中的两个比较重要的知识点：索引和锁。他俩可以说息息相关的，锁会涉及到很多关于索引的知识~</p><p>我个人比较重视对整体知识点的把控，一些细节的地方可能就没有去编写了。在每一个知识点下都会有很多的内容，有兴趣的同学可以在我给出的链接中继续阅读学习。当然了，如果有比较好的文章和资料也不妨在评论区分享一下哈~</p><p>我只是在学习的过程中，把自己遇到的问题写出来，整理出来，希望可以对大家有帮助。如果文章有错的地方，希望大家可以在评论区指正，一起学习交流~</p><p>参考资料：</p><ul><li>《高性能MySQL 第三版》</li></ul><blockquote><p>作者：Java3y</p><p>链接：<a href="https://juejin.im/post/5b55b842f265da0f9e589e79" target="_blank" rel="noopener">https://juejin.im/post/5b55b842f265da0f9e589e79</a></p><p>来源：掘金著作权归作者所有。</p><p>商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自：&lt;a href=&quot;https://juejin.im/post/5b55b842f265da0f9e589e79&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数据库两大神器【索引和锁】&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;只有光头才能变强&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;索引和锁&lt;/strong&gt;在数据库中可以说是非常重要的知识点了，在面试中也会经常会被问到的。&lt;/p&gt;
&lt;p&gt;本文&lt;strong&gt;力求简单讲清每个知识点&lt;/strong&gt;，希望大家看完能有所收获&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;声明：如果没有说明具体的数据库和存储引擎，&lt;strong&gt;默认指的是MySQL中的InnoDB存储引擎&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://changsk.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Mysql" scheme="http://changsk.top/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-188:Best Time to Buy and Sell Stock IV</title>
    <link href="http://changsk.top/2019/07/26/leetcode-188/"/>
    <id>http://changsk.top/2019/07/26/leetcode-188/</id>
    <published>2019-07-26T14:47:53.000Z</published>
    <updated>2019-07-26T15:02:12.252Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>题目难度：Hard</p></blockquote><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p><p>Design an algorithm to find the maximum profit. You may complete at most <strong>k</strong> transactions.</p><p><strong>Note:</strong><br>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p><p><strong>Example 1:</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>], k = <span class="number">2</span></span><br><span class="line">Output: <span class="number">2</span></span><br><span class="line">Explanation: Buy <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">1</span> (price = <span class="number">2</span>) <span class="keyword">and</span> sell <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">2</span> (price = <span class="number">4</span>), profit = <span class="number">4</span><span class="number">-2</span> = <span class="number">2.</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">3</span>], k = <span class="number">2</span></span><br><span class="line">Output: <span class="number">7</span></span><br><span class="line">Explanation: Buy <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">2</span> (price = <span class="number">2</span>) <span class="keyword">and</span> sell <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">3</span> (price = <span class="number">6</span>), profit = <span class="number">6</span><span class="number">-2</span> = <span class="number">4.</span></span><br><span class="line">             Then buy <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">5</span> (price = <span class="number">0</span>) <span class="keyword">and</span> sell <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">6</span> (price = <span class="number">3</span>), profit = <span class="number">3</span><span class="number">-0</span> = <span class="number">3.</span></span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p><code>t[i][j]</code>表示<code>prices</code>中从<code>0</code>到<code>j</code>的股票当中最多交易<code>i</code>次的最大利润</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= len / <span class="number">2</span>) <span class="keyword">return</span> quickSolve(prices);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] t = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>][len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmpMax =  -prices[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                t[i][j] = Math.max(t[i][j - <span class="number">1</span>], prices[j] + tmpMax);</span><br><span class="line">                tmpMax =  Math.max(tmpMax, t[i - <span class="number">1</span>][j - <span class="number">1</span>] - prices[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t[k][len - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大的交易次数为len / 2,所以如果 k 大于等于 len / 2,题目退化为不限交易次数的最大利润</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">quickSolve</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.length, profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">            <span class="comment">// as long as there is a price gap, we gain a profit.</span></span><br><span class="line">            <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) profit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>代码来自<code>LeetCode</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 注解的基本原理</title>
    <link href="http://changsk.top/2019/07/26/java-annotation/"/>
    <id>http://changsk.top/2019/07/26/java-annotation/</id>
    <published>2019-07-26T09:51:16.000Z</published>
    <updated>2019-07-26T10:50:30.578Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://juejin.im/post/5b45bd715188251b3a1db54f#heading-3" target="_blank" rel="noopener">JAVA 注解的基本原理</a></p></blockquote><p>以前，『XML』是各大框架的青睐者，它以松耦合的方式完成了框架中几乎所有的配置，但是随着项目越来越庞大，『XML』的内容也越来越复杂，维护成本变高。</p><p>于是就有人提出来一种标记式高耦合的配置方式，『注解』。方法上可以进行注解，类上也可以注解，字段属性上也可以注解，反正几乎需要配置的地方都可以进行注解。</p><p>关于『注解』和『XML』两种不同的配置模式，争论了好多年了，各有各的优劣，注解可以提供更大的便捷性，易于维护修改，但耦合度高，而 XML 相对于注解则是相反的。</p><p>追求低耦合就要抛弃高效率，追求效率必然会遇到耦合。本文意不再辨析两者谁优谁劣，而在于以最简单的语言介绍注解相关的基本内容。</p><a id="more"></a><h3 id="注解的本质"><a href="#注解的本质" class="headerlink" title="注解的本质"></a>注解的本质</h3><p>「java.lang.annotation.Annotation」接口中有这么一句话，用来描述『注解』。</p><blockquote><p>The common interface extended by all annotation types</p><p>所有的注解类型都继承自这个普通的接口（Annotation）</p></blockquote><p>这句话有点抽象，但却说出了注解的本质。我们看一个 JDK 内置注解的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是注解 @Override 的定义，其实它本质上就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Override</span> <span class="keyword">extends</span> <span class="title">Annotation</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错，注解的本质就是一个继承了 Annotation 接口的接口。有关这一点，你可以去反编译任意一个注解类，你会得到结果的。</p><p><strong>一个注解准确意义上来说，只不过是一种特殊的注释而已，如果没有解析它的代码，它可能连注释都不如。</strong></p><p>而解析一个类或者方法的注解往往有两种形式，一种是编译期直接的扫描，一种是运行期反射。反射的事情我们待会说，而编译器的扫描指的是编译器在对 java 代码编译字节码的过程中会检测到某个类或者方法被一些注解修饰，这时它就会对于这些注解进行某些处理。</p><p>典型的就是注解 @Override，一旦编译器检测到某个方法被修饰了 @Override 注解，编译器就会检查当前方法的方法签名是否真正重写了父类的某个方法，也就是比较父类中是否具有一个同样的方法签名。</p><p>这一种情况只适用于那些编译器已经熟知的注解类，比如 JDK 内置的几个注解，而你自定义的注解，编译器是不知道你这个注解的作用的，当然也不知道该如何处理，往往只是会根据该注解的作用范围来选择是否编译进字节码文件，仅此而已。</p><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>『元注解』是用于修饰注解的注解，通常用在注解的定义上，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我们 @Override 注解的定义，你可以看到其中的 @Target，@Retention 两个注解就是我们所谓的『元注解』，『元注解』一般用于指定某个注解生命周期以及作用目标等信息。</p><p>JAVA 中有以下几个『元注解』：</p><ul><li>@Target：注解的作用目标</li><li>@Retention：注解的生命周期</li><li>@Documented：注解是否应当被包含在 JavaDoc 文档中</li><li>@Inherited：是否允许子类继承该注解</li></ul><p>其中，@Target 用于指明被修饰的注解最终可以作用的目标是谁，也就是指明，你的注解到底是用来修饰方法的？修饰类的？还是用来修饰字段属性的。</p><p>@Target 的定义如下：</p><p><img src="1.jpg" alt="image"></p><p>我们可以通过以下的方式来为这个 value 传值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(value = &#123;ElementType.FIELD&#125;)</span><br></pre></td></tr></table></figure><p>被这个 @Target 注解修饰的注解将只能作用在成员字段上，不能用于修饰方法或者类。其中，ElementType 是一个枚举类型，有以下一些值：</p><ul><li>ElementType.TYPE：允许被修饰的注解作用在类、接口和枚举上</li><li>ElementType.FIELD：允许作用在属性字段上</li><li>ElementType.METHOD：允许作用在方法上</li><li>ElementType.PARAMETER：允许作用在方法参数上</li><li>ElementType.CONSTRUCTOR：允许作用在构造器上</li><li>ElementType.LOCAL_VARIABLE：允许作用在本地局部变量上</li><li>ElementType.ANNOTATION_TYPE：允许作用在注解上</li><li>ElementType.PACKAGE：允许作用在包上</li></ul><p>@Retention 用于指明当前注解的生命周期，它的基本定义如下：</p><p><img src="2.jpg" alt="image"></p><p>同样的，它也有一个 value 属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(value = RetentionPolicy.RUNTIME</span><br></pre></td></tr></table></figure><p>这里的 RetentionPolicy 依然是一个枚举类型，它有以下几个枚举值可取：</p><ul><li>RetentionPolicy.SOURCE：当前注解编译期可见，不会写入 class 文件</li><li>RetentionPolicy.CLASS：类加载阶段丢弃，会写入 class 文件</li><li>RetentionPolicy.RUNTIME：永久保存，可以反射获取</li></ul><p>@Retention 注解指定了被修饰的注解的生命周期，一种是只能在编译期可见，编译后会被丢弃，一种会被编译器编译进 class 文件中，无论是类或是方法，乃至字段，他们都是有属性表的，而 JAVA 虚拟机也定义了几种注解属性表用于存储注解信息，但是这种可见性不能带到方法区，类加载时会予以丢弃，最后一种则是永久存在的可见性。</p><p>剩下两种类型的注解我们日常用的不多，也比较简单，这里不再详细的进行介绍了，你只需要知道他们各自的作用即可。@Documented 注解修饰的注解，当我们执行 JavaDoc 文档打包时会被保存进 doc 文档，反之将在打包时丢弃。@Inherited 注解修饰的注解是具有可继承性的，也就说我们的注解修饰了一个类，而该类的子类将自动继承父类的该注解。</p><h3 id="JAVA-的内置三大注解"><a href="#JAVA-的内置三大注解" class="headerlink" title="JAVA 的内置三大注解"></a>JAVA 的内置三大注解</h3><p>除了上述四种元注解外，JDK 还为我们预定义了另外三种注解，它们是：</p><ul><li>@Override</li><li>@Deprecated</li><li>@SuppressWarnings</li></ul><p>@Override 注解想必是大家很熟悉的了，它的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它没有任何的属性，所以并不能存储任何其他信息。它只能作用于方法之上，编译结束后将被丢弃。</p><p>所以你看，它就是一种典型的『标记式注解』，仅被编译器可知，编译器在对 java 文件进行编译成字节码的过程中，一旦检测到某个方法上被修饰了该注解，就会去匹对父类中是否具有一个同样方法签名的函数，如果不是，自然不能通过编译。</p><p>@Deprecated 的基本定义如下：</p><p><img src="3.jpg" alt="image"></p><p>依然是一种『标记式注解』，永久存在，可以修饰所有的类型，作用是，标记当前的类或者方法或者字段等已经不再被推荐使用了，可能下一次的 JDK 版本就会删除。</p><p>当然，编译器并不会强制要求你做什么，只是告诉你 JDK 已经不再推荐使用当前的方法或者类了，建议你使用某个替代者。</p><p>@SuppressWarnings 主要用来压制 java 的警告，它的基本定义如下：</p><p><img src="4.jpg" alt="image"></p><p>它有一个 value 属性需要你主动的传值，这个 value 代表一个什么意思呢，这个 value 代表的就是需要被压制的警告类型。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Date date = <span class="keyword">new</span> Date(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">11</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么一段代码，程序启动时编译器会报一个警告。</p><blockquote><p>Warning:(8, 21) java: java.util.Date 中的 Date(int,int,int) 已过时</p></blockquote><p>而如果我们不希望程序启动时，编译器检查代码中过时的方法，就可以使用 @SuppressWarnings 注解并给它的 value 属性传入一个参数值来压制编译器的检查。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarning</span>(value = <span class="string">"deprecated"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Date date = <span class="keyword">new</span> Date(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">11</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样你就会发现，编译器不再检查 main 方法下是否有过时的方法调用，也就压制了编译器对于这种警告的检查。</p><p>当然，JAVA 中还有很多的警告类型，他们都会对应一个字符串，通过设置 value 属性的值即可压制对于这一类警告类型的检查。</p><p>自定义注解的相关内容就不再赘述了，比较简单，通过类似以下的语法即可自定义一个注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> InnotationName&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，自定义注解的时候也可以选择性的使用元注解进行修饰，这样你可以更加具体的指定你的注解的生命周期、作用范围等信息。</p><h3 id="注解与反射"><a href="#注解与反射" class="headerlink" title="注解与反射"></a>注解与反射</h3><p>上述内容我们介绍了注解使用上的细节，也简单提到，「注解的本质就是一个继承了 Annotation 接口的接口」，现在我们就来从虚拟机的层面看看，注解的本质到底是什么。</p><p>首先，我们自定义一个注解类型：</p><p><img src="5.jpg" alt="image"></p><p>这里我们指定了 Hello 这个注解只能修饰字段和方法，并且该注解永久存活，以便我们反射获取。</p><p>之前我们说过，虚拟机规范定义了一系列和注解相关的属性表，也就是说，无论是字段、方法或是类本身，如果被注解修饰了，就可以被写进字节码文件。属性表有以下几种：</p><ul><li>RuntimeVisibleAnnotations：运行时可见的注解</li><li>RuntimeInVisibleAnnotations：运行时不可见的注解</li><li>RuntimeVisibleParameterAnnotations：运行时可见的方法参数注解</li><li>RuntimeInVisibleParameterAnnotations：运行时不可见的方法参数注解</li><li>AnnotationDefault：注解类元素的默认值</li></ul><p>给大家看虚拟机的这几个注解相关的属性表的目的在于，让大家从整体上构建一个基本的印象，注解在字节码文件中是如何存储的。</p><p>所以，对于一个类或者接口来说，Class 类中提供了以下一些方法用于反射注解。</p><ul><li>getAnnotation：返回指定的注解</li><li>isAnnotationPresent：判定当前元素是否被指定注解修饰</li><li>getAnnotations：返回所有的注解</li><li>getDeclaredAnnotation：返回本元素的指定注解</li><li>getDeclaredAnnotations：返回本元素的所有注解，不包含父类继承而来的</li></ul><p>方法、字段中相关反射注解的方法基本是类似的，这里不再赘述，我们下面看一个完整的例子。</p><p>首先，设置一个虚拟机启动参数，用于捕获 JDK 动态代理类。</p><blockquote><p>-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true</p></blockquote><p>然后 main 函数。</p><p><img src="6.jpg" alt="image"></p><p>我们说过，注解本质上是继承了 Annotation 接口的接口，而当你通过反射，也就是我们这里的 getAnnotation 方法去获取一个注解类实例的时候，其实 JDK 是通过动态代理机制生成一个实现我们注解（接口）的代理类。</p><p>我们运行程序后，会看到输出目录里有这么一个代理类，反编译之后是这样的：</p><p><img src="7.jpg" alt="image"></p><p><img src="8.jpg" alt="image"></p><p>代理类实现接口 Hello 并重写其所有方法，包括 value 方法以及接口 Hello 从 Annotation 接口继承而来的方法。</p><p>而这个关键的 InvocationHandler 实例是谁？</p><p>AnnotationInvocationHandler 是 JAVA 中专门用于处理注解的 Handler， 这个类的设计也非常有意思。</p><p><img src="9.jpg" alt="image"></p><p>这里有一个 memberValues，它是一个 Map 键值对，键是我们注解属性名称，值就是该属性当初被赋上的值。</p><p><img src="10.jpg" alt="image"></p><p><img src="11.jpg" alt="image"></p><p>而这个 invoke 方法就很有意思了，大家注意看，我们的代理类代理了 Hello 接口中所有的方法，所以对于代理类中任何方法的调用都会被转到这里来。</p><p>var2 指向被调用的方法实例，而这里首先用变量 var4 获取该方法的简明名称，接着 switch 结构判断当前的调用方法是谁，如果是 Annotation 中的四大方法，将 var7 赋上特定的值。</p><p>如果当前调用的方法是 toString，equals，hashCode，annotationType 的话，AnnotationInvocationHandler 实例中已经预定义好了这些方法的实现，直接调用即可。</p><p>那么假如 var7 没有匹配上这四种方法，说明当前的方法调用的是自定义注解字节声明的方法，例如我们 Hello 注解的 value 方法。<strong>这种情况下，将从我们的注解 map 中获取这个注解属性对应的值。</strong></p><p>其实，JAVA 中的注解设计个人觉得有点反人类，明明是属性的操作，非要用方法来实现。当然，如果你有不同的见解，欢迎留言探讨。</p><p>最后我们再总结一下整个反射注解的工作原理：</p><p>首先，我们通过键值对的形式可以为注解属性赋值，像这样：@Hello（value = “hello”）。</p><p>接着，你用注解修饰某个元素，编译器将在编译期扫描每个类或者方法上的注解，会做一个基本的检查，你的这个注解是否允许作用在当前位置，最后会将注解信息写入元素的属性表。</p><p>然后，当你进行反射的时候，虚拟机将所有生命周期在 RUNTIME 的注解取出来放到一个 map 中，并创建一个 AnnotationInvocationHandler 实例，把这个 map 传递给它。</p><p>最后，虚拟机将采用 JDK 动态代理机制生成一个目标注解的代理类，并初始化好处理器。</p><p>那么这样，一个注解的实例就创建出来了，它本质上就是一个代理类，你应当去理解好 AnnotationInvocationHandler 中 invoke 方法的实现逻辑，这是核心。一句话概括就是，<strong>通过方法名返回注解属性值</strong>。</p><blockquote><p>作者：YangAM</p><p>链接：<a href="https://juejin.im/post/5b45bd715188251b3a1db54f" target="_blank" rel="noopener">https://juejin.im/post/5b45bd715188251b3a1db54f</a></p><p>来源：掘金著作权归作者所有。</p><p>商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://juejin.im/post/5b45bd715188251b3a1db54f#heading-3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JAVA 注解的基本原理&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以前，『XML』是各大框架的青睐者，它以松耦合的方式完成了框架中几乎所有的配置，但是随着项目越来越庞大，『XML』的内容也越来越复杂，维护成本变高。&lt;/p&gt;
&lt;p&gt;于是就有人提出来一种标记式高耦合的配置方式，『注解』。方法上可以进行注解，类上也可以注解，字段属性上也可以注解，反正几乎需要配置的地方都可以进行注解。&lt;/p&gt;
&lt;p&gt;关于『注解』和『XML』两种不同的配置模式，争论了好多年了，各有各的优劣，注解可以提供更大的便捷性，易于维护修改，但耦合度高，而 XML 相对于注解则是相反的。&lt;/p&gt;
&lt;p&gt;追求低耦合就要抛弃高效率，追求效率必然会遇到耦合。本文意不再辨析两者谁优谁劣，而在于以最简单的语言介绍注解相关的基本内容。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://changsk.top/categories/Java/"/>
    
    
      <category term="注解" scheme="http://changsk.top/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>操作系统之内存管理</title>
    <link href="http://changsk.top/2019/07/25/os-memory-management/"/>
    <id>http://changsk.top/2019/07/25/os-memory-management/</id>
    <published>2019-07-25T13:04:52.000Z</published>
    <updated>2019-07-25T13:31:12.904Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://juejin.im/post/5988330c5188256dd1666626" target="_blank" rel="noopener">计算机系统012 - 操作系统之内存管理</a></p></blockquote><a id="more"></a><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>所谓内存管理，其最基本的操作就是由CPU把程序装入到内存中执行。远古批处理时代，进程独占各种计算机资源依次执行，因此只要小于可用内存总大小（主要是除去操作系统本身所占内存）的进程均可加载运行。随着操作系统的发展，提高CPU利用率和降低平均响应时长成了两大主流方向。前面的文章中反复提到<strong>提高CPU利用率的最有效方法就是加载多个进程到内存中，通过在一个进程执行I/O操作期间切换至另一进程，避开阻塞等待。</strong>也就是说，同一时刻加载入内存空间的进程数越多，可供选择的进程就越多，就越有机会避开I/O操作等待时间，那么，剩下的问题就是，该如何增加加载入内存空间的进程数。  </p><p>可加载到内存空间的进程总数受到两方面影响：  </p><ul><li>物理内存总量：硬件上内存空间总量总是有限的，如早期计算机只有256MB内存</li><li>单个进程占用内存空间数：为了完成更复杂的功能、呈现更好的视觉效果等，程序日益复杂，运行所需内存空间与日俱增</li></ul><p>简而言之，内存与进程间的态势是<strong>供不应求</strong>。针对问题找方法，可选的解决方法有如下两种：  </p><ul><li>增大物理内存总量<br>  增大物理内存总量，需考虑硬件技术以及经济能力两方面。硬件技术发展总有其时代局限性，即使到今天，民用计算机中单条内存16GB的容量已经是很高端的了，而这一级别的内存条目前均价为600RMB左右。以台式机为例，插满4根组成64GB需要成本约2400RMB，价格不菲。而且这只是内存而已，毕竟计算机整体性能还和其他如CPU、硬盘、显卡等各大烧钱部件息息相关。因此不管是从硬件技术还是经济效益来考虑，增大物理内存总量这条路潜力很有限。  </li><li>降低单个进程运行所需内存空间<br>  能用软件实现的功能，只要对效率上要求不十分严格，实现起来的灵活性和性价比要比单纯扩展硬件要高得多，对于内存的使用也同样如此。要想降低进程所需内存空间，只有一种方法，那就是<strong>只加载进程中当前可能执行到的部分</strong>。  </li></ul><h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a><a href="https://link.juejin.im?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FPrinciple_of_locality" target="_blank" rel="noopener">局部性原理</a></h2><p>从物理学上讲，局部性原理认为一个特定物体只会受到其直接相关环境影响。而对应到计算机系统中，硬件只会与其有直接电气线路相连的其他硬件交互，软件程序中，每一个指令也只会与其附近一段区域内代码相关联。讲句人话就是，<strong>硬件交互需要电气接触，软件执行通常只会牵扯到附近代码</strong>，毕竟编码过程中本身就会将问题进行模块分解。对比例证，阅读理解文学作品时对于单句的理解需结合上下文，商品使用说明书同样是分模块说明的。   </p><p>局部性原理为前一小节提出的“只加载进程中当前可能执行到的部分”的解决方案提供了理论支撑。虽然进程中包括了很多代码和数据，但执行过程中CPU是以顺序执行读取到的指令的，<strong>假如可以保证每条指令只和附近一些指令相关，那就可以只加载一定量的指令就可以实现进程内部的顺序执行</strong>，对于数据部分也是同样的道理。实际应用中，如现在的游戏程序，动辄十几GB、甚至几十GB，其实内部大多是动画CG。如果执行程序的前提是必须全部加载，那么很少有硬件能够成功运行该游戏程序；但基于局部性原理，运行时只加载当前章节或场景必需的代码数据即可，只有当需要切换到其他章节、场景时，再<strong>动态加载</strong>对应代码数据。  </p><h2 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h2><p>虽然根据局部性原理，使得同时可以加载入内存的进程总数有所提升，但内存总量始终是不能改变的，而进程运行过程中也随时可能增减所需内存。要想保持进程总数甚至加载更多进程，在<strong>有增的同时就势必有减</strong>。然而增减终归要有源头，而这个源头就是辅助存储设备，也称为二级存储器，典型设备为磁盘Disk。  </p><p>当内存中没有富余内存空间时，就必须将一部分进程使用到的内存空间减少。这些空间可能包括进程存储原始数据的空间，也有可能包括运行时动态信息的空间，为了再当重新切换回这些进程时可以正确执行，如同进程切换一样，需要将所减少的空间进行存储，而存储的位置只有容量更大的磁盘空间。从内存保存到磁盘、或是从磁盘重新加载回内存的操作就叫做<strong>交换</strong>。   </p><p>内存管理中，只保证提供内存空间，并不保证每次提供的内存空间在物理上位置都一样。例如，进程被交换到磁盘后再次加载，所加载到的位置几乎不会与被交换出内存时所处的位置一样。这也是为了保证各进程所需的不同内存空间总数同时，尽可能减小外部碎片（可视为进程间连接处不能使用的空间）。既然位置发生了变化，但进程还要继续执行，那就只能通过<strong>重定位</strong>技术来Cover掉这个差异。  </p><p><img src="1.jpg" alt="img"></p><p>单纯讲重定位会过于抽象，要理解这个概念，首先要对几种地址类型进行区分：  </p><ul><li>物理地址/绝对地址，是数据在内存中的实际位置，通常物理地址是一组连续线性递增的地址空间</li><li>逻辑地址，指与当前数据在内存中的物理分配地址无关的访问地址，在执行对内存的访问之前必须先把它转换成物理地址</li><li>相对地址，相对于某已知点（通常是程序的开始处）的存储单元</li></ul><p>由于不同操作系统对于进程的具体定义各有差异，内核所使用的调度策略也有所差别，因此进程所能分配到的地址以及地址空间位置的关系也均有所不同。这样一来，进程运行过程中，自然不能通过物理地址来查找指令、数据等信息，为了避免硬件地址对其影响，进程中使用逻辑地址作为分布依据。要想实现这项功能，<strong>操作系统中就必须维护一份逻辑地址与物理地址间的映射表，从而使得操作系统可以将进程运行时的逻辑地址转换为物理地址，进行存取</strong>。  </p><h2 id="典型进程执行过程"><a href="#典型进程执行过程" class="headerlink" title="典型进程执行过程"></a>典型进程执行过程</h2><p>综合前文所述，如在进程执行中选择只加载（或是尽可能少）必需代码、数据，那么典型进程执行过程如下：  </p><ul><li>操作系统读取包含程序开始处的一些字节</li><li>由于进程刚执行，只有小部分在内存中，因此会因为无法读取到后续指令、数据而触发大量中断</li><li>CPU收到中断后移交控制权给操作系统</li><li>操作系统确定数据在磁盘上的位置</li><li>读取数据至内存中</li><li>返回至原进程，继续执行</li></ul><p>这样一段时间后，通过预测等CPU技术，将进程可能执行的指令数据提前加载到内存中，中断将很少触发，整体执行过程趋于稳定，直到进程执行结束。  </p><h1 id="交换单元"><a href="#交换单元" class="headerlink" title="交换单元"></a>交换单元</h1><p>前一节中整体介绍了内存管理中增加内存中可加载进程总数的有效解决方法，但对于交换的具体细节并没有做过多说明，这里就从交换单元的角度来看看交换过程相关问题。  </p><p>通过硬件部分的知识我们了解到，物理内存是线性地址空间，而大多数程序是以模块形式组织，因此从逻辑上来讲，以模块形式组织会更有利于组织代码和数据。通常操作系统占据了内存中的某些固定部分，内存的其余部分可供多个用户进程使用，称为用户空间。而根据用户空间从逻辑地址到物理地址的转换单元粒度大小，可分为如下三类。  </p><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p>同样是远古时期，主要是使用分区技术进行内存管理。通过将内存空间分区，形成若干边界固定的区域。进程加载时，选择大于或等于所需空间大小的分区进行装载。因此分区技术中，<strong>进程加载匹配的单位是分区，进程和分区是是一对一的关系</strong>。  </p><p>分区技术中交换的单位是分区，和其他技术一样，放置时使用到的放置算法主要有三种：  </p><ul><li>最佳适配，选择与要求大小最接近的块</li><li>首次适配，从开始扫描内存，选择大小足够的第一个可用块</li><li>下次适配，从上一次放置的位置开始扫描内存，选择下一个大小足够的可用块</li></ul><p>相较而言，分区技术存在的最大问题是粒度过大，由于进程所需空间值域较广，很容易引入内部（固定分区特有）、外部碎片，造成内存空间上的浪费。虽然通过压缩等技术可以适当减缓，但效率上仍然不十分可观，因此目前分区技术已基本不再使用。  </p><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a><a href="https://link.juejin.im?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FPaging" target="_blank" rel="noopener">分页</a></h2><p>有了分区的前车之鉴，那么<strong>分页技术就适当降低了单元粒度，此时一个进程不再对应一个完整分区，而是对应多个页</strong>。进一步说明之前，首先了解一下如下概念：  </p><ul><li>页（page）<br>  一定大小字节数内存单元，属于逻辑单元。进程中所有代码、数据等信息均按页进行存储，属于逻辑组织形式。每个页有页码及其他信息。</li><li>页框(page frame)<br>  对应页字节数的物理内存，属于物理单元，是实际存在于物理内存中的可用地址单元。页框相当于页的容器，进程运行过程中，可能会动态加载不同页进入页框，CPU则直接对页框进行存取。  </li><li>页表（page table）<br>  既然有页和对应页框，那就必须有映射表将两者联系起来，而页表就是页和页框之间的映射表。换言之，知道页就可以查询到页框，知道页框，也可以查询到对应页。  </li></ul><blockquote><p>页表存在必要性还有一个角度可以理解，由于单元粒度变小，那么单元总数就上升了。为了便于管理，对于总数众多的事物，通常会采用分级管理的方法。以学校对于学生的管理为例，通常会划分为校长、年级主任、班主任、班长、组长等层级。对于内存也同样如此，通过将每8个bit组织为一个字节，每多少字节组织为一页，划分层级。操作系统为每个进程维护一个页表，页表给出该进程的每一页对应的页框的位置。对于每一页中的位置，则进一步使用偏移量来表示。  </p></blockquote><p>当进程尝试引用不在内存中的页时，CPU会判定为页错误，并将控制权暂时从进程移交到操作系统，而操作系统则负责：  </p><ul><li>确定数据在磁盘上的位置</li><li>从内存中获取一个空的页框作为数据容器</li><li>加载所需数据至可用页框</li><li>更新新页框至页表</li><li>返回至原进程，继续执行造成也页错误的指令</li></ul><p>第二步中，如所有页框均处于使用中状态，则操作系统必须选择一个页框进行重用。如被交换页框是被其他进程动态加载以存储数据、或是加载进内存后被进程修改过，则必须写回到磁盘中。操作系统选择页框进行重用的方法称为<strong>页替换算法</strong>，它关系着整体效率。页替换算法有很多侧重性，如最少使用、最早加载等，归根结底，没有适用于所有场景的算法，但通过不断增加有价值的基础信息，是可以使得页替换更加精确地保证某些特性的。  </p><h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a><a href="https://link.juejin.im?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FMemory_segmentation" target="_blank" rel="noopener">分段</a></h2><p>分段技术与分页的区别倒不在单元力度上，而是逻辑组织形式。分页的最终单位是页，而分段最终单位是段。对于硬件电路而言，可能区别不是很大，但对于程序开发而言，有更贴近自然语言表达方式的优点。  </p><p>分段技术将计算机内存分解为各段，每个段有起始地址和长度，以及一系列权限信息（如读、写、执行等）。而同样地，将进程代码数据等为几个段，逻辑地址同样由段号和偏移量组成。</p><p><img src="2.jpg" alt="img"></p><p>和分页对应，分段时操作系统也需维护一个段表。总的来讲，分页和分段有两个特点：  </p><ul><li>进程中所有内存访问都是逻辑地址，这些逻辑地址在运行时动态地被转化成物理地址</li><li>一个进程可以划分成许多块（页和段），执行过程中，这些块不需要连续地位于内存中。</li></ul><h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a><a href="https://link.juejin.im?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FVirtual_memory" target="_blank" rel="noopener">虚拟内存</a></h1><p>虚拟内存的原理是使用二级存储器以使得程序可以使用超出物理内存大小的内存资源，撕掉包装，就是说用一部分低速的磁盘空间，充当内存空间，从而假装每个进程都有很多内存空间可以使用。  </p><p><img src="3.jpg" alt="img"></p><p>如果说内存是实实在在存在的内存单元，那么磁盘上的就是虚拟存在的内存单元，因此将这两者合称为虚拟内存。有人可能比较担心，增加了磁盘和内存间数据交换会不会降低了CPU执行效率，比如说如果实现加载了进程全部指令等，那么执行时只需要直接从内存中读取并依次执行即可，但现在，可能需要等待部分不存在于内存中的指令从磁盘读取，势必会增加指令周期数而拖慢整个CPU。那么只能说，<strong>影响肯定有，但不大，而且可以通过算法策略进行最小化</strong>。回想一下计算机系统整个存储分级机制，同样也是从快到慢，从小到大，但CPU并没有因为内存的低速而变得慢起来。  </p><p>这些算法策略（以分页为例）主要包括如下几类：  </p><ul><li>读取策略<br>  确定一个页何时取入内存，常用的方法是请求分页和预先分页。<ul><li>请求分页，只在访问到某页中单元时才将该页取入内存</li><li>预先分页，利用大多数辅存设备特性，一次性读取许多连续页以平均读取时间</li></ul></li><li>放置策略</li><li>置换策略</li></ul><p><em>这里不对具体算法策略进行展开，毕竟不是本系列文章的初衷，也容易暴露本人算法渣渣的面貌。</em>    </p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>行文至此，可以整理出操作系统的内存管理取决于三个基本方面的选择：  </p><ul><li>是否使用虚存技术</li><li>使用分页还是分段，或是二者结合</li><li>为各种存储管理特征采用的算法</li></ul><p>前两者取决于使用的硬件平台，因此早期系统未提供虚存是因为CPU不支持分页或分段。所以还是那句话，理解一个事物最好追溯其本源，万物存在皆有理，你如果不能理解到其中理，很可能只是因为你没有充分了解其历史局限性。  </p><p><img src="4.jpg" alt="img"></p><p>同时，也希望本篇中讲解到的内存管理方面内容能够给大家形成一个较为清晰的概念，结合前文所述电学、硬件、操作系统等知识，融会贯通，有所感悟，谢谢！</p><blockquote><p>作者：SniperPan</p><p>链接：<a href="https://juejin.im/post/5988330c5188256dd1666626" target="_blank" rel="noopener">https://juejin.im/post/5988330c5188256dd1666626</a></p><p>来源：掘金著作权归作者所有。</p><p>商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://juejin.im/post/5988330c5188256dd1666626&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;计算机系统012 - 操作系统之内存管理&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://changsk.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>Raft算法原理</title>
    <link href="http://changsk.top/2019/07/25/raft/"/>
    <id>http://changsk.top/2019/07/25/raft/</id>
    <published>2019-07-25T02:04:46.000Z</published>
    <updated>2019-07-25T02:18:23.923Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://www.codedump.info/post/20180921-raft/" target="_blank" rel="noopener">Raft算法原理</a></p></blockquote><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>关于Raft算法，有两篇经典的论文，一篇是《In search of an Understandable Consensus Algorithm》，这是作者最开始讲述Raft算法原理的论文，但是这篇论文太简单了，很多算法的细节没有涉及到。更详细的论文是《CONSENSUS: BRIDGING THEORY AND PRACTICE》，除了包括第一篇论文的内容以外，还加上了很多细节的描述。在我阅读完etcd raft算法库的实现之后，发现这个库的代码基本就是按照后一篇论文来写的，甚至有部分测试用例的注释里也写明了是针对这篇论文的某一个小节的情况做验证。</p><p>这篇文章做为我后续分析etcd raft算法的前导文章，将结合后一篇论文加上一些自己的演绎和理解来讲解Raft算法的原理。</p><a id="more"></a><h1 id="算法的基本流程"><a href="#算法的基本流程" class="headerlink" title="算法的基本流程"></a>算法的基本流程</h1><h2 id="Raft算法概述"><a href="#Raft算法概述" class="headerlink" title="Raft算法概述"></a>Raft算法概述</h2><p>Raft算法由leader节点来处理一致性问题。leader节点接收来自客户端的请求日志数据，然后同步到集群中其它节点进行复制，当日志已经同步到超过半数以上节点的时候，leader节点再通知集群中其它节点哪些日志已经被复制成功，可以提交到raft状态机中执行。</p><p>通过以上方式，Raft算法将要解决的一致性问题分为了以下几个子问题。</p><ul><li>leader选举：集群中必须存在一个leader节点。</li><li>日志复制：leader节点接收来自客户端的请求然后将这些请求序列化成日志数据再同步到集群中其它节点。</li><li>安全性：如果某个节点已经将一条提交过的数据输入raft状态机执行了，那么其它节点不可能再将相同索引 的另一条日志数据输入到raft状态机中执行。</li></ul><p>Raft算法需要一直保持的三个属性。</p><ul><li>选举安全性（Election Safety）：在一个任期内只能存在最多一个leader节点。</li><li>Leader节点上的日志为只添加（Leader Append-Only）：leader节点永远不会删除或者覆盖本节点上面的日志数据。</li><li>日志匹配性（Log Matching）：如果两个节点上的日志，在日志的某个索引上的日志数据其对应的任期号相同，那么在两个节点在这条日志之前的日志数据完全匹配。</li><li>leader完备性（Leader Completeness）：如果一条日志在某个任期被提交，那么这条日志数据在leader节点上更高任期号的日志数据中都存在。</li><li>状态机安全性（State Machine Safety）：如果某个节点已经将一条提交过的数据输入raft状态机执行了，那么其它节点不可能再将相同索引的另一条日志数据输入到raft状态机中执行。</li></ul><h2 id="Raft算法基础"><a href="#Raft算法基础" class="headerlink" title="Raft算法基础"></a>Raft算法基础</h2><p>在Raft算法中，一个集群里面的所有节点有以下三种状态：</p><ul><li>Leader：领导者，一个集群里只能存在一个Leader。</li><li>Follower：跟随者，follower是被动的，一个客户端的修改数据请求如果发送到Follower上面时，会首先由Follower重定向到Leader上，</li><li>Candidate：参与者，一个节点切换到这个状态时，将开始进行一次新的选举。</li></ul><p>每一次开始一次新的选举时，称为一个“任期”。每个任期都有一个对应的整数与之关联，称为“任期号”，任期号用单词“Term”表示，这个值是一个严格递增的整数值。</p><p>节点的状态切换状态机如下图所示。</p><p><img src="1.jpg" alt="raft states"></p><p>上图中标记了状态切换的6种路径，下面做一个简单介绍，后续都会展开来详细讨论。</p><ol><li>start up：起始状态，节点刚启动的时候自动进入的是follower状态。</li><li>times out, starts election：follower在启动之后，将开启一个选举超时的定时器，当这个定时器到期时，将切换到candidate状态发起选举。</li><li>times out, new election：进入candidate 状态之后就开始进行选举，但是如果在下一次选举超时到来之前，都还没有选出一个新的leade，那么还会保持在candidate状态重新开始一次新的选举。</li><li>receives votes from majority of servers：当candidate状态的节点，收到了超过半数的节点选票，那么将切换状态成为新的leader。</li><li>discovers current leader or new term：candidate状态的节点，如果收到了来自leader的消息，或者更高任期号的消息，都表示已经有leader了，将切换回到follower状态。</li><li>discovers server with higher term：leader状态下如果收到来自更高任期号的消息，将切换到follower状态。这种情况大多数发生在有网络分区的状态下。</li></ol><p>如果一个candidate在一次选举中赢得leader，那么这个节点将在这个任期中担任leader的角色。但并不是每个任期号都一定对应有一个leader的，比如上面的情况3中，可能在选举超时到来之前都没有产生一个新的leader，那么此时将递增任期号开始一次新的选举。</p><p>从以上的描述可以看出，任期号在raft算法中更像一个“逻辑时钟（logic clock）”的作用，有了这个值，集群可以发现有哪些节点的状态已经过期了。每一个节点状态中都保存一个当前任期号（current term），节点在进行通信时都会带上本节点的当前任期号。如果一个节点的当前任期号小于其他节点的当前任期号，将更新其当前任期号到最新的任期号。如果一个candidate或者leader状态的节点发现自己的当前任期号已经小于其他节点了，那么将切换到follower状态。反之，如果一个节点收到的消息中带上的发送者的任期号已经过期，将拒绝这个请求。</p><p>raft节点之间通过RPC请求来互相通信，主要有以下两类RPC请求。RequestVote RPC用于candidate状态的节点进行选举之用，而AppendEntries RPC由leader节点向其他节点复制日志数据以及同步心跳数据的。</p><h2 id="leader选举"><a href="#leader选举" class="headerlink" title="leader选举"></a>leader选举</h2><p>现在来讲解leader选举的流程。</p><p>raft算法是使用心跳机制来触发leader选举的。</p><p>在节点刚开始启动时，初始状态是follower状态。一个follower状态的节点，只要一直收到来自leader或者candidate的正确RPC消息的话，将一直保持在follower状态。leader节点通过周期性的发送心跳请求（一般使用带有空数据的AppendEntries RPC来进行心跳）来维持着leader节点状态。每个follower同时还有一个选举超时（election timeout）定时器，如果在这个定时器超时之前都没有收到来自leader的心跳请求，那么follower将认为当前集群中没有leader了，将发起一次新的选举。</p><p>发起选举时，follower将递增它的任期号然后切换到candidate状态。然后通过向集群中其它节点发送RequestVote RPC请求来发起一次新的选举。一个节点将保持在该任期内的candidate状态下，直到以下情况之一发生。</p><ul><li>该candidate节点赢得选举，即收到超过半数以上集群中其它节点的投票。</li><li>另一个节点成为了leader。</li><li>选举超时到来时没有任何一个节点成为leader。</li></ul><p>下面来逐个分析以上几种情况。</p><p>第一种情况，如果收到了集群中半数以上节点的投票，那么此时candidate节点将成为新的leader。每个节点在一个任期中只能给一个节点投票，而且遵守“先来后到”的原则。这样就保证了，每个任期最多只有一个节点会赢得选举成为leader。但并不是每个进行选举的candidate节点都会给它投票，在后续的“选举安全性”一节中将展开讨论这个问题。当一个candidate节点赢得选举成为leader后，它将发送心跳消息给其他节点来宣告它的权威性以阻止其它节点再发起新的选举。</p><p>第二种情况，当candidate节点等待其他节点时，如果收到了来自其它节点的AppendEntries RPC请求，同时做个请求中带上的任期号不比candidate节点的小，那么说明集群中已经存在leader了，此时candidate节点将切换到follower状态；但是，如果该RPC请求的任期号比candidate节点的小，那么将拒绝该RPC请求继续保持在candidate状态。</p><p>第三种情况，一个candidate节点在选举超时到来的时候，既没有赢得也没有输掉这次选举。这种情况发生在集群节点数量为偶数个，同时有两个candidate节点进行选举，而两个节点获得的选票数量都是一样时。当选举超时到来时，如果集群中还没有一个leader存在，那么candidate节点将继续递增任期号再次发起一次新的选举。这种情况理论上可以一直无限发生下去。</p><p>为了减少第三种情况发生的概率，每个节点的选举超时时间都是随机决定的，一般在150~300毫秒之间，这样两个节点同时超时的情况就很罕见了。</p><p>以上过程用伪代码来表示如下。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">节点刚启动，进入follower状态，同时创建一个超时时间在<span class="number">150</span><span class="number">-300</span>毫秒之间的选举超时定时器。</span><br><span class="line">follower状态节点主循环：</span><br><span class="line">  如果收到leader节点心跳：</span><br><span class="line">    心跳标志位置<span class="number">1</span></span><br><span class="line">  如果选举超时到期：</span><br><span class="line">    没有收到leader节点心跳：</span><br><span class="line">      任期号term+<span class="number">1</span>，换到candidate状态。</span><br><span class="line">    如果收到leader节点心跳：</span><br><span class="line">      心跳标志位置空</span><br><span class="line">  如果收到选举消息：</span><br><span class="line">    如果当前没有给任何节点投票过 或者 消息的任期号大于当前任期号：</span><br><span class="line">      投票给该节点</span><br><span class="line">    否则：</span><br><span class="line">      拒绝投票给该节点</span><br><span class="line">candidate状态节点主循环：</span><br><span class="line">  向集群中其他节点发送RequestVote请求，请求中带上当前任期号term</span><br><span class="line">  收到AppendEntries消息：</span><br><span class="line">    如果该消息的任期号 &gt;= 本节点任期号term：</span><br><span class="line">      说明已经有leader，切换到follower状态</span><br><span class="line">    否则：</span><br><span class="line">      拒绝该消息</span><br><span class="line">  收到其他节点应答RequestVote消息：</span><br><span class="line">    如果数量超过集群半数以上，切换到leader状态</span><br><span class="line">    </span><br><span class="line">  如果选举超时到期：</span><br><span class="line">    term+<span class="number">1</span>，进行下一次的选举</span><br></pre></td></tr></table></figure><h2 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h2><p>日志复制的流程大体如下：</p><ol><li>每个客户端的请求都会被重定向发送给leader，这些请求最后都会被输入到raft算法状态机中去执行。</li><li>leader在收到这些请求之后，会首先在自己的日志中添加一条新的日志条目。</li><li>在本地添加完日志之后，leader将向集群中其他节点发送AppendEntries RPC请求同步这个日志条目，当这个日志条目被成功复制之后（什么是成功复制，下面会谈到），leader节点将会将这条日志输入到raft状态机中，然后应答客户端。</li></ol><p>Raft日志的组织形式如下图所示。</p><p><img src="2.jpg" alt></p><p>每个日志条目包含以下成员。</p><ol><li>index：日志索引号，即图中最上方的数字，是严格递增的。</li><li>term：日志任期号，就是在每个日志条目中上方的数字，表示这条日志在哪个任期生成的。</li><li>command：日志条目中对数据进行修改的操作。</li></ol><p>一条日志如果被leader同步到集群中超过半数的节点，那么被称为“成功复制”，这个日志条目就是“已被提交（committed）”。如果一条日志已被提交，那么在这条日志之前的所有日志条目也是被提交的，包括之前其他任期内的leader提交的日志。如上图中索引为7的日志条目之前的所有日志都是已被提交的日志。</p><p>以下面的图示来说明日志复制的流程。</p><p><img src="3.jpg" alt></p><ul><li><ol><li>客户端发送SET a=1的命令到leader节点上。</li></ol></li><li><ol start="2"><li>leader节点在本地添加一条日志，其对应的命令为SET a=1。这里涉及到两个索引值，committedIndex存储的最后一条提交（commit）日志的索引，appliedIndex存储的是最后一条应用到状态机中的日志索引值，一条日志只有被提交了才能应用到状态机中，因此总有 committedIndex &gt;= appliedIndex不等式成立。在这里只是添加一条日志还并没有提交，两个索引值还指向上一条日志。</li></ol></li><li><ol start="3"><li>leader节点向集群中其他节点广播AppendEntries消息，带上SET a=1命令。</li></ol></li></ul><p><img src="4.jpg" alt></p><ul><li><ol start="4"><li>收到AppendEntries请求的follower节点，同样在本地添加了一条新的日志，也还并没有提交。</li></ol></li><li><ol start="5"><li>follower节点向leader节点应答AppendEntries消息。</li></ol></li><li><ol start="6"><li>当leader节点收到集群半数以上节点的AppendEntries请求的应答消息时，认为SET a=1命令成功复制，可以进行提交，于是修改了本地committed日志的索引指向最新的存储SET a=1的日志，而appliedIndex还是保持着上一次的值，因为还没有应用该命令到状态机中。</li></ol></li></ul><p><img src="5.jpg" alt></p><ul><li><ol start="7"><li>提交命令完成，给应用层说明这条命令已经提交。此时修改appliedIndex与committedIndex一样了。</li></ol></li><li><ol start="8"><li>leader节点在下一次给follower的AppendEntries请求中，会带上当前最新的committedIndex索引值，follower收到之后同样会修改本地日志的committedIndex索引。</li></ol></li></ul><p>需要说明的是，7和8这两个操作并没有严格的先后顺序，谁在前在后都没关系。</p><p>leader上保存着已被提交的最大日志索引信息，在每次向follower节点发送的AppendEntries RPC请求中都会带上这个索引信息，这样follower节点就知道哪个日志已经被提交了，被提交的日志将会输入Raft状态机中执行。</p><p>Raft算法保持着以下两个属性，这两个属性共同作用满足前面提到的日志匹配（LogMatch）属性：</p><ul><li>如果两个日志条目有相同的索引号和任期号，那么这两条日志存储的是同一个指令。</li><li>如果在两个不同的日志数据中，包含有相同索引和任期号的日志条目，那么在这两个不同的日志中，位于这条日志之前的日志数据是相同的。</li></ul><p>在正常的情况下，follower节点和leader节点的日志一直保持一致，此时AppendEntries RPC请求将不会失败。但是，当leader节点宕机时日志就可能出现不一致的情况，比如在这个leader节点宕机之前同步的数据并没有得到超过半数以上节点都复制成功了。如下图所示就是一种出现前后日志不一致的情况。</p><p><img src="6.jpg" alt></p><p>在上图中，最上面的一排数字是日志的索引，盒子中的数据是该日志对应的任期号，左边的字母表示的是a-f这几个不同的节点。图中演示了好几种节点日志与leader节点日志不一致的情况，下面说明中以二元组&lt;任期号，索引号&gt;来说明各个节点的日志数据情况：</p><ul><li>leader节点：&lt;6, 10&gt;。</li><li>a节点：&lt;6,9&gt;，缺少日志。</li><li>b节点：&lt;4,4&gt;，任期号比leader小，因此缺少日志。</li><li>c节点：&lt;6,11&gt;，任期号与leader相同，但是有比leader日志索引更大的日志，这部分日志是未提交的日志。</li><li>d节点：&lt;7,12&gt;，任期号比leader大，这部分日志是未提交的日志。</li><li>e节点：&lt;4,7&gt;，任期号与索引都比leader小，因此既缺少日志，也有未提交的日志。</li><li>f节点：&lt;3,11&gt;，任期号比leader小，所以缺少日志，而索引比leader大，这部分日志又是未提交的日志。</li></ul><p>在Raft算法中，解决日志数据不一致的方式是Leader节点同步日志数据到follower上，覆盖follower上与leader不一致的数据。</p><p>为了解决与follower节点同步日志的问题，leader节点中存储着两个与每个follower节点日志相关的数据。</p><ul><li>nextIndex存储的是下一次给该节点同步日志时的日志索引。</li><li>matchIndex存储的是该节点的最大日志索引。</li></ul><p>从以上两个索引的定义可知，在follower与leader节点之间日志复制正常的情况下，nextIndex = matchIndex + 1。但是如果出现不一致的情况，则这个等式可能不成立。每个leader节点被选举出来时，将初始化nextIndex为leader节点最后一条日志，而matchIndex为0，这么做的原因在于：leader节点将从后往前探索follower节点当前存储的日志位置，而在不知道follower节点日志位置的情况下只能置空matchIndex了。</p><p>leader节点通过AppendEntries消息来与follower之间进行日志同步的，每次给follower带过去的日志就是以nextIndex来决定，如果follower节点的日志与这个值匹配，将返回成功；否则将返回失败，同时带上本节点当前的最大日志ID，方便leader节点快速定位到follower的日志位置以下一次同步正确的日志数据，而leader节点在收到返回失败的情况下，将置nextIndex = matchIndex + 1。从上面的分析可知，在leader当前之后第一次向follower同步日志失败时，nextIndex = matchIndex + 1 = 1。</p><p>以上图的几个节点为例来说明情况。</p><ul><li>初始状态下，leader节点将存储每个folower节点的nextIndex为10，matchIndex为0。因此在成为leader节点之后首次向follower节点同步日志数据时，将复制索引位置在10以后的日志数据，同时带上日志二元组&lt;6,10&gt;告知follower节点当前leader保存的follower日志状态。</li><li>a节点：由于节点的最大日志数据二元组是&lt;6,9&gt;，正好与leader发过来的日志&lt;6,10&gt;紧挨着，因此返回复制成功。</li><li>b节点：由于节点的最大日志数据二元组是&lt;4,4&gt;，与leader发送过来的日志数据&lt;6,10&gt;不匹配，将返回失败同时带上自己最后的日志索引4，leader节点在收到该拒绝消息之后，将修改保存该节点的nextIndex为matchIndex + 1即1，所以下一次leader节点将同步从索引1到10的数据给b节点。</li><li>c节点：由于节点的最大日志数据二元组是&lt;6,11&gt;，与leader发送过来的日志数据&lt;6,10&gt;不匹配，将返回失败同时带上自己最后的日志索 引11，leader节点在收到该拒绝消息之后，将修改保存该节点的nextIndex为matchIndex + 1即1，所以下一次leader节点将同步从索引1到10的数据给c节点，由于c节点上有未提交的数据，所以在第二次与leader同步完成之后，这些未提交的数据被清除。</li><li>d节点：由于节点的最大日志数据二元组是&lt;7,12&gt;，与leader发送过来的日志数据&lt;6,10&gt;不匹配，将返回失败同时带上自己最后的日志索 引11，leader节点在收到该拒绝消息之后，将修改保存该节点的nextIndex为matchIndex + 1即1，所以下一次leader节点将同步从索引1到10的数据给d节点，由于d节点上有未提交的数据，所以在第二次与leader同步完成之后，这些未提交的数据被清除。</li><li>e节点：由于节点的最大日志数据二元组是&lt;4,7&gt;，与leader发送过来的日志数据&lt;6,10&gt;不匹配，将返回失败同时带上自己最后的日志索 引11，leader节点在收到该拒绝消息之后，将修改保存该节点的nextIndex为matchIndex + 1即1，所以下一次leader节点将同步从索引1到10的数据给e节点，由于e节点上缺少的日志数据将被补齐，而多出来的未提交数据将被清除。</li><li>f节点：由于节点的最大日志数据二元组是&lt;4,7&gt;，与leader发送过来的日志数据&lt;6,10&gt;不匹配，将返回失败同时带上自己最后的日志索 引11，leader节点在收到该拒绝消息之后，将修改保存该节点的nextIndex为matchIndex + 1即1，所以下一次leader节点将同步从索引1到10的数据给f节点，由于f节点上缺少的日志数据将被补齐，而多出来的未提交数据将被清除。</li></ul><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>前面章节已经将leader选举以及日志同步的机制介绍了，这一小节讲解安全性相关的内容。</p><h3 id="选举限制"><a href="#选举限制" class="headerlink" title="选举限制"></a>选举限制</h3><p>raft算法中，并不是所有节点都能成为leader。一个节点要成为leader，需要得到集群中半数以上节点的投票，而一个节点会投票给一个节点，其中一个充分条件是：这个进行选举的节点的日志，比本节点的日志更新。之所以要求这个条件，是为了保证每个当选的节点都有当前最新的数据。为了达到这个检查日志的目的，RequestVote RPC请求中需要带上参加选举节点的日志信息，如果节点发现选举节点的日志信息并不比自己更新，将拒绝给这个节点投票。</p><p>如果判断日志的新旧？这通过对比日志的最后一个日志条目数据来决定，首先将对比条目的任期号，任期号更大的日志数据更新；如果任期号相同，那么索引号更大的数据更新。</p><p>以上处理RequestVote请求的流程伪代码表示如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">follower节点收到RequestVote请求：  对比RequestVote请求中带上的最后一条日志数据：    如果任期号比节点的最后一条数据任期号小：      拒绝投票给该节点    如果索引号比节点的最后一条数据索引小：      拒绝投票给该节点    其他情况：      说明选举节点的日志信息比本节点更新，投票给该节点。</span><br></pre></td></tr></table></figure><h3 id="提交前面任期的日志条目"><a href="#提交前面任期的日志条目" class="headerlink" title="提交前面任期的日志条目"></a>提交前面任期的日志条目</h3><p>如果leader在写入但是还没有提交一条日志之前崩溃，那么这条没有提交的日志是否能提交？有几种情况需要考虑，如下图所示。</p><p><img src="7.jpg" alt></p><p>在上图中，有以下的场景变更。</p><ul><li>情况a：s1是leader，index 2位置写入了数据2，该值只写在了s1，s2上，但是还没有被提交。</li><li>情况b: s1崩溃，s5成为新的leader，该节点在index 2上面提交了另外一个值3，但是这个值只写在了s5上面，并没有被提交。</li><li>情况c: s5崩溃，s1重新成为leader，这一次，index 2的值2写到了集群的大多数节点上。</li></ul><p>此时可能存在以下两种情况：</p><ul><li>情况d1: s1崩溃，s5重新成为leader（投票给s5的是s4，s2和s5自身），那么index 2上的值3这一次成功的写入到集群的半数以上节点之上，并成功提交。</li><li>情况d2: s1不崩溃，而是将index 2为2的值成功提交。</li></ul><p>从情况d的两种场景可以看出，在index 2值为2，且已经被写入到半数以上节点的情况下，同样存在被新的leader覆盖的可能性。</p><p>由于以上的原因，对于当前任期之前任期提交的日志，并不通过判断是否已经在半数以上集群节点写入成功来作为能否提交的依据。只有当前leader任期内的日志是通过比较写入数量是否超过半数来决定是否可以提交的。</p><p>对于任期之前的日志，Raft采用的方式，是只要提交成功了当前任期的日志，那么在日志之前的日志就认为提交成功了。这也是为什么etcd-Raft代码中，在成为leader之后，需要再提交一条dummy的日志的原因–只要该日志提交成功，leader上该日志之前的日志就可以提交成功。</p><h1 id="集群成员变更"><a href="#集群成员变更" class="headerlink" title="集群成员变更"></a>集群成员变更</h1><p>在上面描述Raft基本算法流程中，都假设集群中的节点是稳定不变的。但是在某些情况下，需要手动改变集群的配置。</p><h2 id="安全性-1"><a href="#安全性-1" class="headerlink" title="安全性"></a>安全性</h2><p>安全性是变更集群成员时首先需要考虑到的问题，任何时候都不能出现集群中存在一个以上leader的情况。为了避免出现这种情况，每次变更成员时不能一次添加或者修改超过一个节点，集群不能直接切换到新的状态，如下图所示。</p><p><img src="8.jpg" alt></p><p>在上图中，server 1、2、3组成的是旧集群，server 4、5是准备新加入集群的节点。注意到如果直接尝试切换到新的状态，在某些时间点里，如图中所示，由于server 1、2上的配置还是旧的集群配置，那么可能这两个节点已经选定了一个leader；而server 3、4、5又是新的配置，它们也可能选定了一个leader，而这两个leader不是同一个，这就出现了集群中存在一个以上leader的情况了。</p><p>反之，下图所示是分别往奇数个以及偶数个集群节点中添加删除单个节点的场景。</p><p><img src="9.jpg" alt></p><p>可以看到，不论旧集群节点数量是奇数还是偶数个，都不会出现同时有两个超过半数以上子集群的存在，也就不可能选出超过一个leader。</p><p>raft采用将修改集群配置的命令放在日志条目中来处理，这样做的好处是：</p><ul><li>可以继续沿用原来的AppendEntries命令来同步日志数据，只要把修改集群的命令做为一种特殊的命令就可以了。</li><li>在这个过程中，可以继续处理客户端请求。</li></ul><h2 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h2><h3 id="添加新节点到集群中"><a href="#添加新节点到集群中" class="headerlink" title="添加新节点到集群中"></a>添加新节点到集群中</h3><p>添加一个新的节点到集群时，需要考虑一种情况，即新节点可能落后当前集群日志很多的情况，在这种情况下集群出现故障的概率会大大提高，如下图所示。</p><p><img src="10.jpg" alt></p><p>上图中的情况a中，s1、s2、s3是原有的集群节点，这时把节点s4添加进来，而s4上又什么数据都没有。如果此时s3发生故障，在集群中原来有三个节点的情况下，本来可以容忍一个节点的失败的；但是当变成四个节点的集群时，s3和s4同时不可用整个集群就不可用了。</p><p>因此Raft算法针对这种新添加进来的节点，是如下处理的。</p><ul><li>添加进来的新节点首先将不加入到集群中，而是等待数据追上集群的进度。</li><li>leader同步数据给新节点的流程是，划分为多个轮次，每一轮同步一部分数据，而在同步的时候，leader仍然可以写入新的数据，只要等新的轮次到来继续同步就好。</li></ul><p>以下图来说明同步数据的流程。</p><p><img src="11.jpg" alt></p><p>如上图中，划分为多个轮次来同步数据。比如，在第一轮同步数据时，leader的最大数据索引为10，那么第一轮就同步10之前的数据。而在同步第一轮数据的同时，leader还能继续接收新的数据，假设当同步第一轮完毕时，最大数据索引变成了20，那么第二轮将继续同步从10到20的数据。以此类推。</p><p>这个同步的轮次并不能一直持续下去，一般会有一个限制的轮次数量，比如最多同步10轮。</p><h3 id="删除当前集群的leader节点"><a href="#删除当前集群的leader节点" class="headerlink" title="删除当前集群的leader节点"></a>删除当前集群的leader节点</h3><p>当需要下线当前集群的leader节点时，leader节点将发出一个变更节点配置的命令，只有在该命令被提交之后，原先的leader节点才下线，然后集群会自然有一个节点选举超时而进行新的一轮选举。</p><h3 id="处理移出集群的节点"><a href="#处理移出集群的节点" class="headerlink" title="处理移出集群的节点"></a>处理移出集群的节点</h3><p>如果某个节点在一次配置更新之后，被移出了新的集群，但是这个节点又不知道这个情况，那么按照前面描述的Raft算法流程来说，它应该在选举超时之后，将任期号递增1，发起一次新的选举。虽然最终这个节点不会赢得选举，但是毕竟对集群运行的状态造成了干扰。而且如果这个节点一直不下线，那么上面这个发起新选举的流程就会一直持续下去。</p><p>为了解决这个问题，Raft引入了一个成为“PreVote”的流程，在这个流程中，如果一个节点要发起一次新的选举，那么首先会广播给集群中的其它所有节点，询问下当前该节点上的日志是否足以赢下选举。只有在这个PreVote阶段赢得超过半数节点肯定的情况下，才真正发起一次新的选举。</p><p>然而，PreVote并不能解决所有的问题，因为很有可能该被移除节点上的日志也是最新的。</p><p>由于以上的原因，所以不能完全依靠判断日志的方式来决定是否允许一个节点发起新一轮的选举。</p><p>Raft采用了另一种机制。如果leader节点一直保持着与其它节点的心跳消息，那么就认为leader节点是存活的，此时不允许发起一轮新的选举。这样follower节点处理RequestVote请求时，就需要加上判断，除了判断请求进行选举的节点日志是否最新以外，如果当前在一段时间内还收到过来自leader节点的心跳消息，那么也不允许发起新的选举。然而这种情况与前面描述的leader迁移的情况相悖，在leader迁移时是强制要求发起新的选举的，因此RequestVote请求的处理还要加上这种情况的判断。</p><p>总结来说，RequestVote请求的处理逻辑大致是这样的。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">follower处理RequestVote请求：</span><br><span class="line">  如果请求节点的日志不是最新的：</span><br><span class="line">    拒绝该请求，返回</span><br><span class="line">  如果此时是<span class="built_in">leader</span>迁移的情况：</span><br><span class="line">    接收该请求，返回</span><br><span class="line">  如果最近一段时间还有收到来自<span class="built_in">leader</span>节点的心跳消息：</span><br><span class="line">    拒绝该请求，返回</span><br><span class="line">  接收该请求</span><br></pre></td></tr></table></figure><h1 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h1><p>日志数据如果不进行压缩处理掉的话，会一直增长下去。为此Raft使用快照数据来进行日志压缩，比如针对键值a的几次操作日志a=1、删除a、a=3最后可以被压缩成为最后的结果数据即a=3。</p><p>快照数据和日志数据的组织形式如下图。</p><p><img src="12.jpg" alt></p><p>在上图中：</p><ul><li>未压缩日志前，日志数据保存到了&lt;3,5&gt;的位置，而在&lt;2,3&gt;的位置之前的数据都已经进行提交了，所以可以针对这部分数据进行压缩。</li><li>压缩日志之后，快照文件中存放了几个值：压缩时最后一条日志的二元数据是&lt;2,3&gt;，而针对a的几次操作最后的值为a=3，b的值为2。</li></ul><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="高效处理只读请求"><a href="#高效处理只读请求" class="headerlink" title="高效处理只读请求"></a>高效处理只读请求</h2><p>前面已经提到过，处理一个命令时，需要经历以下流程：leader向集群中其它节点广播日志，在日志被超过半数节点应答之后，leader提交该日志，最后才应答客户端。这样的流程对于一个只读请求而言太久了，而且还涉及到日志落盘的操作，对于只读请求而言这些操作是不必要的。</p><p>但是如果不经过上面的流程，leader节点在收到一个只读请求时就直接将本节点上保存的数据应答客户端，也是不安全的，因为这可能返回已经过期的数据。一方面leader节点可能已经发生了变化，只是这个节点并不知道；另一方面可能数据也发生了改变。返回过期的数据不符合一致性要求，因此这样的做法也是不允许的。</p><p>Raft中针对只读请求是这样做处理的。</p><ol><li>leader节点需要有当前已提交日志的信息。在前面提到过不能提交前面任期的日志条目，因此一个新leader产生之后，需要提交一条空日志，这样来确保上一个任期内的日志全部提交。</li><li>leader节点保存该只读请求到来时的commit日志索引为readIndex，</li><li>leader需要确认自己当前还是集群的leader，因为可能会由于有网络分区的原因导致leader已经被隔离出集群而不自知。为了达到这个目的，leader节点将广播一个heartbeat心跳消息给集群中其它节点，当收到半数以上节点的应答时，leader节点知道自己当前还是leader，同时readIndex索引也是当前集群日志提交的最大索引。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://www.codedump.info/post/20180921-raft/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Raft算法原理&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;关于Raft算法，有两篇经典的论文，一篇是《In search of an Understandable Consensus Algorithm》，这是作者最开始讲述Raft算法原理的论文，但是这篇论文太简单了，很多算法的细节没有涉及到。更详细的论文是《CONSENSUS: BRIDGING THEORY AND PRACTICE》，除了包括第一篇论文的内容以外，还加上了很多细节的描述。在我阅读完etcd raft算法库的实现之后，发现这个库的代码基本就是按照后一篇论文来写的，甚至有部分测试用例的注释里也写明了是针对这篇论文的某一个小节的情况做验证。&lt;/p&gt;
&lt;p&gt;这篇文章做为我后续分析etcd raft算法的前导文章，将结合后一篇论文加上一些自己的演绎和理解来讲解Raft算法的原理。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式" scheme="http://changsk.top/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="Raft" scheme="http://changsk.top/tags/Raft/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-215:Kth Largest Element in an Array(数组中第K大的数)</title>
    <link href="http://changsk.top/2019/07/24/leetcode-215/"/>
    <id>http://changsk.top/2019/07/24/leetcode-215/</id>
    <published>2019-07-24T10:03:01.000Z</published>
    <updated>2019-07-24T13:15:42.688Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">https://leetcode.com/problems/kth-largest-element-in-an-array/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>题目难度：Medium</p></blockquote><p>Find the <strong>k</strong>th largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p><p><strong>Example 1:</strong></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>] <span class="keyword">and</span> k = <span class="number">2</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>] <span class="keyword">and</span> k = <span class="number">4</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p>最大堆实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> heapSort(nums, k);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (array.length) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapAdjust(array, i, array.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调整堆,将最大的节点放在堆尾，然后从根节点重新调整</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length - <span class="number">1</span>; i &gt; array.length - k; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[<span class="number">0</span>];</span><br><span class="line">        array[<span class="number">0</span>] = array[i];</span><br><span class="line">        array[i] = temp;</span><br><span class="line">        heapAdjust(array, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapAdjust</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> s, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp, i;</span><br><span class="line">temp = array[s];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span> * s; i &lt; len; i *= <span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(i &lt; len - <span class="number">1</span> &amp;&amp; array[i] &lt; array[i + <span class="number">1</span>])</span><br><span class="line">            ++i;</span><br><span class="line">        <span class="keyword">if</span>(temp &gt;= array[i]) <span class="keyword">break</span>;</span><br><span class="line">        array[s] = array[i];</span><br><span class="line">        s = i;</span><br><span class="line">    &#125;</span><br><span class="line">    array[s] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><p>快速排序实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> quickSort(nums, k , <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[start];</span><br><span class="line">        <span class="keyword">int</span> low = start, high = end;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[high] &gt;= tmp) high--;</span><br><span class="line">            <span class="keyword">if</span>(low &lt; high) nums[low] = nums[high];</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[low] &lt;= tmp) low++;</span><br><span class="line">            <span class="keyword">if</span>(low &lt; high) nums[high] = nums[low];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[low] = tmp;</span><br><span class="line">        <span class="keyword">if</span>(low == nums.length - k) <span class="keyword">return</span> tmp;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(low &lt; nums.length - k) <span class="keyword">return</span> quickSort(nums, k, low + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> quickSort(nums, k, start, low - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Solution3"><a href="#Solution3" class="headerlink" title="Solution3"></a>Solution3</h2><p>用<code>JDK</code>中的优先级队列<code>PriorityQueue</code>实现.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">                PriorityQueue&lt;Integer&gt; largeK = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(k + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> el : nums) &#123;</span><br><span class="line">                    largeK.add(el);</span><br><span class="line">                    <span class="keyword">if</span> (largeK.size() &gt; k) &#123;</span><br><span class="line">                        largeK.poll();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> largeK.poll();</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/kth-largest-element-in-an-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/kth-largest-element-in-an-array/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-199:Binary Tree Right Side View</title>
    <link href="http://changsk.top/2019/07/23/leetcode-199/"/>
    <id>http://changsk.top/2019/07/23/leetcode-199/</id>
    <published>2019-07-23T13:26:10.000Z</published>
    <updated>2019-07-23T13:41:20.513Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-right-side-view/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>题目难度：Medium</p></blockquote><p>Given a binary tree, imagine yourself standing on the <em>right</em>side of it, return the values of the nodes you can see ordered from top to bottom.</p><p><strong>Example:</strong></p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Input</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,null,<span class="number">5</span>,null,<span class="number">4</span>]</span><br><span class="line"><span class="type">Output</span>: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="type">Explanation</span>:</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>            &lt;-<span class="comment">--</span></span><br><span class="line"> /   \</span><br><span class="line"><span class="number">2</span>     <span class="number">3</span>         &lt;-<span class="comment">--</span></span><br><span class="line"> \     \</span><br><span class="line">  <span class="number">5</span>     <span class="number">4</span>       &lt;-<span class="comment">--</span></span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; resList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> resList;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        TreeNode curNode;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            curNode = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(curNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(curNode.left);</span><br><span class="line">                next++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(curNode.right);</span><br><span class="line">                next++;</span><br><span class="line">            &#125;</span><br><span class="line">            cur++;</span><br><span class="line">            <span class="keyword">if</span>(cur == num)&#123;</span><br><span class="line">                resList.add(curNode.val);</span><br><span class="line">                cur = <span class="number">0</span>;</span><br><span class="line">                num = next;</span><br><span class="line">                next = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/binary-tree-right-side-view/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/binary-tree-right-side-view/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-114:Flatten Binary Tree to Linked List</title>
    <link href="http://changsk.top/2019/07/23/leetcode-114/"/>
    <id>http://changsk.top/2019/07/23/leetcode-114/</id>
    <published>2019-07-23T13:00:26.000Z</published>
    <updated>2019-07-23T13:05:41.034Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/flatten-binary-tree-to-linked-list/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>题目难度: Medium</p></blockquote><p>Given a binary tree, flatten it to a linked list in-place.</p><p>For example, given the following tree:</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">5</span></span><br><span class="line"> / \   \</span><br><span class="line"><span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure><p>The flattened tree should look like:</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">2</span></span><br><span class="line">   \</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">     \</span><br><span class="line">      <span class="number">4</span></span><br><span class="line">       \</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">         \</span><br><span class="line">          <span class="number">6</span></span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode prev = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    flatten(root.right);</span><br><span class="line">    flatten(root.left);</span><br><span class="line">    root.right = prev;</span><br><span class="line">    root.left = <span class="keyword">null</span>;</span><br><span class="line">    prev = root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/flatten-binary-tree-to-linked-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/flatten-binary-tree-to-linked-list/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Linux下各种查找命令（find, grep, which, whereis, locate）</title>
    <link href="http://changsk.top/2019/07/23/linux-find/"/>
    <id>http://changsk.top/2019/07/23/linux-find/</id>
    <published>2019-07-23T02:22:13.000Z</published>
    <updated>2019-07-23T02:49:31.868Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://blog.csdn.net/wzzfeitian/article/details/40985549" target="_blank" rel="noopener">Linux下各种查找命令（find, grep, which, whereis, locate）</a></p></blockquote><a id="more"></a><h2 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h2><blockquote><p>find &lt; path &gt; &lt; expression &gt; &lt; cmd &gt;</p></blockquote><ul><li>path： 所要搜索的目录及其所有子目录。默认为当前目录。</li><li>expression： 所要搜索的文件的特征。</li><li>cmd： 对搜索结果进行特定的处理。</li></ul><p>如果什么参数也不加，find默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。</p><h3 id="find命令常用选项及实例"><a href="#find命令常用选项及实例" class="headerlink" title="find命令常用选项及实例"></a>find命令常用选项及实例</h3><ul><li>-name 按照文件名查找文件。<ol><li>find /dir -name filename  在/dir目录及其子目录下面查找名字为filename的文件</li><li>find . -name “*.c” 在当前目录及其子目录（用“.”表示）中查找任何扩展名为“c”的文件</li></ol></li><li>-perm 按照文件权限来查找文件。</li></ul><ol><li>find . -perm 755 –print 在当前目录下查找文件权限位为755的文件，即文件属主可以读、写、执行，其他用户可以读、执行的文件</li></ol><ul><li>-prune 使用这一选项可以使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略。</li></ul><ol><li>find /apps -path “/apps/bin” -prune -o –print 在/apps目录下查找文件，但不希望在/apps/bin目录下查找</li><li>find /usr/sam -path “/usr/sam/dir1” -prune -o –print 在/usr/sam目录下查找不在dir1子目录之内的所有文件</li></ol><ul><li>-depth：在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找。</li></ul><ol><li>find / -name “CON.FILE” -depth –print 它将首先匹配所有的文件然后再进入子目录中查找</li></ol><ul><li>-user 按照文件属主来查找文件。</li></ul><ol><li>find ~ -user sam –print 在$HOME目录中查找文件属主为sam的文件</li></ol><ul><li>-group 按照文件所属的组来查找文件。</li></ul><ol><li>find /apps -group gem –print 在/apps目录下查找属于gem用户组的文件</li></ol><ul><li>-mtime -n +n 按照文件的更改时间来查找文件， -n表示文件更改时间距现在n天以内，+n表示文件更改时间距现在n天以前。</li></ul><ol><li>find / -mtime -5 –print 在系统根目录下查找更改时间在5日以内的文件</li><li>find /var/adm -mtime +3 –print 在/var/adm目录下查找更改时间在3日以前的文件</li></ol><ul><li>-nogroup 查找无有效所属组的文件，即该文件所属的组在/etc/groups中不存在。</li></ul><ol><li>find / –nogroup -print</li></ol><ul><li>-nouser 查找无有效属主的文件，即该文件的属主在/etc/passwd中不存在。</li></ul><ol><li>find /home -nouser –print</li></ol><ul><li>-newer file1 ! file2 查找更改时间比文件file1新但比文件file2旧的文件。</li><li>-type 查找某一类型的文件，<br>诸如：<br>b - 块设备文件。<br>d - 目录。<br>c - 字符设备文件。<br>p - 管道文件。<br>l - 符号链接文件。<br>f - 普通文件。</li></ul><ol><li>find /etc -type d –print 在/etc目录下查找所有的目录</li><li>find . ! -type d –print 在当前目录下查找除目录以外的所有类型的文件</li><li>find /etc -type l –print 在/etc目录下查找所有的符号链接文件</li></ol><ul><li>-size n[c] 查找文件长度为n块的文件，带有c时表示文件长度以字节计。</li></ul><ol><li>find . -size +1000000c –print 在当前目录下查找文件长度大于1 M字节的文件</li><li>find /home/apache -size 100c –print 在/home/apache目录下查找文件长度恰好为100字节的文件</li><li>find . -size +10 –print 在当前目录下查找长度超过10块的文件（一块等于512字节）</li></ol><ul><li>-mount：在查找文件时不跨越文件系统mount点。</li></ul><ol><li>find . -name “*.XC” -mount –print 从当前目录开始查找位于本文件系统中文件名以XC结尾的文件（不进入其他文件系统）</li></ol><ul><li>-follow：如果find命令遇到符号链接文件，就跟踪至链接所指向的文件</li><li>-exec，find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为’command’ {} ;，注意{}和;之间的空格</li></ul><ol><li>$ find ./ -size 0 -exec rm {} ; 删除文件大小为零的文件</li><li>$ rm -i <code>find ./ -size 0</code>  </li><li>$ find ./ -size 0 | xargs rm -f &amp;</li></ol><p>为了用ls -l命令列出所匹配到的文件，可以把ls -l命令放在find命令的-exec选项中：</p><ol start="4"><li>$ find . -type f -exec ls -l {} ;<br>在/logs目录中查找更改时间在5日以前的文件并删除它们：</li><li>find /logs -type f -mtime +5 -exec rm {} ;</li></ol><ul><li>-ok，和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。</li></ul><ol><li>find . -name “*.conf”  -mtime +5 -ok rm {  } ; 在当前目录中查找所有文件名以.LOG结尾、更改时间在5日以上的文件，并删除它们，只不过在删除之前先给出提示<blockquote><p>说明： 如果你要寻找一个档案的话，那么使用 find 会是一个不错的主意。不过，由于 find 在寻找数据的时候相当的耗硬盘，所以没事情不要使用 find 啦！有更棒的指令可以取代呦，那就是 whereis 与 locate 咯~</p></blockquote></li></ol><h3 id="一些常用命令"><a href="#一些常用命令" class="headerlink" title="一些常用命令"></a>一些常用命令</h3><ol><li>find . -type f -exec ls -l {} ;<br>查找当前路径下的所有普通文件，并把它们列出来。</li><li>find logs -type f -mtime +5 -exec rm {} ;<br>删除logs目录下更新时间为5日以上的文件。</li><li>find . -name “*.log” -mtime +5 -ok rm {} ;<br>删除当前路径下以。log结尾的五日以上的文件，删除之前要确认。</li><li>find ~ -type f -perm 4755 -print<br>查找$HOME目录下suid位被设置，文件属性为755的文件打印出来。<br>说明： find在有点系统中会一次性得到将匹配到的文件都传给exec，但是有的系统对exec的命令长度做限制，就会报：”参数列太长“，这就需要使用xargs。xargs是部分取传来的文件。</li><li>find / -type f -print |xargs file<br>xargs测试文件分类</li><li>find . -name “core*” -print|xargs echo “ “&gt;/tmp/core.log<br>将core文件信息查询结果报存到core。log日志。</li><li>find / -type f -print | xargs chmod o -w</li><li>find . -name * -print |xargs grep “DBO”</li></ol><h2 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h2><p>grep [选项] pattern [文件名]</p><p>命令中的选项为：</p><ul><li>-? 同时显示匹配行上下的？行，如：grep -2 pattern filename 同时显示匹配行的上下2行。</li><li>-b，—byte-offset 打印匹配行前面打印该行所在的块号码。</li><li>-c,—count 只打印匹配的行数，不显示匹配的内容。</li><li>-f File，—file=File 从文件中提取模板。空文件中包含0个模板，所以什么都不匹配。</li><li>-h，—no-filename 当搜索多个文件时，不显示匹配文件名前缀。</li><li>-i，—ignore-case 忽略大小写差别。</li><li>-q，—quiet 取消显示，只返回退出状态。0则表示找到了匹配的行。</li><li>-l，—files-with-matches 打印匹配模板的文件清单。</li><li>-L，—files-without-match 打印不匹配模板的文件清单。</li><li>-n，—line-number 在匹配的行前面打印行号。</li><li>-s，—silent 不显示关于不存在或者无法读取文件的错误信息。</li><li>-v，—revert-match 反检索，只显示不匹配的行。</li><li>-w，—word-regexp 如果被&lt;和&gt;引用，就把表达式做为一个单词搜索。</li><li>-V，—version 显示软件版本信息。<blockquote><p>ls -l | grep ‘^a’ 通过管道过滤ls -l输出的内容，只显示以a开头的行。<br>grep ‘test’ d* 显示所有以d开头的文件中包含test的行。<br>grep ‘test’ aa bb cc 显示在aa，bb，cc文件中匹配test的行。<br>grep ‘[a-z]’ aa 显示所有包含每个字符串至少有5个连续小写字符的字符串的行。<br>grep ‘w(es)t.<em>‘ aa 如果west被匹配，则es就被存储到内存中，并标记为1，然后搜索任意个字符(.</em>)，这些字符后面紧跟着另外一个es()，找到就显示该行。如果用egrep或grep -E，就不用””号进行转义，直接写成’w(es)t.*’就可以了。<br>grep -i pattern files ：不区分大小写地搜索。默认情况区分大小写<br>grep -l pattern files ：只列出匹配的文件名，<br>grep -L pattern files ：列出不匹配的文件名，<br>grep -w pattern files ：只匹配整个单词，而不是字符串的一部分(如匹配‘magic’，而不是‘magical’)，<br>grep -C number pattern files ：匹配的上下文分别显示[number]行，<br>grep pattern1 | pattern2 files ：显示匹配 pattern1 或 pattern2 的行，<br>grep pattern1 files | grep pattern2 ：显示既匹配 pattern1 又匹配 pattern2 的行。</p></blockquote></li></ul><p>pattern为所要匹配的字符串，可使用下列模式</p><blockquote><p>. 匹配任意一个字符<br>* 匹配0 个或多个*前的字符<br>^ 匹配行开头<br>$ 匹配行结尾<br>[] 匹配[ ]中的任意一个字符，[]中可用 - 表示范围，<br>例如[a-z]表示字母a 至z 中的任意一个<br>\ 转意字符</p></blockquote><h2 id="locate命令"><a href="#locate命令" class="headerlink" title="locate命令"></a>locate命令</h2><p>locate命令其实是“find -name”的另一种写法，但是要比后者快得多，原因在于它<strong>不搜索具体目录</strong>，而是<strong>搜索一个数据库（/var/lib/locatedb），这个数据库中含有本地所有文件信息</strong>。Linux系统自动创建这个数据库，并且<strong>每天自动更新一次</strong>，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用<code>updatedb</code>命令，手动更新数据库。</p><p>locate命令的使用实例：</p><blockquote><p>$ locate /etc/sh<br>搜索etc目录下所有以sh开头的文件。<br>$ locate -i ~/m<br>搜索用户主目录下，所有以m开头的文件，并且忽略大小写。</p></blockquote><h2 id="whereis命令"><a href="#whereis命令" class="headerlink" title="whereis命令"></a>whereis命令</h2><p><code>whereis</code>命令只能用于<strong>程序名的搜索</strong>，而且<strong>只搜索二进制文件</strong>（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。</p><p>whereis命令的使用实例：</p><blockquote><p>$ whereis grep<br>grep: /bin/grep /usr/share/man/man1p/grep.1p.gz /usr/share/man/man1/grep.1.gz</p></blockquote><h2 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h2><p>which命令的作用是，在<code>PATH</code>变量指定的路径中，<strong>搜索某个系统命令的位置</strong>，并且返回第一个搜索结果。也就是说，<strong>使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令</strong>。</p><p>which命令的使用实例：</p><blockquote><p>$ which grep<br>/bin/grep</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://blog.csdn.net/wzzfeitian/article/details/40985549&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux下各种查找命令（find, grep, which, whereis, locate）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://changsk.top/categories/Linux/"/>
    
    
      <category term="Linux命令" scheme="http://changsk.top/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-309:Best Time to Buy and Sell Stock with Cooldown</title>
    <link href="http://changsk.top/2019/07/22/leetcode-309/"/>
    <id>http://changsk.top/2019/07/22/leetcode-309/</id>
    <published>2019-07-22T14:08:22.000Z</published>
    <updated>2019-07-22T14:23:33.353Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>题目难度：Medium</p></blockquote><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p><p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:</p><ul><li>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</li><li>After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)</li></ul><p><strong>Example:</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>]</span><br><span class="line"><span class="symbol">Output</span>: <span class="number">3</span> </span><br><span class="line"><span class="symbol">Explanation</span>: transactions = [<span class="keyword">buy, </span><span class="keyword">sell, </span>cooldown, <span class="keyword">buy, </span><span class="keyword">sell]</span></span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>从题目中可以看出，不管哪一天，都只能是 buy 或者 sell 或者 cooldown(rest) 三种状态中的一种，而根据题目的约束条件，我们可以画出下图所示的状态图：<br><img src="1.jpg" alt></p><p>由此图我们可以得到：</p><blockquote><p>s0[i] = max(s0[i - 1], s2[i - 1])<br>s1[i] = max(s0[i - 1] - prices[i], s1[i - 1])<br>s2[i] = s1[i - 1] + prices[i]</p></blockquote><p>其中s0，s1，s2分别表示三种状态下的最大利润值。<br>值得注意的是这里的s0，s1和s2不是单纯的buy，sell， rest，而应该是</p><blockquote><p>s0 —— sell后rest或者rest后rest<br>s1 —— rest后的buy或者buy后的rest<br>s2 —— rest后的sell</p></blockquote><p>同时，可以注意到的是，每次的状态 i 都只与前一次的状态 i - 1有关，也就是说我们可以把空间复杂度从O(n)降到O(1)。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> s0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> s1 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> s2 = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> pre0 = s0;</span><br><span class="line">            <span class="keyword">int</span> pre1 = s1;</span><br><span class="line">            <span class="keyword">int</span> pre2 = s2;</span><br><span class="line">            s0 = Math.max(pre0, pre2);</span><br><span class="line">            s1 = Math.max(pre0 - prices[i], pre1);</span><br><span class="line">            <span class="comment">//换成 s2 = Math.max(pre2, pre1 + prices[i]); 也是对的</span></span><br><span class="line">            s2 = pre1 + prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最大利润不可能出现在buy而未sell的时候，所以不考虑s1</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(s0, s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考：<br><a href="https://blog.csdn.net/zjupeco/article/details/76468185" target="_blank" rel="noopener">LeetCode 309: 一个很清晰的DP解题思路</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-152:Maximum Product Subarray</title>
    <link href="http://changsk.top/2019/07/22/leetcode-152/"/>
    <id>http://changsk.top/2019/07/22/leetcode-152/</id>
    <published>2019-07-22T07:33:44.000Z</published>
    <updated>2019-07-22T07:47:11.620Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-product-subarray/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>题目难度：Medium</p></blockquote><p>Given an integer array <code>nums</code>, find the contiguous subarray within an array (containing at least one number) which has the largest product.</p><p><strong>Example 1:</strong></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> [<span class="number">2</span>,<span class="number">3</span>,<span class="number">-2</span>,<span class="number">4</span>]</span><br><span class="line"><span class="symbol">Output:</span> <span class="number">6</span></span><br><span class="line"><span class="symbol">Explanation:</span> [<span class="number">2</span>,<span class="number">3</span>] has the largest product <span class="number">6.</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="string">-2</span>,0,<span class="string">-1</span>]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The result cannot be 2, because [<span class="string">-2</span>,<span class="string">-1</span>] is not a subarray.</span><br></pre></td></tr></table></figure><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p>数组<code>maxArr</code>中第<code>i</code>个元素表示的是从<code>0</code>到<code>i</code>中以<code>i</code>结尾的连续子数组中最大的乘积。</p><p>数组<code>minArr</code>中第<code>i</code>个元素表示的是从<code>0</code>到<code>i</code>中以<code>i</code>结尾的连续子数组中最小的乘积。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] minArr = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span>[] maxArr = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        maxArr[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        minArr[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                maxArr[i] = Math.max(nums[i], minArr[i - <span class="number">1</span>] * nums[i]);</span><br><span class="line">                minArr[i] = Math.min(nums[i], maxArr[i - <span class="number">1</span>] * nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                maxArr[i] = Math.max(nums[i], maxArr[i - <span class="number">1</span>] * nums[i]);</span><br><span class="line">                minArr[i] = Math.min(nums[i], minArr[i - <span class="number">1</span>] * nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, maxArr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><p><code>maxArr[i]</code>的值只和<code>maxArr[i - 1]</code>、<code>minArr[i - 1]</code>和<code>nums[i]</code>有关，<code>minArr[i]</code>类似，所以可以对<code>Solution1</code>的解法进行内存上的优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>], max = nums[<span class="number">0</span>], min = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = max;</span><br><span class="line">                max = min;</span><br><span class="line">                min = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(nums[i], max * nums[i]);</span><br><span class="line">            min = Math.min(nums[i], min * nums[i]);</span><br><span class="line">            res = Math.max(res, max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/maximum-product-subarray/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/maximum-product-subarray/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-714:Best Time to Buy and Sell Stock with Transaction Fee</title>
    <link href="http://changsk.top/2019/07/22/leetcode-714/"/>
    <id>http://changsk.top/2019/07/22/leetcode-714/</id>
    <published>2019-07-22T03:14:20.000Z</published>
    <updated>2019-07-22T03:24:09.710Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>题目难度：Medium</p></blockquote><p>Your are given an array of integers <code>prices</code>, for which the <code>i</code>-th element is the price of a given stock on day <code>i</code>; and a non-negative integer <code>fee</code> representing a transaction fee.</p><p>You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)</p><p>Return the maximum profit you can make.</p><p><strong>Example 1:</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> prices = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">9</span>], fee = <span class="number">2</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="number">8</span></span><br><span class="line"><span class="symbol">Explanation:</span> The maximum profit can <span class="keyword">be </span>achieved <span class="keyword">by:</span></span><br><span class="line"><span class="keyword">Buying </span><span class="built_in">at</span> prices[<span class="number">0</span>] = <span class="number">1</span>Selling <span class="built_in">at</span> prices[<span class="number">3</span>] = <span class="number">8</span>Buying <span class="built_in">at</span> prices[<span class="number">4</span>] = <span class="number">4</span>Selling <span class="built_in">at</span> prices[<span class="number">5</span>] = <span class="number">9</span>The total profit is ((<span class="number">8</span> - <span class="number">1</span>) - <span class="number">2</span>) + ((<span class="number">9</span> - <span class="number">4</span>) - <span class="number">2</span>) = <span class="number">8</span>.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><p><code>0 &lt; prices.length &lt;= 50000</code>.</p><p><code>0 &lt; prices[i] &lt; 50000</code>.</p><p><code>0 &lt;= fee &lt; 50000</code>.</p><p><strong>问题解析：</strong></p><p>给定数组，其中的元素代表当天的股票价格，不限制股票的购售次数，但要求在购买新股之前要售出之前的股票，求股票交易的最大利润。每次股票交易都要支付固定的交易费。</p><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p>可以用DP来做。</p><ul><li><p>与之前的<code>LeetCode-121：Best Time to Buy and Sell Stock (一次股票交易最大利润)</code>和<code>LeetCode-122：Best Time to Buy and Sell Stock II (多次股票交易最大利润)</code>相似，均为股票交易题目，但本题增加了交易费的条件。</p></li><li><p>分析每天的行为，我们可以知道，主要的行为就是售出和购入。所以我们建立两个动态规划数组：<code>sold</code>和<code>hold</code>，其中<code>sold[i]</code>保存的是<strong>第i天出售股票后的最大利润</strong>，<code>hold[i]</code>保存的是<strong>第i天持有股票的最大利润。</strong></p></li><li><p><code>sold[i]</code>有两个状态，一个是在i天售出的利润，或者保持前一天也就是<code>sold[i-1]</code>的售出利润，选择其中的最大利润。</p></li><li><p><code>hold[i]</code>也有两个状态，一个是在i天购入的利润，或者保持前一天也就是<code>hold[i-1]</code>的持有利润，选择其中的最大利润。</p></li><li><p>写为动态规划式为：<br><code>Soldi=Max(Soldi−1,Holdi−1+Pricesi−fee); Holdi=Max(Holdi,Soldi−1−Pricesi)</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] sold = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] hold = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        hold[<span class="number">0</span>] = -prices[<span class="number">0</span>]; <span class="comment">//拥有的初始金额为0，然后买了第一天的股票，所以拥有的金额为 -prices[0]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            sold[i] = Math.max(sold[i-<span class="number">1</span>], hold[i-<span class="number">1</span>] + prices[i] - fee);</span><br><span class="line">            hold[i] = Math.max(hold[i-<span class="number">1</span>], sold[i-<span class="number">1</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sold[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)，空间复杂度：O(n)</li></ul><h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><p>DP优化。</p><p>同样，与<code>LeetCode-152：Maximum Product Subarray (乘积最大连续子数组)</code>相同，Solution 1 的解法可以做空间上的优化。因为动态规划公式中每次计算使用的只有上一次的结果，所以，我们将前一次的结果做临时的保存即可实现空间上的优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sold = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hold = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> soldpre = sold;</span><br><span class="line">            sold = Math.max(soldpre, hold + prices[i] - fee);</span><br><span class="line">            hold = Math.max(hold, soldpre - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sold;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)，空间复杂度：O(1)</p><blockquote><p>参考：</p><p><a href="https://blog.csdn.net/Koala_Tree/article/details/78530510" target="_blank" rel="noopener">LeetCode-714：Best Time to Buy and Sell Stock with Transaction Fee (带有抛售费用的股票最大利润) – medium</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-123:Best Time to Buy and Sell Stock III</title>
    <link href="http://changsk.top/2019/07/21/leetcode-123/"/>
    <id>http://changsk.top/2019/07/21/leetcode-123/</id>
    <published>2019-07-21T12:29:42.000Z</published>
    <updated>2019-07-21T12:37:17.004Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p><p>Design an algorithm to find the maximum profit. You may complete at most <em>two</em> transactions.</p><p><strong>Note:</strong> You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p><strong>Example 1:</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">Output: <span class="number">6</span></span><br><span class="line">Explanation: Buy <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">4</span> (price = <span class="number">0</span>) <span class="keyword">and</span> sell <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">6</span> (price = <span class="number">3</span>), profit = <span class="number">3</span><span class="number">-0</span> = <span class="number">3.</span></span><br><span class="line">             Then buy <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">7</span> (price = <span class="number">1</span>) <span class="keyword">and</span> sell <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">8</span> (price = <span class="number">4</span>), profit = <span class="number">4</span><span class="number">-1</span> = <span class="number">3.</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Explanation: Buy <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">1</span> (price = <span class="number">1</span>) <span class="keyword">and</span> sell <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">5</span> (price = <span class="number">5</span>), profit = <span class="number">5</span><span class="number">-1</span> = <span class="number">4.</span></span><br><span class="line">             Note <span class="keyword">that</span> you cannot buy <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">1</span>, buy <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">2</span> <span class="keyword">and</span> sell them later, <span class="keyword">as</span> you are</span><br><span class="line">             engaging multiple transactions <span class="keyword">at</span> <span class="keyword">the</span> same <span class="built_in">time</span>. You must sell <span class="keyword">before</span> buying again.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Input:</span> [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line"><span class="string">Output:</span> <span class="number">0</span></span><br><span class="line"><span class="string">Explanation:</span> In <span class="keyword">this</span> <span class="keyword">case</span>, no transaction is done, i.e. max profit = <span class="number">0.</span></span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>把价钱数组<code>prices</code>一分为二，分别计算<code>[0, i]</code>和<code>(i, prices.length - 1]</code>的最大利润，然后加起来，在所有和中求最大值，即为最多交易两次的最大利润。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><p><code>array1</code>数组中下标为<code>i</code>元素表示从<code>i</code>到结尾的最大利润。</p><p><code>array2</code>数组中下标为<code>i</code>元素表示从<code>0</code>到<code>1</code>的最大利润。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//3,3,5,0,0,3,1,4</span></span><br><span class="line">    <span class="comment">//2 2 0 4 4 1 3 0</span></span><br><span class="line">    <span class="comment">//0 0 2 2 2 3 1 4</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] array1 = getMaxPrices1(prices);</span><br><span class="line">        <span class="keyword">int</span>[] array2 = getMaxPrices2(prices);</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; prices.length;i++)&#123;</span><br><span class="line">            sum = array1[i] + array2[i];</span><br><span class="line">            max = Math.max(max, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getMaxPrices1(<span class="keyword">int</span>[] prices)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxPrice = prices[len - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] maxPrices = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> i = len - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            max = Math.max(max, maxPrice - prices[i]);</span><br><span class="line">            maxPrices[i] = max;</span><br><span class="line">            maxPrice = Math.max(maxPrice, prices[i]);</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxPrices;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getMaxPrices2(<span class="keyword">int</span>[] prices)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minPrice = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] maxPrices = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; len)&#123;</span><br><span class="line">            max = Math.max(max, prices[i] - minPrice);</span><br><span class="line">            minPrice = Math.min(minPrice, prices[i]);</span><br><span class="line">            maxPrices[i] = max;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxPrices;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最优方法"><a href="#最优方法" class="headerlink" title="最优方法"></a>最优方法</h2><p>代码来自<code>Leetcode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sell1 = <span class="number">0</span>, sell2 = <span class="number">0</span>, buy1 = Integer.MIN_VALUE, buy2 = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : prices) &#123;</span><br><span class="line">            sell2 = Math.max(sell2, i + buy2);</span><br><span class="line">            buy2 = Math.max(buy2, sell1 - i);</span><br><span class="line">            sell1 = Math.max(sell1, i + buy1);</span><br><span class="line">            buy1 = Math.max(buy1, -i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-122:Best Time to Buy and Sell Stock II</title>
    <link href="http://changsk.top/2019/07/21/leetcode-122/"/>
    <id>http://changsk.top/2019/07/21/leetcode-122/</id>
    <published>2019-07-21T11:14:03.000Z</published>
    <updated>2019-07-21T11:17:51.364Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>题目难度：Easy</p></blockquote><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p><p>Design an algorithm to find the maximum profit. You may <strong>complete as many transactions as you like</strong> (i.e., buy one and sell one share of the stock multiple times).</p><p><strong>Note:</strong> You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p><p><strong>Example 1:</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">Output: <span class="number">7</span></span><br><span class="line">Explanation: Buy <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">2</span> (price = <span class="number">1</span>) <span class="keyword">and</span> sell <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">3</span> (price = <span class="number">5</span>), profit = <span class="number">5</span><span class="number">-1</span> = <span class="number">4.</span></span><br><span class="line">             Then buy <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">4</span> (price = <span class="number">3</span>) <span class="keyword">and</span> sell <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">5</span> (price = <span class="number">6</span>), profit = <span class="number">6</span><span class="number">-3</span> = <span class="number">3.</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Explanation: Buy <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">1</span> (price = <span class="number">1</span>) <span class="keyword">and</span> sell <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">5</span> (price = <span class="number">5</span>), profit = <span class="number">5</span><span class="number">-1</span> = <span class="number">4.</span></span><br><span class="line">             Note <span class="keyword">that</span> you cannot buy <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">1</span>, buy <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">2</span> <span class="keyword">and</span> sell them later, <span class="keyword">as</span> you are</span><br><span class="line">             engaging multiple transactions <span class="keyword">at</span> <span class="keyword">the</span> same <span class="built_in">time</span>. You must sell <span class="keyword">before</span> buying again.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Input:</span> [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line"><span class="string">Output:</span> <span class="number">0</span></span><br><span class="line"><span class="string">Explanation:</span> In <span class="keyword">this</span> <span class="keyword">case</span>, no transaction is done, i.e. max profit = <span class="number">0.</span></span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; prices.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i+<span class="number">1</span>]&gt;prices[i]) total += prices[i+<span class="number">1</span>]-prices[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-138:Copy List with Random Pointer</title>
    <link href="http://changsk.top/2019/07/21/leetcode-138/"/>
    <id>http://changsk.top/2019/07/21/leetcode-138/</id>
    <published>2019-07-21T09:18:43.000Z</published>
    <updated>2019-07-21T09:31:03.579Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">https://leetcode.com/problems/copy-list-with-random-pointer/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p><p>Return a <a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy" target="_blank" rel="noopener"><strong>deep copy</strong></a> of the list.</p><p><img src="1.jpg" alt></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&#123;<span class="string">"$id"</span>:<span class="string">"1"</span>,<span class="string">"next"</span>:&#123;<span class="string">"$id"</span>:<span class="string">"2"</span>,<span class="string">"next"</span>:null,<span class="string">"random"</span>:&#123;<span class="string">"$ref"</span>:<span class="string">"2"</span>&#125;,<span class="string">"val"</span>:<span class="number">2</span>&#125;,<span class="string">"random"</span>:&#123;<span class="string">"$ref"</span>:<span class="string">"2"</span>&#125;,<span class="string">"val"</span>:<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line"><span class="keyword">Node</span> <span class="title">1</span>'s value is <span class="number">1</span>, both of its next <span class="keyword">and</span> random pointer points to <span class="keyword">Node</span> <span class="title">2</span>.</span><br><span class="line"><span class="keyword">Node</span> <span class="title">2</span>'s value is <span class="number">2</span>, its next pointer points to null <span class="keyword">and</span> its random pointer points to itself.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>You must return the <strong>copy of the given head</strong> as a reference to the cloned list.AC</li></ol><h2 id="AC代码1"><a href="#AC代码1" class="headerlink" title="AC代码1"></a>AC代码1</h2><p>用一个<code>map</code>保存原结点和新节点的对应关系，做法好理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment">    public Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val,Node _next,Node _random) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">        random = _random;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  </span><br><span class="line">        Map&lt;Node, Node&gt; map = <span class="keyword">new</span> HashMap&lt;Node, Node&gt;();</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// loop 1. copy all the nodes</span></span><br><span class="line">        Node node = head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.put(node, <span class="keyword">new</span> Node(node.val, <span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// loop 2. assign next and random pointers</span></span><br><span class="line">        node = head;</span><br><span class="line">         <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.get(node).next = map.get(node.next);</span><br><span class="line">            map.get(node).random = map.get(node.random);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> map.get(head);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AC代码2"><a href="#AC代码2" class="headerlink" title="AC代码2"></a>AC代码2</h2><p>把原结点和新节点交错链接，如：</p><p><code>原结点1 -&gt; 新节点1 -&gt; 原结点2 -&gt; 新节点2 -原结点3 -&gt; 新节点3</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment">    public Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val,Node _next,Node _random) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">        random = _random;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node h = head, next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(h!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            next = h.next;</span><br><span class="line">            h.next = <span class="keyword">new</span> Node(h.val, next, <span class="keyword">null</span>);</span><br><span class="line">            h = next;</span><br><span class="line">        &#125;</span><br><span class="line">        h = head;</span><br><span class="line">        <span class="keyword">while</span>(h!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(h.random!=<span class="keyword">null</span>) h.next.random = h.random.next;</span><br><span class="line">            h = h.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        h=head;</span><br><span class="line">        Node newHead = head.next, copy = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(h!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            copy = h.next;</span><br><span class="line">            h.next = h.next.next;</span><br><span class="line">            copy.next = copy.next==<span class="keyword">null</span> ? <span class="keyword">null</span> : copy.next.next;</span><br><span class="line">            h = h.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上代码均来自<strong>Leetcode</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/copy-list-with-random-pointer/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/copy-list-with-random-pointer/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法</title>
    <link href="http://changsk.top/2019/07/21/KMP/"/>
    <id>http://changsk.top/2019/07/21/KMP/</id>
    <published>2019-07-21T08:29:37.000Z</published>
    <updated>2019-07-21T09:08:58.372Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://segmentfault.com/a/1190000008575379" target="_blank" rel="noopener">KMP算法（1）：如何理解KMP</a></p></blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>给定一个主串（以 S 代替）和模式串（以 P 代替），要求找出 P 在 S 中出现的位置，此即串的模式匹配问题。</p><p>Knuth-Morris-Pratt 算法（简称 KMP）是解决这一问题的常用算法之一，这个算法是由高德纳（Donald Ervin Knuth）和沃恩·普拉特在1974年构思，同年詹姆斯·H·莫里斯也独立地设计出该算法，最终三人于1977年联合发表。</p><a id="more"></a><p>在继续下面的内容之前，有必要在这里介绍下两个概念：<strong>真前缀</strong> 和 <strong>真后缀</strong>。</p><p><img src="1.jpg" alt="img"></p><p>由上图所得， “真前缀”指除了自身以外，一个字符串的全部头部组合；”真后缀”指除了自身以外，一个字符串的全部尾部组合。（网上很多博客，应该说是几乎所有的博客，也包括我以前写的，都是“前缀”。严格来说，“真前缀”和“前缀”是不同的，既然不同，还是不要混为一谈的好！）</p><h2 id="朴素字符串匹配算法"><a href="#朴素字符串匹配算法" class="headerlink" title="朴素字符串匹配算法"></a>朴素字符串匹配算法</h2><p>初遇串的模式匹配问题，我们脑海中的第一反应，就是朴素字符串匹配（即所谓的暴力匹配），代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 字符串下标始于 0 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NaiveStringSearch</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;    <span class="comment">// S 的下标</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;    <span class="comment">// P 的下标</span></span><br><span class="line">    <span class="keyword">int</span> s_len = S.size();</span><br><span class="line">    <span class="keyword">int</span> p_len = P.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; s_len &amp;&amp; j &lt; p_len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (S[i] == P[j])  <span class="comment">// 若相等，都前进一步</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>               <span class="comment">// 不相等</span></span><br><span class="line">        &#123;</span><br><span class="line">            i = i - j + <span class="number">1</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j == p_len)        <span class="comment">// 匹配成功</span></span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暴力匹配的时间复杂度为 $O(nm)$，其中 $n$ 为 S 的长度，$m$ 为 P 的长度。很明显，这样的时间复杂度很难满足我们的需求。</p><p>接下来进入正题：时间复杂度为 $Θ(n+m)$ 的 KMP 算法。</p><h2 id="KMP字符串匹配算法"><a href="#KMP字符串匹配算法" class="headerlink" title="KMP字符串匹配算法"></a>KMP字符串匹配算法</h2><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>以下摘自阮一峰的<a href="http://www.ruanyifeng.com/blog/2013/05/Knuth–Morris–Pratt_algorithm.html" target="_blank" rel="noopener">字符串匹配的KMP算法</a>，并作稍微修改。</p><p>（1）</p><p><img src="2.jpg" alt="img"></p><p>首先，主串”BBC ABCDAB ABCDABCDABDE”的第一个字符与模式串”ABCDABD”的第一个字符，进行比较。因为B与A不匹配，所以模式串后移一位。</p><p>（2）</p><p><img src="3.jpg" alt="img"></p><p>因为B与A又不匹配，模式串再往后移。</p><p>（3）</p><p><img src="4.jpg" alt="img"></p><p>就这样，直到主串有一个字符，与模式串的第一个字符相同为止。</p><p>（4）</p><p><img src="5.jpg" alt="img"></p><p>接着比较主串和模式串的下一个字符，还是相同。</p><p>（5）</p><p><img src="6.jpg" alt="img"></p><p>直到主串有一个字符，与模式串对应的字符不相同为止。</p><p>（6）</p><p><img src="7.jpg" alt="img"></p><p>这时，最自然的反应是，将模式串整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把”搜索位置”移到已经比较过的位置，重比一遍。</p><p>（7）</p><p><img src="8.jpg" alt="img"></p><p>一个基本事实是，当空格与D不匹配时，你其实是已经知道前面六个字符是”ABCDAB”。KMP算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，而是继续把它向后移，这样就提高了效率。</p><p>（8）</p><table><thead><tr><th align="left">i</th><th align="left">0</th><th align="left">1</th><th align="left">2</th><th align="left">3</th><th align="left">4</th><th align="left">5</th><th align="left">6</th><th align="left">7</th></tr></thead><tbody><tr><td align="left">模式串</td><td align="left">A</td><td align="left">B</td><td align="left">C</td><td align="left">D</td><td align="left">A</td><td align="left">B</td><td align="left">D</td><td align="left">‘\0’</td></tr><tr><td align="left">next[i]</td><td align="left">-1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">2</td><td align="left">0</td></tr></tbody></table><p>怎么做到这一点呢？可以针对模式串，设置一个跳转数组<code>int next[]</code>，这个数组是怎么计算出来的，后面再介绍，这里只要会用就可以了。</p><p>（9）</p><p><img src="9.jpg" alt="img"></p><p>已知空格与D不匹配时，前面六个字符”ABCDAB”是匹配的。根据跳转数组可知，不匹配处D的next值为2，因此接下来<strong>从模式串下标为2的位置开始匹配</strong>。</p><p>（10）</p><p><img src="10.jpg" alt="img"></p><p>因为空格与Ｃ不匹配，C处的next值为0，因此接下来模式串从下标为0处开始匹配。</p><p>（11）</p><p><img src="11.jpg" alt="img"></p><p>因为空格与A不匹配，此处next值为-1，表示模式串的第一个字符就不匹配，那么直接往后移一位。</p><p>（12）</p><p><img src="12.jpg" alt="img"></p><p>逐位比较，直到发现C与D不匹配。于是，下一步从下标为2的地方开始匹配。</p><p>（13）</p><p><img src="13.jpg" alt="img"></p><p>逐位比较，直到模式串的最后一位，发现完全匹配，于是搜索完成。</p><h3 id="next数组是如何求出的"><a href="#next数组是如何求出的" class="headerlink" title="next数组是如何求出的"></a>next数组是如何求出的</h3><p>next数组的求解基于“真前缀”和“真后缀”，即<code>next[i]</code>等于<code>P[0]...P[i - 1]</code>最长的相同真前后缀的长度（请暂时忽视i等于0时的情况，下面会有解释）。我们依旧以上述的表格为例，为了方便阅读，我复制在下方了。</p><table><thead><tr><th align="left">i</th><th align="left">0</th><th align="left">1</th><th align="left">2</th><th align="left">3</th><th align="left">4</th><th align="left">5</th><th align="left">6</th><th align="left">7</th></tr></thead><tbody><tr><td align="left">模式串</td><td align="left">A</td><td align="left">B</td><td align="left">C</td><td align="left">D</td><td align="left">A</td><td align="left">B</td><td align="left">D</td><td align="left">‘\0’</td></tr><tr><td align="left">next[ i ]</td><td align="left">-1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">2</td><td align="left">0</td></tr></tbody></table><ol><li>i = 0，对于模式串的首字符，我们统一为<code>next[0] = -1</code>；</li><li>i = 1，前面的字符串为<code>A</code>，其最长相同真前后缀长度为0，即<code>next[1] = 0</code>；</li><li>i = 2，前面的字符串为<code>AB</code>，其最长相同真前后缀长度为0，即<code>next[2] = 0</code>；</li><li>i = 3，前面的字符串为<code>ABC</code>，其最长相同真前后缀长度为0，即<code>next[3] = 0</code>；</li><li>i = 4，前面的字符串为<code>ABCD</code>，其最长相同真前后缀长度为0，即<code>next[4] = 0</code>；</li><li>i = 5，前面的字符串为<code>ABCDA</code>，其最长相同真前后缀为<code>A</code>，即<code>next[5] = 1</code>；</li><li>i = 6，前面的字符串为<code>ABCDAB</code>，其最长相同真前后缀为<code>AB</code>，即<code>next[6] = 2</code>；</li><li>i = 7，前面的字符串为<code>ABCDABD</code>，其最长相同真前后缀长度为0，即<code>next[7] = 0</code>。</li></ol><p>那么，为什么根据最长相同真前后缀的长度就可以实现在不匹配情况下的跳转呢？举个代表性的例子：假如<code>i = 6</code>时不匹配，此时我们是知道其位置前的字符串为<code>ABCDAB</code>，仔细观察这个字符串，首尾都有一个<code>AB</code>，既然在<code>i = 6</code>处的D不匹配，我们为何不直接把<code>i = 2</code>处的C拿过来继续比较呢，因为都有一个<code>AB</code>啊，而这个<code>AB</code>就是<code>ABCDAB</code>的最长相同真前后缀，其长度2正好是跳转的下标位置。</p><p>有的读者可能存在疑问，若在<code>i = 5</code>时匹配失败，按照我讲解的思路，此时应该把<code>i = 1</code>处的字符拿过来继续比较，但是这两个位置的字符是一样的啊，都是<code>B</code>，既然一样，拿过来比较不就是无用功了么？其实不是我讲解的有问题，也不是这个算法有问题，而是这个算法还未优化，关于这个问题在下面会详细说明，不过建议读者不要在这里纠结，跳过这个，下面你自然会恍然大悟。</p><p>思路如此简单，接下来就是代码实现了，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* P 为模式串，下标从 0 开始 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="built_in">string</span> P, <span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p_len = P.size();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;   <span class="comment">// P 的下标</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">-1</span>;  </span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; p_len - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || P[i] == P[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一脸懵逼，是不是。。。上述代码就是用来求解模式串中每个位置的<code>next[]</code>值。</p><p>下面具体分析，我把代码分为两部分来讲：</p><p><strong>（1）：i和j的作用是什么？</strong></p><p>i和j就像是两个”指针“，一前一后，通过移动它们来找到最长的相同真前后缀。</p><p><strong>（2）：if…else…语句里做了什么？</strong></p><p><img src="https://subetter.com/images/figures/20180402_14.png" alt="img"></p><p>假设i和j的位置如上图，由<code>next[i] = j</code>得，也就是对于位置i来说，<strong>区段[0, i - 1]的最长相同真前后缀分别是[0, j - 1]和[i - j, i - 1]，即这两区段内容相同</strong>。</p><p>按照算法流程，<code>if (P[i] == P[j])</code>，则<code>i++; j++; next[i] = j;</code>；若不等，则<code>j = next[j]</code>，见下图：</p><p><img src="https://subetter.com/images/figures/20180402_15.png" alt="img"></p><p><code>next[j]</code>代表[0, j - 1]区段中最长相同真前后缀的长度。如图，用左侧两个椭圆来表示这个最长相同真前后缀，即这两个椭圆代表的区段内容相同；同理，右侧也有相同的两个椭圆。所以else语句就是利用第一个椭圆和第四个椭圆内容相同来加快得到[0, i - 1]区段的相同真前后缀的长度。</p><p>细心的朋友会问if语句中<code>j == -1</code>存在的意义是何？第一，程序刚运行时，j是被初始为-1，直接进行<code>P[i] == P[j]</code>判断无疑会边界溢出；第二，else语句中<code>j = next[j]</code>，j是不断后退的，若j在后退中被赋值为-1（也就是<code>j = next[0]</code>），在<code>P[i] == P[j]</code>判断也会边界溢出。综上两点，其意义就是<strong>为了特殊边界判断</strong>。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* P 为模式串，下标从 0 开始 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="built_in">string</span> P, <span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p_len = P.size();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;   <span class="comment">// P 的下标</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">-1</span>;  </span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; p_len - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || P[i] == P[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在 S 中找到 P 第一次出现的位置 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> P, <span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GetNext(P, next);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;  <span class="comment">// S 的下标</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;  <span class="comment">// P 的下标</span></span><br><span class="line">    <span class="keyword">int</span> s_len = S.size();</span><br><span class="line">    <span class="keyword">int</span> p_len = P.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; s_len &amp;&amp; j &lt; p_len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || S[i] == P[j])  <span class="comment">// P 的第一个字符不匹配或 S[i] == P[j]</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];  <span class="comment">// 当前字符匹配失败，进行跳转</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j == p_len)  <span class="comment">// 匹配成功</span></span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> next[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; KMP(<span class="string">"bbc abcdab abcdabcdabde"</span>, <span class="string">"abcdabd"</span>, next) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 15</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KMP优化"><a href="#KMP优化" class="headerlink" title="KMP优化"></a>KMP优化</h2><table><thead><tr><th align="left">i</th><th align="left">0</th><th align="left">1</th><th align="left">2</th><th align="left">3</th><th align="left">4</th><th align="left">5</th><th align="left">6</th><th align="left">7</th></tr></thead><tbody><tr><td align="left">模式串</td><td align="left">A</td><td align="left">B</td><td align="left">C</td><td align="left">D</td><td align="left">A</td><td align="left">B</td><td align="left">D</td><td align="left">‘\0’</td></tr><tr><td align="left">next[ i ]</td><td align="left">-1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">2</td><td align="left">0</td></tr></tbody></table><p>以3.2的表格为例（已复制在上方），若在<code>i = 5</code>时匹配失败，按照3.2的代码，此时应该把<code>i = 1</code>处的字符拿过来继续比较，但是这两个位置的字符是一样的，都是<code>B</code>，既然一样，拿过来比较不就是无用功了么？这我在3.2已经解释过，之所以会这样是因为KMP不够完美。那怎么改写代码就可以解决这个问题呢？很简单。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* P 为模式串，下标从 0 开始 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNextval</span><span class="params">(<span class="built_in">string</span> P, <span class="keyword">int</span> nextval[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p_len = P.size();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;   <span class="comment">// P 的下标</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">-1</span>;  </span><br><span class="line">    nextval[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; p_len - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || P[i] == P[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> (P[i] != P[j])</span><br><span class="line">                nextval[i] = j;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nextval[i] = nextval[j];  <span class="comment">// 既然相同就继续往前找真前缀</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = nextval[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此也给各位读者提个醒，KMP算法严格来说分为KMP算法（未优化版）和KMP算法（优化版），所以建议读者在表述KMP算法时，最好告知你的版本，因为两者在某些情况下区别很大，这里简单说下。</p><p><strong>KMP算法（未优化版）：</strong> next数组表示最长的相同真前后缀的长度，我们不仅可以利用next来解决模式串的匹配问题，也可以用来解决类似字符串重复问题等等，这类问题大家可以在各大OJ找到，这里不作过多表述。</p><p><strong>KMP算法（优化版）：</strong> 根据代码很容易知道（名称也改为了nextval），优化后的next仅仅表示相同真前后缀的长度，但<strong>不一定是最长</strong>（称其为“最优相同真前后缀”更为恰当）。此时我们利用优化后的next可以在模式串匹配问题中以更快的速度得到我们的答案（相较于未优化版），但是上述所说的字符串重复问题，优化版本则束手无策。</p><p>所以，该采用哪个版本，取决于你在现实中遇到的实际问题。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>严蔚敏. 数据结构（C语言版）</li><li>阮一峰. <a href="http://www.ruanyifeng.com/blog/2013/05/Knuth–Morris–Pratt_algorithm.html" target="_blank" rel="noopener">字符串匹配的KMP算法</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://segmentfault.com/a/1190000008575379&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;KMP算法（1）：如何理解KMP&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;给定一个主串（以 S 代替）和模式串（以 P 代替），要求找出 P 在 S 中出现的位置，此即串的模式匹配问题。&lt;/p&gt;
&lt;p&gt;Knuth-Morris-Pratt 算法（简称 KMP）是解决这一问题的常用算法之一，这个算法是由高德纳（Donald Ervin Knuth）和沃恩·普拉特在1974年构思，同年詹姆斯·H·莫里斯也独立地设计出该算法，最终三人于1977年联合发表。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
    
      <category term="KMP" scheme="http://changsk.top/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-85:Maximal Rectangle(最大矩阵面积)</title>
    <link href="http://changsk.top/2019/07/20/leetcode-85/"/>
    <id>http://changsk.top/2019/07/20/leetcode-85/</id>
    <published>2019-07-20T09:03:19.000Z</published>
    <updated>2019-07-20T09:09:02.231Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://blog.csdn.net/tkzc_csk/article/details/88096438" target="_blank" rel="noopener">https://blog.csdn.net/tkzc_csk/article/details/88096438</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>题目难度:Hard</p></blockquote><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area.</p><p>Example:</p><ul><li><p>Input:</p><blockquote><p>[<br>[“1”,“0”,“1”,“0”,“0”],<br>[“1”,“0”,“1”,“1”,“1”],<br>[“1”,“1”,“1”,“1”,“1”],<br>[“1”,“0”,“0”,“1”,“0”]<br>]</p></blockquote></li><li><p>Output: 6</p></li></ul><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><p>参考自:<a href="https://leetcode.com/problems/maximal-rectangle/discuss/231921/Simple-Java-Solution-based-on-84.-Largest-Rectangle-in-Histogram" target="_blank" rel="noopener">https://leetcode.com/problems/maximal-rectangle/discuss/231921/Simple-Java-Solution-based-on-84.-Largest-Rectangle-in-Histogram</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">// 首先，也是用dp做：heights保存某一列从上数第i行的连续的'1'的个数；</span></span><br><span class="line">    <span class="comment">// 然后使用84的逻辑，取连续区间最大的矩形大小就可以了；</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>] == <span class="keyword">null</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> width = matrix[<span class="number">0</span>].length, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] heights = <span class="keyword">new</span> <span class="keyword">int</span>[width];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span>[] row : matrix) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; width; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (row[c] == <span class="string">'1'</span>) heights[c]++;</span><br><span class="line">                <span class="keyword">else</span> heights[c] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, largestRectangleArea(heights));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 以下部分是第84题的解法：分治求最大矩形（不需要修改）</span></span><br><span class="line">    <span class="comment">// 思路：对于每一段区间，都存在一个最小值</span></span><br><span class="line"><span class="comment">// 对于最小值，无非就是三种可能：</span></span><br><span class="line"><span class="comment">// 1：要么整段面积最大，2、3：要么最小值左边或者最小值右边（均不包含最小值）的面积最大，采用分治法递归解决；</span></span><br><span class="line"><span class="comment">// 遇到有序排列的区间，采用递归会降低效率，于是只要单独计算并且比较就可以</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> largestRect(heights, <span class="number">0</span>, heights.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">largestRect</span><span class="params">(<span class="keyword">int</span>[] heights, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (start == end) <span class="keyword">return</span> heights[start];</span><br><span class="line">        <span class="keyword">int</span> minIndex = start;</span><br><span class="line">        <span class="comment">// 使用是否有序排列的变量可以显著提高效率</span></span><br><span class="line">        <span class="comment">// 这里可以检测双向（变大或者变小的顺序）</span></span><br><span class="line">        <span class="keyword">int</span> inc = <span class="number">0</span>, dec = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (heights[i] &lt; heights[minIndex]) minIndex = i;</span><br><span class="line">            <span class="keyword">if</span> (heights[i] &gt; heights[i - <span class="number">1</span>]) inc++; <span class="comment">// 升序</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (heights[i] &lt; heights[i - <span class="number">1</span>]) dec--; <span class="comment">// 降序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 升序</span></span><br><span class="line">        <span class="keyword">if</span> (dec == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++)</span><br><span class="line">                res = Math.max(res, heights[i] * (end - i + <span class="number">1</span>));</span><br><span class="line">        &#125; <span class="comment">// 降序</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (inc == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++)</span><br><span class="line">                res = Math.max(res, heights[i] * (i - start + <span class="number">1</span>));</span><br><span class="line">        &#125; <span class="comment">// 无序</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res = Math.max(Math.max(largestRect(heights, minIndex + <span class="number">1</span>, end), largestRect(heights, start, minIndex - <span class="number">1</span>)),</span><br><span class="line">                    heights[minIndex] * (end - start + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://blog.csdn.net/tkzc_csk/article/details/88096438&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/tkzc_csk/article/details/88096438&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-84:Largest Rectangle in Histogram</title>
    <link href="http://changsk.top/2019/07/20/leetcode-84/"/>
    <id>http://changsk.top/2019/07/20/leetcode-84/</id>
    <published>2019-07-20T08:05:15.000Z</published>
    <updated>2019-07-20T09:09:11.996Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">https://leetcode.com/problems/largest-rectangle-in-histogram/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>题目难度：Hard</p></blockquote><p>Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p><p><img src="1.jpg" alt></p><p>Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].</p><p><img src="2.jpg" alt></p><ul><li>Example:</li></ul><blockquote><p>Input: [2,1,5,6,2,3]<br>Output: 10</p></blockquote><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><p>参考自:<a href="https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/225556/Java-solution-with-explanations-in-Chinese" target="_blank" rel="noopener">https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/225556/Java-solution-with-explanations-in-Chinese</a></p><h3 id="S1-双重遍历法"><a href="#S1-双重遍历法" class="headerlink" title="S1:双重遍历法"></a>S1:双重遍历法</h3><p>本题要求的是一段连续的矩形，能够组成的面积最大的矩形的面积，所以，只要能够求出这一段矩形的位置的就可以了。最简单的想法，将所有的可能的组合都求解一遍，比较之后保留最大的那一个就好了，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">       <span class="keyword">int</span> min = heights[i];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">           <span class="keyword">if</span> (heights[j] &lt; min) &#123;</span><br><span class="line">               min = heights[j];</span><br><span class="line">           &#125;</span><br><span class="line">           max = Math.max(max, min * (i-j+<span class="number">1</span>));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过一个双重遍历，外层遍历矩形的结束地址，内层遍历矩形起始地址，通过求算每一个组合的最大组成面积求解。时间复杂度为<strong>O(n^2)</strong>。</p><h3 id="S2-分治法"><a href="#S2-分治法" class="headerlink" title="S2:分治法"></a>S2:分治法</h3><p>上面的方法我们是依据矩形的起始、结束位置进行分类、求算，那么我们还可以使用另一种方法求算：按照组合矩阵的高度从低到高求解，然后取最大。我们知道，在给定的一组矩阵中，如果取高度为最低的那一个，那么宽度必然可取数组的长度。如，给定的一个数组[2,1,2]，那么当我们取高度为 1 ，那么宽度必然可取 3 。此时组合矩阵的面积是 3 。这时，组合矩阵取得是最低高度 1 。那么接下来，如果取一个更高的高度，那么这个高度为 1 的小矩阵必然不会包含在内，所以下一步要组成的矩阵必然在这个 1 的左边或者右边，这样一来，我们就可以看作，这个高度为 1 的小矩阵将整个矩阵序列分割成了两部分，我们下一步要判断的组合矩阵就在左部或者右部，如此一下，我们只需要求左右两部中能够组成的最大面积就好了，于是，一个数组[2,1,2]被最小值1分割成了两个数组[2]和[2]，如此一来，求[2,1,2]的解的问题变成了求[2]的解，而[2]的解只有一个 2 ，以此类推，我们就可以将任意一个大的问题分解成若干个小的问题，然后在这几个小问题中求最大值即可。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">largestRectangleArea2</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> largest(heights, <span class="number">0</span>, heights.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">largest</span><span class="params">(<span class="keyword">int</span>[] heights, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (start == end) <span class="keyword">return</span> heights[start];</span><br><span class="line">    <span class="keyword">boolean</span> sorted = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> min = start;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start+<span class="number">1</span>; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (heights[i] &lt; heights[i-<span class="number">1</span>]) sorted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (heights[i] &lt; heights[min]) min = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sorted) &#123;</span><br><span class="line">        <span class="keyword">int</span> max = heights[start] * (end - start + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start+<span class="number">1</span>; i &lt;= end; i++) &#123;</span><br><span class="line">            max = Math.max(max, heights[i] * (end - i + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(Math.max(largest(heights, start, min-<span class="number">1</span>), largest(heights, min+<span class="number">1</span>, end)),</span><br><span class="line">            heights[min] * (end - start + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个数组而言，可能成为最大值的解有三个：</p><ul><li>最小值左部的某个解</li><li>最小值右部的某个解</li><li>包含当前最小值的解</li></ul><p>另外，上面的方法中，通过判断当前的子数组是否是一个有序数组，来简化这个数组的判断，上面仅判断了由小到大的顺序，还可以通过判断是否是一个由大到小的顺序进一步提高判断效率。此算法的时间复杂度为O(n*log n)。</p><h3 id="S3-利用栈"><a href="#S3-利用栈" class="headerlink" title="S3:利用栈"></a>S3:利用栈</h3><p>​        第一种方法的外层遍历，是组合矩阵的结束位置，然后在内层逐个遍历组合矩阵的开始位置。通过对这样一个模型的分析，对于以位置 i 结束的组合矩阵来说，它与当前位置之前的矩阵的高度有一定关系：<br>如果 i 位置的高度大于 i-1 位置的高度，则在与这个位置之前的矩阵的组合中，不能以当前位置的高度作为组合矩阵的高度。如数组[1,2]，那么对于位置 2 来说，这两个位置的组合不能以 2 作为组合矩阵高度。<br>如果 i 位置的高度不大于 i-1 位置的高度，则存在高度为当前高度的组合矩阵。如数组[2，1]，对于位置 1 ，有一种组合方法[1,1]，所以在这种情况下应该判断一下。<br>​        另外，我们知道，对于一个高度递增的数组来说，很容易求出其组合矩阵的最大面积，那么是否可以将任意一个矩阵转化为一个高度递增的矩阵序列？如将一个数组[2,3,1,3,5]变成[1,1,1,3,5]，但是这个过程中对 2 作了改变，我们要通过一定办法弥补这里的改变，一种方法是，在作改变前，将其能够组成的组合矩阵的最大面积记录下来，完了之后便可以对其做出改变了。对于上面那个例子，实际上我们是对两个递增的数组求解：[2,3]和[1,1,1,3,5]，而它们之间的最大解必然与[2,3,1,3,5]的解相同。于是，将一个不规则数组转化为若干有序数组，再进行求解，便是本方法的思想。下面是利用栈的一种实现，利用栈的话不需要对原数据进行修改，而是直接将原数组截取成多个有序数组，通过保存索引值确定当前的组合矩阵的宽度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">largestRectangleArea3</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> n = heights.length;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty() &amp;&amp; (i &gt;= n || heights[stack.peek()] &gt; heights[i])) &#123;</span><br><span class="line">            <span class="keyword">int</span> top = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> h = heights[top];</span><br><span class="line">            <span class="keyword">int</span> w = stack.empty() ? i : (i-stack.peek()-<span class="number">1</span>);</span><br><span class="line">            max = Math.max(max, h*w);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="S4-最长宽度法"><a href="#S4-最长宽度法" class="headerlink" title="S4:最长宽度法"></a>S4:最长宽度法</h3><p>我们知道，由多个矩阵组成的组合矩阵，其宽度为矩阵的数量，高度为矩阵中高度最低的那一个。所以，对于任意一个位置的矩阵，假设此时的组合矩阵高度为当前位置矩阵的高度，我们只需要求出这时的组合矩阵的最大宽度，便可以求出以当前矩阵的高度为高度的组合矩阵的最大面积，那么我们只需要求出每一个位置能够形成的最大解，便能够得到本题的解。要求出某个位置的最大解，如 i ，可以这样理解，从数组[0,…,n]中找到最大的一段[start,…,i,…end]，并且在这段中，位置 i 处的高度最低，那么此时这段矩阵组成的组合矩阵的面积必然是(end-start) * heights[i]。所以我们要在位置 i 的左边找到一段[start,…,i]，是的这里面每一个矩阵的高度都大于等于 i 处的高度，同理，还要在 i 的右边找到一段[i,…end]，找到这些之后，位置 i 处的解就可以求得了。所以，对于每一个位置，只要找到在 i 的左边第一个小于 i 处高度的位置 start ，再找到 i 的右边第一个小于 i 处高度的位置 end 便可。而这个数据可以通过两个遍历求解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">largestRectangleArea4</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = heights.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] leftLess = <span class="keyword">new</span> <span class="keyword">int</span>[n], rightLess = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="comment">// find left</span></span><br><span class="line">    leftLess[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = i-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p &gt;= <span class="number">0</span> &amp;&amp; heights[i] &lt;= heights[p]) &#123;</span><br><span class="line">                p -= leftLess[p] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                leftLess[i] = i - p - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// find right</span></span><br><span class="line">    rightLess[n-<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p &lt; n &amp;&amp; heights[i] &lt;= heights[p]) &#123;</span><br><span class="line">                p += rightLess[p] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rightLess[i] = p - <span class="number">1</span> - i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        max = Math.max(max, heights[i] * (leftLess[i] + rightLess[i] + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用一个数组 leftLess 保存每个位置的左边高度大于当前位置高度的矩阵数量，rightLess 同理。具体的求解方法为：对于位置 i ，如果 i-1 处的高度大于 i 处的高度，那么因为leftLess[i-1]保存的是大于位置 i-1 处高度的数量，那么这些位置的高度必然也大于位置 i 处的高度，所以，我们可以直接跳过1 + leftLess[i-1]个位置，判断下一个位置 p 处的高度是否大于 i 处的高度，如果还是大于，那么还要继续跳过leftLess[p] + 1个位置，再判断…直到 p 处的高度小于 i 处的高度，此时在 i 的左边比 i 处高度大的矩阵的数量就是i - p - 1个。对于 rightLess 的求解同理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/largest-rectangle-in-histogram/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/largest-rectangle-in-histogram/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>堆排序Java实现</title>
    <link href="http://changsk.top/2019/07/20/heapSort/"/>
    <id>http://changsk.top/2019/07/20/heapSort/</id>
    <published>2019-07-20T07:54:58.000Z</published>
    <updated>2019-07-24T09:56:20.283Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (array.length) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapAdjust(array, i, array.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调整堆,将最大的节点放在堆尾，然后从根节点重新调整</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[<span class="number">0</span>];</span><br><span class="line">        array[<span class="number">0</span>] = array[i];</span><br><span class="line">        array[i] = temp;</span><br><span class="line">        heapAdjust(array, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapAdjust</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> s, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp, i;</span><br><span class="line">temp = array[s];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span> * s; i &lt; len; i *= <span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(i &lt; len - <span class="number">1</span> &amp;&amp; array[i] &lt; array[i + <span class="number">1</span>])</span><br><span class="line">            ++i;</span><br><span class="line">        <span class="keyword">if</span>(temp &gt;= array[i]) <span class="keyword">break</span>;</span><br><span class="line">        array[s] = array[i];</span><br><span class="line">        s = i;</span><br><span class="line">    &#125;</span><br><span class="line">    array[s] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
    
      <category term="排序" scheme="http://changsk.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-机器人的运动范围</title>
    <link href="http://changsk.top/2019/07/19/jianzhioffer-robot-motion-range/"/>
    <id>http://changsk.top/2019/07/19/jianzhioffer-robot-motion-range/</id>
    <published>2019-07-19T10:21:02.000Z</published>
    <updated>2019-07-19T10:32:02.883Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p><a id="more"></a><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><p>典型的<code>BFS</code>就可以解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">//保存最终的结果，即可以到达多少个格子</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] seen = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];  <span class="comment">//判断是否被遍历过</span></span><br><span class="line">        backtrack(threshold, rows, cols, seen, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//从 [0][0] 开始遍历</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//direction</span></span><br><span class="line">    <span class="keyword">int</span>[] dirx = &#123;<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] diry = &#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">boolean</span>[][] seen, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= rows || j &lt; <span class="number">0</span> || j &gt;= cols || seen[i][j] || (sumBit(i) + sumBit(j)) &gt; threshold) <span class="keyword">return</span>;</span><br><span class="line">        seen[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">//从当前节点开始，依次遍历上下左右四个方向（方向的顺序对结果没有影响）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="number">4</span>;k++)</span><br><span class="line">            backtrack(threshold, rows, cols, seen, i + dirx[k], j + diry[k]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sumBit</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i != <span class="number">0</span>)&#123;</span><br><span class="line">            sum += i % <span class="number">10</span>;</span><br><span class="line">            i /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="http://changsk.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="http://changsk.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
</feed>
