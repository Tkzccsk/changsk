<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>changsk&#39;s blogs</title>
  
  <subtitle>chang.sk@foxmail.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://changsk.top/"/>
  <updated>2019-07-21T12:37:17.004Z</updated>
  <id>http://changsk.top/</id>
  
  <author>
    <name>changsk</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode-123:Best Time to Buy and Sell Stock III</title>
    <link href="http://changsk.top/2019/07/21/leetcode-123/"/>
    <id>http://changsk.top/2019/07/21/leetcode-123/</id>
    <published>2019-07-21T12:29:42.000Z</published>
    <updated>2019-07-21T12:37:17.004Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p><p>Design an algorithm to find the maximum profit. You may complete at most <em>two</em> transactions.</p><p><strong>Note:</strong> You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p><strong>Example 1:</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">Output: <span class="number">6</span></span><br><span class="line">Explanation: Buy <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">4</span> (price = <span class="number">0</span>) <span class="keyword">and</span> sell <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">6</span> (price = <span class="number">3</span>), profit = <span class="number">3</span><span class="number">-0</span> = <span class="number">3.</span></span><br><span class="line">             Then buy <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">7</span> (price = <span class="number">1</span>) <span class="keyword">and</span> sell <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">8</span> (price = <span class="number">4</span>), profit = <span class="number">4</span><span class="number">-1</span> = <span class="number">3.</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Explanation: Buy <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">1</span> (price = <span class="number">1</span>) <span class="keyword">and</span> sell <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">5</span> (price = <span class="number">5</span>), profit = <span class="number">5</span><span class="number">-1</span> = <span class="number">4.</span></span><br><span class="line">             Note <span class="keyword">that</span> you cannot buy <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">1</span>, buy <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">2</span> <span class="keyword">and</span> sell them later, <span class="keyword">as</span> you are</span><br><span class="line">             engaging multiple transactions <span class="keyword">at</span> <span class="keyword">the</span> same <span class="built_in">time</span>. You must sell <span class="keyword">before</span> buying again.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Input:</span> [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line"><span class="string">Output:</span> <span class="number">0</span></span><br><span class="line"><span class="string">Explanation:</span> In <span class="keyword">this</span> <span class="keyword">case</span>, no transaction is done, i.e. max profit = <span class="number">0.</span></span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>把价钱数组<code>prices</code>一分为二，分别计算<code>[0, i]</code>和<code>(i, prices.length - 1]</code>的最大利润，然后加起来，在所有和中求最大值，即为最多交易两次的最大利润。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><p><code>array1</code>数组中下标为<code>i</code>元素表示从<code>i</code>到结尾的最大利润。</p><p><code>array2</code>数组中下标为<code>i</code>元素表示从<code>0</code>到<code>1</code>的最大利润。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//3,3,5,0,0,3,1,4</span></span><br><span class="line">    <span class="comment">//2 2 0 4 4 1 3 0</span></span><br><span class="line">    <span class="comment">//0 0 2 2 2 3 1 4</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] array1 = getMaxPrices1(prices);</span><br><span class="line">        <span class="keyword">int</span>[] array2 = getMaxPrices2(prices);</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; prices.length;i++)&#123;</span><br><span class="line">            sum = array1[i] + array2[i];</span><br><span class="line">            max = Math.max(max, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getMaxPrices1(<span class="keyword">int</span>[] prices)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxPrice = prices[len - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] maxPrices = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> i = len - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            max = Math.max(max, maxPrice - prices[i]);</span><br><span class="line">            maxPrices[i] = max;</span><br><span class="line">            maxPrice = Math.max(maxPrice, prices[i]);</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxPrices;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getMaxPrices2(<span class="keyword">int</span>[] prices)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minPrice = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] maxPrices = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; len)&#123;</span><br><span class="line">            max = Math.max(max, prices[i] - minPrice);</span><br><span class="line">            minPrice = Math.min(minPrice, prices[i]);</span><br><span class="line">            maxPrices[i] = max;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxPrices;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最优方法"><a href="#最优方法" class="headerlink" title="最优方法"></a>最优方法</h2><p>代码来自<code>Leetcode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sell1 = <span class="number">0</span>, sell2 = <span class="number">0</span>, buy1 = Integer.MIN_VALUE, buy2 = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : prices) &#123;</span><br><span class="line">            sell2 = Math.max(sell2, i + buy2);</span><br><span class="line">            buy2 = Math.max(buy2, sell1 - i);</span><br><span class="line">            sell1 = Math.max(sell1, i + buy1);</span><br><span class="line">            buy1 = Math.max(buy1, -i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-122:Best Time to Buy and Sell Stock II</title>
    <link href="http://changsk.top/2019/07/21/leetcode-122/"/>
    <id>http://changsk.top/2019/07/21/leetcode-122/</id>
    <published>2019-07-21T11:14:03.000Z</published>
    <updated>2019-07-21T11:17:51.364Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>题目难度：Easy</p></blockquote><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p><p>Design an algorithm to find the maximum profit. You may <strong>complete as many transactions as you like</strong> (i.e., buy one and sell one share of the stock multiple times).</p><p><strong>Note:</strong> You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p><p><strong>Example 1:</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">Output: <span class="number">7</span></span><br><span class="line">Explanation: Buy <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">2</span> (price = <span class="number">1</span>) <span class="keyword">and</span> sell <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">3</span> (price = <span class="number">5</span>), profit = <span class="number">5</span><span class="number">-1</span> = <span class="number">4.</span></span><br><span class="line">             Then buy <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">4</span> (price = <span class="number">3</span>) <span class="keyword">and</span> sell <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">5</span> (price = <span class="number">6</span>), profit = <span class="number">6</span><span class="number">-3</span> = <span class="number">3.</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Explanation: Buy <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">1</span> (price = <span class="number">1</span>) <span class="keyword">and</span> sell <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">5</span> (price = <span class="number">5</span>), profit = <span class="number">5</span><span class="number">-1</span> = <span class="number">4.</span></span><br><span class="line">             Note <span class="keyword">that</span> you cannot buy <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">1</span>, buy <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">2</span> <span class="keyword">and</span> sell them later, <span class="keyword">as</span> you are</span><br><span class="line">             engaging multiple transactions <span class="keyword">at</span> <span class="keyword">the</span> same <span class="built_in">time</span>. You must sell <span class="keyword">before</span> buying again.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Input:</span> [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line"><span class="string">Output:</span> <span class="number">0</span></span><br><span class="line"><span class="string">Explanation:</span> In <span class="keyword">this</span> <span class="keyword">case</span>, no transaction is done, i.e. max profit = <span class="number">0.</span></span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; prices.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i+<span class="number">1</span>]&gt;prices[i]) total += prices[i+<span class="number">1</span>]-prices[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-138:Copy List with Random Pointer</title>
    <link href="http://changsk.top/2019/07/21/leetcode-138/"/>
    <id>http://changsk.top/2019/07/21/leetcode-138/</id>
    <published>2019-07-21T09:18:43.000Z</published>
    <updated>2019-07-21T09:31:03.579Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">https://leetcode.com/problems/copy-list-with-random-pointer/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p><p>Return a <a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy" target="_blank" rel="noopener"><strong>deep copy</strong></a> of the list.</p><p><img src="1.jpg" alt></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&#123;<span class="string">"$id"</span>:<span class="string">"1"</span>,<span class="string">"next"</span>:&#123;<span class="string">"$id"</span>:<span class="string">"2"</span>,<span class="string">"next"</span>:null,<span class="string">"random"</span>:&#123;<span class="string">"$ref"</span>:<span class="string">"2"</span>&#125;,<span class="string">"val"</span>:<span class="number">2</span>&#125;,<span class="string">"random"</span>:&#123;<span class="string">"$ref"</span>:<span class="string">"2"</span>&#125;,<span class="string">"val"</span>:<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line"><span class="keyword">Node</span> <span class="title">1</span>'s value is <span class="number">1</span>, both of its next <span class="keyword">and</span> random pointer points to <span class="keyword">Node</span> <span class="title">2</span>.</span><br><span class="line"><span class="keyword">Node</span> <span class="title">2</span>'s value is <span class="number">2</span>, its next pointer points to null <span class="keyword">and</span> its random pointer points to itself.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>You must return the <strong>copy of the given head</strong> as a reference to the cloned list.AC</li></ol><h2 id="AC代码1"><a href="#AC代码1" class="headerlink" title="AC代码1"></a>AC代码1</h2><p>用一个<code>map</code>保存原结点和新节点的对应关系，做法好理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment">    public Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val,Node _next,Node _random) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">        random = _random;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  </span><br><span class="line">        Map&lt;Node, Node&gt; map = <span class="keyword">new</span> HashMap&lt;Node, Node&gt;();</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// loop 1. copy all the nodes</span></span><br><span class="line">        Node node = head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.put(node, <span class="keyword">new</span> Node(node.val, <span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// loop 2. assign next and random pointers</span></span><br><span class="line">        node = head;</span><br><span class="line">         <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.get(node).next = map.get(node.next);</span><br><span class="line">            map.get(node).random = map.get(node.random);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> map.get(head);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AC代码2"><a href="#AC代码2" class="headerlink" title="AC代码2"></a>AC代码2</h2><p>把原结点和新节点交错链接，如：</p><p><code>原结点1 -&gt; 新节点1 -&gt; 原结点2 -&gt; 新节点2 -原结点3 -&gt; 新节点3</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment">    public Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val,Node _next,Node _random) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">        random = _random;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node h = head, next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(h!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            next = h.next;</span><br><span class="line">            h.next = <span class="keyword">new</span> Node(h.val, next, <span class="keyword">null</span>);</span><br><span class="line">            h = next;</span><br><span class="line">        &#125;</span><br><span class="line">        h = head;</span><br><span class="line">        <span class="keyword">while</span>(h!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(h.random!=<span class="keyword">null</span>) h.next.random = h.random.next;</span><br><span class="line">            h = h.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        h=head;</span><br><span class="line">        Node newHead = head.next, copy = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(h!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            copy = h.next;</span><br><span class="line">            h.next = h.next.next;</span><br><span class="line">            copy.next = copy.next==<span class="keyword">null</span> ? <span class="keyword">null</span> : copy.next.next;</span><br><span class="line">            h = h.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上代码均来自<strong>Leetcode</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/copy-list-with-random-pointer/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/copy-list-with-random-pointer/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法</title>
    <link href="http://changsk.top/2019/07/21/KMP/"/>
    <id>http://changsk.top/2019/07/21/KMP/</id>
    <published>2019-07-21T08:29:37.000Z</published>
    <updated>2019-07-21T09:08:58.372Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://segmentfault.com/a/1190000008575379" target="_blank" rel="noopener">KMP算法（1）：如何理解KMP</a></p></blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>给定一个主串（以 S 代替）和模式串（以 P 代替），要求找出 P 在 S 中出现的位置，此即串的模式匹配问题。</p><p>Knuth-Morris-Pratt 算法（简称 KMP）是解决这一问题的常用算法之一，这个算法是由高德纳（Donald Ervin Knuth）和沃恩·普拉特在1974年构思，同年詹姆斯·H·莫里斯也独立地设计出该算法，最终三人于1977年联合发表。</p><a id="more"></a><p>在继续下面的内容之前，有必要在这里介绍下两个概念：<strong>真前缀</strong> 和 <strong>真后缀</strong>。</p><p><img src="1.jpg" alt="img"></p><p>由上图所得， “真前缀”指除了自身以外，一个字符串的全部头部组合；”真后缀”指除了自身以外，一个字符串的全部尾部组合。（网上很多博客，应该说是几乎所有的博客，也包括我以前写的，都是“前缀”。严格来说，“真前缀”和“前缀”是不同的，既然不同，还是不要混为一谈的好！）</p><h2 id="朴素字符串匹配算法"><a href="#朴素字符串匹配算法" class="headerlink" title="朴素字符串匹配算法"></a>朴素字符串匹配算法</h2><p>初遇串的模式匹配问题，我们脑海中的第一反应，就是朴素字符串匹配（即所谓的暴力匹配），代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 字符串下标始于 0 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NaiveStringSearch</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;    <span class="comment">// S 的下标</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;    <span class="comment">// P 的下标</span></span><br><span class="line">    <span class="keyword">int</span> s_len = S.size();</span><br><span class="line">    <span class="keyword">int</span> p_len = P.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; s_len &amp;&amp; j &lt; p_len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (S[i] == P[j])  <span class="comment">// 若相等，都前进一步</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>               <span class="comment">// 不相等</span></span><br><span class="line">        &#123;</span><br><span class="line">            i = i - j + <span class="number">1</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j == p_len)        <span class="comment">// 匹配成功</span></span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暴力匹配的时间复杂度为 $O(nm)$，其中 $n$ 为 S 的长度，$m$ 为 P 的长度。很明显，这样的时间复杂度很难满足我们的需求。</p><p>接下来进入正题：时间复杂度为 $Θ(n+m)$ 的 KMP 算法。</p><h2 id="KMP字符串匹配算法"><a href="#KMP字符串匹配算法" class="headerlink" title="KMP字符串匹配算法"></a>KMP字符串匹配算法</h2><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>以下摘自阮一峰的<a href="http://www.ruanyifeng.com/blog/2013/05/Knuth–Morris–Pratt_algorithm.html" target="_blank" rel="noopener">字符串匹配的KMP算法</a>，并作稍微修改。</p><p>（1）</p><p><img src="2.jpg" alt="img"></p><p>首先，主串”BBC ABCDAB ABCDABCDABDE”的第一个字符与模式串”ABCDABD”的第一个字符，进行比较。因为B与A不匹配，所以模式串后移一位。</p><p>（2）</p><p><img src="3.jpg" alt="img"></p><p>因为B与A又不匹配，模式串再往后移。</p><p>（3）</p><p><img src="4.jpg" alt="img"></p><p>就这样，直到主串有一个字符，与模式串的第一个字符相同为止。</p><p>（4）</p><p><img src="5.jpg" alt="img"></p><p>接着比较主串和模式串的下一个字符，还是相同。</p><p>（5）</p><p><img src="6.jpg" alt="img"></p><p>直到主串有一个字符，与模式串对应的字符不相同为止。</p><p>（6）</p><p><img src="7.jpg" alt="img"></p><p>这时，最自然的反应是，将模式串整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把”搜索位置”移到已经比较过的位置，重比一遍。</p><p>（7）</p><p><img src="8.jpg" alt="img"></p><p>一个基本事实是，当空格与D不匹配时，你其实是已经知道前面六个字符是”ABCDAB”。KMP算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，而是继续把它向后移，这样就提高了效率。</p><p>（8）</p><table><thead><tr><th align="left">i</th><th align="left">0</th><th align="left">1</th><th align="left">2</th><th align="left">3</th><th align="left">4</th><th align="left">5</th><th align="left">6</th><th align="left">7</th></tr></thead><tbody><tr><td align="left">模式串</td><td align="left">A</td><td align="left">B</td><td align="left">C</td><td align="left">D</td><td align="left">A</td><td align="left">B</td><td align="left">D</td><td align="left">‘\0’</td></tr><tr><td align="left">next[i]</td><td align="left">-1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">2</td><td align="left">0</td></tr></tbody></table><p>怎么做到这一点呢？可以针对模式串，设置一个跳转数组<code>int next[]</code>，这个数组是怎么计算出来的，后面再介绍，这里只要会用就可以了。</p><p>（9）</p><p><img src="9.jpg" alt="img"></p><p>已知空格与D不匹配时，前面六个字符”ABCDAB”是匹配的。根据跳转数组可知，不匹配处D的next值为2，因此接下来<strong>从模式串下标为2的位置开始匹配</strong>。</p><p>（10）</p><p><img src="10.jpg" alt="img"></p><p>因为空格与Ｃ不匹配，C处的next值为0，因此接下来模式串从下标为0处开始匹配。</p><p>（11）</p><p><img src="11.jpg" alt="img"></p><p>因为空格与A不匹配，此处next值为-1，表示模式串的第一个字符就不匹配，那么直接往后移一位。</p><p>（12）</p><p><img src="12.jpg" alt="img"></p><p>逐位比较，直到发现C与D不匹配。于是，下一步从下标为2的地方开始匹配。</p><p>（13）</p><p><img src="13.jpg" alt="img"></p><p>逐位比较，直到模式串的最后一位，发现完全匹配，于是搜索完成。</p><h3 id="next数组是如何求出的"><a href="#next数组是如何求出的" class="headerlink" title="next数组是如何求出的"></a>next数组是如何求出的</h3><p>next数组的求解基于“真前缀”和“真后缀”，即<code>next[i]</code>等于<code>P[0]...P[i - 1]</code>最长的相同真前后缀的长度（请暂时忽视i等于0时的情况，下面会有解释）。我们依旧以上述的表格为例，为了方便阅读，我复制在下方了。</p><table><thead><tr><th align="left">i</th><th align="left">0</th><th align="left">1</th><th align="left">2</th><th align="left">3</th><th align="left">4</th><th align="left">5</th><th align="left">6</th><th align="left">7</th></tr></thead><tbody><tr><td align="left">模式串</td><td align="left">A</td><td align="left">B</td><td align="left">C</td><td align="left">D</td><td align="left">A</td><td align="left">B</td><td align="left">D</td><td align="left">‘\0’</td></tr><tr><td align="left">next[ i ]</td><td align="left">-1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">2</td><td align="left">0</td></tr></tbody></table><ol><li>i = 0，对于模式串的首字符，我们统一为<code>next[0] = -1</code>；</li><li>i = 1，前面的字符串为<code>A</code>，其最长相同真前后缀长度为0，即<code>next[1] = 0</code>；</li><li>i = 2，前面的字符串为<code>AB</code>，其最长相同真前后缀长度为0，即<code>next[2] = 0</code>；</li><li>i = 3，前面的字符串为<code>ABC</code>，其最长相同真前后缀长度为0，即<code>next[3] = 0</code>；</li><li>i = 4，前面的字符串为<code>ABCD</code>，其最长相同真前后缀长度为0，即<code>next[4] = 0</code>；</li><li>i = 5，前面的字符串为<code>ABCDA</code>，其最长相同真前后缀为<code>A</code>，即<code>next[5] = 1</code>；</li><li>i = 6，前面的字符串为<code>ABCDAB</code>，其最长相同真前后缀为<code>AB</code>，即<code>next[6] = 2</code>；</li><li>i = 7，前面的字符串为<code>ABCDABD</code>，其最长相同真前后缀长度为0，即<code>next[7] = 0</code>。</li></ol><p>那么，为什么根据最长相同真前后缀的长度就可以实现在不匹配情况下的跳转呢？举个代表性的例子：假如<code>i = 6</code>时不匹配，此时我们是知道其位置前的字符串为<code>ABCDAB</code>，仔细观察这个字符串，首尾都有一个<code>AB</code>，既然在<code>i = 6</code>处的D不匹配，我们为何不直接把<code>i = 2</code>处的C拿过来继续比较呢，因为都有一个<code>AB</code>啊，而这个<code>AB</code>就是<code>ABCDAB</code>的最长相同真前后缀，其长度2正好是跳转的下标位置。</p><p>有的读者可能存在疑问，若在<code>i = 5</code>时匹配失败，按照我讲解的思路，此时应该把<code>i = 1</code>处的字符拿过来继续比较，但是这两个位置的字符是一样的啊，都是<code>B</code>，既然一样，拿过来比较不就是无用功了么？其实不是我讲解的有问题，也不是这个算法有问题，而是这个算法还未优化，关于这个问题在下面会详细说明，不过建议读者不要在这里纠结，跳过这个，下面你自然会恍然大悟。</p><p>思路如此简单，接下来就是代码实现了，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* P 为模式串，下标从 0 开始 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="built_in">string</span> P, <span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p_len = P.size();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;   <span class="comment">// P 的下标</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">-1</span>;  </span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; p_len - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || P[i] == P[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一脸懵逼，是不是。。。上述代码就是用来求解模式串中每个位置的<code>next[]</code>值。</p><p>下面具体分析，我把代码分为两部分来讲：</p><p><strong>（1）：i和j的作用是什么？</strong></p><p>i和j就像是两个”指针“，一前一后，通过移动它们来找到最长的相同真前后缀。</p><p><strong>（2）：if…else…语句里做了什么？</strong></p><p><img src="https://subetter.com/images/figures/20180402_14.png" alt="img"></p><p>假设i和j的位置如上图，由<code>next[i] = j</code>得，也就是对于位置i来说，<strong>区段[0, i - 1]的最长相同真前后缀分别是[0, j - 1]和[i - j, i - 1]，即这两区段内容相同</strong>。</p><p>按照算法流程，<code>if (P[i] == P[j])</code>，则<code>i++; j++; next[i] = j;</code>；若不等，则<code>j = next[j]</code>，见下图：</p><p><img src="https://subetter.com/images/figures/20180402_15.png" alt="img"></p><p><code>next[j]</code>代表[0, j - 1]区段中最长相同真前后缀的长度。如图，用左侧两个椭圆来表示这个最长相同真前后缀，即这两个椭圆代表的区段内容相同；同理，右侧也有相同的两个椭圆。所以else语句就是利用第一个椭圆和第四个椭圆内容相同来加快得到[0, i - 1]区段的相同真前后缀的长度。</p><p>细心的朋友会问if语句中<code>j == -1</code>存在的意义是何？第一，程序刚运行时，j是被初始为-1，直接进行<code>P[i] == P[j]</code>判断无疑会边界溢出；第二，else语句中<code>j = next[j]</code>，j是不断后退的，若j在后退中被赋值为-1（也就是<code>j = next[0]</code>），在<code>P[i] == P[j]</code>判断也会边界溢出。综上两点，其意义就是<strong>为了特殊边界判断</strong>。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* P 为模式串，下标从 0 开始 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="built_in">string</span> P, <span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p_len = P.size();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;   <span class="comment">// P 的下标</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">-1</span>;  </span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; p_len - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || P[i] == P[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在 S 中找到 P 第一次出现的位置 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> P, <span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GetNext(P, next);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;  <span class="comment">// S 的下标</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;  <span class="comment">// P 的下标</span></span><br><span class="line">    <span class="keyword">int</span> s_len = S.size();</span><br><span class="line">    <span class="keyword">int</span> p_len = P.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; s_len &amp;&amp; j &lt; p_len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || S[i] == P[j])  <span class="comment">// P 的第一个字符不匹配或 S[i] == P[j]</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];  <span class="comment">// 当前字符匹配失败，进行跳转</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j == p_len)  <span class="comment">// 匹配成功</span></span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> next[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; KMP(<span class="string">"bbc abcdab abcdabcdabde"</span>, <span class="string">"abcdabd"</span>, next) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 15</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KMP优化"><a href="#KMP优化" class="headerlink" title="KMP优化"></a>KMP优化</h2><table><thead><tr><th align="left">i</th><th align="left">0</th><th align="left">1</th><th align="left">2</th><th align="left">3</th><th align="left">4</th><th align="left">5</th><th align="left">6</th><th align="left">7</th></tr></thead><tbody><tr><td align="left">模式串</td><td align="left">A</td><td align="left">B</td><td align="left">C</td><td align="left">D</td><td align="left">A</td><td align="left">B</td><td align="left">D</td><td align="left">‘\0’</td></tr><tr><td align="left">next[ i ]</td><td align="left">-1</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">2</td><td align="left">0</td></tr></tbody></table><p>以3.2的表格为例（已复制在上方），若在<code>i = 5</code>时匹配失败，按照3.2的代码，此时应该把<code>i = 1</code>处的字符拿过来继续比较，但是这两个位置的字符是一样的，都是<code>B</code>，既然一样，拿过来比较不就是无用功了么？这我在3.2已经解释过，之所以会这样是因为KMP不够完美。那怎么改写代码就可以解决这个问题呢？很简单。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* P 为模式串，下标从 0 开始 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNextval</span><span class="params">(<span class="built_in">string</span> P, <span class="keyword">int</span> nextval[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p_len = P.size();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;   <span class="comment">// P 的下标</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">-1</span>;  </span><br><span class="line">    nextval[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; p_len - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || P[i] == P[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> (P[i] != P[j])</span><br><span class="line">                nextval[i] = j;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nextval[i] = nextval[j];  <span class="comment">// 既然相同就继续往前找真前缀</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = nextval[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此也给各位读者提个醒，KMP算法严格来说分为KMP算法（未优化版）和KMP算法（优化版），所以建议读者在表述KMP算法时，最好告知你的版本，因为两者在某些情况下区别很大，这里简单说下。</p><p><strong>KMP算法（未优化版）：</strong> next数组表示最长的相同真前后缀的长度，我们不仅可以利用next来解决模式串的匹配问题，也可以用来解决类似字符串重复问题等等，这类问题大家可以在各大OJ找到，这里不作过多表述。</p><p><strong>KMP算法（优化版）：</strong> 根据代码很容易知道（名称也改为了nextval），优化后的next仅仅表示相同真前后缀的长度，但<strong>不一定是最长</strong>（称其为“最优相同真前后缀”更为恰当）。此时我们利用优化后的next可以在模式串匹配问题中以更快的速度得到我们的答案（相较于未优化版），但是上述所说的字符串重复问题，优化版本则束手无策。</p><p>所以，该采用哪个版本，取决于你在现实中遇到的实际问题。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>严蔚敏. 数据结构（C语言版）</li><li>阮一峰. <a href="http://www.ruanyifeng.com/blog/2013/05/Knuth–Morris–Pratt_algorithm.html" target="_blank" rel="noopener">字符串匹配的KMP算法</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://segmentfault.com/a/1190000008575379&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;KMP算法（1）：如何理解KMP&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;给定一个主串（以 S 代替）和模式串（以 P 代替），要求找出 P 在 S 中出现的位置，此即串的模式匹配问题。&lt;/p&gt;
&lt;p&gt;Knuth-Morris-Pratt 算法（简称 KMP）是解决这一问题的常用算法之一，这个算法是由高德纳（Donald Ervin Knuth）和沃恩·普拉特在1974年构思，同年詹姆斯·H·莫里斯也独立地设计出该算法，最终三人于1977年联合发表。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
    
      <category term="KMP" scheme="http://changsk.top/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-85:Maximal Rectangle(最大矩阵面积)</title>
    <link href="http://changsk.top/2019/07/20/leetcode-85/"/>
    <id>http://changsk.top/2019/07/20/leetcode-85/</id>
    <published>2019-07-20T09:03:19.000Z</published>
    <updated>2019-07-20T09:09:02.231Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://blog.csdn.net/tkzc_csk/article/details/88096438" target="_blank" rel="noopener">https://blog.csdn.net/tkzc_csk/article/details/88096438</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>题目难度:Hard</p></blockquote><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area.</p><p>Example:</p><ul><li><p>Input:</p><blockquote><p>[<br>[“1”,“0”,“1”,“0”,“0”],<br>[“1”,“0”,“1”,“1”,“1”],<br>[“1”,“1”,“1”,“1”,“1”],<br>[“1”,“0”,“0”,“1”,“0”]<br>]</p></blockquote></li><li><p>Output: 6</p></li></ul><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><p>参考自:<a href="https://leetcode.com/problems/maximal-rectangle/discuss/231921/Simple-Java-Solution-based-on-84.-Largest-Rectangle-in-Histogram" target="_blank" rel="noopener">https://leetcode.com/problems/maximal-rectangle/discuss/231921/Simple-Java-Solution-based-on-84.-Largest-Rectangle-in-Histogram</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">// 首先，也是用dp做：heights保存某一列从上数第i行的连续的'1'的个数；</span></span><br><span class="line">    <span class="comment">// 然后使用84的逻辑，取连续区间最大的矩形大小就可以了；</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>] == <span class="keyword">null</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> width = matrix[<span class="number">0</span>].length, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] heights = <span class="keyword">new</span> <span class="keyword">int</span>[width];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span>[] row : matrix) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; width; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (row[c] == <span class="string">'1'</span>) heights[c]++;</span><br><span class="line">                <span class="keyword">else</span> heights[c] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, largestRectangleArea(heights));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 以下部分是第84题的解法：分治求最大矩形（不需要修改）</span></span><br><span class="line">    <span class="comment">// 思路：对于每一段区间，都存在一个最小值</span></span><br><span class="line"><span class="comment">// 对于最小值，无非就是三种可能：</span></span><br><span class="line"><span class="comment">// 1：要么整段面积最大，2、3：要么最小值左边或者最小值右边（均不包含最小值）的面积最大，采用分治法递归解决；</span></span><br><span class="line"><span class="comment">// 遇到有序排列的区间，采用递归会降低效率，于是只要单独计算并且比较就可以</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> largestRect(heights, <span class="number">0</span>, heights.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">largestRect</span><span class="params">(<span class="keyword">int</span>[] heights, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (start == end) <span class="keyword">return</span> heights[start];</span><br><span class="line">        <span class="keyword">int</span> minIndex = start;</span><br><span class="line">        <span class="comment">// 使用是否有序排列的变量可以显著提高效率</span></span><br><span class="line">        <span class="comment">// 这里可以检测双向（变大或者变小的顺序）</span></span><br><span class="line">        <span class="keyword">int</span> inc = <span class="number">0</span>, dec = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (heights[i] &lt; heights[minIndex]) minIndex = i;</span><br><span class="line">            <span class="keyword">if</span> (heights[i] &gt; heights[i - <span class="number">1</span>]) inc++; <span class="comment">// 升序</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (heights[i] &lt; heights[i - <span class="number">1</span>]) dec--; <span class="comment">// 降序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 升序</span></span><br><span class="line">        <span class="keyword">if</span> (dec == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++)</span><br><span class="line">                res = Math.max(res, heights[i] * (end - i + <span class="number">1</span>));</span><br><span class="line">        &#125; <span class="comment">// 降序</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (inc == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++)</span><br><span class="line">                res = Math.max(res, heights[i] * (i - start + <span class="number">1</span>));</span><br><span class="line">        &#125; <span class="comment">// 无序</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res = Math.max(Math.max(largestRect(heights, minIndex + <span class="number">1</span>, end), largestRect(heights, start, minIndex - <span class="number">1</span>)),</span><br><span class="line">                    heights[minIndex] * (end - start + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://blog.csdn.net/tkzc_csk/article/details/88096438&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/tkzc_csk/article/details/88096438&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-84:Largest Rectangle in Histogram</title>
    <link href="http://changsk.top/2019/07/20/leetcode-84/"/>
    <id>http://changsk.top/2019/07/20/leetcode-84/</id>
    <published>2019-07-20T08:05:15.000Z</published>
    <updated>2019-07-20T09:09:11.996Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">https://leetcode.com/problems/largest-rectangle-in-histogram/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>题目难度：Hard</p></blockquote><p>Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p><p><img src="1.jpg" alt></p><p>Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].</p><p><img src="2.jpg" alt></p><ul><li>Example:</li></ul><blockquote><p>Input: [2,1,5,6,2,3]<br>Output: 10</p></blockquote><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><p>参考自:<a href="https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/225556/Java-solution-with-explanations-in-Chinese" target="_blank" rel="noopener">https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/225556/Java-solution-with-explanations-in-Chinese</a></p><h3 id="S1-双重遍历法"><a href="#S1-双重遍历法" class="headerlink" title="S1:双重遍历法"></a>S1:双重遍历法</h3><p>本题要求的是一段连续的矩形，能够组成的面积最大的矩形的面积，所以，只要能够求出这一段矩形的位置的就可以了。最简单的想法，将所有的可能的组合都求解一遍，比较之后保留最大的那一个就好了，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">       <span class="keyword">int</span> min = heights[i];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">           <span class="keyword">if</span> (heights[j] &lt; min) &#123;</span><br><span class="line">               min = heights[j];</span><br><span class="line">           &#125;</span><br><span class="line">           max = Math.max(max, min * (i-j+<span class="number">1</span>));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过一个双重遍历，外层遍历矩形的结束地址，内层遍历矩形起始地址，通过求算每一个组合的最大组成面积求解。时间复杂度为<strong>O(n^2)</strong>。</p><h3 id="S2-分治法"><a href="#S2-分治法" class="headerlink" title="S2:分治法"></a>S2:分治法</h3><p>上面的方法我们是依据矩形的起始、结束位置进行分类、求算，那么我们还可以使用另一种方法求算：按照组合矩阵的高度从低到高求解，然后取最大。我们知道，在给定的一组矩阵中，如果取高度为最低的那一个，那么宽度必然可取数组的长度。如，给定的一个数组[2,1,2]，那么当我们取高度为 1 ，那么宽度必然可取 3 。此时组合矩阵的面积是 3 。这时，组合矩阵取得是最低高度 1 。那么接下来，如果取一个更高的高度，那么这个高度为 1 的小矩阵必然不会包含在内，所以下一步要组成的矩阵必然在这个 1 的左边或者右边，这样一来，我们就可以看作，这个高度为 1 的小矩阵将整个矩阵序列分割成了两部分，我们下一步要判断的组合矩阵就在左部或者右部，如此一下，我们只需要求左右两部中能够组成的最大面积就好了，于是，一个数组[2,1,2]被最小值1分割成了两个数组[2]和[2]，如此一来，求[2,1,2]的解的问题变成了求[2]的解，而[2]的解只有一个 2 ，以此类推，我们就可以将任意一个大的问题分解成若干个小的问题，然后在这几个小问题中求最大值即可。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">largestRectangleArea2</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> largest(heights, <span class="number">0</span>, heights.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">largest</span><span class="params">(<span class="keyword">int</span>[] heights, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (start == end) <span class="keyword">return</span> heights[start];</span><br><span class="line">    <span class="keyword">boolean</span> sorted = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> min = start;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start+<span class="number">1</span>; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (heights[i] &lt; heights[i-<span class="number">1</span>]) sorted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (heights[i] &lt; heights[min]) min = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sorted) &#123;</span><br><span class="line">        <span class="keyword">int</span> max = heights[start] * (end - start + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start+<span class="number">1</span>; i &lt;= end; i++) &#123;</span><br><span class="line">            max = Math.max(max, heights[i] * (end - i + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(Math.max(largest(heights, start, min-<span class="number">1</span>), largest(heights, min+<span class="number">1</span>, end)),</span><br><span class="line">            heights[min] * (end - start + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个数组而言，可能成为最大值的解有三个：</p><ul><li>最小值左部的某个解</li><li>最小值右部的某个解</li><li>包含当前最小值的解</li></ul><p>另外，上面的方法中，通过判断当前的子数组是否是一个有序数组，来简化这个数组的判断，上面仅判断了由小到大的顺序，还可以通过判断是否是一个由大到小的顺序进一步提高判断效率。此算法的时间复杂度为O(n*log n)。</p><h3 id="S3-利用栈"><a href="#S3-利用栈" class="headerlink" title="S3:利用栈"></a>S3:利用栈</h3><p>​        第一种方法的外层遍历，是组合矩阵的结束位置，然后在内层逐个遍历组合矩阵的开始位置。通过对这样一个模型的分析，对于以位置 i 结束的组合矩阵来说，它与当前位置之前的矩阵的高度有一定关系：<br>如果 i 位置的高度大于 i-1 位置的高度，则在与这个位置之前的矩阵的组合中，不能以当前位置的高度作为组合矩阵的高度。如数组[1,2]，那么对于位置 2 来说，这两个位置的组合不能以 2 作为组合矩阵高度。<br>如果 i 位置的高度不大于 i-1 位置的高度，则存在高度为当前高度的组合矩阵。如数组[2，1]，对于位置 1 ，有一种组合方法[1,1]，所以在这种情况下应该判断一下。<br>​        另外，我们知道，对于一个高度递增的数组来说，很容易求出其组合矩阵的最大面积，那么是否可以将任意一个矩阵转化为一个高度递增的矩阵序列？如将一个数组[2,3,1,3,5]变成[1,1,1,3,5]，但是这个过程中对 2 作了改变，我们要通过一定办法弥补这里的改变，一种方法是，在作改变前，将其能够组成的组合矩阵的最大面积记录下来，完了之后便可以对其做出改变了。对于上面那个例子，实际上我们是对两个递增的数组求解：[2,3]和[1,1,1,3,5]，而它们之间的最大解必然与[2,3,1,3,5]的解相同。于是，将一个不规则数组转化为若干有序数组，再进行求解，便是本方法的思想。下面是利用栈的一种实现，利用栈的话不需要对原数据进行修改，而是直接将原数组截取成多个有序数组，通过保存索引值确定当前的组合矩阵的宽度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">largestRectangleArea3</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> n = heights.length;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty() &amp;&amp; (i &gt;= n || heights[stack.peek()] &gt; heights[i])) &#123;</span><br><span class="line">            <span class="keyword">int</span> top = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> h = heights[top];</span><br><span class="line">            <span class="keyword">int</span> w = stack.empty() ? i : (i-stack.peek()-<span class="number">1</span>);</span><br><span class="line">            max = Math.max(max, h*w);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="S4-最长宽度法"><a href="#S4-最长宽度法" class="headerlink" title="S4:最长宽度法"></a>S4:最长宽度法</h3><p>我们知道，由多个矩阵组成的组合矩阵，其宽度为矩阵的数量，高度为矩阵中高度最低的那一个。所以，对于任意一个位置的矩阵，假设此时的组合矩阵高度为当前位置矩阵的高度，我们只需要求出这时的组合矩阵的最大宽度，便可以求出以当前矩阵的高度为高度的组合矩阵的最大面积，那么我们只需要求出每一个位置能够形成的最大解，便能够得到本题的解。要求出某个位置的最大解，如 i ，可以这样理解，从数组[0,…,n]中找到最大的一段[start,…,i,…end]，并且在这段中，位置 i 处的高度最低，那么此时这段矩阵组成的组合矩阵的面积必然是(end-start) * heights[i]。所以我们要在位置 i 的左边找到一段[start,…,i]，是的这里面每一个矩阵的高度都大于等于 i 处的高度，同理，还要在 i 的右边找到一段[i,…end]，找到这些之后，位置 i 处的解就可以求得了。所以，对于每一个位置，只要找到在 i 的左边第一个小于 i 处高度的位置 start ，再找到 i 的右边第一个小于 i 处高度的位置 end 便可。而这个数据可以通过两个遍历求解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">largestRectangleArea4</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = heights.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] leftLess = <span class="keyword">new</span> <span class="keyword">int</span>[n], rightLess = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="comment">// find left</span></span><br><span class="line">    leftLess[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = i-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p &gt;= <span class="number">0</span> &amp;&amp; heights[i] &lt;= heights[p]) &#123;</span><br><span class="line">                p -= leftLess[p] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                leftLess[i] = i - p - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// find right</span></span><br><span class="line">    rightLess[n-<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p &lt; n &amp;&amp; heights[i] &lt;= heights[p]) &#123;</span><br><span class="line">                p += rightLess[p] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rightLess[i] = p - <span class="number">1</span> - i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        max = Math.max(max, heights[i] * (leftLess[i] + rightLess[i] + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用一个数组 leftLess 保存每个位置的左边高度大于当前位置高度的矩阵数量，rightLess 同理。具体的求解方法为：对于位置 i ，如果 i-1 处的高度大于 i 处的高度，那么因为leftLess[i-1]保存的是大于位置 i-1 处高度的数量，那么这些位置的高度必然也大于位置 i 处的高度，所以，我们可以直接跳过1 + leftLess[i-1]个位置，判断下一个位置 p 处的高度是否大于 i 处的高度，如果还是大于，那么还要继续跳过leftLess[p] + 1个位置，再判断…直到 p 处的高度小于 i 处的高度，此时在 i 的左边比 i 处高度大的矩阵的数量就是i - p - 1个。对于 rightLess 的求解同理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/largest-rectangle-in-histogram/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/largest-rectangle-in-histogram/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>堆排序Java实现</title>
    <link href="http://changsk.top/2019/07/20/heapSort/"/>
    <id>http://changsk.top/2019/07/20/heapSort/</id>
    <published>2019-07-20T07:54:58.000Z</published>
    <updated>2019-07-20T07:57:57.393Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//创建堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (array.length) / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapAdjust(array, i, array.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调整堆,将最大的节点放在堆尾，然后从根节点重新调整</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[<span class="number">0</span>];</span><br><span class="line">        array[<span class="number">0</span>] = array[i];</span><br><span class="line">        array[i] = temp;</span><br><span class="line">        heapAdjust(array, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapAdjust</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> s, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp, i;</span><br><span class="line">temp = array[s];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span> * s; i &lt; len; i *= <span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(i &lt; len - <span class="number">1</span> &amp;&amp; array[i] &lt; array[i + <span class="number">1</span>])</span><br><span class="line">            ++i;</span><br><span class="line">        <span class="keyword">if</span>(temp &gt;= array[i]) <span class="keyword">break</span>;</span><br><span class="line">        array[s] = array[i];</span><br><span class="line">        s = i;</span><br><span class="line">    &#125;</span><br><span class="line">    array[s] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
    
      <category term="排序" scheme="http://changsk.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-机器人的运动范围</title>
    <link href="http://changsk.top/2019/07/19/jianzhioffer-robot-motion-range/"/>
    <id>http://changsk.top/2019/07/19/jianzhioffer-robot-motion-range/</id>
    <published>2019-07-19T10:21:02.000Z</published>
    <updated>2019-07-19T10:32:02.883Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p><a id="more"></a><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><p>典型的<code>BFS</code>就可以解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">//保存最终的结果，即可以到达多少个格子</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] seen = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];  <span class="comment">//判断是否被遍历过</span></span><br><span class="line">        backtrack(threshold, rows, cols, seen, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//从 [0][0] 开始遍历</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//direction</span></span><br><span class="line">    <span class="keyword">int</span>[] dirx = &#123;<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] diry = &#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">boolean</span>[][] seen, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= rows || j &lt; <span class="number">0</span> || j &gt;= cols || seen[i][j] || (sumBit(i) + sumBit(j)) &gt; threshold) <span class="keyword">return</span>;</span><br><span class="line">        seen[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">//从当前节点开始，依次遍历上下左右四个方向（方向的顺序对结果没有影响）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="number">4</span>;k++)</span><br><span class="line">            backtrack(threshold, rows, cols, seen, i + dirx[k], j + diry[k]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sumBit</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i != <span class="number">0</span>)&#123;</span><br><span class="line">            sum += i % <span class="number">10</span>;</span><br><span class="line">            i /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="http://changsk.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="http://changsk.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-矩阵中的路径</title>
    <link href="http://changsk.top/2019/07/19/jianzhioffer-path-in-the-matrix/"/>
    <id>http://changsk.top/2019/07/19/jianzhioffer-path-in-the-matrix/</id>
    <published>2019-07-19T10:05:26.000Z</published>
    <updated>2019-07-19T10:10:05.811Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p><a id="more"></a><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>其实这个题不难的，典型的回溯法就可以解决：从数组某个点出发，判断是否和路径首字母相同。如果相同的话，则依次遍历这个点的上下左右四个方向是否和路径的第二个字母相同，相同的话继续。不同的话，回溯到上个节点。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//matrix是用一维数组表示的二维数组，没有看清楚</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] seen = <span class="keyword">new</span> <span class="keyword">boolean</span>[matrix.length]; <span class="comment">//记录数组各元素有没有被遍历，题目要求每个元素最多出现一次。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; rows;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; cols;j++)&#123;</span><br><span class="line">                <span class="comment">//每个元素都可能符合要求</span></span><br><span class="line">                <span class="keyword">if</span>(backtrack(matrix, rows, cols, str, seen, i, j, <span class="number">0</span>) == <span class="keyword">true</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方向：下上左右</span></span><br><span class="line">    <span class="keyword">int</span>[] dirx = &#123;<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] diry = &#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    判断从 i 行 j 列元素开始是否存在一条路径和题目给出的路径中的第 curr 位开始到结束相同</span></span><br><span class="line"><span class="comment">    matrix:原始一维数组</span></span><br><span class="line"><span class="comment">    rows:一维数字的行</span></span><br><span class="line"><span class="comment">    cols:一维数字的列</span></span><br><span class="line"><span class="comment">    str:题目给出的路径</span></span><br><span class="line"><span class="comment">    seen:matrix数组中每个元素是否被遍历过</span></span><br><span class="line"><span class="comment">    i:当前元素的行</span></span><br><span class="line"><span class="comment">    j:当前元素的列</span></span><br><span class="line"><span class="comment">    curr:题目给出路径的下标</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str, <span class="keyword">boolean</span>[] seen, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> curr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = i * cols + j; <span class="comment">//i行j列元素在数组中的下标</span></span><br><span class="line">        <span class="keyword">if</span>(curr == str.length) <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//判断完毕，说明存在一条路径</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= rows || j &lt; <span class="number">0</span> || j &gt;= cols || seen[idx] || matrix[idx] != str[curr]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> res = <span class="keyword">false</span>;</span><br><span class="line">        seen[idx] = <span class="keyword">true</span>;</span><br><span class="line">        curr++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="number">4</span>;k++)&#123;</span><br><span class="line">        <span class="comment">//判断当前元素上下左右四个方向是否和题目给出路径的curr + 1 为相同</span></span><br><span class="line">            res |= backtrack(matrix, rows, cols, str, seen, i + dirx[k], j + diry[k], curr); <span class="comment">//注意，这里不能用++curr *****     </span></span><br><span class="line">        &#125;</span><br><span class="line">        seen[idx] = <span class="keyword">false</span>; <span class="comment">//注意:这个代码不可以放在上一个for里面</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="http://changsk.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="http://changsk.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-滑动窗口的最大值</title>
    <link href="http://changsk.top/2019/07/19/jianzhioffer-sliding-window-max/"/>
    <id>http://changsk.top/2019/07/19/jianzhioffer-sliding-window-max/</id>
    <published>2019-07-19T09:21:47.000Z</published>
    <updated>2019-07-19T09:33:04.150Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个：<br>{[2,3,4],2,6,2,5,1}，<br>{2,[3,4,2],6,2,5,1}，<br>{2,3,[4,2,6],2,5,1}，<br>{2,3,4,[2,6,2],5,1}，<br>{2,3,4,2,[6,2,5],1}，<br>{2,3,4,2,6,[2,5,1]}</p><a id="more"></a><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="comment">//ArrayDeque, LinkedBlockingDeque, LinkedList  均继承自 Deque （double ended queue）， 均实现了双端队列 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">用一个双端队列，队列第一个位置保存当前窗口的最大值元素对应的下标，当窗口滑动一次</span></span><br><span class="line"><span class="comment">1.判断当前最大值是否过期,过期的话直接去掉最大值元素对应的下标</span></span><br><span class="line"><span class="comment">2.新增加的值从队尾开始比较，把所有比他小的值丢掉</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> begin; </span><br><span class="line">        LinkedList&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; i++)&#123;</span><br><span class="line">            begin = i - size + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(q.isEmpty())</span><br><span class="line">                q.add(i);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(begin &gt; q.peekFirst()) <span class="comment">//不好理解的话可以翻译过来：  i - size + 1 &gt; q.peekFirst() ,即 i - q.peekFirst() + 1&gt; size，因为队首保存的是最大元素的下标， i 与队首最大元素的下标差值大于 size，说明包含下标 i 的数字所在的窗口中没有目前队首保存的最大元素。所以要把当前最大元素删除。</span></span><br><span class="line">                q.pollFirst();</span><br><span class="line">         </span><br><span class="line">            <span class="keyword">while</span>((!q.isEmpty()) &amp;&amp; num[q.peekLast()] &lt;= num[i])</span><br><span class="line">                q.pollLast();</span><br><span class="line">            q.add(i);  </span><br><span class="line">            <span class="keyword">if</span>(begin &gt;= <span class="number">0</span>) <span class="comment">//满足一个窗口的大小</span></span><br><span class="line">                res.add(num[q.peekFirst()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个：&lt;br&gt;{[2,3,4],2,6,2,5,1}，&lt;br&gt;{2,[3,4,2],6,2,5,1}，&lt;br&gt;{2,3,[4,2,6],2,5,1}，&lt;br&gt;{2,3,4,[2,6,2],5,1}，&lt;br&gt;{2,3,4,2,[6,2,5],1}，&lt;br&gt;{2,3,4,2,6,[2,5,1]}&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="http://changsk.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="http://changsk.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-460:LFU Cache</title>
    <link href="http://changsk.top/2019/07/19/leetcode-460/"/>
    <id>http://changsk.top/2019/07/19/leetcode-460/</id>
    <published>2019-07-19T08:30:26.000Z</published>
    <updated>2019-07-21T10:51:08.816Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/lfu-cache/" target="_blank" rel="noopener">https://leetcode.com/problems/lfu-cache/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>题目难度：Hard</p></blockquote><p>Design and implement a data structure for <a href="https://en.wikipedia.org/wiki/Least_frequently_used" target="_blank" rel="noopener">Least Frequently Used (LFU)</a> cache. It should support the following operations: <code>get</code> and <code>put</code>.</p><p><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br><code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. For the purpose of this problem, when there is a tie (i.e., two or more keys that have the same frequency), the least <strong>recently</strong> used key would be evicted.</p><p><strong>Follow up:</strong><br>Could you do both operations in <strong>O(1)</strong> time complexity?</p><p><strong>Example:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LFUCache cache = <span class="keyword">new</span> LFUCache( <span class="number">2</span> <span class="comment">/* capacity */</span> );</span><br><span class="line"></span><br><span class="line">cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">cache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">cache.get(<span class="number">1</span>);       <span class="comment">// returns 1</span></span><br><span class="line">cache.put(<span class="number">3</span>, <span class="number">3</span>);    <span class="comment">// evicts key 2</span></span><br><span class="line">cache.get(<span class="number">2</span>);       <span class="comment">// returns -1 (not found)</span></span><br><span class="line">cache.get(<span class="number">3</span>);       <span class="comment">// returns 3.</span></span><br><span class="line">cache.put(<span class="number">4</span>, <span class="number">4</span>);    <span class="comment">// evicts key 1.</span></span><br><span class="line">cache.get(<span class="number">1</span>);       <span class="comment">// returns -1 (not found)</span></span><br><span class="line">cache.get(<span class="number">3</span>);       <span class="comment">// returns 3</span></span><br><span class="line">cache.get(<span class="number">4</span>);       <span class="comment">// returns 4</span></span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><p>代码来自<code>leetcode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//存储cache key-value对</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; vals;</span><br><span class="line">    <span class="comment">//存储每个 key 的访问频率</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; counts;</span><br><span class="line">    <span class="comment">//存储访问频率对应的 key 集合(保持 key 的插入顺序)</span></span><br><span class="line">    HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; lists;</span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line">    <span class="keyword">int</span> min = -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LFUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        cap = capacity;</span><br><span class="line">        vals = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        counts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        lists = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        lists.put(<span class="number">1</span>, <span class="keyword">new</span> LinkedHashSet&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vals.containsKey(key))</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = counts.get(key);</span><br><span class="line">        counts.put(key, count+<span class="number">1</span>);</span><br><span class="line">        lists.get(count).remove(key);</span><br><span class="line">        <span class="keyword">if</span>(count==min &amp;&amp; lists.get(count).size()==<span class="number">0</span>)</span><br><span class="line">            min++;</span><br><span class="line">        <span class="keyword">if</span>(!lists.containsKey(count+<span class="number">1</span>))</span><br><span class="line">            lists.put(count+<span class="number">1</span>, <span class="keyword">new</span> LinkedHashSet&lt;&gt;());</span><br><span class="line">        lists.get(count+<span class="number">1</span>).add(key);</span><br><span class="line">        <span class="keyword">return</span> vals.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cap&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(vals.containsKey(key)) &#123;</span><br><span class="line">            vals.put(key, value);</span><br><span class="line">            get(key);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(vals.size() &gt;= cap) &#123;</span><br><span class="line">            <span class="keyword">int</span> evit = lists.get(min).iterator().next();</span><br><span class="line">            lists.get(min).remove(evit);</span><br><span class="line">            vals.remove(evit);</span><br><span class="line">        &#125;</span><br><span class="line">        vals.put(key, value);</span><br><span class="line">        counts.put(key, <span class="number">1</span>);</span><br><span class="line">        min = <span class="number">1</span>;</span><br><span class="line">        lists.get(<span class="number">1</span>).add(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/lfu-cache/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/lfu-cache/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-栈的压入、弹出序列</title>
    <link href="http://changsk.top/2019/07/19/jianzhioffer-push-pop-sequence/"/>
    <id>http://changsk.top/2019/07/19/jianzhioffer-push-pop-sequence/</id>
    <published>2019-07-19T08:08:49.000Z</published>
    <updated>2019-07-19T08:13:54.230Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的。)</p><a id="more"></a><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>借用一个辅助的栈，遍历压栈顺序，先将第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1≠4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。</p><p>举例：</p><p>入栈1,2,3,4,5</p><p>出栈4,5,3,2,1</p><p>首先1入辅助栈，此时栈顶1≠4，继续入栈2</p><p>此时栈顶2≠4，继续入栈3</p><p>此时栈顶3≠4，继续入栈4</p><p>此时栈顶4＝4，出栈4，弹出序列向后一位，此时为5，,辅助栈里面是1,2,3</p><p>此时栈顶3≠5，继续入栈5</p><p>此时栈顶5=5，出栈5,弹出序列向后一位，此时为3，,辅助栈里面是1,2,3</p><p>….</p><p>依次执行，最后辅助栈为空。如果不为空说明弹出序列不是该栈的弹出顺序。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushA == <span class="keyword">null</span> || popA == <span class="keyword">null</span> || pushA.length != popA.length) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> popAIdx = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; pushA.length;i++)&#123;</span><br><span class="line">            stack.push(pushA[i]);</span><br><span class="line">            <span class="keyword">while</span>(!stack.empty() &amp;&amp; stack.peek() == popA[popAIdx])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                popAIdx++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stack.empty()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的。)&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="http://changsk.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="http://changsk.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-包含min函数的栈</title>
    <link href="http://changsk.top/2019/07/19/jianzhioffer-contain-min-stack/"/>
    <id>http://changsk.top/2019/07/19/jianzhioffer-contain-min-stack/</id>
    <published>2019-07-19T07:59:23.000Z</published>
    <updated>2019-07-19T08:04:58.541Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p><a id="more"></a><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack.push(node);</span><br><span class="line">        <span class="keyword">if</span>(minStack.isEmpty()) &#123;</span><br><span class="line">            minStack.push(node);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node &lt;= min())&#123;</span><br><span class="line">            minStack.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> node = stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(node == min())</span><br><span class="line">            minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="http://changsk.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="http://changsk.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>二叉树前序中序后序遍历的非递归写法</title>
    <link href="http://changsk.top/2019/07/19/binary-tree-traversal-non-recursive/"/>
    <id>http://changsk.top/2019/07/19/binary-tree-traversal-non-recursive/</id>
    <published>2019-07-19T03:38:04.000Z</published>
    <updated>2019-07-19T07:49:39.415Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树前序中序后序遍历的递归遍历非常简单，这里就写一下非递归的方法。<br>核心思路是把每一个结点看成父节点，叶子结点是左右孩子是null的父结点。</p><a id="more"></a><h2 id="前序遍历-中左右"><a href="#前序遍历-中左右" class="headerlink" title="前序遍历(中左右)"></a>前序遍历(中左右)</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用一个栈来存储结点，以便回到之前的父结点。</p><ol><li><p>不断往左子树深入并不断先打印值再入栈直到左叶子的空左孩子</p></li><li><p>弹出栈顶，将指针指向它的右孩子</p></li><li><p>循环1,2步骤直至栈为空且指针也为空（意思是当栈为空但指针不为空时，继续。比如当栈顶元素是二叉树的根节点时，就会出现这种情况，此时指针指向根结点的右孩子，但是栈为空）</p></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!s.isEmpty() || root != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.print(root.val + <span class="string">" "</span>);</span><br><span class="line">            s.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.isEmpty())&#123;</span><br><span class="line">            TreeNode t = s.pop();</span><br><span class="line">            root = t.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中序遍历-左中右"><a href="#中序遍历-左中右" class="headerlink" title="中序遍历(左中右)"></a>中序遍历(左中右)</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li><p>不断往左子树深入并不断入栈直到左叶子的空左孩子</p></li><li><p>弹出栈顶，打印值，并将指针指向它的右孩子</p></li><li><p>循环1,2步骤直至栈为空且指针也为空</p></li></ol><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!s.isEmpty() || root != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            s.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.isEmpty())&#123;</span><br><span class="line">            TreeNode t = s.pop();</span><br><span class="line">            System.out.print(t.val + <span class="string">" "</span>);</span><br><span class="line">            root = t.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后续遍历-左右中"><a href="#后续遍历-左右中" class="headerlink" title="后续遍历(左右中)"></a>后续遍历(左右中)</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>后续遍历稍微复杂一些，因为当左孩子完成打印并从栈中弹出父结点的时候，此时需要判断右孩子需不需要打印，有两种情况：</p><ol><li>如果右孩子为空，或者右孩子已经完成了打印，则打印当前的结点</li><li>如果右孩子未打印过，则需要将右孩子入栈</li></ol><p>这里设置一个指针<code>last</code>来标记上一次打印的结点，这样只要判断last是不是右孩子就知道右孩子打印过没有了</p><p>具体步骤为：</p><ol><li><p>不断往左子树深入并不断入栈直到左叶子的空左孩子</p></li><li><p>弹出栈顶，如果右孩子为null或者last是右孩子，则打印当前值；如果不是，则将指针指向右孩子</p></li><li><p>循环1,2步骤直至栈为空且指针也为空</p></li></ol><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (!s.isEmpty() || root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            s.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.isEmpty())&#123;</span><br><span class="line">            TreeNode t = s.pop();</span><br><span class="line">            <span class="keyword">if</span>(t.right == <span class="keyword">null</span> || last == t.right)&#123;<span class="comment">//在这里面打印t并处理last之后，并不用处理root，因为之所以能进入这里，是因为root一定等于null，所以下一轮循环一定还能进入这里，然后弹出t的父结点做处理</span></span><br><span class="line">                System.out.print(t.val + <span class="string">" "</span>);</span><br><span class="line">                last = t;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//右孩子还没有打印过</span></span><br><span class="line">                s.push(t);<span class="comment">//因为当前结点未打印，所以要重新放回去，等右孩子打印完之后回来打印</span></span><br><span class="line">                root = t.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本文转载自：<a href="https://blog.csdn.net/ChaunceyChen/article/details/88592559" target="_blank" rel="noopener">二叉树前序中序后序遍历的非递归写法（Java）</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二叉树前序中序后序遍历的递归遍历非常简单，这里就写一下非递归的方法。&lt;br&gt;核心思路是把每一个结点看成父节点，叶子结点是左右孩子是null的父结点。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://changsk.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>HTTP之长连接和短连接</title>
    <link href="http://changsk.top/2019/07/18/http-long-connection-short-connection/"/>
    <id>http://changsk.top/2019/07/18/http-long-connection-short-connection/</id>
    <published>2019-07-18T15:51:02.000Z</published>
    <updated>2019-07-18T16:00:03.130Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://www.jianshu.com/p/c41aa401b967" target="_blank" rel="noopener">面试-长链接与短链接</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>长链接和短链接又分别称为持续链接和非持续链接</p></blockquote><p>Web页面上通常有很多对象。有些对象较小，比如HTML文本或图标；有些对象却很大，如视频文件。对于众多小的文件，如果它们的所有请求以及响应都经过相同的TCP连接来发送，其<strong>工作效率就会提高</strong>。这种将多个请求/响应对经同一个TCP链接进行传送的方式被称为<strong>持续连接</strong>。此时，又可以分为两种情况：<strong>无流水线的持续链接</strong>和<strong>有流水线的持续链接</strong>。对于前者，仅当前面的响应已经收到时，客户机才会发出新的请求，这使每个引用对象都会引入一个RTT时延。对于后者，只要客户机遇到一个引用对象，他就发送请求，对于所有的引用的对象，只引入一个RTT时延。这种流水线的持续连接是HTTP/1.1的默认状况。<br> 而对于很大的对象，如果每个请求/响应都单独经过一条TCP连接发送，用户的感受将会更好。这种将每个请求/响应都经过一个单独的TCP连接进行发送的方式被称为<strong>非持续连接</strong>。尽管HTTP客户机和服务器在其默认方式下均使用持续连接方式，但也能将他们的配置成使用非持续连接方式。</p><a id="more"></a><h1 id="表层-HTTP"><a href="#表层-HTTP" class="headerlink" title="表层-HTTP"></a>表层-HTTP</h1><p><strong>长链接与锻炼的区别是头域：Connection。</strong><br> 在http1.0及之前都是默认方式为非持久性链接（关键词未知查不到抱歉！）。在HTTP1.1之后就将链接默认为Keep-Alive表示是持久性链接。当链接想要关闭的话就将状态字设置为close。</p><blockquote><p>题外话，这个头域还有一个作用是可以控制不再转发给代理。<br> 他的根源是控制tcp的链接状态。</p></blockquote><p>一个详细的HTTP请求：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">浏览器与服务器之间使用持续链接方式，将出现下列情况：</span><br><span class="line">（<span class="number">1</span>）HTTP客户机进程发起一个到服务器URL的TCP连接，连接服务器端口是<span class="number">80</span>，这使客户机和服务器上分别有一</span><br><span class="line">个套接字与该链接相关联。</span><br><span class="line">（<span class="number">2</span>）HTTP客户机经过它的套接字接受该请求报文，请求报文中包含了路径名/home.index。</span><br><span class="line">（<span class="number">3</span>）HTTP服务器进程经过他的套接字接受该请求报文，从其存储器（RAM或磁盘）中检索出对象/home.index；</span><br><span class="line">在一个HTTP响应报文中封装该对象，并通过其套接字向客户姐发送响应报文。</span><br><span class="line">（<span class="number">4</span>）HTTP客户机接收响应报文，分析该报文并指出封装的对象是一个HTML文件，并得到对<span class="number">8</span>个JPEG图形和<span class="number">5</span>个视</span><br><span class="line">频的共<span class="number">13</span>个引用。</span><br><span class="line">（<span class="number">5</span>）先传送基本的HTML文件，然后这<span class="number">13</span>个引用对象通过相同的TCP连接一个接一个地传送（流水线技术），直至</span><br><span class="line">该页面上的对象全部传输完毕。其中若传输每个JPEG图形文件用时tj,传输每个视频用时tv，并且忽略了HTML文</span><br><span class="line">件的传输时间，则共用时<span class="number">8</span>tj+<span class="number">5</span>tv,  且tv&gt;&gt;tj。</span><br><span class="line">（<span class="number">6</span>）若一条连接经过一定时间间隔（一个可配置的超时间隔）仍未被使用，则HTTP服务器进程通知TCP断开。</span><br></pre></td></tr></table></figure><p>在上述例子中，如果使用了非持续性连接方式，那么每个TCP连接在服务器发送一个对象后关闭，即该连接并不为其他的对象持续下来。这样一共产生了14个TCP连接。</p><blockquote><p>持久化的链接的<strong>好处</strong>在于减少了tcp链接的重复建立和断开所造成的额外开销，减轻了服务器的负载。另外，减少开销的那部分时间，使http请求和响应能够更早的结束，这样web的显示速度也就相应的提高了。<br> 采用持久化的<strong>原因</strong>是现在的页面越来越大！html中的内容需要发送多次resquest来进行接收，每次都断开tcp链接都会产生明显的开销。<br> 持久化链接固然好，但是我们要知道一个<strong>系统的链接数目</strong>是有限的。我们可以通过ulimit -n可以查看最大链接数。</p></blockquote><h1 id="本质-TCP"><a href="#本质-TCP" class="headerlink" title="本质-TCP"></a>本质-TCP</h1><h2 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h2><p>我们模拟一下TCP短连接的情况，client向server发起连接请求，server接到请求，然后双方建立连接。client向server 发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起 close操作。为什么呢，一般的server不会回复完client后立即关闭连接的，当然不排除有特殊的情况。从上面的描述看，短连接一般只会在 client/server间传递一次读写操作。<br> 短连接的<strong>优点</strong>是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段</p><h2 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h2><p>接下来我们再模拟一下长连接的情况，client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。<br> 先说一下TCP/IP详解上讲到的<strong>TCP保活</strong>功能，保活功能主要为服务器应用提供，<strong>服务器应用希望知道客户主机是否崩溃</strong>，从而可以代表客户使用资源。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将应远等待客户端的数据，保活功能就是试图在服务器端检测到这种半开放的连接。</p><blockquote><p>如果一个给定的连接在两小时内没有任何的动作，则服务器就向客户发一个探测报文段，客户主机必须处于以下4个状态之一：<br> 1.客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常的，服务器在两小时后将保活定时器复位。<br> 2.客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务端将不能收到对探测的响应，并在75秒后超时。服务器总共发送10个这样的探测 ，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。<br> 3.客户主机崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。<br> 4.客户机正常运行，但是服务器不可达，这种情况与2类似，TCP能发现的就是没有收到探查的响应。</p></blockquote><p>链接的实现就是通过socket来进行通讯的</p><p><img src="1.jpg" alt="img"></p><p><strong>长连接短连接操作过程</strong><br><strong>短连接</strong>的操作步骤是：<br>建立连接——数据传输——关闭连接…建立连接——数据传输——关闭连接<br><strong>长连接</strong>的操作步骤是：<br>建立连接——数据传输…（保持连接）…数据传输——关闭连接</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://www.jianshu.com/p/c41aa401b967&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;面试-长链接与短链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;长链接和短链接又分别称为持续链接和非持续链接&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Web页面上通常有很多对象。有些对象较小，比如HTML文本或图标；有些对象却很大，如视频文件。对于众多小的文件，如果它们的所有请求以及响应都经过相同的TCP连接来发送，其&lt;strong&gt;工作效率就会提高&lt;/strong&gt;。这种将多个请求/响应对经同一个TCP链接进行传送的方式被称为&lt;strong&gt;持续连接&lt;/strong&gt;。此时，又可以分为两种情况：&lt;strong&gt;无流水线的持续链接&lt;/strong&gt;和&lt;strong&gt;有流水线的持续链接&lt;/strong&gt;。对于前者，仅当前面的响应已经收到时，客户机才会发出新的请求，这使每个引用对象都会引入一个RTT时延。对于后者，只要客户机遇到一个引用对象，他就发送请求，对于所有的引用的对象，只引入一个RTT时延。这种流水线的持续连接是HTTP/1.1的默认状况。&lt;br&gt; 而对于很大的对象，如果每个请求/响应都单独经过一条TCP连接发送，用户的感受将会更好。这种将每个请求/响应都经过一个单独的TCP连接进行发送的方式被称为&lt;strong&gt;非持续连接&lt;/strong&gt;。尽管HTTP客户机和服务器在其默认方式下均使用持续连接方式，但也能将他们的配置成使用非持续连接方式。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://changsk.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTP" scheme="http://changsk.top/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Redis主从复制原理</title>
    <link href="http://changsk.top/2019/07/18/redis-master-slave-replication/"/>
    <id>http://changsk.top/2019/07/18/redis-master-slave-replication/</id>
    <published>2019-07-18T13:26:41.000Z</published>
    <updated>2019-07-18T13:47:48.281Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://zhuanlan.zhihu.com/p/60239657" target="_blank" rel="noopener">深入Redis：详解 Redis主从复制的原理!</a></p></blockquote><a id="more"></a><h3 id="复制过程"><a href="#复制过程" class="headerlink" title="复制过程"></a>复制过程</h3><p>复制的过程步骤如下：</p><ol><li>从节点执行 <code>slaveof</code> 命令</li><li>从节点只是<strong>保存了 slaveof 命令中主节点的信息</strong>，并没有立即发起复制</li><li>从节点内部的定时任务发现有主节点的信息，<strong>开始使用 socket 连接主节点</strong></li><li>连接建立成功后，发送 <code>ping</code> 命令，希望得到 <code>pong</code> 命令响应，否则会进行重连</li><li>如果主节点设置了权限，那么就需要进行<strong>权限验证</strong>；如果验证失败，复制终止。</li><li>权限验证通过后，进行数据同步，<strong>这是耗时最长的操作</strong>，主节点将把所有的数据全部发送给从节点。</li><li>当主节点把当前的数据同步给从节点后，便完成了复制的建立流程。接下来，<strong>主节点就会持续的把写命令发送给从节点，保证主从数据一致性</strong>。</li></ol><p><img src="1.jpg" alt="img"></p><h3 id="数据间的同步"><a href="#数据间的同步" class="headerlink" title="数据间的同步"></a>数据间的同步</h3><p>上面说的复制过程，其中有一个步骤是“同步数据集”，这个就是现在讲的‘数据间的同步’。</p><p>redis 同步有 2 个命令：<code>sync</code> 和 <code>psync</code>，前者是 redis 2.8 之前的同步命令，后者是 redis 2.8 为了优化 sync 新设计的命令。我们会重点关注 2.8 的 psync 命令。</p><p><strong>psync 命令需要 3 个组件支持：</strong><br>1.主从节点各自复制偏移量<br>2.主节点复制积压缓冲区<br>3.主节点运行 ID</p><p><strong>主从节点各自复制偏移量</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">参与复制的主从节点都会维护自身的复制偏移量。</span><br><span class="line"></span><br><span class="line">主节点在处理完写入命令后，会把命令的字节长度做累加记录，统计信息在 info replication </span><br><span class="line">中的 master_repl_offset 指标中。</span><br><span class="line"></span><br><span class="line">从节点每秒钟上报自身的的复制偏移量给主节点，因此主节点也会保存从节点的复制偏移量。</span><br><span class="line"></span><br><span class="line">从节点在接收到主节点发送的命令后，也会累加自身的偏移量，统计信息在 info replication 中。</span><br><span class="line"></span><br><span class="line">通过对比主从节点的复制偏移量，可以判断主从节点数据是否一致。</span><br></pre></td></tr></table></figure><p><strong>主节点复制积压缓冲区</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">复制积压缓冲区是一个保存在主节点的一个固定长度的先进先出的队列。默认大小 1MB。</span><br><span class="line"></span><br><span class="line">这个队列在 slave 连接是创建。这时主节点响应写命令时，不但会把命令发送给从节点，也会写入复制缓冲区。</span><br><span class="line"></span><br><span class="line">他的作用就是用于部分复制和复制命令丢失的数据补救。</span><br><span class="line"></span><br><span class="line">通过 info replication 可以看到相关信息。</span><br></pre></td></tr></table></figure><p><strong>主节点运行 ID</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">每个 redis 启动的时候，都会生成一个 40 位的运行 ID。</span><br><span class="line"></span><br><span class="line">运行 ID 的主要作用是用来识别 Redis 节点。如果使用 ip+port 的方式，那么如果主节点重启修改</span><br><span class="line">了 RDB/AOF 数据，从节点再基于偏移量进行复制将是不安全的。所以，当运行 id 变化后，从节点将</span><br><span class="line">进行全量复制。也就是说，redis 重启后，默认从节点会进行全量复制。</span><br><span class="line"></span><br><span class="line">如果在重启时不改变运行 ID 呢？</span><br><span class="line">可以通过 debug reload 命令重新加载 RDB 并保持运行 ID 不变。从而有效的避免不必要的全量复制。</span><br><span class="line">他的缺点则是：debug reload 命令会阻塞当前 Redis 节点主线程，因此对于大数据量的主节点或者</span><br><span class="line">无法容忍阻塞的节点，需要谨慎使用。</span><br><span class="line"></span><br><span class="line">一般通过故障转移机制可以解决这个问题。</span><br></pre></td></tr></table></figure><p><strong>psync 命令的使用方式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">命令格式为 `psync &#123;runId&#125; &#123;offset&#125;`</span><br><span class="line"></span><br><span class="line">runId : 从节点所复制主节点的运行 id</span><br><span class="line">offset：当前从节点已复制的数据偏移量</span><br></pre></td></tr></table></figure><p><strong>psync 执行流程：</strong></p><p><img src="2.jpg" alt="img"></p><p><strong>流程说明：</strong>从节点发送 <code>psync</code> 命令给主节点，<code>runId</code> 就是目标主节点的 ID，如果没有默认为 -1，offset 是从节点保存的<strong>复制偏移量</strong>，如果是第一次复制则为 -1.</p><p>主节点会根据 runid 和 offset 决定返回结果：</p><ul><li>如果回复 +FULLRESYNC {runId} {offset} ，那么从节点将触发全量复制流程。</li><li>如果回复 +CONTINUE，从节点将触发部分复制。</li><li>如果回复 +ERR，说明主节点不支持 2.8 的 psync 命令，将使用 sync 执行全量复制。</li></ul><p>到这里，数据之间的同步就讲的差不多了，篇幅还是比较长的。主要是针对 psync 命令相关之间的介绍。</p><h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h3><p>全量复制是 Redis 最早支持的复制方式，也是<strong>主从第一次建立复制时必须经历的的阶段</strong>。触发全量复制的命令是 sync 和 psync。之前说过，这两个命令的分水岭版本是 2.8，redis 2.8 之前使用 sync 只能执行全量不同，<strong>2.8 之后同时支持全量同步和部分同步。</strong></p><p><strong>流程如下：</strong></p><p><img src="3.jpg" alt="img"></p><p><strong>介绍一下上图步骤：</strong></p><ol><li>发送 psync 命令（sync ？ -1）</li><li>主节点根据命令返回 FULLRESYNC</li><li>从节点记录主节点 ID 和 offset</li><li><strong>主节点 bgsave 并保存 RDB 到本地</strong></li><li><strong>主节点发送 RBD 文件到从节点</strong></li><li><strong>从节点收到 RDB 文件并加载到内存中</strong></li><li>主节点在从节点接受数据的期间，将新数据保存到“<strong>复制客户端缓冲区</strong>”，当从节点加载 RDB 完毕，再发送过去。（如果从节点花费时间过长，将导致缓冲区溢出，最后全量同步失败）</li><li><strong>从节点清空数据后加载 RDB 文件，如果 RDB 文件很大，这一步操作仍然耗时，如果此时客户端访问，将导致数据不一致，可以使用配置slave-server-stale-data 关闭</strong>.</li><li><strong>从节点成功加载完 RBD 后，如果开启了 AOF，会立刻做 bgrewriteaof</strong>。</li></ol><p><strong>以上加粗的部分是整个全量同步耗时的地方。</strong></p><p><strong>注意：</strong></p><ol><li>如过 RDB 文件大于 6GB，并且是千兆网卡，Redis 的默认超时机制（60 秒），会导致全量复制失败。<strong>可以通过调大 repl-timeout 参数来解决此问题</strong>。</li><li>Redis 虽然支持无盘复制，即直接通过网络发送给从节点，但功能不是很完善，生产环境慎用。</li></ol><h3 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h3><p>当从节点正在复制主节点时，如果出现网络闪断和其他异常，从节点会让主节点补发丢失的命令数据，主节点只需要将复制缓冲区的数据发送到从节点就能够保证数据的一致性，相比较全量复制，成本小很多。</p><p><strong>步骤如下：</strong></p><p><img src="4.jpg" alt="img"></p><ol><li>当从节点出现网络中断，超过了 <code>repl-timeout</code> 时间，主节点就会中断复制连接。</li><li>主节点会将请求的数据写入到“复制积压缓冲区”，默认 1MB。</li><li>当从节点恢复，重新连接上主节点，从节点会将 offset 和主节点 id 发送到主节点</li><li>主节点校验后，<strong>如果偏移量的数后的数据在缓冲区中</strong>，就发送 cuntinue 响应 —— 表示可以进行部分复制</li><li>主节点将缓冲区的数据发送到从节点，保证主从复制进行正常状态。</li></ol><h3 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h3><p>主从节点在建立复制后，他们之间维护着<strong>长连接</strong>并<strong>彼此发送心跳命令</strong>。</p><p><strong>心跳的关键机制如下：</strong></p><ol><li>主从都有心跳检测机制，各自模拟成对方的客户端进行通信，通过 client list 命令查看复制相关客户端信息，主节点的连接状态为 flags = M，从节点的连接状态是 flags = S。</li><li><strong>主节点默认每隔 10 秒对从节点发送 ping 命令</strong>，可修改配置 repl-ping-slave-period 控制发送频率。</li><li><strong>从节点在主线程每隔一秒发送 replconf ack{offset} 命令，给主节点上报自身当前的复制偏移量</strong>。</li><li>主节点收到 replconf 信息后，判断从节点超时时间，如果超过 repl-timeout 60 秒，则判断节点下线。</li></ol><p><img src="5.jpg" alt="img"></p><p><strong>注意：</strong>为了降低主从延迟，一般把 redis 主从节点部署在相同的机房/同城机房，避免网络延迟带来的网络分区造成的心跳中断等情况。</p><h3 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h3><p><strong>主节点不但负责数据读写，还负责把写命令同步给从节点，写命令的发送过程是异步完成，也就是说主节点处理完写命令后立即返回客户度，并不等待从节点复制完成。</strong></p><p><strong>异步复制的步骤很简单，如下：</strong></p><ol><li>主节点接受处理命令</li><li>主节点处理完后返回响应结果</li><li>对于修改命令，异步发送给从节点，从节点在主线程中执行复制的命令。</li></ol><p><img src="6.jpg" alt="img"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要分析了 Redis 的复制原理，包括复制过程，数据之间的同步，全量复制的流程，部分复制的流程，心跳设计，异步复制流程。</p><p>其中，可以看出，RDB 数据之间的同步非常耗时。所以，Redis 在 2.8 版本退出了类似增量复制的 psync 命令，<strong>当 Redis 主从直接发生了网络中断，不会进行全量复制，而是将数据放到缓冲区（默认 1MB）里，在通过主从之间各自维护复制 offset 来判断缓存区的数据是否溢出</strong>，如果没有溢出，只需要发送缓冲区数据即可，成本很小，反之，则要进行全量复制，因此，控制缓冲区大小非常的重要。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/60239657&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;深入Redis：详解 Redis主从复制的原理!&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://changsk.top/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://changsk.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Linux IO模式及 select、poll、epoll详解</title>
    <link href="http://changsk.top/2019/07/17/linux-io-model/"/>
    <id>http://changsk.top/2019/07/17/linux-io-model/</id>
    <published>2019-07-17T15:12:15.000Z</published>
    <updated>2019-07-18T01:49:59.884Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">Linux IO模式及 select、poll、epoll详解</a></p></blockquote><p>同步IO和异步IO，阻塞IO和非阻塞IO分别是什么，到底有什么区别？不同的人在不同的上下文下给出的答案是不同的。所以先限定一下本文的上下文。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本文讨论的背景是Linux环境下的network IO。</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="概念说明"><a href="#概念说明" class="headerlink" title="概念说明"></a>概念说明</h1><p>在进行解释之前，首先要说明几个概念：</p><ul><li>用户空间和内核空间</li><li>进程切换</li><li>进程的阻塞</li><li>文件描述符</li><li>缓存 I/O</li></ul><h2 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h2><p>现在操作系统都是采用<strong>虚拟存储器</strong>，那么对32位操作系统而言，<strong>它的寻址空间（虚拟存储空间）为4G（2的32次方）。**</strong>操作系统的核心是内核，独立于普通的应用程序<strong>，可以访问受保护的内存空间，</strong>也有<strong>访问底层硬件设备的所有权限</strong>。为了保证用户进程不能直接操作内核（kernel），保证内核的安全操作系统将虚拟空间划分为两部分，一部分为<strong>内核空间</strong>，一部分为<strong>用户空间</strong>。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p><h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为<strong>进程切换</strong>。因此可以说，<strong>任何进程都是在操作系统内核的支持下运行的</strong>，是与内核紧密相关的。</p><p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p><ol><li>保存处理机上下文，包括程序计数器和其他寄存器。</li><li>更新PCB信息。</li><li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li><li>选择另一个进程执行，并更新其PCB。</li><li>更新内存管理的数据结构。</li><li>恢复处理机上下文。</li></ol><p>注：<strong>总而言之就是很耗资源</strong>，具体的可以参考这篇文章：<a href="http://guojing.me/linux-kernel-architecture/posts/process-switch/" target="_blank" rel="noopener">进程切换</a></p><h2 id="进程的阻塞"><a href="#进程的阻塞" class="headerlink" title="进程的阻塞"></a>进程的阻塞</h2><p>正在执行的进程，由于期待的某些事件未发生，如<strong>请求系统资源失败</strong>、等待某种操作的完成、<strong>新数据尚未到达或无新工作做</strong>等，则由系统自动执行<strong>阻塞原语(Block)</strong>，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。<code>当进程进入阻塞状态，是不占用CPU资源的</code>。</p><h2 id="文件描述符fd"><a href="#文件描述符fd" class="headerlink" title="文件描述符fd"></a>文件描述符fd</h2><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述<strong>指向文件的引用的抽象化概念</strong>。</p><p><strong>文件描述符在形式上是一个非负整数</strong>。实际上，它是一个索引值，<strong>指向内核为每一个进程所维护的该进程打开文件的记录表</strong>。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p><h2 id="缓存-I-O"><a href="#缓存-I-O" class="headerlink" title="缓存 I/O"></a>缓存 I/O</h2><p><strong>缓存 I/O 又被称作标准 I/O</strong>，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，<strong>数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</strong></p><p><strong>缓存 I/O 的缺点：</strong><br>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p><h1 id="IO模式"><a href="#IO模式" class="headerlink" title="IO模式"></a>IO模式</h1><p>刚才说了，对于一次IO访问（以<code>read</code>举例），<strong>数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间</strong>。所以说，当一个read操作发生时，它会经历两个阶段：</p><ol><li>等待数据准备 (Waiting for the data to be ready)</li><li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li></ol><p>正式因为这两个阶段，linux系统产生了下面五种网络模式的方案。</p><ul><li>阻塞 I/O（blocking IO）</li><li>非阻塞 I/O（nonblocking IO）</li><li>I/O 多路复用（ IO multiplexing）</li><li>信号驱动 I/O（ signal driven IO）</li><li>异步 I/O（asynchronous IO）</li></ul><p>注：由于signal driven IO在实际中并不常用，所以我这只提及剩下的四种IO Model。</p><h2 id="阻塞-I-O（blocking-IO）"><a href="#阻塞-I-O（blocking-IO）" class="headerlink" title="阻塞 I/O（blocking IO）"></a>阻塞 I/O（blocking IO）</h2><p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：<br><img src="1.jpg" alt="clipboard.png"></p><p>当用户进程调用了<code>recvfrom</code>这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p><blockquote><p>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</p></blockquote><h2 id="非阻塞-I-O（nonblocking-IO）"><a href="#非阻塞-I-O（nonblocking-IO）" class="headerlink" title="非阻塞 I/O（nonblocking IO）"></a>非阻塞 I/O（nonblocking IO）</h2><p>linux下，可以通过设置socket使其变为<code>non-blocking</code>。当对一个non-blocking socket执行读操作时，流程是这个样子：<br><img src="2.jpg" alt="clipboard.png"></p><p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是<strong>立刻返回一个error</strong>。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p><blockquote><p>所以，nonblocking IO的特点是用户进程需要<strong>不断的主动询问</strong>kernel数据好了没有。</p></blockquote><h2 id="I-O-多路复用（-IO-multiplexing）"><a href="#I-O-多路复用（-IO-multiplexing）" class="headerlink" title="I/O 多路复用（ IO multiplexing）"></a>I/O 多路复用（ IO multiplexing）</h2><p>IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p><p><img src="3.jpg" alt="clipboard.png"></p><p><code>当用户进程调用了select，那么整个进程会被block</code>，而同时，<strong>kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</strong></p><blockquote><p>所以，I/O 多路复用的特点是通过一种机制<strong>一个进程能同时等待多个文件描述符</strong>，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</p></blockquote><p>这个图和<code>blocking IO</code>的图其实并没有太大的不同，事实上，还更差一些。因为这里<strong>需要使用两个system call</strong> (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，<strong>用select的优势在于它可以同时处理多个connection。</strong></p><p>所以，如果处理的连接数不是很高的话，使用<code>select/epoll</code>的web server不一定比使用<code>multi-threading + blocking IO</code>的web server性能更好，可能延迟还更大。<strong>select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</strong></p><p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。<strong>只不过process是被select这个函数block</strong>，而不是被socket IO给block。</p><h2 id="异步-I-O（asynchronous-IO）"><a href="#异步-I-O（asynchronous-IO）" class="headerlink" title="异步 I/O（asynchronous IO）"></a>异步 I/O（asynchronous IO）</h2><p>inux下的asynchronous IO其实用得很少。先看一下它的流程：<br><img src="4.jpg" alt="clipboard.png"></p><p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个<code>asynchronous read</code>之后，首先它会<strong>立刻返回</strong>，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，<strong>kernel会给用户进程发送一个signal，告诉它read操作完成了。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="blocking和non-blocking的区别"><a href="#blocking和non-blocking的区别" class="headerlink" title="blocking和non-blocking的区别"></a>blocking和non-blocking的区别</h3><p>调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</p><h3 id="synchronous-IO和asynchronous-IO的区别"><a href="#synchronous-IO和asynchronous-IO的区别" class="headerlink" title="synchronous IO和asynchronous IO的区别"></a>synchronous IO和asynchronous IO的区别</h3><p>在说明<code>synchronous IO</code>和<code>asynchronous IO</code>的区别之前，需要先给出两者的定义。POSIX的定义是这样子的：</p><ul><li>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;</li><li>An asynchronous I/O operation does not cause the requesting process to be blocked;</li></ul><p>两者的区别就在于<strong>synchronous IO做”IO operation”的时候会将process阻塞</strong>。按照这个定义，之前所述的<strong>blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</strong></p><p>有人会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，<strong>定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call</strong>。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。</p><p>而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p><p><strong>各个IO Model的比较如图所示：</strong><br><img src="5.jpg" alt="clipboard.png"></p><p>通过上面的图片，可以发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p><h1 id="I-O-多路复用之select、poll、epoll详解"><a href="#I-O-多路复用之select、poll、epoll详解" class="headerlink" title="I/O 多路复用之select、poll、epoll详解"></a>I/O 多路复用之select、poll、epoll详解</h1><p><strong>select，poll，epoll都是IO多路复用的机制</strong>。I/O多路复用就是通过一种机制，<strong>一个进程可以监视多个描述符</strong>，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但<strong>select，poll，epoll本质上都是同步I/O</strong>，因为他们<strong>都需要在读写事件就绪后自己负责进行读写</strong>，也就是说这个<strong>读写过程是阻塞的</strong>，<strong>而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</strong>（这里啰嗦下）</p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>select 函数监视的文件描述符分3类，分别是<code>writefds</code>、<code>readfds</code>、和<code>exceptfds</code>。<strong>调用select后函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。</strong></p><p>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一 个缺点在于<strong>单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024</strong>，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但 是这样也会造成效率的降低。</p><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="keyword">short</span> events; <span class="comment">/* requested events to watch */</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">/* returned events witnessed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。同时，<strong>pollfd并没有最大数量限制</strong>（但是数量过大后性能也是会下降）。 和select函数一样，<strong>poll返回后，需要轮询pollfd来获取就绪的描述符。</strong></p><blockquote><p>从上面看，select和poll都需要在返回后，<code>通过遍历文件描述符来获取已经就绪的socket</code>。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p></blockquote><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，<strong>没有描述符限制</strong>。<strong>epoll使用一个文件描述符管理多个描述符</strong>，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p><h3 id="epoll操作过程"><a href="#epoll操作过程" class="headerlink" title="epoll操作过程"></a>epoll操作过程</h3><p>epoll操作过程需要三个接口，分别如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>1. int epoll_create(int size);</strong><br>创建一个epoll的句柄，<strong>size用来告诉内核这个监听的数目一共有多大</strong>，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，<code>参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议</code>。当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p><p><strong>2. int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</strong><br>函数是对指定描述符fd执行op操作。</p><ul><li>epfd：是epoll_create()的返回值。</li><li>op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。</li><li>fd：是需要监听的fd（文件描述符）</li><li>epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">  <span class="keyword">__uint32_t</span> events;  <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;  <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//events可以是以下几个宏的集合：</span></span><br><span class="line">EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</span><br><span class="line">EPOLLOUT：表示对应的文件描述符可以写；</span><br><span class="line">EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</span><br><span class="line">EPOLLERR：表示对应的文件描述符发生错误；</span><br><span class="line">EPOLLHUP：表示对应的文件描述符被挂断；</span><br><span class="line">EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</span><br><span class="line">EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</span><br></pre></td></tr></table></figure><p><strong>3. int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</strong><br>等待epfd上的io事件，最多返回maxevents个事件。<br>参数events用来表示<strong>从内核得到事件的集合</strong>，<strong>maxevents告之内核这个events有多大</strong>，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p><h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><p>　epoll对文件描述符的操作有两种模式：<strong>LT（level trigger）</strong>和<strong>ET（edge trigger）</strong>。LT模式是默认模式，LT模式与ET模式的区别如下：<br>　　<strong>LT模式</strong>：当<code>epoll_wait</code>检测到描述符事件发生并将此事件通知应用程序，<code>应用程序可以不立即处理该事件</code>。下次调用epoll_wait时，会再次响应应用程序并通知此事件。<br>　　<strong>ET模式</strong>：当<code>epoll_wait</code>检测到描述符事件发生并将此事件通知应用程序，<code>应用程序必须立即处理该事件</code>。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p><h4 id="1-LT模式"><a href="#1-LT模式" class="headerlink" title="1. LT模式"></a>1. LT模式</h4><p><strong>LT(level triggered)是缺省的工作方式</strong>，并且同时支持<code>block</code>和<code>no-block socket</code>.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。<strong>如果你不作任何操作，内核还是会继续通知你的。</strong></p><h4 id="2-ET模式"><a href="#2-ET模式" class="headerlink" title="2. ET模式"></a>2. ET模式</h4><p>ET(edge-triggered)是<strong>高速工作方式</strong>，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</p><p><strong>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。</strong>epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p><h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h4><p><strong>假如有这样一个例子：</strong></p><ol><li>我们已经把一个用来从管道中读取数据的文件句柄(RFD)添加到epoll描述符</li><li>这个时候从管道的另一端被写入了2KB的数据</li><li>调用epoll_wait(2)，并且它会返回RFD，说明它已经准备好读取操作</li><li>然后我们读取了1KB的数据</li><li>调用epoll_wait(2)……</li></ol><p><strong>LT模式：</strong><br>如果是LT模式，那么在第5步调用epoll_wait(2)之后，仍然能受到通知。</p><p><strong>ET模式：</strong><br>如果我们在第1步将RFD添加到epoll描述符的时候使用了EPOLLET标志，那么在第5步调用epoll_wait(2)之后将有可能会挂起，因为<strong>剩余的数据还存在于文件的输入缓冲区内</strong>，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候 ET 工作模式才会汇报事件。因此在第5步的时候，调用者可能会放弃等待仍在存在于文件输入缓冲区内的剩余数据。</p><p>当使用epoll的ET模型来工作时，当产生了一个EPOLLIN事件后，读数据的时候需要考虑的是当recv()返回的大小如果等于请求的大小，那么很有可能是缓冲区还有数据未读完，也意味着该次事件还没有处理完，所以还需要再次读取：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(rs)&#123;</span><br><span class="line">  buflen = recv(activeevents[i].data.fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(buflen &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 由于是非阻塞的模式,所以当errno为EAGAIN时,表示当前缓冲区已无数据可读</span></span><br><span class="line">    <span class="comment">// 在这里就当作是该次事件已处理处.</span></span><br><span class="line">    <span class="keyword">if</span>(errno == EAGAIN)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(buflen == <span class="number">0</span>)&#123;</span><br><span class="line">     <span class="comment">// 这里表示对端的socket已正常关闭.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(buflen == <span class="keyword">sizeof</span>(buf)&#123;</span><br><span class="line">      rs = <span class="number">1</span>;   <span class="comment">// 需要再次读取</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span>&#123;</span><br><span class="line">      rs = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Linux中的EAGAIN含义</strong></p></blockquote><p>Linux环境下开发经常会碰到很多错误(设置errno)，其中EAGAIN是其中比较常见的一个错误(比如用在非阻塞操作中)。<br>从字面上来看，是提示再试一次。这个错误经常出现在当应用程序进行一些非阻塞(non-blocking)操作(对文件或socket)的时候。</p><p>例如，以 O_NONBLOCK的标志打开文件/socket/FIFO，如果你连续做read操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返回，read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试。<br>又例如，当一个系统调用(比如fork)因为没有足够的资源(比如虚拟内存)而执行失败，返回EAGAIN提示其再调用一次(也许下次就能成功)。</p><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><p>下面是一段不完整的代码且格式不对，意在表述上面的过程，去掉了一些模板代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPADDRESS   <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT        8787</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE     1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTENQ     5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FDSIZE      1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLEVENTS 100</span></span><br><span class="line"></span><br><span class="line">listenfd = socket_bind(IPADDRESS,PORT);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">EPOLLEVENTS</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个描述符</span></span><br><span class="line">epollfd = epoll_create(FDSIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加监听描述符事件</span></span><br><span class="line">add_event(epollfd,listenfd,EPOLLIN);</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环等待</span></span><br><span class="line"><span class="keyword">for</span> ( ; ; )&#123;</span><br><span class="line">    <span class="comment">//该函数返回已经准备好的描述符事件数目</span></span><br><span class="line">    ret = epoll_wait(epollfd,events,EPOLLEVENTS,<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">//处理接收到的连接</span></span><br><span class="line">    handle_events(epollfd,events,ret,listenfd,buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_events</span><span class="params">(<span class="keyword">int</span> epollfd,struct epoll_event *events,<span class="keyword">int</span> num,<span class="keyword">int</span> listenfd,<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">     <span class="keyword">int</span> fd;</span><br><span class="line">     <span class="comment">//进行遍历;这里只要遍历已经准备好的io事件。num并不是当初epoll_create时的FDSIZE。</span></span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; num;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         fd = events[i].data.fd;</span><br><span class="line">        <span class="comment">//根据描述符的类型和事件类型进行处理</span></span><br><span class="line">         <span class="keyword">if</span> ((fd == listenfd) &amp;&amp;(events[i].events &amp; EPOLLIN))</span><br><span class="line">            handle_accpet(epollfd,listenfd);</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)</span><br><span class="line">            do_read(epollfd,fd,buf);</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT)</span><br><span class="line">            do_write(epollfd,fd,buf);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加事件</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_event</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> state)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = state;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    epoll_ctl(epollfd,EPOLL_CTL_ADD,fd,&amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理接收到的连接</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_accpet</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> listenfd)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> clifd;     </span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span>     </span><br><span class="line">     <span class="keyword">socklen_t</span>  cliaddrlen;     </span><br><span class="line">     clifd = accept(listenfd,(struct sockaddr*)&amp;cliaddr,&amp;cliaddrlen);     </span><br><span class="line">     <span class="keyword">if</span> (clifd == <span class="number">-1</span>)         </span><br><span class="line">     perror(<span class="string">"accpet error:"</span>);     </span><br><span class="line">     <span class="keyword">else</span> &#123;         </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"accept a new client: %s:%d\n"</span>,inet_ntoa(cliaddr.sin_addr),cliaddr.sin_port);                       <span class="comment">//添加一个客户描述符和事件         </span></span><br><span class="line">         add_event(epollfd,clifd,EPOLLIN);     </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读处理</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_read</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">char</span> *buf)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nread;</span><br><span class="line">    nread = read(fd,buf,MAXSIZE);</span><br><span class="line">    <span class="keyword">if</span> (nread == <span class="number">-1</span>)     &#123;         </span><br><span class="line">        perror(<span class="string">"read error:"</span>);         </span><br><span class="line">        close(fd); <span class="comment">//记住close fd        </span></span><br><span class="line">        delete_event(epollfd,fd,EPOLLIN); <span class="comment">//删除监听 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)     &#123;         </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"client close.\n"</span>);</span><br><span class="line">        close(fd); <span class="comment">//记住close fd       </span></span><br><span class="line">        delete_event(epollfd,fd,EPOLLIN); <span class="comment">//删除监听 </span></span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">else</span> &#123;         </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"read message is : %s"</span>,buf);        </span><br><span class="line">        <span class="comment">//修改描述符对应的事件，由读改为写         </span></span><br><span class="line">        modify_event(epollfd,fd,EPOLLOUT);     </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写处理</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_write</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">char</span> *buf)</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">int</span> nwrite;     </span><br><span class="line">    nwrite = write(fd,buf,<span class="built_in">strlen</span>(buf));     </span><br><span class="line">    <span class="keyword">if</span> (nwrite == <span class="number">-1</span>)&#123;         </span><br><span class="line">        perror(<span class="string">"write error:"</span>);        </span><br><span class="line">        close(fd);   <span class="comment">//记住close fd       </span></span><br><span class="line">        delete_event(epollfd,fd,EPOLLOUT);  <span class="comment">//删除监听    </span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        modify_event(epollfd,fd,EPOLLIN); </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="number">0</span>,MAXSIZE); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除事件</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete_event</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = state;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    epoll_ctl(epollfd,EPOLL_CTL_DEL,fd,&amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改事件</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modify_event</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> state)</span></span>&#123;     </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = state;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    epoll_ctl(epollfd,EPOLL_CTL_MOD,fd,&amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注：另外一端我就省了</span></span><br></pre></td></tr></table></figure><h3 id="epoll总结"><a href="#epoll总结" class="headerlink" title="epoll总结"></a>epoll总结</h3><p>在 select/poll中，<strong>进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描</strong>，而<strong>epoll事先通过epoll_ctl()来注册一 个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait() 时便得到通知</strong>。(<code>此处去掉了遍历文件描述符，而是通过监听回调的的机制</code>。这正是epoll的魅力所在。)</p><p><strong>epoll的优点主要是一下几个方面：</strong></p><ol><li><strong>监视的描述符数量不受限制</strong>，<strong>它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右</strong>，具体数目可以<code>cat /proc/sys/fs/file-max</code>查看,一般来说这个数目和系统内存关系很大。<strong>select的最大缺点就是进程打开的fd是有数量限制的</strong>。这对于连接数量比较大的服务器来说根本不能满足。虽然也可以选择多进程的解决方案( Apache就是这样实现的)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完美的方案。</li><li><strong>IO的效率不会随着监视fd的数量的增长而下降</strong>。epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的。只有就绪的fd才会执行回调函数。</li></ol><blockquote><p>如果没有大量的idle -connection或者dead-connection，epoll的效率并不会比select/poll高很多，但是当遇到大量的idle- connection，就会发现epoll的效率大大高于select/poll。</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.cnblogs.com/Anker/p/3269106.html" target="_blank" rel="noopener">用户空间与内核空间，进程上下文与中断上下文[总结]</a><br><a href="http://guojing.me/linux-kernel-architecture/posts/process-switch/" target="_blank" rel="noopener">进程切换</a><br><a href="https://zh.wikipedia.org/wiki/文件描述符" target="_blank" rel="noopener">维基百科-文件描述符</a><br><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-directio/" target="_blank" rel="noopener">Linux 中直接 I/O 机制的介绍</a><br><a href="http://blog.csdn.net/historyasamirror/article/details/5778378" target="_blank" rel="noopener">IO - 同步，异步，阻塞，非阻塞 （亡羊补牢篇）</a><br><a href="http://www.cnblogs.com/bigwangdi/p/3182958.html" target="_blank" rel="noopener">Linux中select poll和epoll的区别</a><br><a href="http://www.cnblogs.com/Anker/archive/2013/08/14/3258674.html" target="_blank" rel="noopener">IO多路复用之select总结</a><br><a href="http://www.cnblogs.com/Anker/archive/2013/08/15/3261006.html" target="_blank" rel="noopener">IO多路复用之poll总结</a><br><a href="http://www.cnblogs.com/Anker/archive/2013/08/17/3263780.html" target="_blank" rel="noopener">IO多路复用之epoll总结</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://segmentfault.com/a/1190000003063859&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux IO模式及 select、poll、epoll详解&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同步IO和异步IO，阻塞IO和非阻塞IO分别是什么，到底有什么区别？不同的人在不同的上下文下给出的答案是不同的。所以先限定一下本文的上下文。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;本文讨论的背景是Linux环境下的network IO。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://changsk.top/categories/Linux/"/>
    
    
      <category term="select" scheme="http://changsk.top/tags/select/"/>
    
      <category term="poll" scheme="http://changsk.top/tags/poll/"/>
    
      <category term="epoll" scheme="http://changsk.top/tags/epoll/"/>
    
  </entry>
  
  <entry>
    <title>Java CAS 原理剖析</title>
    <link href="http://changsk.top/2019/07/17/java-cas/"/>
    <id>http://changsk.top/2019/07/17/java-cas/</id>
    <published>2019-07-17T12:30:31.000Z</published>
    <updated>2019-07-17T12:42:16.225Z</updated>
    
    <content type="html"><![CDATA[<p>在Java并发中，我们最初接触的应该就是<code>synchronized</code>关键字了，但是<code>synchronized</code>属于重量级锁，很多时候会引起<strong>性能问题</strong>，<code>volatile</code>也是个不错的选择，但是<code>volatile</code><strong>不能保证原子性</strong>，只能在某些场合下使用。</p><a id="more"></a><p>像<code>synchronized</code>这种独占锁属于<strong>悲观锁</strong>，它是在假设一定会发生冲突的，那么加锁恰好有用，除此之外，还有<strong>乐观锁</strong>，乐观锁的含义就是假设没有发生冲突，那么我正好可以进行某项操作，如果要是发生冲突呢，那我就<strong>重试直到成功</strong>，乐观锁最常见的就是<code>CAS</code>。</p><p>我们在读<code>Concurrent</code>包下的类的源码时，发现无论是<strong>ReenterLock内部的AQS，还是各种Atomic开头的原子类</strong>，内部都应用到了<code>CAS</code>，最常见的就是我们在并发编程时遇到的<code>i++</code>这种情况。传统的方法肯定是在方法上加上<code>synchronized</code>关键字:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种方法在性能上可能会差一点，我们还可以使用<code>AtomicInteger</code>，就可以保证<code>i</code>原子的<code>++</code>了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AtomicInteger i;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看<code>getAndIncrement</code>的内部：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再深入到<code>getAndAddInt</code>():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们见到<code>compareAndSwapInt</code>这个函数，它也是<code>CAS</code>缩写的由来。那么仔细分析下这个函数做了什么呢？</p><p>首先我们发现<code>compareAndSwapInt</code>前面的<code>this</code>，那么它属于哪个类呢，我们看上一步<code>getAndAddInt</code>，前面是<code>unsafe</code>。这里我们进入的<code>Unsafe</code>类。这里要对<code>Unsafe</code>类做个说明。结合<code>AtomicInteger</code>的定义来说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6214790243416807050L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>在<code>AtomicInteger</code>数据定义的部分，我们可以看到，其实实际存储的值是放在<code>value</code>中的，除此之外我们还获取了<code>unsafe</code>实例，并且定义了<code>valueOffset</code>。再看到<code>static</code>块，懂类加载过程的都知道，<code>static</code>块的加载发生于类加载的时候，是最先初始化的，这时候我们调用<code>unsafe</code>的<code>objectFieldOffset</code>从<code>Atomic</code>类文件中获取<code>value</code>的偏移量，那么<code>valueOffset</code>其实就是记录<code>value</code>的偏移量的。</p><p>再回到上面一个函数<code>getAndAddInt</code>，我们看<code>var5</code>获取的是什么，通过调用<code>unsafe</code>的<code>getIntVolatile(var1, var2)</code>，这是个native方法，具体实现到JDK源码里去看了，其实就是获取<code>var1</code>中，<code>var2</code>偏移量处的值。<code>var1</code>就是<code>AtomicInteger</code>，<code>var2</code>就是我们前面提到的<code>valueOffset</code>,这样我们就从内存里获取到现在<code>valueOffset</code>处的值了。</p><p>现在重点来了，<code>compareAndSwapInt（var1, var2, var5, var5 + var4）</code>其实换成<code>compareAndSwapInt（obj, offset, expect, update）</code>比较清楚，意思就是如果<code>obj</code>内的<code>value</code>和<code>expect</code>相等，就<strong>证明没有其他线程改变过这个变量</strong>，那么就更新它为<code>update</code>，如果这一步的<code>CAS</code>没有成功，那就采用<strong>自旋</strong>的方式继续进行<code>CAS</code>操作，取出乍一看这也是两个步骤了啊，其实在<code>JNI</code>里是借助于一个<code>CPU</code>指令完成的。所以还是原子操作。</p><h2 id="CAS底层原理"><a href="#CAS底层原理" class="headerlink" title="CAS底层原理"></a>CAS底层原理</h2><p>CAS底层使用<code>JNI</code>调用C代码实现的，如果你有<code>Hotspot</code>源码，那么在<code>Unsafe.cpp</code>里可以找到它的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> JNINativeMethod methods_15[] = &#123;</span><br><span class="line">    <span class="comment">//省略一堆代码...</span></span><br><span class="line">    &#123;CC<span class="string">"compareAndSwapInt"</span>,  CC<span class="string">"("</span>OBJ<span class="string">"J"</span><span class="string">"I"</span><span class="string">"I"</span><span class="string">")Z"</span>,      FN_PTR(Unsafe_CompareAndSwapInt)&#125;,</span><br><span class="line">    &#123;CC<span class="string">"compareAndSwapLong"</span>, CC<span class="string">"("</span>OBJ<span class="string">"J"</span><span class="string">"J"</span><span class="string">"J"</span><span class="string">")Z"</span>,      FN_PTR(Unsafe_CompareAndSwapLong)&#125;,</span><br><span class="line">    <span class="comment">//省略一堆代码...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以看到<code>compareAndSwapInt</code>实现是在<code>Unsafe_CompareAndSwapInt</code>里面，再深入到<code>Unsafe_CompareAndSwapInt</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_CompareAndSwapInt"</span>);</span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure><p>p是取出的对象，addr是p中offset处的地址，最后调用了<code>Atomic::cmpxchg(x, addr, e)</code>, 其中参数x是即将更新的值，参数e是原内存的值。代码中能看到cmpxchg有基于各个平台的实现，这里我选择Linux X86平台下的源码分析：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> jint     Atomic::cmpxchg    (jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value) &#123;</span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><br><span class="line">  __<span class="function">asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">4</span>) <span class="string">"cmpxchgl %1,(%3)"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"=a"</span> (exchange_value)</span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"r"</span> (exchange_value), <span class="string">"a"</span> (compare_value), <span class="string">"r"</span> (dest), <span class="string">"r"</span> (mp)</span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> exchange_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一段小汇编，<code>__asm__</code>说明是ASM汇编，<code>__volatile__</code>禁止编译器优化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Adding a lock prefix to an instruction on MP machine</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_IF_MP(mp) <span class="meta-string">"cmp $0, "</span> #mp <span class="meta-string">"; je 1f; lock; 1: "</span></span></span><br></pre></td></tr></table></figure><p><code>os::is_MP</code>判断当前系统是否为多核系统，如果是就给<strong>总线加锁</strong>，<strong>所以同一芯片上的其他处理器就暂时不能通过总线访问内存，保证了该指令在多处理器环境下的原子性。</strong></p><p>在正式解读这段汇编前，我们来了解下嵌入汇编的基本格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">asm ( assembler template</span><br><span class="line">    : output operands                  /* optional */</span><br><span class="line">    : input operands                   /* optional */</span><br><span class="line">    : list of clobbered registers      /* optional */</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><ul><li><strong>template</strong>就是<code>cmpxchgl %1,(%3)</code>表示汇编模板</li><li><strong>output operands</strong>表示输出操作数,<code>=a</code>对应eax寄存器</li><li><strong>input operand</strong> 表示输入参数，<code>%1</code> 就是<code>exchange_value</code>, <code>%3</code>是<code>dest</code>, <code>%4</code>就是<code>mp</code>， <code>r</code>表示任意寄存器，<code>a</code>还是<code>eax</code>寄存器</li><li><strong>list of clobbered registers</strong>就是些额外参数，<code>cc</code>表示编译器<code>cmpxchgl</code>的执行将影响到标志寄存器, <code>memory</code>告诉编译器要重新从内存中读取变量的最新值，这点实现了<code>volatile</code>的感觉。</li></ul><p>那么表达式其实就是<code>cmpxchgl exchange_value ,dest</code>，我们会发现<code>%2</code>也就是<code>compare_value</code>没有用上，这里就要分析<code>cmpxchgl</code>的语义了。<code>cmpxchgl</code>末尾<code>l</code>表示操作数长度为<code>4</code>，上面已经知道了。<code>cmpxchgl</code>会默认比较<code>eax</code>寄存器的值即<code>compare_value</code>和<code>exchange_value</code>的值，<strong>如果相等，就把dest的值赋值给exchange_value,否则，将exchange_value赋值给eax</strong>。具体汇编指令可以查看Intel手册<a href="https://link.juejin.im?target=http%3A%2F%2Ffaydoc.tripod.com%2Fcpu%2Fcmpxchg.htm" target="_blank" rel="noopener">CMPXCHG</a></p><p><strong>最终，JDK通过CPU的<code>cmpxchgl</code>指令的支持，实现<code>AtomicInteger</code>的<code>CAS</code>操作的原子性。</strong></p><h2 id="CAS-的问题"><a href="#CAS-的问题" class="headerlink" title="CAS 的问题"></a>CAS 的问题</h2><ol><li><strong>ABA问题</strong></li></ol><p>CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。这就是CAS的ABA问题。 <strong>常见的解决思路是使用版本号</strong>。<strong>在变量前面追加上版本号</strong>，每次变量更新的时候把版本号加一，那么<code>A-B-A</code> 就会变成<code>1A-2B-3A</code>。 目前在JDK的atomic包里提供了一个类<code>AtomicStampedReference</code>来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，<strong>并且当前标志是否等于预期标志</strong>，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><ol start="2"><li><strong>循环时间长开销大</strong></li></ol><p>上面我们说过如果CAS不成功，则会原地自旋，如果长时间自旋会给CPU带来非常大的执行开销。</p><blockquote><p>作者：卡巴拉的树</p><p>链接：<a href="https://juejin.im/post/5a73cbbff265da4e807783f5" target="_blank" rel="noopener">https://juejin.im/post/5a73cbbff265da4e807783f5</a></p><p>来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Java并发中，我们最初接触的应该就是&lt;code&gt;synchronized&lt;/code&gt;关键字了，但是&lt;code&gt;synchronized&lt;/code&gt;属于重量级锁，很多时候会引起&lt;strong&gt;性能问题&lt;/strong&gt;，&lt;code&gt;volatile&lt;/code&gt;也是个不错的选择，但是&lt;code&gt;volatile&lt;/code&gt;&lt;strong&gt;不能保证原子性&lt;/strong&gt;，只能在某些场合下使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://changsk.top/categories/Java/"/>
    
    
      <category term="java" scheme="http://changsk.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>构造回文</title>
    <link href="http://changsk.top/2019/07/17/longest-common-subsequence/"/>
    <id>http://changsk.top/2019/07/17/longest-common-subsequence/</id>
    <published>2019-07-17T12:08:12.000Z</published>
    <updated>2019-07-17T12:16:21.082Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://blog.csdn.net/zr1076311296/article/details/51723040" target="_blank" rel="noopener">腾讯2017暑期实习生笔试题</a>、</p></blockquote><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="1.jpg" alt></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>看到这个图的时候相信大家明白了吧，就是这个题，我一直没有思路，今天突然想起来了，所以就准备解决它。其实这个题主要是运用一个算法思路来解决，最长公共子序列。</p><pre><code>仔细想一想，将字符串逆序后与原来的字符串求最长公共子序列不就是这个构造回文吗？这应该很好理解吧，下面简单科普一下最长公共子序列：这中序列不是连续的，意思是可以有间隔，去掉那些干扰项以后，两个序列完全相同，而且要求这个子序列最长。这类问题和之前 leetcode 上机器人跳到最右下角那个题一样，是一种动态规划的题。而且这种问题的当前位置的解受前面位置的解的影响，假设 s1，s2为两个字符串，i表示s1中第i个字符，j表示s2中第j个字符，那么:</code></pre><p><img src="2.jpg" alt></p><p>再一次说明一下解题思路：<strong>输入字符串S，将字符串S逆序，逆序后的字符串为tmp，然后求S与tmp的最长公共子序列，最后用S的长度减去最长公共子序列的长度，就是需要删除的元素的个数</strong>。 相信思路大家明白思路了，下面给出代码。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LongestStrHui</span><span class="params">(<span class="built_in">string</span> &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> tmp = s;</span><br><span class="line"><span class="comment">//逆序</span></span><br><span class="line">reverse(tmp.begin(), tmp.end());</span><br><span class="line"><span class="keyword">int</span> len = s.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化二维数组,数组多开辟了一些空间，是为了优化</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; V(len + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">//根据"公式"开始去找各个位置的公共子序列长度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] == tmp[j])</span><br><span class="line">V[i + <span class="number">1</span>][j + <span class="number">1</span>] = <span class="number">1</span> + V[i][j];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">V[i + <span class="number">1</span>][j + <span class="number">1</span>] = max(V[i][j + <span class="number">1</span>], V[i + <span class="number">1</span>][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//整个序列的最长公共子序列</span></span><br><span class="line"><span class="keyword">return</span> len - V[len][len];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; LongestStrHui(s)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://blog.csdn.net/zr1076311296/article/details/51723040&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;腾讯2017暑期实习生笔试题&lt;/a&gt;、&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>linux之top</title>
    <link href="http://changsk.top/2019/07/17/linux-top/"/>
    <id>http://changsk.top/2019/07/17/linux-top/</id>
    <published>2019-07-17T02:38:17.000Z</published>
    <updated>2019-07-17T03:01:12.484Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://www.cnblogs.com/peida/archive/2012/12/24/2831353.html" target="_blank" rel="noopener">每天一个linux命令（44）：top命令</a></p></blockquote><p>top命令是Linux下常用的<strong>性能分析工具</strong>，能够<strong>实时显示系统中各个进程的资源占用状况</strong>，类似于Windows的任务管理器。下面详细介绍它的使用方法。top是一个<strong>动态显示</strong>过程,即可以<strong>通过用户按键来不断刷新当前状态</strong>.如果在前台执行该命令,它将独占前台,直到用户终止该程序为止.比较准确的说,top命令提供了实时的对系统处理器的状态监视.它将<strong>显示系统中CPU最“敏感”的任务列表</strong>.该命令可以<strong>按CPU使用.内存使用和执行时间对任务进行排序</strong>；而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定.</p><a id="more"></a><p><strong>1．命令格式：</strong></p><p>top [参数]</p><p><strong>2．命令功能：</strong></p><p>显示当前系统正在执行的进程的相关信息，包括<strong>进程ID</strong>、<strong>内存占用率</strong>、<strong>CPU占用率</strong>等</p><p><strong>3．命令参数：</strong></p><p>-b 批处理</p><p>-c 显示完整的治命令</p><p>-I 忽略失效过程</p><p>-s 保密模式</p><p>-S 累积模式</p><p>-i&lt;时间&gt; 设置间隔时间</p><p>-u&lt;用户名&gt; 指定用户名</p><p>-p&lt;进程号&gt; 指定进程</p><p>-n&lt;次数&gt; 循环显示的次数</p><p><strong>4．使用实例：</strong></p><p><strong>实例1：显示进程信息</strong></p><p><strong>命令：</strong></p><p>top</p><p><strong>输出：</strong></p><p>[root@TG1704 log]# top</p><p>top - 14:06:23 up 70 days, 16:44,  2 users,  load average: 1.25, 1.32, 1.35</p><p>Tasks: 206 total,   1 running, 205 sleeping,   0 stopped,   0 zombie</p><p>Cpu(s):  5.9%us,  3.4%sy,  0.0%ni, 90.4%id,  0.0%wa,  0.0%hi,  0.2%si,  0.0%st</p><p>Mem:  32949016k total, 14411180k used, 18537836k free,   169884k buffers</p><p>Swap: 32764556k total,        0k used, 32764556k free,  3612636k cached</p><p>  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                                                                </p><p>28894 root      22   0 1501m 405m  10m S 52.2  1.3   2534:16 java                                                                   </p><p>18249 root      18   0 3201m 1.9g  11m S 35.9  6.0 569:39.41 java                                                                   </p><p> 2808 root      25   0 3333m 1.0g  11m S 24.3  3.1 526:51.85 java                                                                   </p><p>25668 root      23   0 3180m 704m  11m S 14.0  2.2 360:44.53 java                                                                   </p><p>  574 root      25   0 3168m 611m  10m S 12.6  1.9 556:59.63 java                                                                   </p><p> 1599 root      20   0 3237m 1.9g  11m S 12.3  6.2 262:01.14 java                                                                   </p><p> 1008 root      21   0 3147m 842m  10m S  0.3  2.6   4:31.08 java                                                                   </p><p>13823 root      23   0 3031m 2.1g  10m S  0.3  6.8 176:57.34 java                                                                   </p><p>28218 root      15   0 12760 1168  808 R  0.3  0.0   0:01.43 top                                                                    </p><p>29062 root      20   0 1241m 227m  10m S  0.3  0.7   2:07.32 java                                                                   </p><p>​    1 root      15   0 10368  684  572 S  0.0  0.0   1:30.85 init                                                                   </p><p>​    2 root      RT  -5     0    0    0 S  0.0  0.0   0:01.01 migration/0                                                            </p><p>​    3 root      34  19     0    0    0 S  0.0  0.0   0:00.00 ksoftirqd/0                                                            </p><p>​    4 root      RT  -5     0    0    0 S  0.0  0.0   0:00.00 watchdog/0                                                             </p><p>​    5 root      RT  -5     0    0    0 S  0.0  0.0   0:00.80 migration/1                                                            </p><p>​    6 root      34  19     0    0    0 S  0.0  0.0   0:00.00 ksoftirqd/1                                                            </p><p>​    7 root      RT  -5     0    0    0 S  0.0  0.0   0:00.00 watchdog/1                                                             </p><p>​    8 root      RT  -5     0    0    0 S  0.0  0.0   0:20.59 migration/2                                                            </p><p>​    9 root      34  19     0    0    0 S  0.0  0.0   0:00.09 ksoftirqd/2                                                            </p><p>   10 root      RT  -5     0    0    0 S  0.0  0.0   0:00.00 watchdog/2                                                             </p><p>   11 root      RT  -5     0    0    0 S  0.0  0.0   0:23.66 migration/3                                                            </p><p>   12 root      34  19     0    0    0 S  0.0  0.0   0:00.03 ksoftirqd/3                                                            </p><p>   13 root      RT  -5     0    0    0 S  0.0  0.0   0:00.00 watchdog/3                                                             </p><p>   14 root      RT  -5     0    0    0 S  0.0  0.0   0:20.29 migration/4                                                            </p><p>   15 root      34  19     0    0    0 S  0.0  0.0   0:00.07 ksoftirqd/4                                                            </p><p>   16 root      RT  -5     0    0    0 S  0.0  0.0   0:00.00 watchdog/4                                                             </p><p>   17 root      RT  -5     0    0    0 S  0.0  0.0   0:23.07 migration/5                                                            </p><p>   18 root      34  19     0    0    0 S  0.0  0.0   0:00.07 ksoftirqd/5                                                            </p><p>   19 root      RT  -5     0    0    0 S  0.0  0.0   0:00.00 watchdog/5                                                             </p><p>   20 root      RT  -5     0    0    0 S  0.0  0.0   0:17.16 migration/6                                                            </p><p>   21 root      34  19     0    0    0 S  0.0  0.0   0:00.05 ksoftirqd/6                                                            </p><p>   22 root      RT  -5     0    0    0 S  0.0  0.0   0:00.00 watchdog/6                                                             </p><p>   23 root      RT  -5     0    0    0 S  0.0  0.0   0:58.28 migration/7</p><p><strong>说明：</strong></p><p><strong>统计信息区</strong>：</p><p>前五行是<strong>当前系统情况整体的统计信息区</strong>。下面我们看每一行信息的具体意义。</p><p><strong>第一行</strong>，任务队列信息，同 uptime 命令的执行结果，具体参数说明情况如下：</p><p>14:06:23 — 当前系统时间</p><p>up 70 days, 16:44 — 系统已经运行了70天16小时44分钟（在这期间系统没有重启过的吆！）</p><p>2 users — 当前有2个用户登录系统</p><p>load average: 1.15, 1.42, 1.44 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。</p><p><strong>load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了</strong>。</p><p><strong>第二行</strong>，Tasks — 任务（进程），具体信息说明如下：</p><p>系统现在共有206个进程，其中处于运行中的有1个，205个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。</p><p><strong>第三行</strong>，cpu状态信息，具体属性说明如下：</p><p>5.9%us — 用户空间占用CPU的百分比。</p><p>3.4% sy — 内核空间占用CPU的百分比。</p><p>0.0% ni — 改变过优先级的进程占用CPU的百分比</p><p>90.4% id — 空闲CPU百分比</p><p>0.0% wa — IO等待占用CPU的百分比</p><p>0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比</p><p>0.2% si — 软中断（Software Interrupts）占用CPU的百分比</p><p><strong>备注：</strong>在这里CPU的使用比率和windows概念不同，需要理解linux系统用户空间和内核空间的相关知识！</p><p><strong>第四行</strong>,内存状态，具体信息如下：</p><p>32949016k total — 物理内存总量（32GB）</p><p>14411180k used — 使用中的内存总量（14GB）</p><p>18537836k free — 空闲内存总量（18GB）</p><p>169884k buffers — 缓存的内存量 （169M）</p><p><strong>第五行，</strong>swap交换分区信息，具体信息说明如下：</p><p>32764556k total — 交换区总量（32GB）</p><p>0k used — 使用的交换区总量（0K）</p><p>32764556k free — 空闲交换区总量（32GB）</p><p>3612636k cached — 缓冲的交换区总量（3.6GB）</p><p><strong>备注：</strong></p><p>第四行中使用中的内存总量（used）指的是现在系统内核控制的内存数，<strong>空闲内存总量（free）是内核还未纳入其管控范围的数量</strong>。纳入内核管理的内存不见得都在使用中，还包括过去使用过的现在可以被重复利用的内存，内核并不把这些可被重新使用的内存交还到free中去，因此在linux上free内存会越来越少，但不用为此担心。</p><p>如果出于习惯去计算可用内存数，这里有个近似的计算公式：<code>第四行的free + 第四行的buffers + 第五行的cached</code>，按这个公式此台服务器的可用内存：18537836k +169884k +3612636k = 22GB左右。</p><p><strong>对于内存监控，在top里我们要时刻监控第五行swap交换分区的used，如果这个数值在不断的变化，说明内核在不断进行内存和swap的数据交换，这是真正的内存不够用了。</strong></p><p><strong>第六行，空行。</strong></p><p><strong>第七行以下：各进程（任务）的状态监控，项目列信息说明如下：</strong></p><p><strong>PID — 进程id</strong></p><p><strong>USER — 进程所有者</strong></p><p>PR — 进程优先级</p><p>NI — nice值。负值表示高优先级，正值表示低优先级</p><p>VIRT — <strong>进程使用的虚拟内存总量</strong>，单位kb。VIRT=SWAP+RES</p><p>RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</p><p>SHR — 共享内存大小，单位kb</p><p>S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</p><p>%CPU — 上次更新到现在的CPU时间占用百分比</p><p>%MEM — 进程使用的物理内存百分比</p><p>TIME+ — 进程使用的CPU时间总计，单位1/100秒</p><p>COMMAND — 进程名称（命令名/命令行）</p><p><strong>其他使用技巧：</strong></p><p><strong>1.</strong>多U多核CPU监控</p><p>在top基本视图中，按键盘数字“1”，可监控每个逻辑CPU的状况：</p><p>​    <img src="1.jpg" alt="img"> </p><p>观察上图，服务器有16个逻辑CPU，实际上是4个物理CPU。再按数字键1，就会返回到top基本视图界面。</p><p><strong>2.</strong>高亮显示当前运行进程</p><p>​    敲击键盘“b”（打开/关闭加亮效果），top的视图变化如下：</p><p>​       <img src="2.jpg" alt="img">  </p><p>我们发现进程id为2570的“top”进程被加亮了，top进程就是视图第二行显示的唯一的运行态（running）的那个进程，可以通过敲击“y”键关闭或打开运行态进程的加亮效果。</p><p><strong>3.</strong>进程字段排序</p><p>默认进入top时，各进程是按照<strong>CPU的占用量</strong>来排序的，在下图中进程ID为28894的java进程排在第一（cpu占用142%），进程ID为574的java进程排在第二（cpu占用16%）。</p><p>​      <img src="3.jpg" alt="img"></p><p>​    敲击键盘“x”（打开/关闭排序列的加亮效果），top的视图变化如下：</p><p>​      <img src="4.jpg" alt="img">     </p><p>可以看到，top默认的排序列是“%CPU”。</p><p>*<em>4. *</em>通过”shift + &gt;”或”shift + &lt;”可以向右或左改变排序列</p><p>​    下图是按一次”shift + &gt;”的效果图,视图现在已经按照%MEM来排序。</p><p>​       <img src="5.jpg" alt="img">     </p><p><strong>5.top交互命令</strong></p><p>在top 命令执行过程中可以使用的一些交互命令。这些命令都是单字母的，如果在命令行中使用了s 选项， 其中一些命令可能会被屏蔽。</p><p>h 显示帮助画面，给出一些简短的命令总结说明</p><p>k 终止一个进程。</p><p>i 忽略闲置和僵死进程。这是一个开关式命令。</p><p>q 退出程序</p><p>r 重新安排一个进程的优先级别</p><p>S 切换到累计模式</p><p>s 改变两次刷新之间的延迟时间（单位为s），如果有小数，就换算成m s。输入0值则系统将不断刷新，<strong>默认值是5 s</strong></p><p>f或者F 从当前显示中添加或者删除项目</p><p>o或者O 改变显示项目的顺序</p><p>l 切换显示平均负载和启动时间信息</p><p>m 切换显示内存信息</p><p>t 切换显示进程和CPU状态信息</p><p>c 切换显示命令名称和完整命令行</p><p>M 根据驻留内存大小进行排序</p><p>P 根据CPU使用百分比大小进行排序</p><p>T 根据时间/累计时间进行排序</p><p>W 将当前设置写入~/.toprc文件中 </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://www.cnblogs.com/peida/archive/2012/12/24/2831353.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;每天一个linux命令（44）：top命令&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;top命令是Linux下常用的&lt;strong&gt;性能分析工具&lt;/strong&gt;，能够&lt;strong&gt;实时显示系统中各个进程的资源占用状况&lt;/strong&gt;，类似于Windows的任务管理器。下面详细介绍它的使用方法。top是一个&lt;strong&gt;动态显示&lt;/strong&gt;过程,即可以&lt;strong&gt;通过用户按键来不断刷新当前状态&lt;/strong&gt;.如果在前台执行该命令,它将独占前台,直到用户终止该程序为止.比较准确的说,top命令提供了实时的对系统处理器的状态监视.它将&lt;strong&gt;显示系统中CPU最“敏感”的任务列表&lt;/strong&gt;.该命令可以&lt;strong&gt;按CPU使用.内存使用和执行时间对任务进行排序&lt;/strong&gt;；而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定.&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://changsk.top/categories/Linux/"/>
    
    
      <category term="Linux命令" scheme="http://changsk.top/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
</feed>
