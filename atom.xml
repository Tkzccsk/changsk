<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>changsk&#39;s blogs</title>
  
  <subtitle>chang.sk@foxmail.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://changsk.top/"/>
  <updated>2019-09-22T09:03:11.175Z</updated>
  <id>http://changsk.top/</id>
  
  <author>
    <name>changsk</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode-129:Sum Root to Leaf Numbers</title>
    <link href="http://changsk.top/2019/09/22/leetcode-129/"/>
    <id>http://changsk.top/2019/09/22/leetcode-129/</id>
    <published>2019-09-22T09:01:06.000Z</published>
    <updated>2019-09-22T09:03:11.175Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">https://leetcode.com/problems/sum-root-to-leaf-numbers/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>题目难度：Medium</strong></p><p>Given a binary tree containing digits from <code>0-9</code> only, each root-to-leaf path could represent a number.</p><p>An example is the root-to-leaf path <code>1-&gt;2-&gt;3</code> which represents the number <code>123</code>.</p><p>Find the total sum of all root-to-leaf numbers.</p><p><strong>Note:</strong> A leaf is a node with no children.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line">Output: 25</span><br><span class="line">Explanation:</span><br><span class="line">The root-to-leaf path 1-&gt;2 represents the number 12.</span><br><span class="line">The root-to-leaf path 1-&gt;3 represents the number 13.</span><br><span class="line">Therefore, sum = 12 + 13 = 25.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,9,0,5,1]</span><br><span class="line">    4</span><br><span class="line">   / \</span><br><span class="line">  9   0</span><br><span class="line"> / \</span><br><span class="line">5   1</span><br><span class="line">Output: 1026</span><br><span class="line">Explanation:</span><br><span class="line">The root-to-leaf path 4-&gt;9-&gt;5 represents the number 495.</span><br><span class="line">The root-to-leaf path 4-&gt;9-&gt;1 represents the number 491.</span><br><span class="line">The root-to-leaf path 4-&gt;0 represents the number 40.</span><br><span class="line">Therefore, sum = 495 + 491 + 40 = 1026.</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        sumNumbersCore(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sumNumbersCore</span><span class="params">(TreeNode root, <span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">        cur = cur * <span class="number">10</span> + root.val;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            res += cur;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">            sumNumbersCore(root.left, cur);</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">            sumNumbersCore(root.right, cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/sum-root-to-leaf-numbers/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/sum-root-to-leaf-numbers/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-126:Word Ladder II</title>
    <link href="http://changsk.top/2019/09/18/leetcode-126/"/>
    <id>http://changsk.top/2019/09/18/leetcode-126/</id>
    <published>2019-09-18T14:30:50.000Z</published>
    <updated>2019-09-19T03:17:26.327Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/word-ladder-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/word-ladder-ii/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>题目难度：Hard</strong></p><p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find all shortest transformation sequence(s) from <em>beginWord</em> to <em>endWord</em>, such that:</p><ol><li>Only one letter can be changed at a time</li><li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.</li></ol><p><strong>Note:</strong></p><ul><li>Return an empty list if there is no such transformation sequence.</li><li>All words have the same length.</li><li>All words contain only lowercase alphabetic characters.</li><li>You may assume no duplicates in the word list.</li><li>You may assume <em>beginWord</em> and <em>endWord</em> are non-empty and are not the same.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = &quot;hit&quot;,</span><br><span class="line">endWord = &quot;cog&quot;,</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = &quot;hit&quot;</span><br><span class="line">endWord = &quot;cog&quot;</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line"></span><br><span class="line">Output: []</span><br><span class="line"></span><br><span class="line">Explanation: The endWord &quot;cog&quot; is not in wordList, therefore no possible transformation.</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>代码来自：<code>LeetCode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; dict = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">        <span class="keyword">if</span>(!dict.contains(endWord))&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; begin = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; end = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        begin.add(beginWord);</span><br><span class="line">        end.add(endWord);</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        bfs(begin, end, dict, map, <span class="keyword">false</span>);</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(beginWord);</span><br><span class="line">        dfs(beginWord, endWord, res, list, map);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//function: 从 begin 中的任意元素通过变换为 dict 中的任意元素可到达 end 中的任意元素</span></span><br><span class="line">    <span class="comment">// map 表示从 key 变换一次可达的 list</span></span><br><span class="line">    <span class="comment">//reverse : false 表示从 begin 到达 end， true 表示从 end 到达 begin</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Set&lt;String&gt; begin, Set&lt;String&gt; end, Set&lt;String&gt; dict, Map&lt;String, List&lt;String&gt;&gt; map, <span class="keyword">boolean</span> reverse)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(begin.size() &gt; end.size())&#123;</span><br><span class="line">            bfs(end, begin, dict, map, !reverse);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> finish = <span class="keyword">false</span>;</span><br><span class="line">        Set&lt;String&gt; temp = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        dict.removeAll(begin);</span><br><span class="line">        <span class="keyword">for</span>(String w : begin)&#123;</span><br><span class="line">            <span class="keyword">char</span>[] array = w.toCharArray();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">                <span class="keyword">char</span> old = array[i];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; c++)&#123;</span><br><span class="line">                    array[i] = c;</span><br><span class="line">                    String newWord = <span class="keyword">new</span> String(array);</span><br><span class="line">                    <span class="keyword">if</span>(dict.contains(newWord))&#123;</span><br><span class="line">                        <span class="keyword">if</span>(end.contains(newWord))&#123;</span><br><span class="line">                            finish = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            temp.add(newWord);</span><br><span class="line">                        &#125;</span><br><span class="line">                        String key = reverse ? newWord : w;</span><br><span class="line">                        String val = reverse ? w : newWord;</span><br><span class="line">                        <span class="keyword">if</span>(!map.containsKey(key))&#123;</span><br><span class="line">                            map.put(key, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">                        &#125;</span><br><span class="line">                        map.get(key).add(val);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                array[i] = old;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!finish)&#123;</span><br><span class="line">            bfs(temp, end, dict, map, reverse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//function: 求从 begin 到达 end 的所有路径</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String begin, String end, List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; list, Map&lt;String, List&lt;String&gt;&gt; map)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin.equals(end))&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(begin))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(String str : map.get(begin))&#123;</span><br><span class="line">            list.add(str);</span><br><span class="line">            dfs(str, end, res, list, map);</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/word-ladder-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/word-ladder-ii/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-128:Longest Consecutive Sequence(最长的连续序列)</title>
    <link href="http://changsk.top/2019/09/18/leetcode-128/"/>
    <id>http://changsk.top/2019/09/18/leetcode-128/</id>
    <published>2019-09-18T14:05:02.000Z</published>
    <updated>2019-09-19T03:50:26.432Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-consecutive-sequence/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>题目难度：Hard</strong></p><p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p><p>Your algorithm should run in O(<em>n</em>) complexity.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [100, 4, 200, 1, 3, 2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> preNum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> curLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == preNum) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == preNum + <span class="number">1</span>) curLen++;</span><br><span class="line">            <span class="keyword">else</span> curLen = <span class="number">1</span>;</span><br><span class="line">            preNum = nums[i];</span><br><span class="line">            res = Math.max(res, curLen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/longest-consecutive-sequence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/longest-consecutive-sequence/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-127:Word Ladder</title>
    <link href="http://changsk.top/2019/09/18/leetcode-127/"/>
    <id>http://changsk.top/2019/09/18/leetcode-127/</id>
    <published>2019-09-18T14:00:53.000Z</published>
    <updated>2019-09-18T14:16:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/word-ladder/" target="_blank" rel="noopener">https://leetcode.com/problems/word-ladder/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>题目难度：Medium</strong></p><p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find the length of shortest transformation sequence from <em>beginWord</em> to <em>endWord</em>, such that:</p><ol><li>Only one letter can be changed at a time.</li><li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is <em>not</em> a transformed word.</li></ol><p><strong>Note:</strong></p><ul><li>Return 0 if there is no such transformation sequence.</li><li>All words have the same length.</li><li>All words contain only lowercase alphabetic characters.</li><li>You may assume no duplicates in the word list.</li><li>You may assume <em>beginWord</em> and <em>endWord</em> are non-empty and are not the same.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = &quot;hit&quot;,</span><br><span class="line">endWord = &quot;cog&quot;,</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">Output: 5</span><br><span class="line"></span><br><span class="line">Explanation: As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,</span><br><span class="line">return its length 5.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = &quot;hit&quot;</span><br><span class="line">endWord = &quot;cog&quot;</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line"></span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">Explanation: The endWord &quot;cog&quot; is not in wordList, therefore no possible transformation.</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>代码来自：<code>Leetcode</code></p><p>利用<code>BFS</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span></span>&#123;</span><br><span class="line">        Set&lt;String&gt; beginSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; endSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        beginSet.add(beginWord);</span><br><span class="line">        endSet.add(endWord);</span><br><span class="line">        Set&lt;String&gt; dict = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">        <span class="keyword">if</span> (!dict.contains(endWord)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> search(beginSet, endSet, dict,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//function: 从 beginSet 中的任意元素到达 endSet 中的任意元素的最小距离，dict 是中间转换集合， cnt是当前变换次数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">search</span> <span class="params">(Set&lt;String&gt; beginSet, Set&lt;String&gt; endSet, Set&lt;String&gt; dict, <span class="keyword">int</span> cnt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beginSet.isEmpty() || endSet.isEmpty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">        dict.removeAll(beginSet);</span><br><span class="line">        Set&lt;String&gt; nextSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String str : beginSet)&#123;</span><br><span class="line">            <span class="keyword">char</span>[] chs = str.toCharArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++)&#123;</span><br><span class="line">                <span class="keyword">char</span> c = chs[i];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> j = <span class="string">'a'</span>; j &lt; <span class="string">'z'</span>; j++)&#123;</span><br><span class="line">                    chs[i] = j;</span><br><span class="line">                    String tmp = <span class="keyword">new</span> String(chs);</span><br><span class="line">                    <span class="keyword">if</span> (!dict.contains(tmp)) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (endSet.contains(tmp)) <span class="keyword">return</span> cnt;</span><br><span class="line">                    nextSet.add(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                chs[i] = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从 nextSet 中的元素到达 endSet 中的元素，还是反过来效果都是一样的，也就是说 nextSet 和 endSet 可以互换，但是相对来说 nextSet 应该选取元素更少的集合，这样在 search 函数中就可以尽可能的减少string 的创建</span></span><br><span class="line">        <span class="keyword">return</span> endSet.size() &gt; nextSet.size() ? search(nextSet, endSet, dict, cnt) : search(endSet, nextSet, dict, cnt);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/word-ladder/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/word-ladder/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-124:Binary Tree Maximum Path Sum</title>
    <link href="http://changsk.top/2019/09/17/leetcode-124/"/>
    <id>http://changsk.top/2019/09/17/leetcode-124/</id>
    <published>2019-09-17T14:10:04.000Z</published>
    <updated>2019-09-17T15:28:56.561Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-maximum-path-sum/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>题目难度：Hard</strong></p><p>Given a <strong>non-empty</strong> binary tree, find the maximum path sum.</p><p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain <strong>at least one node</strong> and does not need to go through the root.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      / \</span><br><span class="line">     2   3</span><br><span class="line"></span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [-10,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">   -10</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">Output: 42</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>代码来自<code>Leetcode</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxValue;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        maxValue = Integer.MIN_VALUE;</span><br><span class="line">        maxPathDown(root);</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//function:求出从 node 结点开始向下延伸所经过结点的最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxPathDown</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = Math.max(<span class="number">0</span>, maxPathDown(node.left));</span><br><span class="line">        <span class="keyword">int</span> right = Math.max(<span class="number">0</span>, maxPathDown(node.right));</span><br><span class="line">        maxValue = Math.max(maxValue, left + right + node.val);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + node.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>题意及代码可参考：<a href="https://segmentfault.com/a/1190000018983149" target="_blank" rel="noopener">https://segmentfault.com/a/1190000018983149</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/binary-tree-maximum-path-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/binary-tree-maximum-path-sum/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-117:Populating Next Right Pointers in Each Node II</title>
    <link href="http://changsk.top/2019/09/16/leetcode-117/"/>
    <id>http://changsk.top/2019/09/16/leetcode-117/</id>
    <published>2019-09-16T15:25:15.000Z</published>
    <updated>2019-09-16T15:29:30.948Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>题目难度：Medium</strong></p><p>Given a binary tree</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p><p>Initially, all next pointers are set to <code>NULL</code>.</p><p><strong>Example:</strong></p><p><img src="1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;val&quot;:3&#125;,&quot;val&quot;:1&#125;</span><br><span class="line"></span><br><span class="line">Output: &#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;5&quot;&#125;,&quot;val&quot;:3&#125;,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;4&quot;&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;6&quot;&#125;,&quot;val&quot;:1&#125;</span><br><span class="line"></span><br><span class="line">Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li>You may only use constant extra space.</li><li>Recursive approach is fine, implicit stack space does not count as extra space for this problem.</li></ul><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val,Node _left,Node _right,Node _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Node head = <span class="keyword">null</span>; <span class="comment">//head of the next level</span></span><br><span class="line">        Node prev = <span class="keyword">null</span>; <span class="comment">//the leading node on the next level</span></span><br><span class="line">        Node cur = root;  <span class="comment">//current node of current level</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123; <span class="comment">//iterate on the current level</span></span><br><span class="line">                <span class="comment">//left child</span></span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prev.next = cur.left;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        head = cur.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    prev = cur.left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//right child</span></span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prev.next = cur.right;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        head = cur.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    prev = cur.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//move to next node</span></span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//move to next level</span></span><br><span class="line">            cur = head;</span><br><span class="line">            head = <span class="keyword">null</span>;</span><br><span class="line">            prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val,Node _left,Node _right,Node _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">       Node iter = root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (iter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node dummy = <span class="keyword">new</span> Node();</span><br><span class="line">            Node current = dummy;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (iter != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (iter.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    current.next = iter.left;</span><br><span class="line">                    current = current.next;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (iter.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    current.next = iter.right;</span><br><span class="line">                    current = current.next;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                iter = iter.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            iter = dummy.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-87:Scramble String</title>
    <link href="http://changsk.top/2019/09/16/leetcode-87/"/>
    <id>http://changsk.top/2019/09/16/leetcode-87/</id>
    <published>2019-09-16T02:44:56.000Z</published>
    <updated>2019-09-16T02:52:53.324Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/scramble-string/" target="_blank" rel="noopener">https://leetcode.com/problems/scramble-string/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>题目难度：Hard</strong></p><p>Given a string <em>s1</em>, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.</p><p>Below is one possible representation of <em>s1</em> = <code>&quot;great&quot;</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    great</span><br><span class="line">   /    \</span><br><span class="line">  gr    eat</span><br><span class="line"> / \    /  \</span><br><span class="line">g   r  e   at</span><br><span class="line">           / \</span><br><span class="line">          a   t</span><br></pre></td></tr></table></figure><p>To scramble the string, we may choose any non-leaf node and swap its two children.</p><p>For example, if we choose the node <code>&quot;gr&quot;</code> and swap its two children, it produces a scrambled string <code>&quot;rgeat&quot;</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    rgeat</span><br><span class="line">   /    \</span><br><span class="line">  rg    eat</span><br><span class="line"> / \    /  \</span><br><span class="line">r   g  e   at</span><br><span class="line">           / \</span><br><span class="line">          a   t</span><br></pre></td></tr></table></figure><p>We say that <code>&quot;rgeat&quot;</code> is a scrambled string of <code>&quot;great&quot;</code>.</p><p>Similarly, if we continue to swap the children of nodes <code>&quot;eat&quot;</code> and <code>&quot;at&quot;</code>, it produces a scrambled string <code>&quot;rgtae&quot;</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    rgtae</span><br><span class="line">   /    \</span><br><span class="line">  rg    tae</span><br><span class="line"> / \    /  \</span><br><span class="line">r   g  ta  e</span><br><span class="line">       / \</span><br><span class="line">      t   a</span><br></pre></td></tr></table></figure><p>We say that <code>&quot;rgtae&quot;</code> is a scrambled string of <code>&quot;great&quot;</code>.</p><p>Given two strings <em>s1</em> and <em>s2</em> of the same length, determine if <em>s2</em> is a scrambled string of <em>s1</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s1 = &quot;great&quot;, s2 = &quot;rgeat&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s1 = &quot;abcde&quot;, s2 = &quot;caebd&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isScramble</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1 == <span class="keyword">null</span> || s2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s1.equals(s2)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s1.length() != s2.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] letters = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> len = s1.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            letters[s1.charAt(i)-<span class="string">'a'</span>]++;</span><br><span class="line">            letters[s2.charAt(i)-<span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(letters[i]!= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isScramble(s1.substring(<span class="number">0</span>,i), s2.substring(<span class="number">0</span>,i)) &amp;&amp; isScramble(s1.substring(i), s2.substring(i))) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(isScramble(s1.substring(<span class="number">0</span>,i), s2.substring(len-i)) &amp;&amp; isScramble(s1.substring(i), s2.substring(<span class="number">0</span>,len-i))) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/scramble-string/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/scramble-string/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-81:Search in Rotated Sorted Array II</title>
    <link href="http://changsk.top/2019/09/15/leetcode-81/"/>
    <id>http://changsk.top/2019/09/15/leetcode-81/</id>
    <published>2019-09-15T09:48:11.000Z</published>
    <updated>2019-09-16T01:34:41.187Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/search-in-rotated-sorted-array-ii/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>题目难度：Medium</strong></p><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e., <code>[0,0,1,2,2,5,6]</code> might become <code>[2,5,6,0,0,1,2]</code>).</p><p>You are given a target value to search. If found in the array return <code>true</code>, otherwise return <code>false</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [2,5,6,0,0,1,2], target = 0</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [2,5,6,0,0,1,2], target = 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Follow up:</strong></p><ul><li>This is a follow up problem to <a href="https://leetcode.com/problems/search-in-rotated-sorted-array/description/" target="_blank" rel="noopener">Search in Rotated Sorted Array</a>, where <code>nums</code> may contain duplicates.</li><li>Would this affect the run-time complexity? How and why?</li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote><p>参考自：<a href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/discuss/28218/My-8ms-C%2B%2B-solution-(o(logn)-on-average-o(n)-worst-case)" target="_blank" rel="noopener">My 8ms C++ solution (o(logn) on average, o(n) worst case)</a></p></blockquote><p>The idea is the same as the previous one without duplicates</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1) everytime check if targe == nums[mid], if so, we find it.</span><br><span class="line">2) otherwise, we check if the first half is in order (i.e. nums[left]&lt;=nums[mid]) </span><br><span class="line">  and if so, go to step 3), otherwise, the second half is in order,   go to step 4)</span><br><span class="line">3) check if target in the range of [left, mid-1] (i.e. nums[left]&lt;=target &lt; nums[mid]), if so, do search in the first half, i.e. right = mid-1; otherwise, search in the second half left = mid+1;</span><br><span class="line">4)  check if target in the range of [mid+1, right] (i.e. nums[mid]&lt;target &lt;= nums[right]), if so, do search in the second half, i.e. left = mid+1; otherwise search in the first half right = mid-1;</span><br></pre></td></tr></table></figure><p>The only difference is that due to the existence of duplicates, we can have nums[left] == nums[mid] and in that case, the first half could be out of order (i.e. NOT in the ascending order, e.g. [3 1 2 3 3 3 3]) and we have to deal this case separately. In that case, it is guaranteed that nums[right] also equals to nums[mid], so what we can do is to check if nums[mid]== nums[left] == nums[right] before the original logic, and if so, we can move left and right both towards the middle by 1. and repeat.</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">            <span class="comment">// 这种做法比 mid = (end + start) / 2 要好，因为 end + start 的值可能会大于 int 类型的最大值</span></span><br><span class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>( (nums[start] == nums[mid]) &amp;&amp; (nums[end] == nums[mid]) ) &#123;++start; --end;&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[start] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[start] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    end = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    start = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[end]) &#123;</span><br><span class="line">                    start = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    end = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/search-in-rotated-sorted-array-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/search-in-rotated-sorted-array-ii/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-72:Edit Distance</title>
    <link href="http://changsk.top/2019/09/15/leetcode-72/"/>
    <id>http://changsk.top/2019/09/15/leetcode-72/</id>
    <published>2019-09-15T08:49:39.000Z</published>
    <updated>2019-09-15T09:07:25.311Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/edit-distance/" target="_blank" rel="noopener">https://leetcode.com/problems/edit-distance/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>题目难度：Hard</strong></p><p>Given two words <em>word1</em> and <em>word2</em>, find the minimum number of operations required to convert <em>word1</em> to <em>word2</em>.</p><p>You have the following 3 operations permitted on a word:</p><ol><li>Insert a character</li><li>Delete a character</li><li>Replace a character</li></ol><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">horse -&gt; rorse (replace &apos;h&apos; with &apos;r&apos;)</span><br><span class="line">rorse -&gt; rose (remove &apos;r&apos;)</span><br><span class="line">rose -&gt; ros (remove &apos;e&apos;)</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: </span><br><span class="line">intention -&gt; inention (remove &apos;t&apos;)</span><br><span class="line">inention -&gt; enention (replace &apos;i&apos; with &apos;e&apos;)</span><br><span class="line">enention -&gt; exention (replace &apos;n&apos; with &apos;x&apos;)</span><br><span class="line">exention -&gt; exection (replace &apos;n&apos; with &apos;c&apos;)</span><br><span class="line">exection -&gt; execution (insert &apos;u&apos;)</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>以下解释及Solution1代码均来自：<a href="https://leetcode.com/problems/edit-distance/discuss/25849/Java-DP-solution-O(nm)" target="_blank" rel="noopener">https://leetcode.com/problems/edit-distance/discuss/25849/Java-DP-solution-O(nm)</a></p></blockquote><p>Let following be the function definition :-</p><p>f(i, j) := minimum cost (or steps) required to convert first i characters of word1 to first j characters of word2</p><p>Case 1: word1[i] == word2[j], i.e. the ith the jth character matches.</p><blockquote><p>f(i, j) = f(i - 1, j - 1)</p></blockquote><p>Case 2: word1[i] != word2[j], then we must either insert, delete or replace, whichever is cheaper</p><blockquote><p>f(i, j) = 1 + min { f(i, j - 1), f(i - 1, j), f(i - 1, j - 1) }</p></blockquote><ol><li>f(i, j - 1) represents insert operation</li><li>f(i - 1, j) represents delete operation</li><li>f(i - 1, j - 1) represents replace operation</li></ol><p>Here, we consider any operation from word1 to word2. It means, when we say insert operation, we insert a new character after word1 that matches the jth character of word2. So, now have to match i characters of word1 to j - 1 characters of word2. Same goes for other 2 operations as well.</p><p>Note that the problem is symmetric. The insert operation in one direction (i.e. from word1 to word2) is same as delete operation in other. So, we could choose any direction.</p><p>Above equations become the recursive definitions for DP.</p><p>Base Case:</p><blockquote><p>f(0, k) = f(k, 0) = k</p></blockquote><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p>非递归写法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length();</span><br><span class="line">        <span class="keyword">int</span> n = word2.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] cost = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">            cost[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            cost[<span class="number">0</span>][i] = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i) == word2.charAt(j))</span><br><span class="line">                    cost[i + <span class="number">1</span>][j + <span class="number">1</span>] = cost[i][j];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> a = cost[i][j];</span><br><span class="line">                    <span class="keyword">int</span> b = cost[i][j + <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">int</span> c = cost[i + <span class="number">1</span>][j];</span><br><span class="line">                    cost[i + <span class="number">1</span>][j + <span class="number">1</span>] = a &lt; b ? (a &lt; c ? a : c) : (b &lt; c ? b : c);</span><br><span class="line">                    cost[i + <span class="number">1</span>][j + <span class="number">1</span>]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cost[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><p>递归写法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[word1.length() + <span class="number">1</span>][word2.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> minHelper(word1, word2, dp, word1.length(), word2.length());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//function: 求 dp[i][j]</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">minHelper</span><span class="params">(String word1, String word2, <span class="keyword">int</span>[][]dp, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i][j] != <span class="number">0</span>) <span class="keyword">return</span> dp[i][j];</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">return</span> dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span>) <span class="keyword">return</span> dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) </span><br><span class="line">            <span class="keyword">return</span> dp[i][j] = minHelper(word1, word2, dp, i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> insert = minHelper(word1, word2, dp, i-<span class="number">1</span>, j);</span><br><span class="line">        <span class="keyword">int</span> replace = minHelper(word1, word2, dp, i-<span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> delete = minHelper(word1, word2, dp, i, j - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> dp[i][j] = Math.min(insert,Math.min(replace,delete)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/edit-distance/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/edit-distance/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>字符串s1最少删除多少个字符使得s1包含字符串s2</title>
    <link href="http://changsk.top/2019/09/14/Minimum-number-of-deletions/"/>
    <id>http://changsk.top/2019/09/14/Minimum-number-of-deletions/</id>
    <published>2019-09-14T14:21:45.000Z</published>
    <updated>2019-09-14T14:39:13.522Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两非空字符串<code>s1</code>和<code>s2</code>，<code>s1</code>的长度大于<code>s2</code>的长度，问<code>s1</code>最少删除多少个字符使得<code>s1</code>包含字符串<code>s2</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(String s1, String s2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(s1.contains(s2)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s1.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.charAt(i) == s2.charAt(j)) j++;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span>(j == s2.length()) &#123;</span><br><span class="line">                min = Math.min(min, i - start);</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">                start = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min - s2.length();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定两非空字符串&lt;code&gt;s1&lt;/code&gt;和&lt;code&gt;s2&lt;/code&gt;，&lt;code&gt;s1&lt;/code&gt;的长度大于&lt;c
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-71:Simplify Path(简化路径/路径压缩)</title>
    <link href="http://changsk.top/2019/09/14/leetcode-71/"/>
    <id>http://changsk.top/2019/09/14/leetcode-71/</id>
    <published>2019-09-14T13:43:56.000Z</published>
    <updated>2019-09-14T14:05:54.145Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/simplify-path/" target="_blank" rel="noopener">https://leetcode.com/problems/simplify-path/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>题目难度：Medium</strong></p><p>Given an <strong>absolute path</strong> for a file (Unix-style), simplify it. Or in other words, convert it to the <strong>canonical path</strong>.</p><p>In a UNIX-style file system, a period <code>.</code> refers to the current directory. Furthermore, a double period <code>..</code> moves the directory up a level. For more information, see: <a href="https://www.linuxnix.com/abslute-path-vs-relative-path-in-linuxunix/" target="_blank" rel="noopener">Absolute path vs relative path in Linux/Unix</a></p><p>Note that the returned canonical path must always begin with a slash <code>/</code>, and there must be only a single slash <code>/</code> between two directory names. The last directory name (if it exists) <strong>must not</strong> end with a trailing <code>/</code>. Also, the canonical path must be the <strong>shortest</strong> string representing the absolute path.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;/home/&quot;</span><br><span class="line">Output: &quot;/home&quot;</span><br><span class="line">Explanation: Note that there is no trailing slash after the last directory name.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;/../&quot;</span><br><span class="line">Output: &quot;/&quot;</span><br><span class="line">Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;/home//foo/&quot;</span><br><span class="line">Output: &quot;/home/foo&quot;</span><br><span class="line">Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;/a/./b/../../c/&quot;</span><br><span class="line">Output: &quot;/c&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;/a/../../b/../c//.//&quot;</span><br><span class="line">Output: &quot;/c&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 6:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;/a//b////c/d//././/..&quot;</span><br><span class="line">Output: &quot;/a/b/c&quot;</span><br></pre></td></tr></table></figure><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = path.length();</span><br><span class="line">        <span class="keyword">while</span>(i &lt; len)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; len &amp;&amp; path.charAt(i) == <span class="string">'/'</span>) i++;</span><br><span class="line">            <span class="keyword">if</span>(i == len) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">char</span> c = path.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'.'</span> &amp;&amp; i + <span class="number">1</span> == len) <span class="keyword">break</span>; <span class="comment">// /. 结束的情况</span></span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'.'</span> &amp;&amp; j + <span class="number">1</span> &lt; len &amp;&amp; path.charAt(j + <span class="number">1</span>) == <span class="string">'/'</span>) i++; <span class="comment">// /./的情况</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'.'</span> &amp;&amp; j + <span class="number">1</span> &lt; len &amp;&amp; path.charAt(j + <span class="number">1</span>) == <span class="string">'.'</span> &amp;&amp; (j + <span class="number">2</span> == len || path.charAt(j + <span class="number">2</span>) == <span class="string">'/'</span>)) &#123; <span class="comment">// /../的情况</span></span><br><span class="line">                <span class="keyword">if</span> (list.size() != <span class="number">0</span>) list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">                i = i + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">while</span> (c != <span class="string">'/'</span>)&#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">if</span>(i == len) <span class="keyword">break</span>;</span><br><span class="line">                c = path.charAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(sb.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">"/"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; list.size();k++)</span><br><span class="line">            <span class="keyword">if</span>(k == list.size() - <span class="number">1</span>) sb.append(list.get(k));</span><br><span class="line">            <span class="keyword">else</span> sb.append(list.get(k) + <span class="string">"/"</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><p>代码来自：<a href="https://leetcode.com/problems/simplify-path/discuss/25686/Java-10-lines-solution-with-stack" target="_blank" rel="noopener">https://leetcode.com/problems/simplify-path/discuss/25686/Java-10-lines-solution-with-stack</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    Deque&lt;String&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; skip = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="string">".."</span>,<span class="string">"."</span>,<span class="string">""</span>));</span><br><span class="line">    <span class="keyword">for</span> (String dir : path.split(<span class="string">"/"</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dir.equals(<span class="string">".."</span>) &amp;&amp; !stack.isEmpty()) stack.pop();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!skip.contains(dir)) stack.push(dir);</span><br><span class="line">    &#125;</span><br><span class="line">    String res = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (String dir : stack) res = <span class="string">"/"</span> + dir + res;</span><br><span class="line">    <span class="keyword">return</span> res.isEmpty() ? <span class="string">"/"</span> : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/simplify-path/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/simplify-path/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>计算机图形学、数字图像处理、计算机视觉之间的区别与联系</title>
    <link href="http://changsk.top/2019/09/14/CV-CG-DIP/"/>
    <id>http://changsk.top/2019/09/14/CV-CG-DIP/</id>
    <published>2019-09-14T12:04:42.000Z</published>
    <updated>2019-09-14T12:28:56.542Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://www.cnblogs.com/lauzhishuai/p/6293735.html" target="_blank" rel="noopener">【学习笔记】计算机图形学、数字图像处理、计算机视觉之间的区别与联系</a></p></blockquote><p>三者之间既有区别，又有联系，不确切的描述：</p><p>计算机图形学≈画图</p><p>计算机视觉≈看图</p><p>数字图像处理≈看图前沐浴更衣焚香做好各种仪式，然后再看图</p><a id="more"></a><p><img src="1.jpg" alt="img"></p><p><strong>计算机图形学（Computer Graphics）讲的是图形，也就是图形的构造方式，是一种从无到有的概念，从数据得到图像。是给定关于景象结构、表面反射特性、光源配置及相机模型的信息，生成图像。</strong></p><p><strong>计算机视觉（Computer Vision）是给定图象，从图象提取信息，包括景象的三维结构，运动检测，识别物体等。</strong> </p><p><strong>数字图像处理（Digital Image Processing）是对已有的图像进行变换、分析、重构，得到的仍是图像。</strong></p><p><strong>模式识别（PR）本质就是分类，根据常识或样本或二者结合进行分类，可以对图像进行分类，从图像得到数据。</strong></p><p>Computer Graphics和Computer Vision是同一过程的两个方向。Computer Graphics将抽象的语义信息转化成图像，Computer Vision从图像中提取抽象的语义信息。Image Processing探索的是从一个图像或者一组图像之间的互相转化和关系，与语义信息无关。总之，计算机图形学是计算机视觉的逆问题，两者从最初相互独立的平行发展到最近的融合是一大趋势。图像模式的分类是计算机视觉中的一个重要问题，模式识别中的许多方法可以应用于计算机视觉中。</p><p>区别：<br>Computer Graphics，简称 CG 。输入的是对虚拟场景的描述，通常为多边形数组，而每个多边形由三个顶点组成，每个顶点包括三维坐标、贴图坐标、rgb颜色等。输出的是图像，即二维像素数组。<br>Computer Vision，简称 CV。输入的是图像或图像序列，通常来自相机或usb摄像头。输出的是对于图像序列对应的真实世界的理解，比如检测人脸、识别车牌。<br>Digital Image Processing，简称 DIP。输入的是图像，输出的也是图像。Photoshop中对一副图像应用滤镜就是典型的一种图像处理。常见操作有模糊、灰度化、增强对比度等。</p><p>联系：<br>CG 中也会用到 DIP，现今的三维游戏为了增加表现力都会叠加全屏的后期特效，原理就是 DIP，只是将计算量放在了显卡端。<br>CV 更是大量依赖 DIP 来打杂活，比如对需要识别的照片进行预处理。<br>最后还要提到近年来的热点——增强现实（AR），它既需要 CG，又需要 CV，当然也不会漏掉 DIP。它用 DIP 进行预处理，用 CV 进行跟踪物体的识别与姿态获取，用 CG 进行虚拟三维物体的叠加。</p><p>简单点说：1 计算机视觉，里面人工智能的东西更多一些，不仅仅是图像处理的知识，还涵盖了人工智能，机器学习等领域知识；2，计算机图形学，主要涉及图形成像及游戏类开发，如opengl等，还有就是视频渲染等；3，图像处理，这个主要针对图像图像的基本处理，如图像检索或则图像识别，压缩，复原等等操作。</p><p>计算机图形学和数字图像处理是比较老的技术。计算机视觉要迟几十年才提出。<br>计算机图形学和数字图像处理的区别在于图形和图像。<br>图形是矢量的、纯数字式的。图像常常由来自现实世界的信号产生，有时也包括图形。<br>而图像和图形都是数据的简单堆积，图像是像素的叠加，图形则是基本图元的叠加。计算机视觉要从图像中整理出一些信息或统计数据，也就是说要对计算机图像作进一步的分析。计算机图形学的研究成果可以用于产生数字图像处理所需要的素材，计算机视觉需要以数字图像处理作为基础。计算机视觉与数字图像处理的这种关系类似于物理学和数学的关系。</p><p>另外，如果不是浙江大学的或者中科院计算所的，不建议做计算机图形学这一方向，难度太大（图形比图像虽然表面上只高一维，但实际上工作量大了好多倍；其次，图像，国内外差距目前已经很小，好发重要期刊；图形，除上面两个单位和微软外，国内外差距很大，不好发重要期刊）</p><p>数字图像处理主要是对已有的图像，比如说可见光的图像、红外图像、雷达成像进行噪声滤除、边缘检测、图像恢复等处理，就像用ps 处理照片一样的。人脸识别啊、指纹识别啊、运动物体跟踪啊，都属于图像处理。去噪有各种滤波算法；其他的有各种时频变化算法，如傅里叶变化，小波变换等，有很多这方面的书籍。<br>图形学主要研究如何生成图形的，像用autoCAD作图，就是图形学中算法的应用。各种动漫软件中图形算法的生成等。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://www.cnblogs.com/lauzhishuai/p/6293735.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;【学习笔记】计算机图形学、数字图像处理、计算机视觉之间的区别与联系&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;三者之间既有区别，又有联系，不确切的描述：&lt;/p&gt;
&lt;p&gt;计算机图形学≈画图&lt;/p&gt;
&lt;p&gt;计算机视觉≈看图&lt;/p&gt;
&lt;p&gt;数字图像处理≈看图前沐浴更衣焚香做好各种仪式，然后再看图&lt;/p&gt;
    
    </summary>
    
      <category term="计算机视觉" scheme="http://changsk.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
      <category term="数字图像处理" scheme="http://changsk.top/categories/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="计算机图形学" scheme="http://changsk.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
      <category term="计算机视觉" scheme="http://changsk.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
      <category term="数字图像处理" scheme="http://changsk.top/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="计算机图形学" scheme="http://changsk.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-410:Split Array Largest Sum(分割数组最大和)</title>
    <link href="http://changsk.top/2019/09/14/leetcode-410/"/>
    <id>http://changsk.top/2019/09/14/leetcode-410/</id>
    <published>2019-09-14T03:31:39.000Z</published>
    <updated>2019-09-14T04:21:46.542Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/split-array-largest-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/split-array-largest-sum/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>题目难度：Hard</strong></p><p>Given an array which consists of non-negative integers and an integer <em>m</em>, you can split the array into <em>m</em> non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these <em>m</em> subarrays.</p><p><strong>Note:</strong><br>If <em>n</em> is the length of array, assume the following constraints are satisfied:</p><ul><li>1 ≤ <em>n</em> ≤ 1000</li><li>1 ≤ <em>m</em> ≤ min(50, <em>n</em>)</li></ul><p><strong>Examples:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums = [7,2,5,10,8]</span><br><span class="line">m = 2</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">18</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">There are four ways to split nums into two subarrays.</span><br><span class="line">The best way is to split it into [7,2,5] and [10,8],</span><br><span class="line">where the largest sum among the two subarrays is only 18.</span><br></pre></td></tr></table></figure><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><ol><li>The answer is between maximum value of input array numbers and sum of those numbers.</li><li>Use binary search to approach the correct answer. We have <code>l = max number of array; r = sum of all numbers in the array;</code>Every time we do <code>mid = (l + r) / 2;</code></li><li>Use greedy to narrow down left and right boundaries in binary search.<br>3.1 Cut the array from left.<br>3.2 Try our best to make sure that the sum of numbers between each two cuts (inclusive) is large enough but still less than <code>mid</code>.3.3 We’ll end up with two results: either we can divide the array into more than m subarrays or we cannot.<br><strong>If we can</strong>, it means that the <code>mid</code> value we pick is too small because we’ve already tried our best to make sure each part holds as many non-negative numbers as we can but we still have numbers left. So, it is impossible to cut the array into m parts and make sure each parts is no larger than <code>mid</code>. We should increase m. This leads to <code>l = mid + 1;</code><br><strong>If we can’t</strong>, it is either we successfully divide the array into m parts and the sum of each part is less than <code>mid</code>, or we used up all numbers before we reach m. Both of them mean that we should lower <code>mid</code> because we need to find the minimum one. This leads to <code>r = mid - 1;</code></li></ol><blockquote><p>参考自：<a href="https://leetcode.com/problems/split-array-largest-sum/discuss/89817/Clear-Explanation%3A-8ms-Binary-Search-Java" target="_blank" rel="noopener">https://leetcode.com/problems/split-array-largest-sum/discuss/89817/Clear-Explanation%3A-8ms-Binary-Search-Java</a></p></blockquote><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>; <span class="comment">// int 数组元素之和可能超过 int 类型的最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            max = Math.max(num, max);</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">1</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)sum;</span><br><span class="line">        <span class="comment">//binary search</span></span><br><span class="line">        <span class="keyword">long</span> l = max; <span class="keyword">long</span> r = sum;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">long</span> mid = (l + r)/ <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (valid(mid, nums, m)) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(<span class="keyword">long</span> target, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            total += num;</span><br><span class="line">            <span class="keyword">if</span> (total &gt; target) &#123;</span><br><span class="line">                total = num;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span> (count &gt; m) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考自：<a href="https://leetcode.com/problems/split-array-largest-sum/discuss/89817/Clear-Explanation%3A-8ms-Binary-Search-Java" target="_blank" rel="noopener">https://leetcode.com/problems/split-array-largest-sum/discuss/89817/Clear-Explanation%3A-8ms-Binary-Search-Java</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/split-array-largest-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/split-array-largest-sum/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>数组循环右移k位</title>
    <link href="http://changsk.top/2019/09/14/Array-loop-right-shift/"/>
    <id>http://changsk.top/2019/09/14/Array-loop-right-shift/</id>
    <published>2019-09-14T02:07:06.000Z</published>
    <updated>2019-09-14T02:39:36.496Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>将一个长度为n的数组A的元素循环右移k位,比如数组 1, 2, 3, 4, 5循环右移3位之后变成3, 4, 5, 1, 2</p><a id="more"></a><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rightShift</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || n &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        n %= arr.length;</span><br><span class="line">        reverse(arr, <span class="number">0</span>, arr.length - n - <span class="number">1</span>);</span><br><span class="line">        reverse(arr, arr.length - n, arr.length - <span class="number">1</span>);</span><br><span class="line">        reverse(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end)&#123;</span><br><span class="line">        temp = arr[start];</span><br><span class="line">        arr[start] = arr[end];</span><br><span class="line">        arr[end] = temp;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;将一个长度为n的数组A的元素循环右移k位,比如数组 1, 2, 3, 4, 5循环右移3位之后变成3, 4, 5, 1, 2&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>【微软面试题】在二叉搜索树中找最小的大于某个key值的节点</title>
    <link href="http://changsk.top/2019/09/13/Minimum-value-greater-than-k/"/>
    <id>http://changsk.top/2019/09/13/Minimum-value-greater-than-k/</id>
    <published>2019-09-13T13:01:30.000Z</published>
    <updated>2019-09-13T13:04:38.231Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://blog.csdn.net/luckyxiaoqiang/article/details/8937535" target="_blank" rel="noopener">【微软面试题】在二叉搜索树中找最小的大于某个key值的节点</a></p></blockquote><p>在二叉搜索树中找最小的大于某个key值的节点</p><p>如         8<br>      /       \</p><p>   6         12<br>  /             /   <br>2          11    14</p><p>key = 8 返回11<br>key = 1 返回2<br>key = 16 返回NULL</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代实现</span></span><br><span class="line"><span class="function">TreeNode * <span class="title">FindCeiling</span><span class="params">(TreeNode *root, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode * ceiling = <span class="literal">NULL</span>;</span><br><span class="line">    TreeNode * current = root;</span><br><span class="line">    <span class="keyword">while</span>(current)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(current-&gt;val &lt;= key)</span><br><span class="line">            current = current-&gt;right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ceiling = current;</span><br><span class="line">            current = current-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ceiling;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="function">TreeNode * <span class="title">FindCeiling</span><span class="params">(TreeNode *root, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val &lt;= key)</span><br><span class="line">        <span class="keyword">return</span> FindCeiling(root-&gt;right, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode *ceiling = FindCeiling(root-&gt;left, key);</span><br><span class="line">        <span class="keyword">return</span> ceiling ? ceiling : root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://blog.csdn.net/luckyxiaoqiang/article/details/8937535&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;【微软面试题】在二叉搜索树中找最小的大于某个key值的节点&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在二叉搜索树中找最小的大于某个key值的节点&lt;/p&gt;
&lt;p&gt;如
         8&lt;br&gt;      /       \&lt;/p&gt;
&lt;p&gt;   6         12&lt;br&gt;  /             /   &lt;br&gt;2          11    14&lt;/p&gt;
&lt;p&gt;key = 8 返回11&lt;br&gt;key = 1 返回2&lt;br&gt;key = 16 返回NULL&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>字节跳动面试题 —— 水壶问题</title>
    <link href="http://changsk.top/2019/09/13/Kettle-problem/"/>
    <id>http://changsk.top/2019/09/13/Kettle-problem/</id>
    <published>2019-09-13T12:33:05.000Z</published>
    <updated>2019-09-13T12:49:19.507Z</updated>
    
    <content type="html"><![CDATA[<p>原题：给你一个装满水的 8 升满壶和两个分别是 5 升、3 升的空壶，请想个优雅的办法，使得其中一个水壶恰好装 4 升水，每一步的操作只能是倒空或倒满。</p><a id="more"></a><p><img src="1.jpg" alt="img"></p><p>理解了这个题目的意思之后，我们的第一个方法肯定就是使用强大的脑力来进行暴力破解法，瓶子里的水在我们的脑子里颠三倒四，但是脑子有可能没那么清晰，想了几步之后就开始出现记忆错乱，然后就不得不开始慢慢重播。 甚至到最后好不容易搞定了，但是怎么走过来的步骤又给忘记的一干二净 —— 智商好像受到了点小小的侮辱！</p><p>这道题其实有一道非常科学的解决方法 —— 广度遍历，我们将三个瓶子的状态标示为一个数。</p><p><strong>8 0 0</strong></p><p>然后开始拓展这个数的所有可能的状态，第一步这个数可以变为，括号里的数是上一步的数字</p><p><strong>3 5 0（8 0 0） 、 5 0 3（8 0 0）</strong></p><p>然后继续拓展第二步所有可能的状态，<strong>并且不得和之前的状态出现重复（这叫剪枝）</strong></p><p><strong>0 5 3（3 5 0）、3 2 3（3 5 0）、5 3 0（5 0 3）</strong></p><p>继续第三步</p><p><strong>6 2 0（3 2 3）、2 3 3（5 3 0）</strong></p><p>我们发现状态变少了，这是怎么回事呢？这是因为剪枝约束 —— 不得出现和之前重复的状态，就好比下象棋，如果我不动我还能活，但是必须动就会被将死的感觉一样。</p><p>继续第四步</p><p><strong>6 0 2（6 2 0）、2 5 1（2 3 3）</strong></p><p>继续第五步，怎么还没出现 4 这个数字呢，好着急啊！</p><p><strong>1 5 2（6 0 2）、7 0 1（2 5 1）</strong></p><p>继续第六步</p><p><strong>1 4 3（1 5 2）</strong></p><p>总算搞定了，这就是算法的<strong>停止条件</strong>，出现第一个数字 4。所以最终的路径就是</p><p><strong>1 4 3</strong> &lt;– <strong>1 5 2</strong> &lt;– <strong>6 0 2</strong> &lt;– <strong>6 2 0</strong> &lt;– <strong>3 2 3</strong> &lt;– <strong>3 5 0</strong> &lt;– <strong>8 0 0</strong></p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.csk.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态类，arr数组的三个属性分别表示三个壶当前的水量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Status</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        Status(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)&#123;</span><br><span class="line">            arr[<span class="number">0</span>] = x;</span><br><span class="line">            arr[<span class="number">1</span>] = y;</span><br><span class="line">            arr[<span class="number">2</span>] = z;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Status(Status s)&#123;</span><br><span class="line">            arr[<span class="number">0</span>] = s.arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">1</span>] = s.arr[<span class="number">1</span>];</span><br><span class="line">            arr[<span class="number">2</span>] = s.arr[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        @Override</span></span><br><span class="line"><span class="comment">        public int hashCode() &#123;</span></span><br><span class="line"><span class="comment">            return arr[0] + arr[1] + arr[2];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">            Status status = (Status)obj;</span><br><span class="line">            <span class="keyword">return</span> arr[<span class="number">0</span>] == status.arr[<span class="number">0</span>] &amp;&amp; arr[<span class="number">1</span>] == status.arr[<span class="number">1</span>] &amp;&amp; arr[<span class="number">2</span>] == status.arr[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存可以到达最终结果的每一次状态变化的list</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;List&lt;Status&gt;&gt; resList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] caps = &#123;<span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>&#125;; <span class="comment">//每一个壶的最大容量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Status&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Status s = <span class="keyword">new</span> Status(<span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        list.add(<span class="keyword">new</span> Status(s));</span><br><span class="line">        helper(s, list);</span><br><span class="line">        System.out.println(resList.size());</span><br><span class="line">        List&lt;Status&gt; curStatus;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; resList.size();i++) &#123;</span><br><span class="line">            curStatus = resList.get(i);</span><br><span class="line">            System.out.println(i  + <span class="string">" : "</span>);</span><br><span class="line">            <span class="keyword">for</span>(Status status : curStatus)</span><br><span class="line">                System.out.println(status.arr[<span class="number">0</span>] + <span class="string">" "</span> + status.arr[<span class="number">1</span>] + <span class="string">" "</span> + status.arr[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(Status status, List&lt;Status&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(status.arr[<span class="number">0</span>] == <span class="number">4</span> || status.arr[<span class="number">1</span>] == <span class="number">4</span> || status.arr[<span class="number">2</span>] == <span class="number">4</span>)&#123;</span><br><span class="line">            resList.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> temp;</span><br><span class="line">                <span class="keyword">if</span> (status.arr[i] == <span class="number">0</span> || status.arr[j] == caps[j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(status.arr[i] &gt;= caps[j] - status.arr[j]) temp = caps[j] - status.arr[j];</span><br><span class="line">                <span class="keyword">else</span> temp = status.arr[i];</span><br><span class="line">                status.arr[i] -= temp;</span><br><span class="line">                status.arr[j] += temp;</span><br><span class="line">                Status s = <span class="keyword">new</span> Status(status);</span><br><span class="line">                <span class="keyword">if</span> (list.contains(s)) &#123;</span><br><span class="line">                    status.arr[i] += temp;</span><br><span class="line">                    status.arr[j] -= temp;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    list.add(s);</span><br><span class="line">                    helper(status, list);</span><br><span class="line">                    list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">                    status.arr[i] += temp;</span><br><span class="line">                    status.arr[j] -= temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：</p><p>除代码之外的其他部门转载自：<a href="https://zhuanlan.zhihu.com/p/79938638?utm_source=wechat_session&utm_medium=social&utm_oi=691743492317147136" target="_blank" rel="noopener">字节跳动面试题 —— 水壶问题</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原题：给你一个装满水的 8 升满壶和两个分别是 5 升、3 升的空壶，请想个优雅的办法，使得其中一个水壶恰好装 4 升水，每一步的操作只能是倒空或倒满。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>小船过河</title>
    <link href="http://changsk.top/2019/09/11/Boat-crossing-the-river/"/>
    <id>http://changsk.top/2019/09/11/Boat-crossing-the-river/</id>
    <published>2019-09-11T03:57:11.000Z</published>
    <updated>2019-09-11T04:04:40.073Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="https://blog.csdn.net/lijiaxu_1/article/details/75209042" target="_blank" rel="noopener">小船过河问题</a></p><h2 id="小船过河问题"><a href="#小船过河问题" class="headerlink" title="小船过河问题"></a>小船过河问题</h2><p>POJ1700是一道经典的贪心算法例题。</p><p>题目大意是只有一艘船，能乘2人，船的运行速度为2人中较慢一人的速度，过去后还需一个人把船划回来，问把n个人运到对岸，最少需要多久。</p><p>先将所有人过河所需的时间按照升序排序，我们考虑把单独过河所需要时间最多的两个旅行者送到对岸去，有两种方式：</p><ol><li>最快的和次快的过河，然后最快的将船划回来；次慢的和最慢的过河，然后次快的将船划回来，<br>所需时间为：<code>t[0]+2*t[1]+t[n-1]</code>;</li><li>最快的和最慢的过河，然后最快的将船划回来，最快的和次慢的过河，然后最快的将船划回来，<br>所需时间为：<code>2*t[0]+t[n-2]+t[n-1]</code>。</li></ol><p>算一下就知道，除此之外的其它情况用的时间一定更多。每次都运送耗时最长的两人而不影响其它人，问题具有贪心子结构的性质。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> <span class="keyword">const</span> &amp;x, <span class="keyword">int</span> <span class="keyword">const</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &lt; y;<span class="comment">//由小到大排列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> N = <span class="number">8</span>;<span class="comment">//一共N个人要过河</span></span><br><span class="line"><span class="keyword">int</span> spendTime[<span class="number">8</span>] = &#123; <span class="number">3</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span> &#125;;<span class="comment">//每个人过河的速度</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">sort(spendTime, spendTime + <span class="number">8</span>, cmp);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> (N&gt;<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum = min(sum + spendTime[<span class="number">1</span>]* <span class="number">2</span> + spendTime[<span class="number">0</span>]  + spendTime[N - <span class="number">1</span>],<span class="comment">//第一种过河方式</span></span><br><span class="line">sum + spendTime[<span class="number">0</span>] * <span class="number">2</span> + spendTime[N - <span class="number">1</span>] + spendTime[N - <span class="number">2</span>]);<span class="comment">//第二种过河方式</span></span><br><span class="line">N -= <span class="number">2</span>;<span class="comment">//两个两个的运人  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (N == <span class="number">3</span>) sum += spendTime[<span class="number">0</span>] + spendTime[<span class="number">1</span>] + spendTime[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (N == <span class="number">2</span>)sum += spendTime[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> sum += spendTime[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"一共用时："</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自：&lt;a href=&quot;https://blog.csdn.net/lijiaxu_1/article/details/75209042&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;小船过河问题&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;小船过河问题&quot;&gt;&lt;a href=&quot;#小船过河问题&quot; class=&quot;headerlink&quot; title=&quot;小船过河问题&quot;&gt;&lt;/a&gt;小船过河问题&lt;/h2&gt;&lt;p&gt;POJ1700是一道经典的贪心算法例题。&lt;/p&gt;
&lt;p&gt;题目大意是只有一艘船，能乘2人，船的运行速度为2人中较慢一人的速度，过去后还需一个人把船划回来，问把n个人运到对岸，最少需要多久。&lt;/p&gt;
&lt;p&gt;先将所有人过河所需的时间按照升序排序，我们考虑把单独过河所需要时间最多的两个旅行者送到对岸去，有两种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最快的和次快的过河，然后最快的将船划回来；次慢的和最慢的过河，然后次快的将船划回来，&lt;br&gt;所需时间为：&lt;code&gt;t[0]+2*t[1]+t[n-1]&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;最快的和最慢的过河，然后最快的将船划回来，最快的和次慢的过河，然后最快的将船划回来，&lt;br&gt;所需时间为：&lt;code&gt;2*t[0]+t[n-2]+t[n-1]&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;算一下就知道，除此之外的其它情况用的时间一定更多。每次都运送耗时最长的两人而不影响其它人，问题具有贪心子结构的性质。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-230:Kth Smallest Element in a BST(二叉搜索树中第k小的结点)</title>
    <link href="http://changsk.top/2019/09/11/leetcode-230/"/>
    <id>http://changsk.top/2019/09/11/leetcode-230/</id>
    <published>2019-09-11T02:42:37.000Z</published>
    <updated>2019-09-11T03:29:42.434Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener">https://leetcode.com/problems/kth-smallest-element-in-a-bst/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>题目难度：Medium</strong></p><p>Given a binary search tree, write a function <code>kthSmallest</code> to find the <strong>k</strong>th smallest element in it.</p><p><strong>Note:</strong><br>You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,1,4,null,2], k = 1</span><br><span class="line">   3</span><br><span class="line">  / \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class="line">       5</span><br><span class="line">      / \</span><br><span class="line">     3   6</span><br><span class="line">    / \</span><br><span class="line">   2   4</span><br><span class="line">  /</span><br><span class="line"> 1</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Follow up:</strong><br>What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?</p><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        helper(root, k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        helper(root.left, k);</span><br><span class="line">        cur++;</span><br><span class="line">        <span class="keyword">if</span>(cur == k) &#123;</span><br><span class="line">            res = root.val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(root.right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/kth-smallest-element-in-a-bst/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/kth-smallest-element-in-a-bst/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-464:Can I Win</title>
    <link href="http://changsk.top/2019/09/10/leetcode-464/"/>
    <id>http://changsk.top/2019/09/10/leetcode-464/</id>
    <published>2019-09-10T15:48:07.000Z</published>
    <updated>2019-09-11T02:30:25.412Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/can-i-win/" target="_blank" rel="noopener">https://leetcode.com/problems/can-i-win/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>题目难度：Medium</strong></p><p>In the “100 game,” two players take turns adding, to a running total, any integer from 1..10. The player who first causes the running total to reach or exceed 100 wins.</p><p>What if we change the game so that players cannot re-use integers?</p><p>For example, two players might take turns drawing from a common pool of numbers of 1..15 without replacement until they reach a total &gt;= 100.</p><p>Given an integer <code>maxChoosableInteger</code> and another integer <code>desiredTotal</code>, determine if the first player to move can force a win, assuming both players play optimally.</p><p>You can always assume that <code>maxChoosableInteger</code> will not be larger than 20 and <code>desiredTotal</code> will not be larger than 300.</p><p><strong>Example</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">maxChoosableInteger = 10</span><br><span class="line">desiredTotal = 11</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">false</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">No matter which integer the first player choose, the first player will lose.</span><br><span class="line">The first player can choose an integer from 1 up to 10.</span><br><span class="line">If the first player choose 1, the second player can only choose integers from 2 up to 10.</span><br><span class="line">The second player will win by choosing 10 and get a total = 11, which is &gt;= desiredTotal.</span><br><span class="line">Same with other integers chosen by the first player, the second player will always win.</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canIWin</span><span class="params">(<span class="keyword">int</span> maxChoosableInteger, <span class="keyword">int</span> desiredTotal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (desiredTotal &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (maxChoosableInteger * (maxChoosableInteger + <span class="number">1</span>) / <span class="number">2</span>&lt;desiredTotal) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(desiredTotal, <span class="number">0</span>, <span class="keyword">new</span> HashMap&lt;Integer, Boolean&gt;(), maxChoosableInteger);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> total, <span class="keyword">int</span> state, HashMap&lt;Integer, Boolean&gt; hashMap, <span class="keyword">int</span> maxChoosableInteger)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key = state;</span><br><span class="line">        <span class="keyword">if</span> (hashMap.containsKey(key)) <span class="keyword">return</span> hashMap.get(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; maxChoosableInteger;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((state &amp; (<span class="number">1</span> &lt;&lt; i)) == <span class="number">0</span>) &#123;</span><br><span class="line">                state |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">                <span class="keyword">if</span> (total &lt;= i+<span class="number">1</span> || !dfs(total - (i + <span class="number">1</span>), state, hashMap, maxChoosableInteger)) &#123;</span><br><span class="line">                    hashMap.put(key, <span class="keyword">true</span>);</span><br><span class="line">                    state ^= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                state ^= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        hashMap.put(key, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canIWin</span><span class="params">(<span class="keyword">int</span> maxChoosableInteger, <span class="keyword">int</span> desiredTotal)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//特殊情况1:可选择的最大数大于等于期望值</span></span><br><span class="line">        <span class="keyword">if</span> (desiredTotal &lt;= maxChoosableInteger) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//特殊情况2:可选择的数加和小于期望值</span></span><br><span class="line">        <span class="keyword">if</span> (((<span class="number">1</span> + maxChoosableInteger) / <span class="number">2</span> * maxChoosableInteger) &lt; desiredTotal) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> canIWin(desiredTotal, <span class="number">0</span>, maxChoosableInteger, <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span> &lt;&lt; maxChoosableInteger]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canIWin</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> path, <span class="keyword">int</span> maxInt, <span class="keyword">int</span>[] memo)</span> </span>&#123; <span class="comment">// HashMap&lt;Integer, Boolean&gt; map) &#123;</span></span><br><span class="line">        <span class="comment">// if (map.containsKey(path)) return map.get(path);</span></span><br><span class="line">        <span class="keyword">if</span> (memo[path] != <span class="number">0</span>) <span class="keyword">return</span> memo[path] == <span class="number">1</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//选择一个未被选择过的数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = maxInt; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((path &amp; (<span class="number">1</span> &lt;&lt; (maxInt - i))) != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= target) &#123;</span><br><span class="line">                <span class="comment">//map.put(path, true);</span></span><br><span class="line">                memo[path] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> canWin = canIWin(target - i, path | (<span class="number">1</span> &lt;&lt; (maxInt - i)), maxInt, memo); <span class="comment">//map);</span></span><br><span class="line">            <span class="keyword">if</span> (!canWin) &#123;</span><br><span class="line">                <span class="comment">//map.put(path, true);</span></span><br><span class="line">                memo[path] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//map.put(path, false);</span></span><br><span class="line">        memo[path] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/can-i-win/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/can-i-win/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-575:Distribute Candies(分糖果)</title>
    <link href="http://changsk.top/2019/09/10/leetcode-575/"/>
    <id>http://changsk.top/2019/09/10/leetcode-575/</id>
    <published>2019-09-10T03:44:05.000Z</published>
    <updated>2019-09-10T03:46:19.235Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/distribute-candies/" target="_blank" rel="noopener">https://leetcode.com/problems/distribute-candies/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>题目难度:Easy</strong></p><p>Given an integer array with <strong>even</strong> length, where different numbers in this array represent different <strong>kinds</strong> of candies. Each number means one candy of the corresponding kind. You need to distribute these candies <strong>equally</strong> in number to brother and sister. Return the maximum number of <strong>kinds</strong> of candies the sister could gain.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: candies = [1,1,2,2,3,3]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">There are three different kinds of candies (1, 2 and 3), and two candies for each kind.</span><br><span class="line">Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too. </span><br><span class="line">The sister has three different kinds of candies.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: candies = [1,1,2,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1]. </span><br><span class="line">The sister has two different kinds of candies, the brother has only one kind of candies.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>The length of the given array is in range [2, 10,000], and will be even.</li><li>The number in given array is in range [-100,000, 100,000].</li></ol><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">distributeCandies</span><span class="params">(<span class="keyword">int</span>[] candies)</span> </span>&#123;</span><br><span class="line">         Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : candies)</span><br><span class="line">            set.add(i);</span><br><span class="line">        <span class="keyword">return</span> set.size() &gt;= candies.length / <span class="number">2</span> ? candies.length / <span class="number">2</span> : set.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/distribute-candies/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/distribute-candies/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
</feed>
