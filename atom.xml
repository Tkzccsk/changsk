<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>changsk&#39;s blogs</title>
  
  <subtitle>chang.sk@foxmail.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://changsk.top/"/>
  <updated>2019-07-18T16:00:03.130Z</updated>
  <id>http://changsk.top/</id>
  
  <author>
    <name>changsk</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTTP之长连接和短连接</title>
    <link href="http://changsk.top/2019/07/18/http-long-connection-short-connection/"/>
    <id>http://changsk.top/2019/07/18/http-long-connection-short-connection/</id>
    <published>2019-07-18T15:51:02.000Z</published>
    <updated>2019-07-18T16:00:03.130Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://www.jianshu.com/p/c41aa401b967" target="_blank" rel="noopener">面试-长链接与短链接</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>长链接和短链接又分别称为持续链接和非持续链接</p></blockquote><p>Web页面上通常有很多对象。有些对象较小，比如HTML文本或图标；有些对象却很大，如视频文件。对于众多小的文件，如果它们的所有请求以及响应都经过相同的TCP连接来发送，其<strong>工作效率就会提高</strong>。这种将多个请求/响应对经同一个TCP链接进行传送的方式被称为<strong>持续连接</strong>。此时，又可以分为两种情况：<strong>无流水线的持续链接</strong>和<strong>有流水线的持续链接</strong>。对于前者，仅当前面的响应已经收到时，客户机才会发出新的请求，这使每个引用对象都会引入一个RTT时延。对于后者，只要客户机遇到一个引用对象，他就发送请求，对于所有的引用的对象，只引入一个RTT时延。这种流水线的持续连接是HTTP/1.1的默认状况。<br> 而对于很大的对象，如果每个请求/响应都单独经过一条TCP连接发送，用户的感受将会更好。这种将每个请求/响应都经过一个单独的TCP连接进行发送的方式被称为<strong>非持续连接</strong>。尽管HTTP客户机和服务器在其默认方式下均使用持续连接方式，但也能将他们的配置成使用非持续连接方式。</p><a id="more"></a><h1 id="表层-HTTP"><a href="#表层-HTTP" class="headerlink" title="表层-HTTP"></a>表层-HTTP</h1><p><strong>长链接与锻炼的区别是头域：Connection。</strong><br> 在http1.0及之前都是默认方式为非持久性链接（关键词未知查不到抱歉！）。在HTTP1.1之后就将链接默认为Keep-Alive表示是持久性链接。当链接想要关闭的话就将状态字设置为close。</p><blockquote><p>题外话，这个头域还有一个作用是可以控制不再转发给代理。<br> 他的根源是控制tcp的链接状态。</p></blockquote><p>一个详细的HTTP请求：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">浏览器与服务器之间使用持续链接方式，将出现下列情况：</span><br><span class="line">（<span class="number">1</span>）HTTP客户机进程发起一个到服务器URL的TCP连接，连接服务器端口是<span class="number">80</span>，这使客户机和服务器上分别有一</span><br><span class="line">个套接字与该链接相关联。</span><br><span class="line">（<span class="number">2</span>）HTTP客户机经过它的套接字接受该请求报文，请求报文中包含了路径名/home.index。</span><br><span class="line">（<span class="number">3</span>）HTTP服务器进程经过他的套接字接受该请求报文，从其存储器（RAM或磁盘）中检索出对象/home.index；</span><br><span class="line">在一个HTTP响应报文中封装该对象，并通过其套接字向客户姐发送响应报文。</span><br><span class="line">（<span class="number">4</span>）HTTP客户机接收响应报文，分析该报文并指出封装的对象是一个HTML文件，并得到对<span class="number">8</span>个JPEG图形和<span class="number">5</span>个视</span><br><span class="line">频的共<span class="number">13</span>个引用。</span><br><span class="line">（<span class="number">5</span>）先传送基本的HTML文件，然后这<span class="number">13</span>个引用对象通过相同的TCP连接一个接一个地传送（流水线技术），直至</span><br><span class="line">该页面上的对象全部传输完毕。其中若传输每个JPEG图形文件用时tj,传输每个视频用时tv，并且忽略了HTML文</span><br><span class="line">件的传输时间，则共用时<span class="number">8</span>tj+<span class="number">5</span>tv,  且tv&gt;&gt;tj。</span><br><span class="line">（<span class="number">6</span>）若一条连接经过一定时间间隔（一个可配置的超时间隔）仍未被使用，则HTTP服务器进程通知TCP断开。</span><br></pre></td></tr></table></figure><p>在上述例子中，如果使用了非持续性连接方式，那么每个TCP连接在服务器发送一个对象后关闭，即该连接并不为其他的对象持续下来。这样一共产生了14个TCP连接。</p><blockquote><p>持久化的链接的<strong>好处</strong>在于减少了tcp链接的重复建立和断开所造成的额外开销，减轻了服务器的负载。另外，减少开销的那部分时间，使http请求和响应能够更早的结束，这样web的显示速度也就相应的提高了。<br> 采用持久化的<strong>原因</strong>是现在的页面越来越大！html中的内容需要发送多次resquest来进行接收，每次都断开tcp链接都会产生明显的开销。<br> 持久化链接固然好，但是我们要知道一个<strong>系统的链接数目</strong>是有限的。我们可以通过ulimit -n可以查看最大链接数。</p></blockquote><h1 id="本质-TCP"><a href="#本质-TCP" class="headerlink" title="本质-TCP"></a>本质-TCP</h1><h2 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h2><p>我们模拟一下TCP短连接的情况，client向server发起连接请求，server接到请求，然后双方建立连接。client向server 发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起 close操作。为什么呢，一般的server不会回复完client后立即关闭连接的，当然不排除有特殊的情况。从上面的描述看，短连接一般只会在 client/server间传递一次读写操作。<br> 短连接的<strong>优点</strong>是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段</p><h2 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h2><p>接下来我们再模拟一下长连接的情况，client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。<br> 先说一下TCP/IP详解上讲到的<strong>TCP保活</strong>功能，保活功能主要为服务器应用提供，<strong>服务器应用希望知道客户主机是否崩溃</strong>，从而可以代表客户使用资源。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将应远等待客户端的数据，保活功能就是试图在服务器端检测到这种半开放的连接。</p><blockquote><p>如果一个给定的连接在两小时内没有任何的动作，则服务器就向客户发一个探测报文段，客户主机必须处于以下4个状态之一：<br> 1.客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常的，服务器在两小时后将保活定时器复位。<br> 2.客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务端将不能收到对探测的响应，并在75秒后超时。服务器总共发送10个这样的探测 ，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。<br> 3.客户主机崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。<br> 4.客户机正常运行，但是服务器不可达，这种情况与2类似，TCP能发现的就是没有收到探查的响应。</p></blockquote><p>链接的实现就是通过socket来进行通讯的</p><p><img src="1.jpg" alt="img"></p><p><strong>长连接短连接操作过程</strong><br><strong>短连接</strong>的操作步骤是：<br>建立连接——数据传输——关闭连接…建立连接——数据传输——关闭连接<br><strong>长连接</strong>的操作步骤是：<br>建立连接——数据传输…（保持连接）…数据传输——关闭连接</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://www.jianshu.com/p/c41aa401b967&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;面试-长链接与短链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;长链接和短链接又分别称为持续链接和非持续链接&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Web页面上通常有很多对象。有些对象较小，比如HTML文本或图标；有些对象却很大，如视频文件。对于众多小的文件，如果它们的所有请求以及响应都经过相同的TCP连接来发送，其&lt;strong&gt;工作效率就会提高&lt;/strong&gt;。这种将多个请求/响应对经同一个TCP链接进行传送的方式被称为&lt;strong&gt;持续连接&lt;/strong&gt;。此时，又可以分为两种情况：&lt;strong&gt;无流水线的持续链接&lt;/strong&gt;和&lt;strong&gt;有流水线的持续链接&lt;/strong&gt;。对于前者，仅当前面的响应已经收到时，客户机才会发出新的请求，这使每个引用对象都会引入一个RTT时延。对于后者，只要客户机遇到一个引用对象，他就发送请求，对于所有的引用的对象，只引入一个RTT时延。这种流水线的持续连接是HTTP/1.1的默认状况。&lt;br&gt; 而对于很大的对象，如果每个请求/响应都单独经过一条TCP连接发送，用户的感受将会更好。这种将每个请求/响应都经过一个单独的TCP连接进行发送的方式被称为&lt;strong&gt;非持续连接&lt;/strong&gt;。尽管HTTP客户机和服务器在其默认方式下均使用持续连接方式，但也能将他们的配置成使用非持续连接方式。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://changsk.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTP" scheme="http://changsk.top/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Redis主从复制原理</title>
    <link href="http://changsk.top/2019/07/18/redis-master-slave-replication/"/>
    <id>http://changsk.top/2019/07/18/redis-master-slave-replication/</id>
    <published>2019-07-18T13:26:41.000Z</published>
    <updated>2019-07-18T13:47:48.281Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://zhuanlan.zhihu.com/p/60239657" target="_blank" rel="noopener">深入Redis：详解 Redis主从复制的原理!</a></p></blockquote><a id="more"></a><h3 id="复制过程"><a href="#复制过程" class="headerlink" title="复制过程"></a>复制过程</h3><p>复制的过程步骤如下：</p><ol><li>从节点执行 <code>slaveof</code> 命令</li><li>从节点只是<strong>保存了 slaveof 命令中主节点的信息</strong>，并没有立即发起复制</li><li>从节点内部的定时任务发现有主节点的信息，<strong>开始使用 socket 连接主节点</strong></li><li>连接建立成功后，发送 <code>ping</code> 命令，希望得到 <code>pong</code> 命令响应，否则会进行重连</li><li>如果主节点设置了权限，那么就需要进行<strong>权限验证</strong>；如果验证失败，复制终止。</li><li>权限验证通过后，进行数据同步，<strong>这是耗时最长的操作</strong>，主节点将把所有的数据全部发送给从节点。</li><li>当主节点把当前的数据同步给从节点后，便完成了复制的建立流程。接下来，<strong>主节点就会持续的把写命令发送给从节点，保证主从数据一致性</strong>。</li></ol><p><img src="1.jpg" alt="img"></p><h3 id="数据间的同步"><a href="#数据间的同步" class="headerlink" title="数据间的同步"></a>数据间的同步</h3><p>上面说的复制过程，其中有一个步骤是“同步数据集”，这个就是现在讲的‘数据间的同步’。</p><p>redis 同步有 2 个命令：<code>sync</code> 和 <code>psync</code>，前者是 redis 2.8 之前的同步命令，后者是 redis 2.8 为了优化 sync 新设计的命令。我们会重点关注 2.8 的 psync 命令。</p><p><strong>psync 命令需要 3 个组件支持：</strong><br>1.主从节点各自复制偏移量<br>2.主节点复制积压缓冲区<br>3.主节点运行 ID</p><p><strong>主从节点各自复制偏移量</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">参与复制的主从节点都会维护自身的复制偏移量。</span><br><span class="line"></span><br><span class="line">主节点在处理完写入命令后，会把命令的字节长度做累加记录，统计信息在 info replication </span><br><span class="line">中的 master_repl_offset 指标中。</span><br><span class="line"></span><br><span class="line">从节点每秒钟上报自身的的复制偏移量给主节点，因此主节点也会保存从节点的复制偏移量。</span><br><span class="line"></span><br><span class="line">从节点在接收到主节点发送的命令后，也会累加自身的偏移量，统计信息在 info replication 中。</span><br><span class="line"></span><br><span class="line">通过对比主从节点的复制偏移量，可以判断主从节点数据是否一致。</span><br></pre></td></tr></table></figure><p><strong>主节点复制积压缓冲区</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">复制积压缓冲区是一个保存在主节点的一个固定长度的先进先出的队列。默认大小 1MB。</span><br><span class="line"></span><br><span class="line">这个队列在 slave 连接是创建。这时主节点响应写命令时，不但会把命令发送给从节点，也会写入复制缓冲区。</span><br><span class="line"></span><br><span class="line">他的作用就是用于部分复制和复制命令丢失的数据补救。</span><br><span class="line"></span><br><span class="line">通过 info replication 可以看到相关信息。</span><br></pre></td></tr></table></figure><p><strong>主节点运行 ID</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">每个 redis 启动的时候，都会生成一个 40 位的运行 ID。</span><br><span class="line"></span><br><span class="line">运行 ID 的主要作用是用来识别 Redis 节点。如果使用 ip+port 的方式，那么如果主节点重启修改</span><br><span class="line">了 RDB/AOF 数据，从节点再基于偏移量进行复制将是不安全的。所以，当运行 id 变化后，从节点将</span><br><span class="line">进行全量复制。也就是说，redis 重启后，默认从节点会进行全量复制。</span><br><span class="line"></span><br><span class="line">如果在重启时不改变运行 ID 呢？</span><br><span class="line">可以通过 debug reload 命令重新加载 RDB 并保持运行 ID 不变。从而有效的避免不必要的全量复制。</span><br><span class="line">他的缺点则是：debug reload 命令会阻塞当前 Redis 节点主线程，因此对于大数据量的主节点或者</span><br><span class="line">无法容忍阻塞的节点，需要谨慎使用。</span><br><span class="line"></span><br><span class="line">一般通过故障转移机制可以解决这个问题。</span><br></pre></td></tr></table></figure><p><strong>psync 命令的使用方式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">命令格式为 `psync &#123;runId&#125; &#123;offset&#125;`</span><br><span class="line"></span><br><span class="line">runId : 从节点所复制主节点的运行 id</span><br><span class="line">offset：当前从节点已复制的数据偏移量</span><br></pre></td></tr></table></figure><p><strong>psync 执行流程：</strong></p><p><img src="2.jpg" alt="img"></p><p><strong>流程说明：</strong>从节点发送 <code>psync</code> 命令给主节点，<code>runId</code> 就是目标主节点的 ID，如果没有默认为 -1，offset 是从节点保存的<strong>复制偏移量</strong>，如果是第一次复制则为 -1.</p><p>主节点会根据 runid 和 offset 决定返回结果：</p><ul><li>如果回复 +FULLRESYNC {runId} {offset} ，那么从节点将触发全量复制流程。</li><li>如果回复 +CONTINUE，从节点将触发部分复制。</li><li>如果回复 +ERR，说明主节点不支持 2.8 的 psync 命令，将使用 sync 执行全量复制。</li></ul><p>到这里，数据之间的同步就讲的差不多了，篇幅还是比较长的。主要是针对 psync 命令相关之间的介绍。</p><h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h3><p>全量复制是 Redis 最早支持的复制方式，也是<strong>主从第一次建立复制时必须经历的的阶段</strong>。触发全量复制的命令是 sync 和 psync。之前说过，这两个命令的分水岭版本是 2.8，redis 2.8 之前使用 sync 只能执行全量不同，<strong>2.8 之后同时支持全量同步和部分同步。</strong></p><p><strong>流程如下：</strong></p><p><img src="3.jpg" alt="img"></p><p><strong>介绍一下上图步骤：</strong></p><ol><li>发送 psync 命令（sync ？ -1）</li><li>主节点根据命令返回 FULLRESYNC</li><li>从节点记录主节点 ID 和 offset</li><li><strong>主节点 bgsave 并保存 RDB 到本地</strong></li><li><strong>主节点发送 RBD 文件到从节点</strong></li><li><strong>从节点收到 RDB 文件并加载到内存中</strong></li><li>主节点在从节点接受数据的期间，将新数据保存到“<strong>复制客户端缓冲区</strong>”，当从节点加载 RDB 完毕，再发送过去。（如果从节点花费时间过长，将导致缓冲区溢出，最后全量同步失败）</li><li><strong>从节点清空数据后加载 RDB 文件，如果 RDB 文件很大，这一步操作仍然耗时，如果此时客户端访问，将导致数据不一致，可以使用配置slave-server-stale-data 关闭</strong>.</li><li><strong>从节点成功加载完 RBD 后，如果开启了 AOF，会立刻做 bgrewriteaof</strong>。</li></ol><p><strong>以上加粗的部分是整个全量同步耗时的地方。</strong></p><p><strong>注意：</strong></p><ol><li>如过 RDB 文件大于 6GB，并且是千兆网卡，Redis 的默认超时机制（60 秒），会导致全量复制失败。<strong>可以通过调大 repl-timeout 参数来解决此问题</strong>。</li><li>Redis 虽然支持无盘复制，即直接通过网络发送给从节点，但功能不是很完善，生产环境慎用。</li></ol><h3 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h3><p>当从节点正在复制主节点时，如果出现网络闪断和其他异常，从节点会让主节点补发丢失的命令数据，主节点只需要将复制缓冲区的数据发送到从节点就能够保证数据的一致性，相比较全量复制，成本小很多。</p><p><strong>步骤如下：</strong></p><p><img src="4.jpg" alt="img"></p><ol><li>当从节点出现网络中断，超过了 <code>repl-timeout</code> 时间，主节点就会中断复制连接。</li><li>主节点会将请求的数据写入到“复制积压缓冲区”，默认 1MB。</li><li>当从节点恢复，重新连接上主节点，从节点会将 offset 和主节点 id 发送到主节点</li><li>主节点校验后，<strong>如果偏移量的数后的数据在缓冲区中</strong>，就发送 cuntinue 响应 —— 表示可以进行部分复制</li><li>主节点将缓冲区的数据发送到从节点，保证主从复制进行正常状态。</li></ol><h3 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h3><p>主从节点在建立复制后，他们之间维护着<strong>长连接</strong>并<strong>彼此发送心跳命令</strong>。</p><p><strong>心跳的关键机制如下：</strong></p><ol><li>主从都有心跳检测机制，各自模拟成对方的客户端进行通信，通过 client list 命令查看复制相关客户端信息，主节点的连接状态为 flags = M，从节点的连接状态是 flags = S。</li><li><strong>主节点默认每隔 10 秒对从节点发送 ping 命令</strong>，可修改配置 repl-ping-slave-period 控制发送频率。</li><li><strong>从节点在主线程每隔一秒发送 replconf ack{offset} 命令，给主节点上报自身当前的复制偏移量</strong>。</li><li>主节点收到 replconf 信息后，判断从节点超时时间，如果超过 repl-timeout 60 秒，则判断节点下线。</li></ol><p><img src="5.jpg" alt="img"></p><p><strong>注意：</strong>为了降低主从延迟，一般把 redis 主从节点部署在相同的机房/同城机房，避免网络延迟带来的网络分区造成的心跳中断等情况。</p><h3 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h3><p><strong>主节点不但负责数据读写，还负责把写命令同步给从节点，写命令的发送过程是异步完成，也就是说主节点处理完写命令后立即返回客户度，并不等待从节点复制完成。</strong></p><p><strong>异步复制的步骤很简单，如下：</strong></p><ol><li>主节点接受处理命令</li><li>主节点处理完后返回响应结果</li><li>对于修改命令，异步发送给从节点，从节点在主线程中执行复制的命令。</li></ol><p><img src="6.jpg" alt="img"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要分析了 Redis 的复制原理，包括复制过程，数据之间的同步，全量复制的流程，部分复制的流程，心跳设计，异步复制流程。</p><p>其中，可以看出，RDB 数据之间的同步非常耗时。所以，Redis 在 2.8 版本退出了类似增量复制的 psync 命令，<strong>当 Redis 主从直接发生了网络中断，不会进行全量复制，而是将数据放到缓冲区（默认 1MB）里，在通过主从之间各自维护复制 offset 来判断缓存区的数据是否溢出</strong>，如果没有溢出，只需要发送缓冲区数据即可，成本很小，反之，则要进行全量复制，因此，控制缓冲区大小非常的重要。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/60239657&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;深入Redis：详解 Redis主从复制的原理!&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://changsk.top/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://changsk.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Linux IO模式及 select、poll、epoll详解</title>
    <link href="http://changsk.top/2019/07/17/linux-io-model/"/>
    <id>http://changsk.top/2019/07/17/linux-io-model/</id>
    <published>2019-07-17T15:12:15.000Z</published>
    <updated>2019-07-18T01:49:59.884Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">Linux IO模式及 select、poll、epoll详解</a></p></blockquote><p>同步IO和异步IO，阻塞IO和非阻塞IO分别是什么，到底有什么区别？不同的人在不同的上下文下给出的答案是不同的。所以先限定一下本文的上下文。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本文讨论的背景是Linux环境下的network IO。</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="概念说明"><a href="#概念说明" class="headerlink" title="概念说明"></a>概念说明</h1><p>在进行解释之前，首先要说明几个概念：</p><ul><li>用户空间和内核空间</li><li>进程切换</li><li>进程的阻塞</li><li>文件描述符</li><li>缓存 I/O</li></ul><h2 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h2><p>现在操作系统都是采用<strong>虚拟存储器</strong>，那么对32位操作系统而言，<strong>它的寻址空间（虚拟存储空间）为4G（2的32次方）。**</strong>操作系统的核心是内核，独立于普通的应用程序<strong>，可以访问受保护的内存空间，</strong>也有<strong>访问底层硬件设备的所有权限</strong>。为了保证用户进程不能直接操作内核（kernel），保证内核的安全操作系统将虚拟空间划分为两部分，一部分为<strong>内核空间</strong>，一部分为<strong>用户空间</strong>。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p><h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为<strong>进程切换</strong>。因此可以说，<strong>任何进程都是在操作系统内核的支持下运行的</strong>，是与内核紧密相关的。</p><p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p><ol><li>保存处理机上下文，包括程序计数器和其他寄存器。</li><li>更新PCB信息。</li><li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li><li>选择另一个进程执行，并更新其PCB。</li><li>更新内存管理的数据结构。</li><li>恢复处理机上下文。</li></ol><p>注：<strong>总而言之就是很耗资源</strong>，具体的可以参考这篇文章：<a href="http://guojing.me/linux-kernel-architecture/posts/process-switch/" target="_blank" rel="noopener">进程切换</a></p><h2 id="进程的阻塞"><a href="#进程的阻塞" class="headerlink" title="进程的阻塞"></a>进程的阻塞</h2><p>正在执行的进程，由于期待的某些事件未发生，如<strong>请求系统资源失败</strong>、等待某种操作的完成、<strong>新数据尚未到达或无新工作做</strong>等，则由系统自动执行<strong>阻塞原语(Block)</strong>，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。<code>当进程进入阻塞状态，是不占用CPU资源的</code>。</p><h2 id="文件描述符fd"><a href="#文件描述符fd" class="headerlink" title="文件描述符fd"></a>文件描述符fd</h2><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述<strong>指向文件的引用的抽象化概念</strong>。</p><p><strong>文件描述符在形式上是一个非负整数</strong>。实际上，它是一个索引值，<strong>指向内核为每一个进程所维护的该进程打开文件的记录表</strong>。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p><h2 id="缓存-I-O"><a href="#缓存-I-O" class="headerlink" title="缓存 I/O"></a>缓存 I/O</h2><p><strong>缓存 I/O 又被称作标准 I/O</strong>，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，<strong>数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</strong></p><p><strong>缓存 I/O 的缺点：</strong><br>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p><h1 id="IO模式"><a href="#IO模式" class="headerlink" title="IO模式"></a>IO模式</h1><p>刚才说了，对于一次IO访问（以<code>read</code>举例），<strong>数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间</strong>。所以说，当一个read操作发生时，它会经历两个阶段：</p><ol><li>等待数据准备 (Waiting for the data to be ready)</li><li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li></ol><p>正式因为这两个阶段，linux系统产生了下面五种网络模式的方案。</p><ul><li>阻塞 I/O（blocking IO）</li><li>非阻塞 I/O（nonblocking IO）</li><li>I/O 多路复用（ IO multiplexing）</li><li>信号驱动 I/O（ signal driven IO）</li><li>异步 I/O（asynchronous IO）</li></ul><p>注：由于signal driven IO在实际中并不常用，所以我这只提及剩下的四种IO Model。</p><h2 id="阻塞-I-O（blocking-IO）"><a href="#阻塞-I-O（blocking-IO）" class="headerlink" title="阻塞 I/O（blocking IO）"></a>阻塞 I/O（blocking IO）</h2><p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：<br><img src="1.jpg" alt="clipboard.png"></p><p>当用户进程调用了<code>recvfrom</code>这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p><blockquote><p>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</p></blockquote><h2 id="非阻塞-I-O（nonblocking-IO）"><a href="#非阻塞-I-O（nonblocking-IO）" class="headerlink" title="非阻塞 I/O（nonblocking IO）"></a>非阻塞 I/O（nonblocking IO）</h2><p>linux下，可以通过设置socket使其变为<code>non-blocking</code>。当对一个non-blocking socket执行读操作时，流程是这个样子：<br><img src="2.jpg" alt="clipboard.png"></p><p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是<strong>立刻返回一个error</strong>。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p><blockquote><p>所以，nonblocking IO的特点是用户进程需要<strong>不断的主动询问</strong>kernel数据好了没有。</p></blockquote><h2 id="I-O-多路复用（-IO-multiplexing）"><a href="#I-O-多路复用（-IO-multiplexing）" class="headerlink" title="I/O 多路复用（ IO multiplexing）"></a>I/O 多路复用（ IO multiplexing）</h2><p>IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p><p><img src="3.jpg" alt="clipboard.png"></p><p><code>当用户进程调用了select，那么整个进程会被block</code>，而同时，<strong>kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</strong></p><blockquote><p>所以，I/O 多路复用的特点是通过一种机制<strong>一个进程能同时等待多个文件描述符</strong>，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</p></blockquote><p>这个图和<code>blocking IO</code>的图其实并没有太大的不同，事实上，还更差一些。因为这里<strong>需要使用两个system call</strong> (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，<strong>用select的优势在于它可以同时处理多个connection。</strong></p><p>所以，如果处理的连接数不是很高的话，使用<code>select/epoll</code>的web server不一定比使用<code>multi-threading + blocking IO</code>的web server性能更好，可能延迟还更大。<strong>select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</strong></p><p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。<strong>只不过process是被select这个函数block</strong>，而不是被socket IO给block。</p><h2 id="异步-I-O（asynchronous-IO）"><a href="#异步-I-O（asynchronous-IO）" class="headerlink" title="异步 I/O（asynchronous IO）"></a>异步 I/O（asynchronous IO）</h2><p>inux下的asynchronous IO其实用得很少。先看一下它的流程：<br><img src="4.jpg" alt="clipboard.png"></p><p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个<code>asynchronous read</code>之后，首先它会<strong>立刻返回</strong>，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，<strong>kernel会给用户进程发送一个signal，告诉它read操作完成了。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="blocking和non-blocking的区别"><a href="#blocking和non-blocking的区别" class="headerlink" title="blocking和non-blocking的区别"></a>blocking和non-blocking的区别</h3><p>调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</p><h3 id="synchronous-IO和asynchronous-IO的区别"><a href="#synchronous-IO和asynchronous-IO的区别" class="headerlink" title="synchronous IO和asynchronous IO的区别"></a>synchronous IO和asynchronous IO的区别</h3><p>在说明<code>synchronous IO</code>和<code>asynchronous IO</code>的区别之前，需要先给出两者的定义。POSIX的定义是这样子的：</p><ul><li>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;</li><li>An asynchronous I/O operation does not cause the requesting process to be blocked;</li></ul><p>两者的区别就在于<strong>synchronous IO做”IO operation”的时候会将process阻塞</strong>。按照这个定义，之前所述的<strong>blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</strong></p><p>有人会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，<strong>定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call</strong>。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。</p><p>而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p><p><strong>各个IO Model的比较如图所示：</strong><br><img src="5.jpg" alt="clipboard.png"></p><p>通过上面的图片，可以发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p><h1 id="I-O-多路复用之select、poll、epoll详解"><a href="#I-O-多路复用之select、poll、epoll详解" class="headerlink" title="I/O 多路复用之select、poll、epoll详解"></a>I/O 多路复用之select、poll、epoll详解</h1><p><strong>select，poll，epoll都是IO多路复用的机制</strong>。I/O多路复用就是通过一种机制，<strong>一个进程可以监视多个描述符</strong>，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但<strong>select，poll，epoll本质上都是同步I/O</strong>，因为他们<strong>都需要在读写事件就绪后自己负责进行读写</strong>，也就是说这个<strong>读写过程是阻塞的</strong>，<strong>而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</strong>（这里啰嗦下）</p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>select 函数监视的文件描述符分3类，分别是<code>writefds</code>、<code>readfds</code>、和<code>exceptfds</code>。<strong>调用select后函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。</strong></p><p>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一 个缺点在于<strong>单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024</strong>，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但 是这样也会造成效率的降低。</p><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="keyword">short</span> events; <span class="comment">/* requested events to watch */</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">/* returned events witnessed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。同时，<strong>pollfd并没有最大数量限制</strong>（但是数量过大后性能也是会下降）。 和select函数一样，<strong>poll返回后，需要轮询pollfd来获取就绪的描述符。</strong></p><blockquote><p>从上面看，select和poll都需要在返回后，<code>通过遍历文件描述符来获取已经就绪的socket</code>。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p></blockquote><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，<strong>没有描述符限制</strong>。<strong>epoll使用一个文件描述符管理多个描述符</strong>，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p><h3 id="epoll操作过程"><a href="#epoll操作过程" class="headerlink" title="epoll操作过程"></a>epoll操作过程</h3><p>epoll操作过程需要三个接口，分别如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>1. int epoll_create(int size);</strong><br>创建一个epoll的句柄，<strong>size用来告诉内核这个监听的数目一共有多大</strong>，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，<code>参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议</code>。当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p><p><strong>2. int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</strong><br>函数是对指定描述符fd执行op操作。</p><ul><li>epfd：是epoll_create()的返回值。</li><li>op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。</li><li>fd：是需要监听的fd（文件描述符）</li><li>epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">  <span class="keyword">__uint32_t</span> events;  <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;  <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//events可以是以下几个宏的集合：</span></span><br><span class="line">EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</span><br><span class="line">EPOLLOUT：表示对应的文件描述符可以写；</span><br><span class="line">EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</span><br><span class="line">EPOLLERR：表示对应的文件描述符发生错误；</span><br><span class="line">EPOLLHUP：表示对应的文件描述符被挂断；</span><br><span class="line">EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</span><br><span class="line">EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</span><br></pre></td></tr></table></figure><p><strong>3. int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</strong><br>等待epfd上的io事件，最多返回maxevents个事件。<br>参数events用来表示<strong>从内核得到事件的集合</strong>，<strong>maxevents告之内核这个events有多大</strong>，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p><h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><p>　epoll对文件描述符的操作有两种模式：<strong>LT（level trigger）</strong>和<strong>ET（edge trigger）</strong>。LT模式是默认模式，LT模式与ET模式的区别如下：<br>　　<strong>LT模式</strong>：当<code>epoll_wait</code>检测到描述符事件发生并将此事件通知应用程序，<code>应用程序可以不立即处理该事件</code>。下次调用epoll_wait时，会再次响应应用程序并通知此事件。<br>　　<strong>ET模式</strong>：当<code>epoll_wait</code>检测到描述符事件发生并将此事件通知应用程序，<code>应用程序必须立即处理该事件</code>。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p><h4 id="1-LT模式"><a href="#1-LT模式" class="headerlink" title="1. LT模式"></a>1. LT模式</h4><p><strong>LT(level triggered)是缺省的工作方式</strong>，并且同时支持<code>block</code>和<code>no-block socket</code>.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。<strong>如果你不作任何操作，内核还是会继续通知你的。</strong></p><h4 id="2-ET模式"><a href="#2-ET模式" class="headerlink" title="2. ET模式"></a>2. ET模式</h4><p>ET(edge-triggered)是<strong>高速工作方式</strong>，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</p><p><strong>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。</strong>epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p><h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h4><p><strong>假如有这样一个例子：</strong></p><ol><li>我们已经把一个用来从管道中读取数据的文件句柄(RFD)添加到epoll描述符</li><li>这个时候从管道的另一端被写入了2KB的数据</li><li>调用epoll_wait(2)，并且它会返回RFD，说明它已经准备好读取操作</li><li>然后我们读取了1KB的数据</li><li>调用epoll_wait(2)……</li></ol><p><strong>LT模式：</strong><br>如果是LT模式，那么在第5步调用epoll_wait(2)之后，仍然能受到通知。</p><p><strong>ET模式：</strong><br>如果我们在第1步将RFD添加到epoll描述符的时候使用了EPOLLET标志，那么在第5步调用epoll_wait(2)之后将有可能会挂起，因为<strong>剩余的数据还存在于文件的输入缓冲区内</strong>，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候 ET 工作模式才会汇报事件。因此在第5步的时候，调用者可能会放弃等待仍在存在于文件输入缓冲区内的剩余数据。</p><p>当使用epoll的ET模型来工作时，当产生了一个EPOLLIN事件后，读数据的时候需要考虑的是当recv()返回的大小如果等于请求的大小，那么很有可能是缓冲区还有数据未读完，也意味着该次事件还没有处理完，所以还需要再次读取：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(rs)&#123;</span><br><span class="line">  buflen = recv(activeevents[i].data.fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(buflen &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 由于是非阻塞的模式,所以当errno为EAGAIN时,表示当前缓冲区已无数据可读</span></span><br><span class="line">    <span class="comment">// 在这里就当作是该次事件已处理处.</span></span><br><span class="line">    <span class="keyword">if</span>(errno == EAGAIN)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(buflen == <span class="number">0</span>)&#123;</span><br><span class="line">     <span class="comment">// 这里表示对端的socket已正常关闭.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(buflen == <span class="keyword">sizeof</span>(buf)&#123;</span><br><span class="line">      rs = <span class="number">1</span>;   <span class="comment">// 需要再次读取</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span>&#123;</span><br><span class="line">      rs = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Linux中的EAGAIN含义</strong></p></blockquote><p>Linux环境下开发经常会碰到很多错误(设置errno)，其中EAGAIN是其中比较常见的一个错误(比如用在非阻塞操作中)。<br>从字面上来看，是提示再试一次。这个错误经常出现在当应用程序进行一些非阻塞(non-blocking)操作(对文件或socket)的时候。</p><p>例如，以 O_NONBLOCK的标志打开文件/socket/FIFO，如果你连续做read操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返回，read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试。<br>又例如，当一个系统调用(比如fork)因为没有足够的资源(比如虚拟内存)而执行失败，返回EAGAIN提示其再调用一次(也许下次就能成功)。</p><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><p>下面是一段不完整的代码且格式不对，意在表述上面的过程，去掉了一些模板代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPADDRESS   <span class="meta-string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT        8787</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE     1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTENQ     5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FDSIZE      1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPOLLEVENTS 100</span></span><br><span class="line"></span><br><span class="line">listenfd = socket_bind(IPADDRESS,PORT);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">EPOLLEVENTS</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个描述符</span></span><br><span class="line">epollfd = epoll_create(FDSIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加监听描述符事件</span></span><br><span class="line">add_event(epollfd,listenfd,EPOLLIN);</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环等待</span></span><br><span class="line"><span class="keyword">for</span> ( ; ; )&#123;</span><br><span class="line">    <span class="comment">//该函数返回已经准备好的描述符事件数目</span></span><br><span class="line">    ret = epoll_wait(epollfd,events,EPOLLEVENTS,<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">//处理接收到的连接</span></span><br><span class="line">    handle_events(epollfd,events,ret,listenfd,buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_events</span><span class="params">(<span class="keyword">int</span> epollfd,struct epoll_event *events,<span class="keyword">int</span> num,<span class="keyword">int</span> listenfd,<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">     <span class="keyword">int</span> fd;</span><br><span class="line">     <span class="comment">//进行遍历;这里只要遍历已经准备好的io事件。num并不是当初epoll_create时的FDSIZE。</span></span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; num;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         fd = events[i].data.fd;</span><br><span class="line">        <span class="comment">//根据描述符的类型和事件类型进行处理</span></span><br><span class="line">         <span class="keyword">if</span> ((fd == listenfd) &amp;&amp;(events[i].events &amp; EPOLLIN))</span><br><span class="line">            handle_accpet(epollfd,listenfd);</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)</span><br><span class="line">            do_read(epollfd,fd,buf);</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT)</span><br><span class="line">            do_write(epollfd,fd,buf);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加事件</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_event</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> state)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = state;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    epoll_ctl(epollfd,EPOLL_CTL_ADD,fd,&amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理接收到的连接</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_accpet</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> listenfd)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> clifd;     </span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span>     </span><br><span class="line">     <span class="keyword">socklen_t</span>  cliaddrlen;     </span><br><span class="line">     clifd = accept(listenfd,(struct sockaddr*)&amp;cliaddr,&amp;cliaddrlen);     </span><br><span class="line">     <span class="keyword">if</span> (clifd == <span class="number">-1</span>)         </span><br><span class="line">     perror(<span class="string">"accpet error:"</span>);     </span><br><span class="line">     <span class="keyword">else</span> &#123;         </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"accept a new client: %s:%d\n"</span>,inet_ntoa(cliaddr.sin_addr),cliaddr.sin_port);                       <span class="comment">//添加一个客户描述符和事件         </span></span><br><span class="line">         add_event(epollfd,clifd,EPOLLIN);     </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读处理</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_read</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">char</span> *buf)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nread;</span><br><span class="line">    nread = read(fd,buf,MAXSIZE);</span><br><span class="line">    <span class="keyword">if</span> (nread == <span class="number">-1</span>)     &#123;         </span><br><span class="line">        perror(<span class="string">"read error:"</span>);         </span><br><span class="line">        close(fd); <span class="comment">//记住close fd        </span></span><br><span class="line">        delete_event(epollfd,fd,EPOLLIN); <span class="comment">//删除监听 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)     &#123;         </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"client close.\n"</span>);</span><br><span class="line">        close(fd); <span class="comment">//记住close fd       </span></span><br><span class="line">        delete_event(epollfd,fd,EPOLLIN); <span class="comment">//删除监听 </span></span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">else</span> &#123;         </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"read message is : %s"</span>,buf);        </span><br><span class="line">        <span class="comment">//修改描述符对应的事件，由读改为写         </span></span><br><span class="line">        modify_event(epollfd,fd,EPOLLOUT);     </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写处理</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_write</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">char</span> *buf)</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">int</span> nwrite;     </span><br><span class="line">    nwrite = write(fd,buf,<span class="built_in">strlen</span>(buf));     </span><br><span class="line">    <span class="keyword">if</span> (nwrite == <span class="number">-1</span>)&#123;         </span><br><span class="line">        perror(<span class="string">"write error:"</span>);        </span><br><span class="line">        close(fd);   <span class="comment">//记住close fd       </span></span><br><span class="line">        delete_event(epollfd,fd,EPOLLOUT);  <span class="comment">//删除监听    </span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        modify_event(epollfd,fd,EPOLLIN); </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="number">0</span>,MAXSIZE); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除事件</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete_event</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = state;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    epoll_ctl(epollfd,EPOLL_CTL_DEL,fd,&amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改事件</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modify_event</span><span class="params">(<span class="keyword">int</span> epollfd,<span class="keyword">int</span> fd,<span class="keyword">int</span> state)</span></span>&#123;     </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = state;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    epoll_ctl(epollfd,EPOLL_CTL_MOD,fd,&amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注：另外一端我就省了</span></span><br></pre></td></tr></table></figure><h3 id="epoll总结"><a href="#epoll总结" class="headerlink" title="epoll总结"></a>epoll总结</h3><p>在 select/poll中，<strong>进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描</strong>，而<strong>epoll事先通过epoll_ctl()来注册一 个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait() 时便得到通知</strong>。(<code>此处去掉了遍历文件描述符，而是通过监听回调的的机制</code>。这正是epoll的魅力所在。)</p><p><strong>epoll的优点主要是一下几个方面：</strong></p><ol><li><strong>监视的描述符数量不受限制</strong>，<strong>它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右</strong>，具体数目可以<code>cat /proc/sys/fs/file-max</code>查看,一般来说这个数目和系统内存关系很大。<strong>select的最大缺点就是进程打开的fd是有数量限制的</strong>。这对于连接数量比较大的服务器来说根本不能满足。虽然也可以选择多进程的解决方案( Apache就是这样实现的)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完美的方案。</li><li><strong>IO的效率不会随着监视fd的数量的增长而下降</strong>。epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的。只有就绪的fd才会执行回调函数。</li></ol><blockquote><p>如果没有大量的idle -connection或者dead-connection，epoll的效率并不会比select/poll高很多，但是当遇到大量的idle- connection，就会发现epoll的效率大大高于select/poll。</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.cnblogs.com/Anker/p/3269106.html" target="_blank" rel="noopener">用户空间与内核空间，进程上下文与中断上下文[总结]</a><br><a href="http://guojing.me/linux-kernel-architecture/posts/process-switch/" target="_blank" rel="noopener">进程切换</a><br><a href="https://zh.wikipedia.org/wiki/文件描述符" target="_blank" rel="noopener">维基百科-文件描述符</a><br><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-directio/" target="_blank" rel="noopener">Linux 中直接 I/O 机制的介绍</a><br><a href="http://blog.csdn.net/historyasamirror/article/details/5778378" target="_blank" rel="noopener">IO - 同步，异步，阻塞，非阻塞 （亡羊补牢篇）</a><br><a href="http://www.cnblogs.com/bigwangdi/p/3182958.html" target="_blank" rel="noopener">Linux中select poll和epoll的区别</a><br><a href="http://www.cnblogs.com/Anker/archive/2013/08/14/3258674.html" target="_blank" rel="noopener">IO多路复用之select总结</a><br><a href="http://www.cnblogs.com/Anker/archive/2013/08/15/3261006.html" target="_blank" rel="noopener">IO多路复用之poll总结</a><br><a href="http://www.cnblogs.com/Anker/archive/2013/08/17/3263780.html" target="_blank" rel="noopener">IO多路复用之epoll总结</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://segmentfault.com/a/1190000003063859&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux IO模式及 select、poll、epoll详解&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同步IO和异步IO，阻塞IO和非阻塞IO分别是什么，到底有什么区别？不同的人在不同的上下文下给出的答案是不同的。所以先限定一下本文的上下文。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;本文讨论的背景是Linux环境下的network IO。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://changsk.top/categories/Linux/"/>
    
    
      <category term="select" scheme="http://changsk.top/tags/select/"/>
    
      <category term="poll" scheme="http://changsk.top/tags/poll/"/>
    
      <category term="epoll" scheme="http://changsk.top/tags/epoll/"/>
    
  </entry>
  
  <entry>
    <title>Java CAS 原理剖析</title>
    <link href="http://changsk.top/2019/07/17/java-cas/"/>
    <id>http://changsk.top/2019/07/17/java-cas/</id>
    <published>2019-07-17T12:30:31.000Z</published>
    <updated>2019-07-17T12:42:16.225Z</updated>
    
    <content type="html"><![CDATA[<p>在Java并发中，我们最初接触的应该就是<code>synchronized</code>关键字了，但是<code>synchronized</code>属于重量级锁，很多时候会引起<strong>性能问题</strong>，<code>volatile</code>也是个不错的选择，但是<code>volatile</code><strong>不能保证原子性</strong>，只能在某些场合下使用。</p><a id="more"></a><p>像<code>synchronized</code>这种独占锁属于<strong>悲观锁</strong>，它是在假设一定会发生冲突的，那么加锁恰好有用，除此之外，还有<strong>乐观锁</strong>，乐观锁的含义就是假设没有发生冲突，那么我正好可以进行某项操作，如果要是发生冲突呢，那我就<strong>重试直到成功</strong>，乐观锁最常见的就是<code>CAS</code>。</p><p>我们在读<code>Concurrent</code>包下的类的源码时，发现无论是<strong>ReenterLock内部的AQS，还是各种Atomic开头的原子类</strong>，内部都应用到了<code>CAS</code>，最常见的就是我们在并发编程时遇到的<code>i++</code>这种情况。传统的方法肯定是在方法上加上<code>synchronized</code>关键字:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种方法在性能上可能会差一点，我们还可以使用<code>AtomicInteger</code>，就可以保证<code>i</code>原子的<code>++</code>了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AtomicInteger i;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看<code>getAndIncrement</code>的内部：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再深入到<code>getAndAddInt</code>():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们见到<code>compareAndSwapInt</code>这个函数，它也是<code>CAS</code>缩写的由来。那么仔细分析下这个函数做了什么呢？</p><p>首先我们发现<code>compareAndSwapInt</code>前面的<code>this</code>，那么它属于哪个类呢，我们看上一步<code>getAndAddInt</code>，前面是<code>unsafe</code>。这里我们进入的<code>Unsafe</code>类。这里要对<code>Unsafe</code>类做个说明。结合<code>AtomicInteger</code>的定义来说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6214790243416807050L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>在<code>AtomicInteger</code>数据定义的部分，我们可以看到，其实实际存储的值是放在<code>value</code>中的，除此之外我们还获取了<code>unsafe</code>实例，并且定义了<code>valueOffset</code>。再看到<code>static</code>块，懂类加载过程的都知道，<code>static</code>块的加载发生于类加载的时候，是最先初始化的，这时候我们调用<code>unsafe</code>的<code>objectFieldOffset</code>从<code>Atomic</code>类文件中获取<code>value</code>的偏移量，那么<code>valueOffset</code>其实就是记录<code>value</code>的偏移量的。</p><p>再回到上面一个函数<code>getAndAddInt</code>，我们看<code>var5</code>获取的是什么，通过调用<code>unsafe</code>的<code>getIntVolatile(var1, var2)</code>，这是个native方法，具体实现到JDK源码里去看了，其实就是获取<code>var1</code>中，<code>var2</code>偏移量处的值。<code>var1</code>就是<code>AtomicInteger</code>，<code>var2</code>就是我们前面提到的<code>valueOffset</code>,这样我们就从内存里获取到现在<code>valueOffset</code>处的值了。</p><p>现在重点来了，<code>compareAndSwapInt（var1, var2, var5, var5 + var4）</code>其实换成<code>compareAndSwapInt（obj, offset, expect, update）</code>比较清楚，意思就是如果<code>obj</code>内的<code>value</code>和<code>expect</code>相等，就<strong>证明没有其他线程改变过这个变量</strong>，那么就更新它为<code>update</code>，如果这一步的<code>CAS</code>没有成功，那就采用<strong>自旋</strong>的方式继续进行<code>CAS</code>操作，取出乍一看这也是两个步骤了啊，其实在<code>JNI</code>里是借助于一个<code>CPU</code>指令完成的。所以还是原子操作。</p><h2 id="CAS底层原理"><a href="#CAS底层原理" class="headerlink" title="CAS底层原理"></a>CAS底层原理</h2><p>CAS底层使用<code>JNI</code>调用C代码实现的，如果你有<code>Hotspot</code>源码，那么在<code>Unsafe.cpp</code>里可以找到它的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> JNINativeMethod methods_15[] = &#123;</span><br><span class="line">    <span class="comment">//省略一堆代码...</span></span><br><span class="line">    &#123;CC<span class="string">"compareAndSwapInt"</span>,  CC<span class="string">"("</span>OBJ<span class="string">"J"</span><span class="string">"I"</span><span class="string">"I"</span><span class="string">")Z"</span>,      FN_PTR(Unsafe_CompareAndSwapInt)&#125;,</span><br><span class="line">    &#123;CC<span class="string">"compareAndSwapLong"</span>, CC<span class="string">"("</span>OBJ<span class="string">"J"</span><span class="string">"J"</span><span class="string">"J"</span><span class="string">")Z"</span>,      FN_PTR(Unsafe_CompareAndSwapLong)&#125;,</span><br><span class="line">    <span class="comment">//省略一堆代码...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以看到<code>compareAndSwapInt</code>实现是在<code>Unsafe_CompareAndSwapInt</code>里面，再深入到<code>Unsafe_CompareAndSwapInt</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_CompareAndSwapInt"</span>);</span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure><p>p是取出的对象，addr是p中offset处的地址，最后调用了<code>Atomic::cmpxchg(x, addr, e)</code>, 其中参数x是即将更新的值，参数e是原内存的值。代码中能看到cmpxchg有基于各个平台的实现，这里我选择Linux X86平台下的源码分析：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> jint     Atomic::cmpxchg    (jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value) &#123;</span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><br><span class="line">  __<span class="function">asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">4</span>) <span class="string">"cmpxchgl %1,(%3)"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"=a"</span> (exchange_value)</span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"r"</span> (exchange_value), <span class="string">"a"</span> (compare_value), <span class="string">"r"</span> (dest), <span class="string">"r"</span> (mp)</span></span></span><br><span class="line"><span class="function"><span class="params">                    : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> exchange_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一段小汇编，<code>__asm__</code>说明是ASM汇编，<code>__volatile__</code>禁止编译器优化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Adding a lock prefix to an instruction on MP machine</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_IF_MP(mp) <span class="meta-string">"cmp $0, "</span> #mp <span class="meta-string">"; je 1f; lock; 1: "</span></span></span><br></pre></td></tr></table></figure><p><code>os::is_MP</code>判断当前系统是否为多核系统，如果是就给<strong>总线加锁</strong>，<strong>所以同一芯片上的其他处理器就暂时不能通过总线访问内存，保证了该指令在多处理器环境下的原子性。</strong></p><p>在正式解读这段汇编前，我们来了解下嵌入汇编的基本格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">asm ( assembler template</span><br><span class="line">    : output operands                  /* optional */</span><br><span class="line">    : input operands                   /* optional */</span><br><span class="line">    : list of clobbered registers      /* optional */</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><ul><li><strong>template</strong>就是<code>cmpxchgl %1,(%3)</code>表示汇编模板</li><li><strong>output operands</strong>表示输出操作数,<code>=a</code>对应eax寄存器</li><li><strong>input operand</strong> 表示输入参数，<code>%1</code> 就是<code>exchange_value</code>, <code>%3</code>是<code>dest</code>, <code>%4</code>就是<code>mp</code>， <code>r</code>表示任意寄存器，<code>a</code>还是<code>eax</code>寄存器</li><li><strong>list of clobbered registers</strong>就是些额外参数，<code>cc</code>表示编译器<code>cmpxchgl</code>的执行将影响到标志寄存器, <code>memory</code>告诉编译器要重新从内存中读取变量的最新值，这点实现了<code>volatile</code>的感觉。</li></ul><p>那么表达式其实就是<code>cmpxchgl exchange_value ,dest</code>，我们会发现<code>%2</code>也就是<code>compare_value</code>没有用上，这里就要分析<code>cmpxchgl</code>的语义了。<code>cmpxchgl</code>末尾<code>l</code>表示操作数长度为<code>4</code>，上面已经知道了。<code>cmpxchgl</code>会默认比较<code>eax</code>寄存器的值即<code>compare_value</code>和<code>exchange_value</code>的值，<strong>如果相等，就把dest的值赋值给exchange_value,否则，将exchange_value赋值给eax</strong>。具体汇编指令可以查看Intel手册<a href="https://link.juejin.im?target=http%3A%2F%2Ffaydoc.tripod.com%2Fcpu%2Fcmpxchg.htm" target="_blank" rel="noopener">CMPXCHG</a></p><p><strong>最终，JDK通过CPU的<code>cmpxchgl</code>指令的支持，实现<code>AtomicInteger</code>的<code>CAS</code>操作的原子性。</strong></p><h2 id="CAS-的问题"><a href="#CAS-的问题" class="headerlink" title="CAS 的问题"></a>CAS 的问题</h2><ol><li><strong>ABA问题</strong></li></ol><p>CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。这就是CAS的ABA问题。 <strong>常见的解决思路是使用版本号</strong>。<strong>在变量前面追加上版本号</strong>，每次变量更新的时候把版本号加一，那么<code>A-B-A</code> 就会变成<code>1A-2B-3A</code>。 目前在JDK的atomic包里提供了一个类<code>AtomicStampedReference</code>来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，<strong>并且当前标志是否等于预期标志</strong>，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><ol start="2"><li><strong>循环时间长开销大</strong></li></ol><p>上面我们说过如果CAS不成功，则会原地自旋，如果长时间自旋会给CPU带来非常大的执行开销。</p><blockquote><p>作者：卡巴拉的树</p><p>链接：<a href="https://juejin.im/post/5a73cbbff265da4e807783f5" target="_blank" rel="noopener">https://juejin.im/post/5a73cbbff265da4e807783f5</a></p><p>来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Java并发中，我们最初接触的应该就是&lt;code&gt;synchronized&lt;/code&gt;关键字了，但是&lt;code&gt;synchronized&lt;/code&gt;属于重量级锁，很多时候会引起&lt;strong&gt;性能问题&lt;/strong&gt;，&lt;code&gt;volatile&lt;/code&gt;也是个不错的选择，但是&lt;code&gt;volatile&lt;/code&gt;&lt;strong&gt;不能保证原子性&lt;/strong&gt;，只能在某些场合下使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://changsk.top/categories/Java/"/>
    
    
      <category term="java" scheme="http://changsk.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>构造回文</title>
    <link href="http://changsk.top/2019/07/17/longest-common-subsequence/"/>
    <id>http://changsk.top/2019/07/17/longest-common-subsequence/</id>
    <published>2019-07-17T12:08:12.000Z</published>
    <updated>2019-07-17T12:16:21.082Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://blog.csdn.net/zr1076311296/article/details/51723040" target="_blank" rel="noopener">腾讯2017暑期实习生笔试题</a>、</p></blockquote><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="1.jpg" alt></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>看到这个图的时候相信大家明白了吧，就是这个题，我一直没有思路，今天突然想起来了，所以就准备解决它。其实这个题主要是运用一个算法思路来解决，最长公共子序列。</p><pre><code>仔细想一想，将字符串逆序后与原来的字符串求最长公共子序列不就是这个构造回文吗？这应该很好理解吧，下面简单科普一下最长公共子序列：这中序列不是连续的，意思是可以有间隔，去掉那些干扰项以后，两个序列完全相同，而且要求这个子序列最长。这类问题和之前 leetcode 上机器人跳到最右下角那个题一样，是一种动态规划的题。而且这种问题的当前位置的解受前面位置的解的影响，假设 s1，s2为两个字符串，i表示s1中第i个字符，j表示s2中第j个字符，那么:</code></pre><p><img src="2.jpg" alt></p><p>再一次说明一下解题思路：<strong>输入字符串S，将字符串S逆序，逆序后的字符串为tmp，然后求S与tmp的最长公共子序列，最后用S的长度减去最长公共子序列的长度，就是需要删除的元素的个数</strong>。 相信思路大家明白思路了，下面给出代码。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LongestStrHui</span><span class="params">(<span class="built_in">string</span> &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> tmp = s;</span><br><span class="line"><span class="comment">//逆序</span></span><br><span class="line">reverse(tmp.begin(), tmp.end());</span><br><span class="line"><span class="keyword">int</span> len = s.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化二维数组,数组多开辟了一些空间，是为了优化</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; V(len + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">//根据"公式"开始去找各个位置的公共子序列长度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] == tmp[j])</span><br><span class="line">V[i + <span class="number">1</span>][j + <span class="number">1</span>] = <span class="number">1</span> + V[i][j];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">V[i + <span class="number">1</span>][j + <span class="number">1</span>] = max(V[i][j + <span class="number">1</span>], V[i + <span class="number">1</span>][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//整个序列的最长公共子序列</span></span><br><span class="line"><span class="keyword">return</span> len - V[len][len];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; LongestStrHui(s)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://blog.csdn.net/zr1076311296/article/details/51723040&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;腾讯2017暑期实习生笔试题&lt;/a&gt;、&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://changsk.top/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>linux之top</title>
    <link href="http://changsk.top/2019/07/17/linux-top/"/>
    <id>http://changsk.top/2019/07/17/linux-top/</id>
    <published>2019-07-17T02:38:17.000Z</published>
    <updated>2019-07-17T03:01:12.484Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://www.cnblogs.com/peida/archive/2012/12/24/2831353.html" target="_blank" rel="noopener">每天一个linux命令（44）：top命令</a></p></blockquote><p>top命令是Linux下常用的<strong>性能分析工具</strong>，能够<strong>实时显示系统中各个进程的资源占用状况</strong>，类似于Windows的任务管理器。下面详细介绍它的使用方法。top是一个<strong>动态显示</strong>过程,即可以<strong>通过用户按键来不断刷新当前状态</strong>.如果在前台执行该命令,它将独占前台,直到用户终止该程序为止.比较准确的说,top命令提供了实时的对系统处理器的状态监视.它将<strong>显示系统中CPU最“敏感”的任务列表</strong>.该命令可以<strong>按CPU使用.内存使用和执行时间对任务进行排序</strong>；而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定.</p><a id="more"></a><p><strong>1．命令格式：</strong></p><p>top [参数]</p><p><strong>2．命令功能：</strong></p><p>显示当前系统正在执行的进程的相关信息，包括<strong>进程ID</strong>、<strong>内存占用率</strong>、<strong>CPU占用率</strong>等</p><p><strong>3．命令参数：</strong></p><p>-b 批处理</p><p>-c 显示完整的治命令</p><p>-I 忽略失效过程</p><p>-s 保密模式</p><p>-S 累积模式</p><p>-i&lt;时间&gt; 设置间隔时间</p><p>-u&lt;用户名&gt; 指定用户名</p><p>-p&lt;进程号&gt; 指定进程</p><p>-n&lt;次数&gt; 循环显示的次数</p><p><strong>4．使用实例：</strong></p><p><strong>实例1：显示进程信息</strong></p><p><strong>命令：</strong></p><p>top</p><p><strong>输出：</strong></p><p>[root@TG1704 log]# top</p><p>top - 14:06:23 up 70 days, 16:44,  2 users,  load average: 1.25, 1.32, 1.35</p><p>Tasks: 206 total,   1 running, 205 sleeping,   0 stopped,   0 zombie</p><p>Cpu(s):  5.9%us,  3.4%sy,  0.0%ni, 90.4%id,  0.0%wa,  0.0%hi,  0.2%si,  0.0%st</p><p>Mem:  32949016k total, 14411180k used, 18537836k free,   169884k buffers</p><p>Swap: 32764556k total,        0k used, 32764556k free,  3612636k cached</p><p>  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                                                                </p><p>28894 root      22   0 1501m 405m  10m S 52.2  1.3   2534:16 java                                                                   </p><p>18249 root      18   0 3201m 1.9g  11m S 35.9  6.0 569:39.41 java                                                                   </p><p> 2808 root      25   0 3333m 1.0g  11m S 24.3  3.1 526:51.85 java                                                                   </p><p>25668 root      23   0 3180m 704m  11m S 14.0  2.2 360:44.53 java                                                                   </p><p>  574 root      25   0 3168m 611m  10m S 12.6  1.9 556:59.63 java                                                                   </p><p> 1599 root      20   0 3237m 1.9g  11m S 12.3  6.2 262:01.14 java                                                                   </p><p> 1008 root      21   0 3147m 842m  10m S  0.3  2.6   4:31.08 java                                                                   </p><p>13823 root      23   0 3031m 2.1g  10m S  0.3  6.8 176:57.34 java                                                                   </p><p>28218 root      15   0 12760 1168  808 R  0.3  0.0   0:01.43 top                                                                    </p><p>29062 root      20   0 1241m 227m  10m S  0.3  0.7   2:07.32 java                                                                   </p><p>​    1 root      15   0 10368  684  572 S  0.0  0.0   1:30.85 init                                                                   </p><p>​    2 root      RT  -5     0    0    0 S  0.0  0.0   0:01.01 migration/0                                                            </p><p>​    3 root      34  19     0    0    0 S  0.0  0.0   0:00.00 ksoftirqd/0                                                            </p><p>​    4 root      RT  -5     0    0    0 S  0.0  0.0   0:00.00 watchdog/0                                                             </p><p>​    5 root      RT  -5     0    0    0 S  0.0  0.0   0:00.80 migration/1                                                            </p><p>​    6 root      34  19     0    0    0 S  0.0  0.0   0:00.00 ksoftirqd/1                                                            </p><p>​    7 root      RT  -5     0    0    0 S  0.0  0.0   0:00.00 watchdog/1                                                             </p><p>​    8 root      RT  -5     0    0    0 S  0.0  0.0   0:20.59 migration/2                                                            </p><p>​    9 root      34  19     0    0    0 S  0.0  0.0   0:00.09 ksoftirqd/2                                                            </p><p>   10 root      RT  -5     0    0    0 S  0.0  0.0   0:00.00 watchdog/2                                                             </p><p>   11 root      RT  -5     0    0    0 S  0.0  0.0   0:23.66 migration/3                                                            </p><p>   12 root      34  19     0    0    0 S  0.0  0.0   0:00.03 ksoftirqd/3                                                            </p><p>   13 root      RT  -5     0    0    0 S  0.0  0.0   0:00.00 watchdog/3                                                             </p><p>   14 root      RT  -5     0    0    0 S  0.0  0.0   0:20.29 migration/4                                                            </p><p>   15 root      34  19     0    0    0 S  0.0  0.0   0:00.07 ksoftirqd/4                                                            </p><p>   16 root      RT  -5     0    0    0 S  0.0  0.0   0:00.00 watchdog/4                                                             </p><p>   17 root      RT  -5     0    0    0 S  0.0  0.0   0:23.07 migration/5                                                            </p><p>   18 root      34  19     0    0    0 S  0.0  0.0   0:00.07 ksoftirqd/5                                                            </p><p>   19 root      RT  -5     0    0    0 S  0.0  0.0   0:00.00 watchdog/5                                                             </p><p>   20 root      RT  -5     0    0    0 S  0.0  0.0   0:17.16 migration/6                                                            </p><p>   21 root      34  19     0    0    0 S  0.0  0.0   0:00.05 ksoftirqd/6                                                            </p><p>   22 root      RT  -5     0    0    0 S  0.0  0.0   0:00.00 watchdog/6                                                             </p><p>   23 root      RT  -5     0    0    0 S  0.0  0.0   0:58.28 migration/7</p><p><strong>说明：</strong></p><p><strong>统计信息区</strong>：</p><p>前五行是<strong>当前系统情况整体的统计信息区</strong>。下面我们看每一行信息的具体意义。</p><p><strong>第一行</strong>，任务队列信息，同 uptime 命令的执行结果，具体参数说明情况如下：</p><p>14:06:23 — 当前系统时间</p><p>up 70 days, 16:44 — 系统已经运行了70天16小时44分钟（在这期间系统没有重启过的吆！）</p><p>2 users — 当前有2个用户登录系统</p><p>load average: 1.15, 1.42, 1.44 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。</p><p><strong>load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了</strong>。</p><p><strong>第二行</strong>，Tasks — 任务（进程），具体信息说明如下：</p><p>系统现在共有206个进程，其中处于运行中的有1个，205个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。</p><p><strong>第三行</strong>，cpu状态信息，具体属性说明如下：</p><p>5.9%us — 用户空间占用CPU的百分比。</p><p>3.4% sy — 内核空间占用CPU的百分比。</p><p>0.0% ni — 改变过优先级的进程占用CPU的百分比</p><p>90.4% id — 空闲CPU百分比</p><p>0.0% wa — IO等待占用CPU的百分比</p><p>0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比</p><p>0.2% si — 软中断（Software Interrupts）占用CPU的百分比</p><p><strong>备注：</strong>在这里CPU的使用比率和windows概念不同，需要理解linux系统用户空间和内核空间的相关知识！</p><p><strong>第四行</strong>,内存状态，具体信息如下：</p><p>32949016k total — 物理内存总量（32GB）</p><p>14411180k used — 使用中的内存总量（14GB）</p><p>18537836k free — 空闲内存总量（18GB）</p><p>169884k buffers — 缓存的内存量 （169M）</p><p><strong>第五行，</strong>swap交换分区信息，具体信息说明如下：</p><p>32764556k total — 交换区总量（32GB）</p><p>0k used — 使用的交换区总量（0K）</p><p>32764556k free — 空闲交换区总量（32GB）</p><p>3612636k cached — 缓冲的交换区总量（3.6GB）</p><p><strong>备注：</strong></p><p>第四行中使用中的内存总量（used）指的是现在系统内核控制的内存数，<strong>空闲内存总量（free）是内核还未纳入其管控范围的数量</strong>。纳入内核管理的内存不见得都在使用中，还包括过去使用过的现在可以被重复利用的内存，内核并不把这些可被重新使用的内存交还到free中去，因此在linux上free内存会越来越少，但不用为此担心。</p><p>如果出于习惯去计算可用内存数，这里有个近似的计算公式：<code>第四行的free + 第四行的buffers + 第五行的cached</code>，按这个公式此台服务器的可用内存：18537836k +169884k +3612636k = 22GB左右。</p><p><strong>对于内存监控，在top里我们要时刻监控第五行swap交换分区的used，如果这个数值在不断的变化，说明内核在不断进行内存和swap的数据交换，这是真正的内存不够用了。</strong></p><p><strong>第六行，空行。</strong></p><p><strong>第七行以下：各进程（任务）的状态监控，项目列信息说明如下：</strong></p><p><strong>PID — 进程id</strong></p><p><strong>USER — 进程所有者</strong></p><p>PR — 进程优先级</p><p>NI — nice值。负值表示高优先级，正值表示低优先级</p><p>VIRT — <strong>进程使用的虚拟内存总量</strong>，单位kb。VIRT=SWAP+RES</p><p>RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</p><p>SHR — 共享内存大小，单位kb</p><p>S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</p><p>%CPU — 上次更新到现在的CPU时间占用百分比</p><p>%MEM — 进程使用的物理内存百分比</p><p>TIME+ — 进程使用的CPU时间总计，单位1/100秒</p><p>COMMAND — 进程名称（命令名/命令行）</p><p><strong>其他使用技巧：</strong></p><p><strong>1.</strong>多U多核CPU监控</p><p>在top基本视图中，按键盘数字“1”，可监控每个逻辑CPU的状况：</p><p>​    <img src="1.jpg" alt="img"> </p><p>观察上图，服务器有16个逻辑CPU，实际上是4个物理CPU。再按数字键1，就会返回到top基本视图界面。</p><p><strong>2.</strong>高亮显示当前运行进程</p><p>​    敲击键盘“b”（打开/关闭加亮效果），top的视图变化如下：</p><p>​       <img src="2.jpg" alt="img">  </p><p>我们发现进程id为2570的“top”进程被加亮了，top进程就是视图第二行显示的唯一的运行态（running）的那个进程，可以通过敲击“y”键关闭或打开运行态进程的加亮效果。</p><p><strong>3.</strong>进程字段排序</p><p>默认进入top时，各进程是按照<strong>CPU的占用量</strong>来排序的，在下图中进程ID为28894的java进程排在第一（cpu占用142%），进程ID为574的java进程排在第二（cpu占用16%）。</p><p>​      <img src="3.jpg" alt="img"></p><p>​    敲击键盘“x”（打开/关闭排序列的加亮效果），top的视图变化如下：</p><p>​      <img src="4.jpg" alt="img">     </p><p>可以看到，top默认的排序列是“%CPU”。</p><p>*<em>4. *</em>通过”shift + &gt;”或”shift + &lt;”可以向右或左改变排序列</p><p>​    下图是按一次”shift + &gt;”的效果图,视图现在已经按照%MEM来排序。</p><p>​       <img src="5.jpg" alt="img">     </p><p><strong>5.top交互命令</strong></p><p>在top 命令执行过程中可以使用的一些交互命令。这些命令都是单字母的，如果在命令行中使用了s 选项， 其中一些命令可能会被屏蔽。</p><p>h 显示帮助画面，给出一些简短的命令总结说明</p><p>k 终止一个进程。</p><p>i 忽略闲置和僵死进程。这是一个开关式命令。</p><p>q 退出程序</p><p>r 重新安排一个进程的优先级别</p><p>S 切换到累计模式</p><p>s 改变两次刷新之间的延迟时间（单位为s），如果有小数，就换算成m s。输入0值则系统将不断刷新，<strong>默认值是5 s</strong></p><p>f或者F 从当前显示中添加或者删除项目</p><p>o或者O 改变显示项目的顺序</p><p>l 切换显示平均负载和启动时间信息</p><p>m 切换显示内存信息</p><p>t 切换显示进程和CPU状态信息</p><p>c 切换显示命令名称和完整命令行</p><p>M 根据驻留内存大小进行排序</p><p>P 根据CPU使用百分比大小进行排序</p><p>T 根据时间/累计时间进行排序</p><p>W 将当前设置写入~/.toprc文件中 </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://www.cnblogs.com/peida/archive/2012/12/24/2831353.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;每天一个linux命令（44）：top命令&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;top命令是Linux下常用的&lt;strong&gt;性能分析工具&lt;/strong&gt;，能够&lt;strong&gt;实时显示系统中各个进程的资源占用状况&lt;/strong&gt;，类似于Windows的任务管理器。下面详细介绍它的使用方法。top是一个&lt;strong&gt;动态显示&lt;/strong&gt;过程,即可以&lt;strong&gt;通过用户按键来不断刷新当前状态&lt;/strong&gt;.如果在前台执行该命令,它将独占前台,直到用户终止该程序为止.比较准确的说,top命令提供了实时的对系统处理器的状态监视.它将&lt;strong&gt;显示系统中CPU最“敏感”的任务列表&lt;/strong&gt;.该命令可以&lt;strong&gt;按CPU使用.内存使用和执行时间对任务进行排序&lt;/strong&gt;；而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定.&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://changsk.top/categories/Linux/"/>
    
    
      <category term="Linux命令" scheme="http://changsk.top/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>distributed-lock</title>
    <link href="http://changsk.top/2019/07/16/distributed-lock/"/>
    <id>http://changsk.top/2019/07/16/distributed-lock/</id>
    <published>2019-07-16T12:54:22.000Z</published>
    <updated>2019-07-16T12:54:22.187Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>详解CMS垃圾回收机制</title>
    <link href="http://changsk.top/2019/07/15/jvm-cms/"/>
    <id>http://changsk.top/2019/07/15/jvm-cms/</id>
    <published>2019-07-15T02:38:53.000Z</published>
    <updated>2019-07-15T04:38:27.435Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是CMS？"><a href="#什么是CMS？" class="headerlink" title="什么是CMS？"></a>什么是CMS？</h2><p>Concurrent Mark Sweep。</p><p>看名字就知道，CMS是一款并发、使用标记-清除算法的gc。</p><p>CMS是针对老年代进行回收的GC。</p><a id="more"></a><h2 id="CMS有什么用？"><a href="#CMS有什么用？" class="headerlink" title="CMS有什么用？"></a>CMS有什么用？</h2><p>CMS以获取最小停顿时间为目的。</p><p>在一些对响应时间有很高要求的应用或网站中，用户程序不能有长时间的停顿，CMS 可以用于此场景。 </p><p>CMS收集器的主要设计目标是：低应用停顿时间。它通过两种方式实现这一目标：</p><ol><li><p>不压缩老年代，而是使用空闲列表来管理回收空间。</p></li><li><p>大部分标记清理工作与应用程序并发执行。</p></li></ol><p>主要问题：由于不压缩带来的老年代堆碎片，或者在对象分配率高的情况下，都可能导致Full GC。</p><h2 id="CMS如何执行？"><a href="#CMS如何执行？" class="headerlink" title="CMS如何执行？"></a>CMS如何执行？</h2><p>CMS收集器的GC周期主要由7个阶段组成，其中有两个阶段会发生stop-the-world，其他阶段都是并发执行的。（亦有4个阶段、6个阶段等说法）</p><h3 id="Phase-1-Initial-Mark（初始化标记）"><a href="#Phase-1-Initial-Mark（初始化标记）" class="headerlink" title="Phase 1: Initial Mark（初始化标记）"></a>Phase 1: Initial Mark（初始化标记）</h3><p>初始化标记阶段，是CMS GC的第一个阶段，也是标记阶段的开始。主要工作是标记可直达的存活对象。</p><p>主要标记过程</p><ul><li>从GC Roots遍历可直达的老年代对象；</li><li>遍历被新生代存活对象所引用的老年代对象。</li></ul><p>程序执行情况</p><ul><li>支持单线程或并行标记。</li><li>发生stop-the-world，暂停所有应用线程。</li></ul><p><img src="1.jpg" alt="img"></p><p>（Marked obj：老年代绿色圆点表示被初始化标记的对象。）</p><h3 id="Phase-2-Concurrent-Mark（并发标记）"><a href="#Phase-2-Concurrent-Mark（并发标记）" class="headerlink" title="Phase 2: Concurrent Mark（并发标记）"></a>Phase 2: Concurrent Mark（并发标记）</h3><p>并发标记阶段，是CMS GC的第二个阶段。</p><p>在该阶段，GC线程和应用线程将并发执行。也就是说，在第一个阶段（Initial Mark）被暂停的应用线程将恢复运行。</p><p>并发标记阶段的主要工作是，通过遍历第一个阶段（Initial Mark）标记出来的存活对象，继续递归遍历老年代，并标记可直接或间接到达的所有老年代存活对象。</p><p><img src="2.jpg" alt="img"></p><p>（Current obj：该对象的引用关系发生变化，对下一个对象的引用被删除。）</p><p>由于在并发标记阶段，应用线程和GC线程是并发执行的，因此可能产生新的对象或对象关系发生变化，例如：</p><ul><li>新生代的对象晋升到老年代；</li><li>直接在老年代分配对象；</li><li>老年代对象的引用关系发生变更；</li><li>等等。</li></ul><p>对于这些对象，需要重新标记以防止被遗漏。为了提高重新标记的效率，本阶段会把这些发生变化的对象所在的Card标识为Dirty，这样后续就只需要扫描这些Dirty Card的对象，从而避免扫描整个老年代。</p><h3 id="Phase-3-Concurrent-Preclean（并发预清理）"><a href="#Phase-3-Concurrent-Preclean（并发预清理）" class="headerlink" title="Phase 3: Concurrent Preclean（并发预清理）"></a>Phase 3: Concurrent Preclean（并发预清理）</h3><p>在并发预清洗阶段，将会重新扫描前一个阶段标记的Dirty对象，并标记被Dirty对象直接或间接引用的对象，然后清除Card标识。</p><p>标记被Dirty对象直接或间接引用的对象：</p><p><img src="3.jpg" alt="img"></p><p>清除Dirty对象的Card标识：</p><p><img src="4.jpg" alt="img"></p><h3 id="Phase-4-Concurrent-Abortable-Preclean（可中止的并发预清理）"><a href="#Phase-4-Concurrent-Abortable-Preclean（可中止的并发预清理）" class="headerlink" title="Phase 4: Concurrent Abortable Preclean（可中止的并发预清理）"></a>Phase 4: Concurrent Abortable Preclean（可中止的并发预清理）</h3><p>本阶段尽可能承担更多的并发预处理工作，从而减轻在Final Remark阶段的stop-the-world。</p><p>在该阶段，主要循环的做两件事：</p><ul><li>处理 From 和 To 区的对象，标记可达的老年代对象；</li><li>和上一个阶段一样，扫描处理Dirty Card中的对象。</li></ul><p>具体执行多久，取决于许多因素，满足其中一个条件将会中止运行：</p><ul><li>执行循环次数达到了阈值；</li><li>执行时间达到了阈值；</li><li>新生代Eden区的内存使用率达到了阈值。</li></ul><h3 id="Phase-5-Final-Remark（重新标记）"><a href="#Phase-5-Final-Remark（重新标记）" class="headerlink" title="Phase 5: Final Remark（重新标记）"></a>Phase 5: Final Remark（重新标记）</h3><p>预清理阶段也是并发执行的，并不一定是所有存活对象都会被标记，因为在并发标记的过程中对象及其引用关系还在不断变化中。</p><p>因此，需要有一个stop-the-world的阶段来完成最后的标记工作，这就是重新标记阶段（CMS标记阶段的最后一个阶段）。主要目的是重新扫描之前并发处理阶段的所有残留更新对象。</p><p>主要工作：</p><ul><li>遍历新生代对象，重新标记；（新生代会被分块，多线程扫描）</li><li>根据GC Roots，重新标记；</li><li>遍历老年代的Dirty Card，重新标记。这里的Dirty Card，大部分已经在Preclean阶段被处理过了。</li></ul><h3 id="Phase-6-Concurrent-Sweep（并发清理）"><a href="#Phase-6-Concurrent-Sweep（并发清理）" class="headerlink" title="Phase 6: Concurrent Sweep（并发清理）"></a>Phase 6: Concurrent Sweep（并发清理）</h3><p>并发清理阶段，主要工作是清理所有未被标记的死亡对象，回收被占用的空间。</p><p><img src="5.jpg" alt="img"></p><h3 id="Phase-7-Concurrent-Reset（并发重置）"><a href="#Phase-7-Concurrent-Reset（并发重置）" class="headerlink" title="Phase 7: Concurrent Reset（并发重置）"></a>Phase 7: Concurrent Reset（并发重置）</h3><p>并发重置阶段，将清理并恢复在CMS GC过程中的各种状态，重新初始化CMS相关数据结构，为下一个垃圾收集周期做好准备。</p><h2 id="CMS有什么问题？"><a href="#CMS有什么问题？" class="headerlink" title="CMS有什么问题？"></a>CMS有什么问题？</h2><p><strong>CMS这三个字母就隐含了问题所在</strong>。<strong>并发+标记-清除算法 是问题的来源</strong>。 </p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>并发意味着多线程抢占CPU资源，即GC线程与用户线程抢占CPU。这可能会造成用户线程执行效率下降。</p><p>CMS默认的回收线程数是<strong>(CPU个数+3)/4。</strong>这个公式的意思是当CPU大于4个时,保证回收线程占用至少25%的CPU资源，这样用户线程占用75%的CPU，这是可以接受的。</p><p>但是，如果CPU资源很少，比如只有两个的时候怎么办？按照上面的公式，CMS会启动1个GC线程。相当于GC线程占用了50%的CPU资源，这就可能导致用户程序的执行速度忽然降低了50%，50%已经是很明显的降低了。</p><p><strong>这种场景怎么处理呢？</strong></p><p>我给的答案是可以不用考虑这种场景。现在的PC机中都至少有双核处理器，更别说大型的服务器了。</p><p>CMS的解决方案是提供了一个 incremental mode（增量模式）。</p><p>在这种模式下，进行并发标记、清理时让GC线程、用户线程交替运行，尽量减少GC线程独占CPU资源的时间。</p><p>这会造成GC时间更长，但对用户线程造成的影响就会少一些。</p><p>但实践证明，这种模式下CMS的表现很一般，并没有什么大的优化。</p><p>i-CMS已经被声明为“<strong><em>deprecated</em></strong>”，不再提倡使用。</p><p>(<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#concurrent_mark_sweep_cms_collector" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#concurrent_mark_sweep_cms_collector</a>)</p><h3 id="浮动垃圾"><a href="#浮动垃圾" class="headerlink" title="浮动垃圾"></a>浮动垃圾</h3><p>并发清理阶段用户线程还在运行，这段时间就可能产生新的垃圾，新的垃圾在此次GC无法清除，只能等到下次清理。这些垃圾有个专业名词：<strong>浮动垃圾</strong>。</p><p>由于垃圾回收阶段用户线程仍在执行，必需预留出内存空间给用户线程使用。因此不能像其他回收器那样，等到老年代满了再进行GC。</p><p>CMS 提供了<strong>CMSInitiatingOccupancyFraction</strong>参数来设置老年代空间使用百分比,达到百分比就进行垃圾回收。</p><p>这个参数默认是92%，参数选择需要看具体的应用场景。</p><p>设置的太小会导致频繁的CMS GC，产生大量的停顿；反过来想，设置的太高会发生什么？</p><p>假设现在设置为99%，还剩1%的空间可以使用。</p><p>在并发清理阶段，若用户线程需要使用的空间大于1%，就会产生Concurrent  Mode Failure错误，意思就是说并发模式失败。</p><p>这时，虚拟机就会启动备案：使用Serial Old收集器重新对老年代进行垃圾回收.如此一来，停顿时间变得更长。</p><p>所以<strong>CMSInitiatingOccupancyFraction</strong>的设置要具体问题具体分析。</p><p>网上有一些设置此参数的公式，个人认为不是很严谨(原因就是CMS另外一个问题导致的),因此不写出来以免大家疑惑。</p><p>其实CMS有<strong>动态检查机制</strong>。</p><p>CMS会根据历史记录，预测老年代还需要多久填满及进行一次回收所需要的时间。</p><p>在老年代空间用完之前，CMS可以根据自己的预测自动执行垃圾回收。</p><p>这个特性可以使用参数<strong>UseCMSInitiatingOccupancyOnly</strong>来关闭。</p><p>这里提个<em>问题给读者思考，如果让你设计，<strong>如何预测什么时候开始自动执行</strong>？</em></p><h3 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h3><p>前两个问题是由并发引起的，接下来要说的问题就是由标记-清除算法引起的。</p><p>使用标记-清除算法可能造成大量的空间碎片。空间碎片过多，就会给大对象分配带来麻烦。</p><p>往往老年代还有很大剩余空间，但无法找到足够大的连续空间来分配当前对象,不得不触发一次Full GC。</p><p>CMS的解决方案是使用<strong>UseCMSCompactAtFullCollection</strong>参数(默认开启)，在顶不住要进行Full GC时开启内存碎片整理。</p><p>这个过程需要STW，碎片问题解决了,但停顿时间又变长了。</p><p>虚拟机还提供了另外一个参数<strong>CMSFullGCsBeforeCompaction</strong>，用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的（默认为0，每次进入Full GC时都进行碎片整理）。</p><p>延伸一个“foreground collector”的东西给大家，这个玩意在Java8中也声明为<strong>deprecated</strong>。(<a href="https://bugs.openjdk.java.net/browse/JDK-8027132" target="_blank" rel="noopener">https://bugs.openjdk.java.net/browse/JDK-8027132</a>)</p><blockquote><p>参考：<br><a href="https://zhanjia.iteye.com/blog/2435266" target="_blank" rel="noopener">Java之CMS GC的7个阶段</a><br><a href="https://www.cnblogs.com/littleLord/p/5380624.html" target="_blank" rel="noopener">详解CMS垃圾回收机制</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是CMS？&quot;&gt;&lt;a href=&quot;#什么是CMS？&quot; class=&quot;headerlink&quot; title=&quot;什么是CMS？&quot;&gt;&lt;/a&gt;什么是CMS？&lt;/h2&gt;&lt;p&gt;Concurrent Mark Sweep。&lt;/p&gt;
&lt;p&gt;看名字就知道，CMS是一款并发、使用标记-清除算法的gc。&lt;/p&gt;
&lt;p&gt;CMS是针对老年代进行回收的GC。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://changsk.top/categories/Java/"/>
    
    
      <category term="java" scheme="http://changsk.top/tags/java/"/>
    
      <category term="jvm" scheme="http://changsk.top/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>HTTP1.0、HTTP1.1 和 HTTP2.0 的区别</title>
    <link href="http://changsk.top/2019/07/14/http1-2/"/>
    <id>http://changsk.top/2019/07/14/http1-2/</id>
    <published>2019-07-14T13:56:50.000Z</published>
    <updated>2019-07-14T14:28:44.308Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://juejin.im/entry/5981c5df518825359a2b9476" target="_blank" rel="noopener">HTTP1.0、HTTP1.1 和 HTTP2.0 的区别</a></p></blockquote><a id="more"></a><h2 id="HTTP的历史"><a href="#HTTP的历史" class="headerlink" title="HTTP的历史"></a>HTTP的历史</h2><p>早在 HTTP 建立之初，主要就是为了将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。也是说对于前端来说，我们所写的HTML页面将要放在我们的 web 服务器上，用户端通过浏览器访问url地址来获取网页的显示内容，但是到了 WEB2.0 以来，我们的页面变得复杂，不仅仅单纯的是一些简单的文字和图片，同时我们的 HTML 页面有了 CSS，Javascript，来丰富我们的页面展示，当 ajax 的出现，我们又多了一种向服务器端获取数据的方法，这些其实都是基于 HTTP 协议的。同样到了移动互联网时代，我们页面可以跑在手机端浏览器里面，但是和 PC 相比，手机端的网络情况更加复杂，这使得我们开始了不得不对 HTTP 进行深入理解并不断优化过程中。</p><p><img src="1.jpg" alt="img"></p><h2 id="HTTP的基本优化"><a href="#HTTP的基本优化" class="headerlink" title="HTTP的基本优化"></a>HTTP的基本优化</h2><p>影响一个 HTTP 网络请求的因素主要有两个：<strong>带宽和延迟。</strong></p><ul><li><p><strong>带宽：</strong>如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，但是现在网络基础建设已经使得带宽得到极大的提升，我们不再会担心由带宽而影响网速，那么就只剩下延迟了。</p></li><li><p><strong>延迟：</strong></p></li><li><ul><li>浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。</li><li>DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。</li><li>建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。</li></ul></li></ul><h2 id="HTTP1-0和HTTP1-1的一些区别"><a href="#HTTP1-0和HTTP1-1的一些区别" class="headerlink" title="HTTP1.0和HTTP1.1的一些区别"></a>HTTP1.0和HTTP1.1的一些区别</h2><p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p><ol><li><p><strong>缓存处理</strong>，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</p><blockquote><p>If-Modified-Since是标准的HTTP请求头标签，在发送HTTP请求时，把浏览器端缓存页面的最后修改时间一起发到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行比较。</p><p>如果时间一致，那么返回HTTP状态码304（不返回文件内容），客户端接到之后，就直接把本地缓存文件显示到浏览器中。</p><p>如果时间不一致，就返回HTTP状态码200和新的文件内容，客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示到浏览器中。</p></blockquote></li><li><p><strong>带宽优化及网络连接的使用</strong>，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，<strong>HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content）</strong>，这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p></li><li><p><strong>错误通知的管理</strong>，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；<strong>410（Gone）表示服务器上的某个资源被永久性的删除。</strong></p></li><li><p><strong>Host头处理</strong>，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p></li><li><p><strong>长连接</strong>，<strong>HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理</strong>，在一个TCP连接上可以传送多个HTTP请求和响应，<strong>减少了建立和关闭连接的消耗和延迟</strong>，在HTTP1.1中默认开启<code>Connection： keep-alive</code>，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p></li></ol><h2 id="HTTPS与HTTP的一些区别"><a href="#HTTPS与HTTP的一些区别" class="headerlink" title="HTTPS与HTTP的一些区别"></a>HTTPS与HTTP的一些区别</h2><ul><li>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</li><li>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。</li><li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。</li></ul><p><img src="2.jpg" alt="img"></p><h2 id="SPDY：HTTP1-x的优化"><a href="#SPDY：HTTP1-x的优化" class="headerlink" title="SPDY：HTTP1.x的优化"></a>SPDY：HTTP1.x的优化</h2><p>2012年google如一声惊雷提出了SPDY的方案，优化了HTTP1.X的请求延迟，解决了HTTP1.X的安全性，具体如下：</p><ol><li><strong>降低延迟</strong>，针对HTTP高延迟的问题，SPDY优雅的采取了<strong>多路复用</strong>（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。</li><li><strong>请求优先级</strong>（request prioritization）。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。<strong>SPDY允许给每个request设置优先级</strong>，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。</li><li><strong>header压缩。</strong>前面提到HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。</li><li><strong>基于HTTPS的加密协议传输</strong>，大大提高了传输数据的可靠性。</li><li><strong>服务端推送</strong>（server push），采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。SPDY构成图：</li></ol><p><img src="3.jpg" alt="img"></p><p>SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。</p><h2 id="HTTP2-0性能惊人"><a href="#HTTP2-0性能惊人" class="headerlink" title="HTTP2.0性能惊人"></a>HTTP2.0性能惊人</h2><p><strong>HTTP/2: the Future of the Internet</strong> <a href="https://link.zhihu.com/?target=https://http2.akamai.com/demo" target="_blank" rel="noopener">https://link.zhihu.com/?target=https://http2.akamai.com/demo</a> 是 Akamai 公司建立的一个官方的演示，用以说明 HTTP/2 相比于之前的 HTTP/1.1 在性能上的大幅度提升。 同时请求 379 张图片，从Load time 的对比可以看出 HTTP/2 在速度上的优势。</p><p><img src="4.jpg" alt="img"></p><h2 id="HTTP2-0：SPDY的升级版"><a href="#HTTP2-0：SPDY的升级版" class="headerlink" title="HTTP2.0：SPDY的升级版"></a>HTTP2.0：SPDY的升级版</h2><p>HTTP2.0可以说是SPDY的升级版（其实原本也是基于SPDY设计的），但是，HTTP2.0 跟 SPDY 仍有不同的地方，如下：</p><p><strong>HTTP2.0和SPDY的区别：</strong></p><ol><li>HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS</li><li>HTTP2.0 消息头的压缩算法采用 <strong>HPACK</strong> <a href="http://http2.github.io/http2-spec/compression.html，而非" target="_blank" rel="noopener">http://http2.github.io/http2-spec/compression.html，而非</a> SPDY 采用的 <strong>DEFLATE</strong> <a href="http://zh.wikipedia.org/wiki/DEFLATE" target="_blank" rel="noopener">http://zh.wikipedia.org/wiki/DEFLATE</a></li></ol><h2 id="HTTP2-0和HTTP1-X相比的新特性"><a href="#HTTP2-0和HTTP1-X相比的新特性" class="headerlink" title="HTTP2.0和HTTP1.X相比的新特性"></a>HTTP2.0和HTTP1.X相比的新特性</h2><ul><li><strong>新的二进制格式</strong>（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</li><li><strong>多路复用</strong>（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</li><li><strong>header压缩</strong>，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li><li><strong>服务端推送</strong>（server push），同SPDY一样，HTTP2.0也具有server push功能。</li></ul><h2 id="HTTP2-0的升级改造"><a href="#HTTP2-0的升级改造" class="headerlink" title="HTTP2.0的升级改造"></a>HTTP2.0的升级改造</h2><ul><li>前文说了HTTP2.0其实可以支持非HTTPS的，但是现在主流的浏览器像chrome，firefox表示还是只支持基于 TLS 部署的HTTP2.0协议，所以要想升级成HTTP2.0还是先升级HTTPS为好。</li><li>当你的网站已经升级HTTPS之后，那么升级HTTP2.0就简单很多，如果你使用NGINX，只要在配置文件中启动相应的协议就可以了，可以参考<strong>NGINX白皮书，NGINX配置HTTP2.0官方指南</strong>  <a href="https://www.nginx.com/blog/nginx-1-9-5/。" target="_blank" rel="noopener">https://www.nginx.com/blog/nginx-1-9-5/。</a></li><li>使用了HTTP2.0那么，原本的HTTP1.x怎么办，这个问题其实不用担心，HTTP2.0完全兼容HTTP1.x的语义，对于不支持HTTP2.0的浏览器，NGINX会自动向下兼容的。</li></ul><h2 id="附注"><a href="#附注" class="headerlink" title="附注"></a>附注</h2><p><strong>HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？</strong></p><ul><li>HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；</li><li>HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，<strong>后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞</strong>；</li><li>HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；具体如图：</li></ul><p><img src="5.jpg" alt="img"></p><p>服务器推送到底是什么？服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。具体如下：</p><ul><li>普通的客户端请求过程：</li></ul><p><img src="6.jpg" alt="img"></p><ul><li>服务端推送的过程：</li></ul><p><img src="7.jpg" alt="img"></p><p><strong>为什么需要头部压缩？</strong>假定一个页面有100个资源需要加载（这个数量对于今天的Web而言还是挺保守的）, 而每一次请求都有1kb的消息头（这同样也并不少见，因为Cookie和引用等东西的存在）, 则至少需要多消耗100kb来获取这些消息头。HTTP2.0可以维护一个字典，差量更新HTTP头部，大大降低因头部传输产生的流量。具体参考：HTTP/2 头部压缩技术介绍</p><p><strong>HTTP2.0多路复用有多好？</strong>HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 <strong>TCP 慢启动</strong>。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://juejin.im/entry/5981c5df518825359a2b9476&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HTTP1.0、HTTP1.1 和 HTTP2.0 的区别&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://changsk.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTP" scheme="http://changsk.top/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议</title>
    <link href="http://changsk.top/2019/07/14/http-introduction/"/>
    <id>http://changsk.top/2019/07/14/http-introduction/</id>
    <published>2019-07-14T12:53:33.000Z</published>
    <updated>2019-07-14T13:20:15.315Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://juejin.im/post/5ad4465d6fb9a028da7d0117" target="_blank" rel="noopener">5分钟让你明白HTTP</a></p></blockquote><a id="more"></a><h2 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h2><h3 id="http协议介绍"><a href="#http协议介绍" class="headerlink" title="http协议介绍"></a>http协议介绍</h3><ol><li><p>HTTP协议（HyperText Transfer Protocol，<strong>超文本传输协议</strong>）是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。</p></li><li><p>HTTP是基于<code>TCP/IP</code>通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）</p></li><li><p>HTTP协议通常承载于TCP协议之上，有时也承载于<code>TLS</code>或<code>SSL</code>协议层之上，这个时候，就成了我们常说的HTTPS。如下图 </p><p><img src="1.jpg" alt="http/https"></p></li><li><p>HTTP是一个应用层协议，由<strong>请求和响应</strong>构成，是一个标准的<strong>客户端服务器</strong>模型。HTTP是一个<strong>无状态</strong>的协议。</p></li><li><p>HTTP默认的端口号为80，<strong>HTTPS的端口号为443</strong>。</p></li></ol><h3 id="http协议工作流程"><a href="#http协议工作流程" class="headerlink" title="http协议工作流程"></a>http协议工作流程</h3><p>一次HTTP操作称为一个事务，其工作过程大概如下：</p><ol><li>用户在浏览器中键入需要访问网页的URL或者点击某个网页中链接；</li><li>浏览器根据URL中的域名，<strong>通过DNS解析出目标网页的IP地址</strong>；</li></ol><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">浏览器请求这个页面：http://hackr.ip/index.html</span><br><span class="line">在这一步，需要域名系统DNS解析域名hackr.ip,得主机的<span class="built_in">IP</span>地址 20X<span class="meta">.189</span><span class="meta">.105</span><span class="meta">.112</span>。</span><br><span class="line">然后将上面结合本机自己的信息，封装成一个http请求数据包</span><br></pre></td></tr></table></figure><ol start="3"><li>在HTTP开始工作前，<strong>客户端首先会通过TCP/IP协议来和服务端建立链接（TCP三次握手）</strong></li><li>建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和其他内容。</li><li>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。</li><li>一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码： </li></ol><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Connection</span>:<span class="meta">keep</span>-alive</span><br></pre></td></tr></table></figure><p>，<strong>TCP连接在发送后将仍然保持打开状态</strong>，于是，浏览器可以继续通过相同的连接发送请求。<strong>保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</strong> </p><p><img src="2.jpg" alt="http链接步骤"></p><p><img src="3.jpg" alt="http协议和tcp协议"></p><h4 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h4><p>短连接的操作步骤是： 建立连接——数据传输——关闭连接…建立连接——数据传输——关闭连接</p><p>如果客户请求频繁，<strong>将在TCP的建立和关闭操作上浪费较多时间和带宽。</strong> </p><p><img src="https://user-gold-cdn.xitu.io/2018/4/16/162cd71c10945b10?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="短连接"></p><h4 id="长链接"><a href="#长链接" class="headerlink" title="长链接"></a>长链接</h4><blockquote><p>长链接,指在<strong>一个连接上可以连续发送多个数据包</strong>，在连接保持期间，如果没有数据包发送，需要双方发链路检测包。</p></blockquote><p>长链接操作步骤： 建立连接——数据传输…（保持连接）…数据传输——关闭连接</p><p><strong>长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间</strong></p><p>长链接分为 without pipelining 和 with pipelining，下图中是without pipelining，客户端只在收到前一个请求的响应后，才发出新的请求。 </p><p><img src="5.jpg" alt="长链接"></p><h4 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h4><p>下图是with pipelining，<strong>每次建立链接后无需等待请求回来就可以发送下一个请求</strong> </p><p><img src="6.jpg" alt="管线化"></p><h3 id="Http请求报文"><a href="#Http请求报文" class="headerlink" title="Http请求报文"></a>Http请求报文</h3><p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：</p><p>请求行（request line）、请求头部（header）、请求体组成，下图给出了请求报文的一般格式。 </p><p><img src="7.jpg" alt="HTTP请求"></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">请求行:</span><br><span class="line">    方法:</span><br><span class="line">        GET 获取资源</span><br><span class="line">        POST 向服务器端发送数据，传输实体主体</span><br><span class="line">        PUT 传输文件</span><br><span class="line">        HEAD 获取报文首部</span><br><span class="line">        <span class="keyword">DELETE</span> 删除文件</span><br><span class="line">        OPTIONS 询问支持的方法</span><br><span class="line">        <span class="keyword">TRACE</span> 追踪路径</span><br><span class="line">    URL</span><br><span class="line">    协议/版本号</span><br><span class="line">    </span><br><span class="line">请求头:</span><br><span class="line">    通用首部(General <span class="built_in">Header</span>)</span><br><span class="line">    请求首部(Request <span class="built_in">Header</span>)</span><br><span class="line">    响应首部(Response <span class="built_in">Header</span>)</span><br><span class="line">    实体首部(Entity <span class="built_in">Header</span> Fields)</span><br><span class="line">    </span><br><span class="line">请求体</span><br></pre></td></tr></table></figure><p>请求报文拆解： </p><p><img src="8.jpg" alt="http请求报文"></p><h4 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h4><p><img src="9.jpg" alt="get请求"></p><h4 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h4><p><img src="10.jpg" alt="post请求"></p><h3 id="Http响应报文"><a href="#Http响应报文" class="headerlink" title="Http响应报文"></a>Http响应报文</h3><p>HTTP响应组成：响应行、响应头、响应体。</p><p><img src="11.jpg" alt="http响应"></p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">响应行</span><br><span class="line">    （HTTP/<span class="number">1.1</span>）表明HTTP版本为<span class="number">1.1</span>版本，状态码为<span class="number">200</span>，状态消息为（ok）</span><br><span class="line">响应头</span><br><span class="line">    <span class="built_in">Date</span>:生成响应的日期和时间；</span><br><span class="line">    Content-<span class="built_in">Type</span>:指定了MIME类型的HTML(<span class="built_in">text</span>/html),编码类型是ISO-<span class="number">8859</span>-<span class="number">1</span></span><br><span class="line">响应体</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>响应报文拆解： </p><p><img src="12.jpg" alt="http响应报文"></p><h3 id="Http状态码"><a href="#Http状态码" class="headerlink" title="Http状态码"></a>Http状态码</h3><table><thead><tr><th>类别</th><th>原因</th></tr></thead><tbody><tr><td>1XX</td><td>Informational(信息性状态码)</td></tr><tr><td>2XX</td><td>Success(成功状态码)</td></tr><tr><td>3XX</td><td>Redirection(重定向)</td></tr><tr><td>4XX</td><td>Client Error(客户端错误状态码)</td></tr><tr><td>5XX</td><td>Server Error(服务器错误状态吗)</td></tr></tbody></table><h4 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h4><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">200</span>(<span class="name">OK</span> 客户端发过来的数据被正常处理</span><br><span class="line"><span class="number">204</span>(<span class="name">Not</span> Content 正常响应，没有实体</span><br><span class="line"><span class="number">206</span>(<span class="name">Partial</span> Content 范围请求，返回部分数据，响应报文中由Content-Range指定实体内容</span><br></pre></td></tr></table></figure><h4 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h4><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">301</span>(Moved Permanently) 永久重定向</span><br><span class="line"><span class="number">302</span>(Found) 临时重定向，规范要求，方法名不变，但是都会改变</span><br><span class="line"><span class="number">303</span>(See Other) 和<span class="number">302</span>类似，但必须用GET方法</span><br><span class="line"><span class="number">304</span>(<span class="keyword">Not</span> Modified) 状态未改变， 配合(<span class="keyword">If</span>-Match、<span class="keyword">If</span>-Modified-Since、<span class="keyword">If</span>-None_Match、<span class="keyword">If</span>-<span class="keyword">Range</span>、<span class="keyword">If</span>-Unmodified-Since)</span><br><span class="line"><span class="number">307</span>(<span class="keyword">Temporary</span> Redirect) 临时重定向，不该改变请求方法</span><br></pre></td></tr></table></figure><h4 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">400</span>(Bad Request) 请求报文语法错误</span><br><span class="line"><span class="symbol">401 </span>(unauthorized) 需要认证</span><br><span class="line"><span class="number">403</span>(Forbidden) 服务器拒绝访问对应的资源</span><br><span class="line"><span class="number">404</span>(<span class="keyword">Not</span> Found) 服务器上无法找到资源</span><br></pre></td></tr></table></figure><h4 id="5XX-服务器端错误"><a href="#5XX-服务器端错误" class="headerlink" title="5XX 服务器端错误"></a>5XX 服务器端错误</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">500(Internal<span class="built_in"> Server </span>Error)服务器故障</span><br><span class="line">503(Service Unavailable) 服务器处于超负载或正在停机维护</span><br></pre></td></tr></table></figure><h3 id="首部"><a href="#首部" class="headerlink" title="首部"></a>首部</h3><h4 id="首部字段"><a href="#首部字段" class="headerlink" title="首部字段"></a>首部字段</h4><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td><strong>Cache-Control</strong></td><td>控制缓存行为</td></tr><tr><td><strong>Connection</strong></td><td>链接的管理</td></tr><tr><td><strong>Date</strong></td><td>报文日期</td></tr><tr><td>Pragma</td><td>报文指令</td></tr><tr><td>Trailer</td><td>报文尾部的首部</td></tr><tr><td>Trasfer-Encoding</td><td>指定报文主体的传输编码方式</td></tr><tr><td><strong>Upgrade</strong></td><td>升级为其他协议</td></tr><tr><td>Via</td><td>代理服务器信息</td></tr><tr><td>Warning</td><td>错误通知</td></tr></tbody></table><h4 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h4><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Accept</td><td>用户代理可处理的媒体类型</td></tr><tr><td><strong>Accept-Charset</strong></td><td>优先的字符集</td></tr><tr><td><strong>Accept-Encoding</strong></td><td>优先的编码</td></tr><tr><td>Accept-Langulage</td><td>优先的语言</td></tr><tr><td>Authorization</td><td>Web认证信息</td></tr><tr><td>Expect</td><td>期待服务器的特定行为</td></tr><tr><td>From</td><td>用户的电子邮箱地址</td></tr><tr><td><strong>Host</strong></td><td>请求资源所在的服务器</td></tr><tr><td>If-Match</td><td>比较实体标记</td></tr><tr><td><strong>If-Modified-Since</strong></td><td>比较资源的更新时间</td></tr><tr><td>If-None-Match</td><td>比较实体标记</td></tr><tr><td>If-Range</td><td>资源未更新时发送实体Byte的范围请求</td></tr><tr><td>If-Unmodified-Since</td><td>比较资源的更新时间(和If-Modified-Since相反)</td></tr><tr><td>Max-Forwards</td><td>最大传输跳数</td></tr><tr><td>Proxy-Authorization</td><td>代理服务器需要客户端认证</td></tr><tr><td>Range</td><td>实体字节范围请求</td></tr><tr><td><strong>Referer</strong></td><td>请求中的URI的原始获取方</td></tr><tr><td>TE</td><td>传输编码的优先级</td></tr><tr><td><strong>User-Agent</strong></td><td>HTTP客户端程序的信息</td></tr></tbody></table><h4 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h4><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Accept-Ranges</td><td>是否接受字节范围</td></tr><tr><td>Age</td><td>资源的创建时间</td></tr><tr><td>ETag</td><td>资源的匹配信息</td></tr><tr><td><strong>Location</strong></td><td>客户端重定向至指定的URI</td></tr><tr><td>Proxy-Authenticate</td><td>代理服务器对客户端的认证信息</td></tr><tr><td>Retry-After</td><td>再次发送请求的时机</td></tr><tr><td>Server</td><td>服务器的信息</td></tr><tr><td>Vary</td><td>代理服务器缓存的管理信息</td></tr><tr><td>www-Authenticate</td><td>服务器对客户端的认证</td></tr></tbody></table><h4 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h4><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Allow</td><td>资源可支持的HTTP方法</td></tr><tr><td><strong>Content-Encoding</strong></td><td>实体的编码方式</td></tr><tr><td><strong>Content-Language</strong></td><td>实体的自然语言</td></tr><tr><td>Content-Length</td><td>实体的内容大小(字节为单位)</td></tr><tr><td>Content-Location</td><td>替代对应资源的URI</td></tr><tr><td><strong>Content-MD5</strong></td><td>实体的报文摘要</td></tr><tr><td>Content-Range</td><td>实体的位置范围</td></tr><tr><td>Content-Type</td><td>实体主体的媒体类型</td></tr><tr><td><strong>Expires</strong></td><td>实体过期时间</td></tr><tr><td><strong>Last-Modified</strong></td><td>资源的最后修改时间</td></tr></tbody></table><p>参考：</p><ol><li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.runoob.com%2Fhttp%2Fhttp-intro.html" target="_blank" rel="noopener">HTTP简介</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Fqdhxhz%2Fp%2F8468913.html" target="_blank" rel="noopener">HTTP协议详解</a></li><li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.zhufengpeixun.cn%2Fplan%2Fhtml%2F14.http-1.html" target="_blank" rel="noopener">HTTP</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Fchyg%2Fp%2F5212008.html" target="_blank" rel="noopener">HTTP工作过程</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://juejin.im/post/5ad4465d6fb9a028da7d0117&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;5分钟让你明白HTTP&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://changsk.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTP" scheme="http://changsk.top/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-146:LRU Cache</title>
    <link href="http://changsk.top/2019/07/14/leetcode-146/"/>
    <id>http://changsk.top/2019/07/14/leetcode-146/</id>
    <published>2019-07-14T09:33:41.000Z</published>
    <updated>2019-07-14T09:55:17.359Z</updated>
    
    <content type="html"><![CDATA[<p>原题链接：<a href="https://leetcode.com/problems/lru-cache/" target="_blank" rel="noopener">https://leetcode.com/problems/lru-cache/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>题目难度：Medium</p></blockquote><p>Design and implement a data structure for <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU" target="_blank" rel="noopener">Least Recently Used (LRU) cache</a>. It should support the following operations: <code>get</code> and <code>put</code>.</p><p><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br><code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p><p>The cache is initialized with a <strong>positive</strong> capacity.</p><p><strong>Follow up:</strong><br>Could you do both operations in <strong>O(1)</strong> time complexity?</p><p><strong>Example:</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LRUCache cache = new LRUCache( <span class="number">2</span> <span class="comment">/* capacity */</span> );</span><br><span class="line"></span><br><span class="line">cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">cache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">cache.get(<span class="number">1</span>);       <span class="comment">// returns 1</span></span><br><span class="line">cache.put(<span class="number">3</span>, <span class="number">3</span>);    <span class="comment">// evicts key 2</span></span><br><span class="line">cache.get(<span class="number">2</span>);       <span class="comment">// returns -1 (not found)</span></span><br><span class="line">cache.put(<span class="number">4</span>, <span class="number">4</span>);    <span class="comment">// evicts key 1</span></span><br><span class="line">cache.get(<span class="number">1</span>);       <span class="comment">// returns -1 (not found)</span></span><br><span class="line">cache.get(<span class="number">3</span>);       <span class="comment">// returns 3</span></span><br><span class="line">cache.get(<span class="number">4</span>);       <span class="comment">// returns 4</span></span><br></pre></td></tr></table></figure><h2 id="AC代码1"><a href="#AC代码1" class="headerlink" title="AC代码1"></a>AC代码1</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> cap;</span><br><span class="line">  HashMap&lt;Integer, Node&gt; node_map;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    Node prev;</span><br><span class="line">    Node next;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node (Node p, Node n, <span class="keyword">int</span> k, <span class="keyword">int</span> v) &#123;</span><br><span class="line">      <span class="keyword">this</span>.prev = p;</span><br><span class="line">      <span class="keyword">this</span>.next = n;</span><br><span class="line">      <span class="keyword">this</span>.val = v;</span><br><span class="line">      <span class="keyword">this</span>.key = k;</span><br><span class="line">    &#125;</span><br><span class="line">    Node() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Node head, tail;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    node.prev.next = node.next;</span><br><span class="line">    node.next.prev = node.prev;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    Node next = head.next;</span><br><span class="line">    node.next = next;</span><br><span class="line">    next.prev = node;</span><br><span class="line">    node.prev = head;</span><br><span class="line">    head.next = node;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cap = capacity;</span><br><span class="line">    <span class="keyword">this</span>.node_map = <span class="keyword">new</span> HashMap();  </span><br><span class="line">    <span class="keyword">this</span>.head = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="keyword">this</span>.tail = <span class="keyword">new</span> Node();</span><br><span class="line">    head.next = tail;</span><br><span class="line">    tail.prev = head;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node_map.containsKey(key) == <span class="keyword">false</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    Node node = node_map.get(key);</span><br><span class="line">    removeNode(node);</span><br><span class="line">    addToHead(node);</span><br><span class="line">    <span class="keyword">return</span> node.val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node_map.containsKey(key)) &#123;</span><br><span class="line">      Node node = node_map.get(key);</span><br><span class="line">      node.val = value;</span><br><span class="line">      removeNode(node);</span><br><span class="line">      addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(node_map.size() == <span class="keyword">this</span>.cap) &#123;</span><br><span class="line">        <span class="comment">// System.out.println(tail.prev.key);</span></span><br><span class="line">        node_map.remove(tail.prev.key);</span><br><span class="line">        removeNode(tail.prev);</span><br><span class="line">      &#125;</span><br><span class="line">      Node node = <span class="keyword">new</span> Node(<span class="keyword">null</span>, <span class="keyword">null</span>, key, value);</span><br><span class="line">      node_map.put(key, node);</span><br><span class="line">      addToHead(node);</span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="AC代码2"><a href="#AC代码2" class="headerlink" title="AC代码2"></a>AC代码2</h2><p>利用<code>jdk</code>中的<code>LinkedHashMap</code>实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;Integer, Integer&gt; map;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> LinkedHashMap&lt;Integer, Integer&gt;(capacity, .<span class="number">75f</span>, <span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Remove the eldest element whenever size of cache exceeds the capacity</span></span><br><span class="line">        <span class="keyword">return</span> (size() &gt; capacity);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.getOrDefault(key, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><blockquote><p>注：以上代码均来自于leetcode</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原题链接：&lt;a href=&quot;https://leetcode.com/problems/lru-cache/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/lru-cache/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
      <category term="LRU" scheme="http://changsk.top/tags/LRU/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop和Spark的异同</title>
    <link href="http://changsk.top/2019/07/14/hadoop-spark/"/>
    <id>http://changsk.top/2019/07/14/hadoop-spark/</id>
    <published>2019-07-14T08:49:54.000Z</published>
    <updated>2019-07-14T08:52:15.722Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://zhuanlan.zhihu.com/p/32800581" target="_blank" rel="noopener">Hadoop和Spark的异同</a></p></blockquote><a id="more"></a><h2 id="解决问题的层面不一样"><a href="#解决问题的层面不一样" class="headerlink" title="解决问题的层面不一样"></a>解决问题的层面不一样</h2><p>Hadoop和Spark两者都是大数据框架，但是各自存在的目的不尽相同。</p><ul><li>Hadoop实质上是解决大数据大到无法在一台计算机上进行存储、无法在要求的时间内进行处理的问题，是一个分布式数据基础设施。</li><li>HDFS，它将巨大的数据集分派到一个由普通计算机组成的集群中的多个节点进行存储，通过将块保存到多个副本上，提供高可靠的文件存储。</li><li>MapReduce，通过简单的Mapper和Reducer的抽象提供一个编程模型，可以在一个由几十台上百台的机器上并发地分布式处理大量数据集，而把并发、分布式和故障恢复等细节隐藏。</li><li>Hadoop复杂的数据处理需要分解为多个Job（包含一个Mapper和一个Reducer）组成的有向无环图。</li><li>Spark则允许程序开发者使用有向无环图（DAG）开发复杂的多步数据管道。而且还支持跨有向无环图的内存数据共享，以便不同的作业可以共同处理同一个数据。是一个专门用来对那些分布式存储的大数据进行处理的工具，它并不会进行分布式数据的存储。</li><li>可将Spark看作是Hadoop MapReduce的一个替代品而不是Hadoop的替代品。</li></ul><h2 id="Hadoop的局限和不足"><a href="#Hadoop的局限和不足" class="headerlink" title="Hadoop的局限和不足"></a>Hadoop的局限和不足</h2><ul><li>一个Job只有Map和Reduce两个阶段，复杂的计算需要大量的Job完成，Job间的依赖关系由开发人员进行管理。</li><li>中间结果也放到HDFS文件系统中。对于迭代式数据处理性能比较差。</li><li>Reduce Task需要等待所有的Map Task都完成后才开始计算。</li><li>时延高，只适用批量数据处理，对于交互式数据处理，实时数据处理的支持不够。</li></ul><h2 id="两者可合可分"><a href="#两者可合可分" class="headerlink" title="两者可合可分"></a>两者可合可分</h2><ul><li>Hadoop除了提供HDFS分布式数据存储功能之外，还提供了MapReduce的数据处理功能。所以我们完全可以抛开Spark，仅使用Hadoop自身的MapReduce来完成数据的处理。</li><li>相反，Spark也不是非要依附在Hadoop身上才能生存。但它没有提供文件管理系统，所以，它必须和其他的分布式文件系统进行集成才能运作。我们可以选择Hadoop的HDFS，也可以选择其他的基于云的数据系统平台。但Spark默认来说还是被用在Hadoop上面的，被认为它们的结合是最好的选择。</li></ul><p><img src="1.jpg" alt="img"></p><h2 id="Spark数据处理速度秒杀MapReduce"><a href="#Spark数据处理速度秒杀MapReduce" class="headerlink" title="Spark数据处理速度秒杀MapReduce"></a>Spark数据处理速度秒杀MapReduce</h2><ul><li>Spark因为处理数据的方式不一样，会比MapReduce快上很多。MapReduce是分步对数据进行处理的: “从集群中读取数据，进行一次处理，将结果写到集群，从集群中读取更新后的数据，进行下一次的处理，将结果写到集群，等等…”</li><li>Spark会在内存中以接近“实时”的时间完成所有的数据分析：“从集群中读取数据，完成所有必须的分析处理（依赖多个算子），将结果写回集群，完成，” Spark的批处理速度比MapReduce快近10倍，内存中的数据分析速度则快近100倍。</li><li>如果需要处理的数据和结果需求大部分情况下是静态的，且有充足的时间等待批处理的完成，MapReduce的处理方式也是完全可以接受的。</li><li>但如果你需要对时实流数据进行分析，比如来自工厂的传感器收集回来的数据，又或者用户访问网站的日志信息，那么更应该使用Spark进行处理。</li></ul><h2 id="灾难恢复机制"><a href="#灾难恢复机制" class="headerlink" title="灾难恢复机制"></a>灾难恢复机制</h2><ul><li>两者的灾难恢复方式不同，因为Hadoop将每次处理后的数据都写入到磁盘上，所以其天生就能很有弹性的对系统错误进行处理。</li><li>Spark的数据对象存储在分布于数据集群中的叫做弹性分布式数据集(RDD: Resilient Distributed Dataset)中。这些数据对象既可以放在内存，也可以放在磁盘，所以RDD同样也可以提供完成的灾难恢复功能。</li></ul><h2 id="Spark优势"><a href="#Spark优势" class="headerlink" title="Spark优势"></a>Spark优势</h2><ul><li>Spark的优势不仅体现在性能提升上，Spark框架为批处理（Spark Core），交互式（Spark SQL），流式（Spark Streaming），机器学习（MLlib），图计算（GraphX）提供了一个统一的数据处理平台。</li><li>Spark通过在数据处理过程中成本更低的Shuffle方式，将MapReduce提升到一个更高的层次。利用内存数据存储和接近实时的处理能力，Spark比其他的大数据处理技术的性能要快很多倍。</li><li>Spark将中间结果保存在内存中而不是写入磁盘，当需要多次处理同一数据集时，这一点特别实用。</li><li>支持比Map和Reduce更多的函数。</li><li>Spark的RDD是分布式大数据处理的高层次抽象的数据集合，对这个集合的任何操作都可以像函数式编程中操作内存中的集合一样直观、简便，但集合操作的实现确是在后台分解成一系列Task发送到集群上完成。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32800581&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hadoop和Spark的异同&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://changsk.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Hadoop" scheme="http://changsk.top/tags/Hadoop/"/>
    
      <category term="Spark" scheme="http://changsk.top/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>深入理解spark之架构与原理</title>
    <link href="http://changsk.top/2019/07/14/spark-Architecture/"/>
    <id>http://changsk.top/2019/07/14/spark-Architecture/</id>
    <published>2019-07-14T07:41:47.000Z</published>
    <updated>2019-07-14T08:43:53.151Z</updated>
    
    <content type="html"><![CDATA[<p> Spark提供了一个全面、统一的框架用于管理各种有着不同性质（文本数据、图表数据等）的数据集和数据源（批量数据或实时的流数据）的大数据处理的需求。<br>官方资料介绍<strong>Spark可以将Hadoop集群中的应用在内存中的运行速度提升100倍</strong>，<strong>甚至能够将应用在磁盘上的运行速度提升10倍。</strong></p><a id="more"></a><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><p>Application：用户编写的Spark应用程序。</p></li><li><p>Driver：Spark中的Driver即运行上述Application的main函数并创建SparkContext，<strong>创建SparkContext的目的是为了准备Spark应用程序的运行环境，在Spark中有SparkContext负责与ClusterManager通信，进行资源申请、任务的分配和监控等，当Executor部分运行完毕后，Driver同时负责将SparkContext关闭。</strong></p></li><li><p>Executor：是运行在工作节点（WorkerNode）的一个进程，负责运行Task。</p></li><li><p>RDD：弹性分布式数据集，是分布式内存的一个抽象概念，提供了一种高度受限的共享内存模型。</p></li><li><p>DAG：有向无环图，反映RDD之间的依赖关系。</p></li><li><p>Stage：是Job的基本调度单位，<strong>一个Job会分为多组Task，每组Task被称为Stage</strong>，或者也被称为TaskSet，代表一组关联的，相互之间没有Shuffle依赖关系的任务组成的任务集。</p></li><li><p>RDD（resillient distributed dataset）：弹性分布式数据集。</p></li><li><p>Task：具体执行任务。Task分为<code>ShuffleMapTask</code>和<code>ResultTask</code>两种。<strong>ShuffleMapTask和ResultTask分别类似于Hadoop中的Map，Reduce。</strong></p></li><li><p>job：用户提交的作业。<strong>一个Job可能由一到多个Task组成。</strong>一个Job包含多个RDD及作用于相应RDD上的各种操作。</p></li><li><p>Stage：Job分成的阶段。一个Job可能被划分为一到多个Stage。</p></li><li><p>Partition：数据分区。即一个RDD的数据可以划分为多少个分区。</p></li><li><p>NarrowDependency：窄依赖。即子RDD依赖于父RDD中固定的Partition。NarrowDependency分为OneToOneDependency和RangeDependency两种。</p></li><li><p>ShuffleDependency：shuffle依赖，也称为宽依赖。即子RDD对父RDD中的所有Partition都有依赖。</p></li><li><p>DAG（Directed Acycle graph）：有向无环图。<strong>用于反映各RDD之间的依赖关系</strong>。</p></li><li><p>Cluter Manager：指的是在集群上获取资源的外部服务。目前有三种类型<br>1) Standalon : spark原生的资源管理，由Master负责资源的分配<br>2) Apache Mesos:与hadoop MR兼容性良好的一种资源调度框架<br>3) Hadoop Yarn: 主要是指Yarn中的ResourceManager</p><p>一个Application由一个Driver和若干个Job构成，一个Job由多个Stage构成，一个Stage由多个没有Shuffle关系的Task组成。</p><p>当执行一个Application时，Driver会向集群管理器申请资源，启动Executor，并向Executor发送应用程序代码和文件，然后在Executor上执行Task，运行结束后，执行结果会返回给Driver，或者写到HDFS或者其它数据库中。</p></li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>Spark适用场景：</p><ol><li><strong>Spark是基于内存的迭代计算框架</strong>，适用于需要多次操作特定数据集的应用场合。<strong>需要反复操作的次数越多，所需读取的数据量越大，受益越大</strong>，数据量小但是计算密集度较大的场合，受益就相对较小。</li><li>数据量不是特别大，但是要求近实时统计分析需求                                                           </li></ol><p>spark不适用场景：</p><ol><li>内存hold不住的场景，<strong>在内存不足的情况下，Spark会下放到磁盘，会降低应有的性能</strong></li><li><strong>有高实时性要求的流式计算业务，例如实时性要求毫秒级</strong></li><li>由于<strong>RDD设计上的只读特点</strong>，所以Spark对于待分析数据频繁变动的情景很难做（并不是不可以），比如数据集在频繁变化（不停增删改），而且又需要结果具有很强的一致性（不一致时间窗口很小），那么就不合适了。</li><li>流线长或文件流量非常大的数据集不适合。你会发现你的内存不够用，集群压力大时一旦一个task失败会导致他前面一条线所有的前置任务全部重跑，然后恶性循环会导致更多的task失败，整个sparkapp效率极低。就不如MapReduce啦！</li><li>由于RDD的特性，Spark不适用那种异步细粒度更新状态的应用，例如web服务的存储或者是增量的web爬虫和索引。就是对于那种增量修改的应用模型不适合。</li></ol><h3 id="架构及生态"><a href="#架构及生态" class="headerlink" title="架构及生态"></a>架构及生态</h3><p>Apache Spark是一个正在快速成长的<strong>开源集群计算系统</strong>。Apache Spark生态系统中的包和框架日益丰富，使得Spark能够进行高级数据分析。Apache Spark的快速成功得益于它的强大功能和易于使用性。相比于传统的<code>MapReduce</code>大数据分析，Spark<strong>效率更高</strong>、<strong>运行时速度</strong>更快。Apache Spark 提供了<strong>内存中的分布式计算能力</strong>，具有Java、 Scala、Python、R四种编程语言的API编程接口。Spark生态系统如下图所示：</p><p><img src="1.jpg" alt="img"></p><p><code>Spark Core</code>：包含Spark的基本功能，包含任务调度，内存管理，容错机制等，内部定义了RDDs(弹性分布式数据集)，提供了很多APIs来创建和操作这些RDDs。为其他组件提供底层的服务。其他Spark的库都是构建在RDD和Spark Core之上的</p><p><code>Spark SQL</code>：Spark处理结构化数据的库，就像Hive SQL,Mysql一样，企业中用来做报表统计。提供通过<strong>Apache Hive的SQL变体Hive查询语言（HiveQL）与Spark进行交互的API</strong>。<strong>每个数据库表被当做一个RDD，Spark SQL查询被转换为Spark操作。</strong></p><p><code>Spark Streaming</code>：<strong>对实时数据流进行处理和控制</strong>。Spark Streaming允许程序能够像普通RDD一样处理实时数据。实时数据流处理组件，类似Storm。Spark Streaming提供了API来操作实时流数据。企业中用来从Kafka接收数据做实时统计。</p><p><code>MLlib</code>：一个<strong>常用机器学习算法库</strong>，<strong>算法被实现为对RDD的Spark操作</strong>。这个库包含可扩展的学习算法，比如分类、回归等需要对大量数据集进行迭代的操作。</p><p><code>GraphX</code>：控制图、并行图操作和计算的一组算法和工具的集合。GraphX扩展了RDD API，包含控制图、创建子图、访问路径上所有顶点的操作</p><p>Spark架构的组成图如下：</p><p><img src="2.jpg" alt="Spark cluster components"></p><p><code>Cluster Manager</code>：<strong>在standalone模式中即为Master主节点，控制整个集群，监控worker。在YARN模式中为资源管理器</strong></p><p><code>Worker节点</code>：<strong>从节点，负责控制计算节点，启动Executor或者Driver。</strong></p><p><code>Driver</code>： <strong>运行Application 的main()函数</strong></p><p><code>Executor</code>：<strong>执行器，是为某个Application运行在worker node上的一个进程</strong></p><h3 id="与Hadoop比较"><a href="#与Hadoop比较" class="headerlink" title="与Hadoop比较"></a>与Hadoop比较</h3><p><strong>Hadoop MapReduce缺点：</strong></p><ul><li>表达能力有限</li><li>磁盘IO开销大，任务之间的衔接涉及IO开销</li><li>延迟高，Map任务要全部结束，reduce任务才能开始。</li></ul><p>Spark借鉴Hadoop MapReduce优点的同时，解决了MapReuce所面临的问题，有如下优点：</p><ul><li>Spark的计算模式也属于MapReduce，但不局限于Map和Reduce操作，还提供多种数据集操作类型，编程模型比Hadoop MapReduce更灵活。</li><li>Spark提供了<strong>内存计算</strong>，<strong>可将中间结果放到内存中</strong>，<strong>对于迭代运算效率更高</strong></li><li>Spark基于DAG的任务调度执行机制，要优于Hadoop MapReduce的迭代执行机制。</li><li>Spark 的Executor利用多线程来执行具体的任务减少任务的启动开销；</li><li>Executor中有一个BlockManager存储模块，会将内存和磁盘共同作为存储设备，有效减少IO开销；</li></ul><h3 id="Spark编程模型"><a href="#Spark编程模型" class="headerlink" title="Spark编程模型"></a>Spark编程模型</h3><p>Spark 应用程序从编写到提交、执行、输出的整个过程如图所示，图中描述的步骤如下：</p><p>1) 用户使用<strong>SparkContext提供的API</strong>（常用的有<code>textFile</code>、<code>sequenceFile</code>、runJob、stop等）编写<code>Driver application</code>程序。此外<strong>SQLContext、HiveContext及StreamingContext对SparkContext进行封装，并提供了SQL、Hive及流式计算相关的API。</strong></p><p>2) 使用SparkContext提交的用户应用程序，首先会使用<code>BlockManager</code>和<code>BroadcastManager</code>将任务的<code>Hadoop配置</code>进行广播。然后由<strong>DAGScheduler将任务转换为RDD并组织成DAG</strong>，<strong>DAG还将被划分为不同的Stage</strong>。最后由TaskScheduler借助ActorSystem将任务提交给集群管理器（Cluster Manager）。</p><p>3) 集群管理器（ClusterManager）<strong>给任务分配资源，即将具体任务分配到Worker上</strong>，<strong>Worker创建Executor来处理任务的运行</strong>。<code>Standalone、YARN、Mesos、EC2</code>等都可以作为Spark的集群管理器。</p><p><img src="3.jpg" alt="img"></p><h3 id="spark计算模型"><a href="#spark计算模型" class="headerlink" title="spark计算模型"></a>spark计算模型</h3><p><strong>RDD可以看做是对各种数据计算模型的统一抽象，Spark的计算过程主要是RDD的迭代计算过程</strong>。RDD的迭代计算过程非常类似于管道。<strong>分区数量取决于partition数量的设定，每个分区的数据只会在一个Task中计算。所有分区可以在多个机器节点的Executor上并行执行。</strong></p><p><img src="4.jpg" alt="img"></p><h3 id="集群架构设计"><a href="#集群架构设计" class="headerlink" title="集群架构设计"></a>集群架构设计</h3><p><img src="5.jpg" alt="架构"></p><p>整个集群分为 <code>Master</code> 节点和<code>Worker</code> 节点，<strong>相当于 Hadoop 的 Master 和 Slave 节点。</strong> <strong>Master 节点上常驻 Master 守护进程，负责管理全部的 Worker 节点。</strong> <strong>Worker 节点上常驻 Worker 守护进程，负责与 Master 节点通信并管理 executors。</strong> Driver 官方解释是 “The process running the main() function of the application and creating the SparkContext”。Application 就是用户自己写的 Spark 程序（driver program)。</p><h3 id="spark-运行流程与特点"><a href="#spark-运行流程与特点" class="headerlink" title="spark 运行流程与特点"></a>spark 运行流程与特点</h3><p><img src="6.jpg" alt="相关图片"></p><ol><li>构建Spark Application的运行环境，启动SparkContext</li><li>SparkContext向资源管理器（可以是Standalone，Mesos，Yarn）申请运行Executor资源，并启动StandaloneExecutorbackend</li><li>Executor向SparkContext申请Task</li><li>SparkContext将应用程序分发给Executor</li><li>SparkContext构建成DAG图，将DAG图分解成Stage、将Taskset发送给Task Scheduler，最后由Task Scheduler将Task发送给Executor运行</li><li>Task在Executor上运行，运行完释放所有资源</li></ol><p>特点：</p><ol><li><strong>每个Application获取专属的executor进程</strong>，该进程在Application期间一直驻留，并以多线程方式运行Task。这种Application隔离机制是有优势的，无论是从调度角度看（每个Driver调度他自己的任务），还是从运行角度看（来自不同Application的Task运行在不同JVM中），当然这样意味着Spark Application不能跨应用程序共享数据，除非将数据写入外部存储系统</li><li>Spark与资源管理器无关，<strong>只要能够获取executor进程，并能保持相互通信就可以了</strong></li><li>提交SparkContext的Client应该靠近Worker节点（运行Executor的节点），最好是在同一个Rack里，因为Spark Application运行过程中SparkContext和Executor之间有大量的信息交换</li><li>Task采用了数据本地性和推测执行的优化机制</li></ol><h3 id="RDD特性及运行流程"><a href="#RDD特性及运行流程" class="headerlink" title="RDD特性及运行流程"></a>RDD特性及运行流程</h3><p><strong>RDD特性</strong></p><ul><li>高效的容错性，根据DAG图恢复分区，数据复制或者记录日志 </li><li>RDD血缘关系、重新计算丢失分区、无需回滚系统、重算过程在不同节点之间并行、只记录粗粒度的操作</li><li>中间结果持久化到内存，数据在内存中的多个RDD操作之间进行传递，避免了不必要的读写磁盘开销<br>存放的数据可以是Java对象，避免了不必要的对象序列化和反序列化</li></ul><p><strong>RDD在Spark中运行大概分为以下三步：</strong></p><ol><li><p>创建RDD对象</p></li><li><p>DAGScheduler模块介入运算，计算<strong>RDD之间的依赖关系</strong>，<strong>RDD之间的依赖关系就形成了DAG</strong></p></li><li><p><strong>每一个Job被分为多个Stage</strong>。划分Stage的一个主要依据是当前计算因子的输入是否是确定的，如果是则将其分在同一个Stage，避免多个Stage之间的消息传递开销</p><p><img src="7.jpg" alt></p><p><img src="8.jpg" alt="img"></p></li></ol><p>创建 RDD  上面的例子除去最后一个 collect 是个动作，不会创建 RDD 之外，前面四个转换都会创建出新的 RDD 。因此第一步就是创建好所有 RDD( 内部的五项信息 )？创建执行计划 Spark 会尽可能地管道化，并基于是否要重新组织数据来划分阶段 (stage) ，例如本例中的 groupBy() 转换就会将整个执行计划划分成两阶段执行。最终会产生一个 DAG(directed acyclic graph ，有向无环图 ) 作为逻辑执行计划</p><p><img src="9.jpg" alt="img"></p><p>调度任务  将各阶段划分成不同的 任务 (task) ，每个任务都是数据和计算的合体。在进行下一阶段前，当前阶段的所有任务都要执行完成。因为下一阶段的第一个转换一定是重新组织数据的，所以必须等当前阶段所有结果数据都计算出来了才能继续</p><h3 id="spark运行模式"><a href="#spark运行模式" class="headerlink" title="spark运行模式"></a>spark运行模式</h3><h4 id="standalone-独立集群运行模式"><a href="#standalone-独立集群运行模式" class="headerlink" title="standalone: 独立集群运行模式"></a>standalone: 独立集群运行模式</h4><ul><li><strong>Standalone模式使用Spark自带的资源调度框架</strong></li><li>采用Master/Slaves的典型架构，选用<code>ZooKeeper</code>来实现Master的HA</li></ul><p><img src="10.jpg" alt="img"></p><h4 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h4><p><code>Spark on YARN</code>模式根据Driver在集群中的位置分为两种模式：一种是<code>YARN-Client</code>模式，另一种是<code>YARN-Cluster</code>（或称为YARN-Standalone模式）</p><p><strong>Yarn-Client模式中，Driver在客户端本地运行</strong>，这种模式可以使得Spark Application和客户端进行交互，因为Driver在客户端，<strong>所以可以通过webUI访问Driver的状态</strong>，默认是<a href="http://hadoop1:4040访问，而YARN通过http://" target="_blank" rel="noopener">http://hadoop1:4040访问，而YARN通过http://</a> hadoop1:8088访问</p><ul><li>YARN-client的工作流程步骤为：</li></ul><p><img src="11.jpg" alt="img"></p><ul><li>Spark Yarn Client向YARN的ResourceManager申请启动Application Master。同时在SparkContent初始化中将创建DAGScheduler和TASKScheduler等，由于我们选择的是Yarn-Client模式，程序会选择YarnClientClusterScheduler和YarnClientSchedulerBackend</li><li>ResourceManager收到请求后，在集群中选择一个NodeManager，为该应用程序分配第一个Container，要求它在这个Container中启动应用程序的ApplicationMaster，与YARN-Cluster区别的是在该ApplicationMaster不运行SparkContext，只与SparkContext进行联系进行资源的分派</li><li>Client中的SparkContext初始化完毕后，与ApplicationMaster建立通讯，向ResourceManager注册，根据任务信息向ResourceManager申请资源（Container）</li><li>一旦ApplicationMaster申请到资源（也就是Container）后，便与对应的NodeManager通信，要求它在获得的Container中启动CoarseGrainedExecutorBackend，CoarseGrainedExecutorBackend启动后会向Client中的SparkContext注册并申请Task</li><li>client中的SparkContext分配Task给CoarseGrainedExecutorBackend执行，CoarseGrainedExecutorBackend运行Task并向Driver汇报运行的状态和进度，以让Client随时掌握各个任务的运行状态，从而可以在任务失败时重新启动任务</li><li>应用程序运行完成后，Client的SparkContext向ResourceManager申请注销并关闭自己</li></ul><p><strong>Spark Cluster模式:</strong></p><ul><li>在YARN-Cluster模式中，当用户向YARN中提交一个应用程序后，YARN将分两个阶段运行该应用程序：</li></ul><ol><li>第一个阶段是把Spark的Driver作为一个ApplicationMaster在YARN集群中先启动；</li><li>第二个阶段是由ApplicationMaster创建应用程序，然后为它向ResourceManager申请资源，并启动Executor来运行Task，同时监控它的整个运行过程，直到运行完成</li></ol><p><img src="12.jpg" alt="img"></p><ul><li>Spark Yarn Client向YARN中提交应用程序，包括ApplicationMaster程序、启动ApplicationMaster的命令、需要在Executor中运行的程序等</li><li>ResourceManager收到请求后，在集群中选择一个NodeManager，为该应用程序分配第一个Container，要求它在这个Container中启动应用程序的ApplicationMaster，其中ApplicationMaster进行SparkContext等的初始化</li><li>ApplicationMaster向ResourceManager注册，这样用户可以直接通过ResourceManage查看应用程序的运行状态，然后它将采用轮询的方式通过RPC协议为各个任务申请资源，并监控它们的运行状态直到运行结束</li><li>一旦ApplicationMaster申请到资源（也就是Container）后，便与对应的NodeManager通信，要求它在获得的Container中启动CoarseGrainedExecutorBackend，CoarseGrainedExecutorBackend启动后会向ApplicationMaster中的SparkContext注册并申请Task。这一点和Standalone模式一样，只不过SparkContext在Spark Application中初始化时，使用CoarseGrainedSchedulerBackend配合YarnClusterScheduler进行任务的调度，其中YarnClusterScheduler只是对TaskSchedulerImpl的一个简单包装，增加了对Executor的等待逻辑等</li><li>ApplicationMaster中的SparkContext分配Task给CoarseGrainedExecutorBackend执行，CoarseGrainedExecutorBackend运行Task并向ApplicationMaster汇报运行的状态和进度，以让ApplicationMaster随时掌握各个任务的运行状态，从而可以在任务失败时重新启动任务</li><li>应用程序运行完成后，ApplicationMaster向ResourceManager申请注销并关闭自己</li></ul><blockquote><p>参考：</p><p><a href="https://juejin.im/post/5a73c8386fb9a0635e3cafaa" target="_blank" rel="noopener">深入理解spark之架构与原理</a></p><p><a href="https://blog.csdn.net/zxc123e/article/details/79912343" target="_blank" rel="noopener">Spark基本架构及运行原理</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; Spark提供了一个全面、统一的框架用于管理各种有着不同性质（文本数据、图表数据等）的数据集和数据源（批量数据或实时的流数据）的大数据处理的需求。&lt;br&gt;官方资料介绍&lt;strong&gt;Spark可以将Hadoop集群中的应用在内存中的运行速度提升100倍&lt;/strong&gt;，&lt;strong&gt;甚至能够将应用在磁盘上的运行速度提升10倍。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://changsk.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="Spark" scheme="http://changsk.top/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>进程间通信方式</title>
    <link href="http://changsk.top/2019/07/13/process-communication/"/>
    <id>http://changsk.top/2019/07/13/process-communication/</id>
    <published>2019-07-13T15:38:29.000Z</published>
    <updated>2019-07-14T05:20:39.267Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://www.jianshu.com/p/c1015f5ffa74" target="_blank" rel="noopener">进程间通信IPC (InterProcess Communication)</a></p></blockquote><h2 id="进程间通信的概念"><a href="#进程间通信的概念" class="headerlink" title="进程间通信的概念"></a>进程间通信的概念</h2><p>每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以<strong>进程之间要交换数据必须通过内核</strong>，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为<strong>进程间通信（IPC，InterProcess Communication）</strong></p><a id="more"></a><p><img src="1.jpg" alt="img"></p><p>进程间通信模型</p><h2 id="进程间通信的7种方式"><a href="#进程间通信的7种方式" class="headerlink" title="进程间通信的7种方式"></a>进程间通信的7种方式</h2><p><strong>第一类：传统的Unix通信机制</strong></p><h3 id="管道-匿名管道-pipe"><a href="#管道-匿名管道-pipe" class="headerlink" title="管道/匿名管道(pipe)"></a>管道/匿名管道(pipe)</h3><ul><li><p>管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。</p></li><li><p>只能用于父子进程或者兄弟进程之间(<strong>具有亲缘关系的进程</strong>);</p></li><li><p>单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。</p></li><li><p>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</p></li></ul><p>  <img src="2.jpg" alt="img"></p><p>  进程间管道通信模型</p><p><strong>管道的实质：</strong><br> 管道的实质是一个<strong>内核缓冲区</strong>，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。<br> 该缓冲区可以看做是一个<strong>循环队列</strong>，<strong>读和写的位置都是自动增长的</strong>，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。<br> <strong>当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。</strong></p><p><strong>管道的局限：</strong><br> 管道的主要局限性正体现在它的特点上：</p><ul><li><strong>只支持单向数据流</strong>；</li><li>只能用于具有亲缘关系的进程之间；</li><li>没有名字；</li><li>管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，<strong>为缓冲区分配一个页面大小</strong>）；</li><li>管道所传送的是无格式<strong>字节流</strong>，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如<strong>多少字节算作一个消息</strong>（或命令、或记录）等等；</li></ul><h3 id="有名管道-FIFO"><a href="#有名管道-FIFO" class="headerlink" title="有名管道(FIFO)"></a>有名管道(FIFO)</h3><p> 匿名管道，由于没有名字，<strong>只能用于亲缘关系的进程间通信</strong>。为了克服这个缺点，提出了有名管道(FIFO)。<br> 有名管道不同于匿名管道之处在于它提供了一个<strong>路径名</strong>与之关联，<strong>以有名管道的文件形式存在于文件系统中</strong>，这样，<strong>即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信</strong>，因此，通过有名管道不相关的进程也能交换数据。值的注意的是，有名管道严格遵循<strong>先进先出(first in first out)</strong>,对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如<code>lseek()</code>等文件定位操作。<strong>有名管道的名字存在于文件系统中，内容存放在内存中。</strong></p><blockquote><p><strong>匿名管道和有名管道总结：</strong><br> （1）管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写。<br> （2）匿名管道是单向的，只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。<br> （3）<strong>无名管道阻塞问题：</strong>无名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，如果管道发现另一端断开，将自动退出。<br> （4）<strong>有名管道阻塞问题：</strong>有名管道在打开时需要确实对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。</p></blockquote><p><a href="https://link.jianshu.com?t=http://blog.chinaunix.net/uid-26833883-id-3227144.html" target="_blank" rel="noopener">延伸阅读：该博客有匿名管道和有名管道的C语言实践</a></p><h3 id="信号-Signal"><a href="#信号-Signal" class="headerlink" title="信号(Signal)"></a>信号(Signal)</h3><ul><li>信号是Linux系统中用于进程间互相通信或者操作的一种机制，<strong>信号可以在任何时候发给某一进程，而无需知道该进程的状态。</strong></li><li>如果该进程当前并未处于执行状态，则该信号就由内核保存起来，直到该进程恢复执行并传递给它为止。</li><li>如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。</li></ul><blockquote><p><strong>Linux系统中常用信号：</strong><br> （1）<strong>SIGHUP：</strong>用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。<br> （2）<strong>SIGINT：</strong>程序终止信号。程序运行过程中，按<code>Ctrl+C</code>键将产生该信号。<br> （3）<strong>SIGQUIT：</strong>程序退出信号。程序运行过程中，按<code>Ctrl+\\</code>键将产生该信号。<br> （4）<strong>SIGBUS和SIGSEGV：</strong>进程访问非法地址。<br> （5）<strong>SIGFPE：</strong>运算中出现致命错误，如除零操作、数据溢出等。<br> （6）<strong>SIGKILL：</strong>用户终止进程执行信号。shell下执行<code>kill -9</code>发送该信号。<br> （7）<strong>SIGTERM：</strong>结束进程信号。shell下执行<code>kill 进程pid</code>发送该信号。<br> （8）<strong>SIGALRM：</strong>定时器信号。<br> （9）<strong>SIGCLD：</strong>子进程退出信号。如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程。</p></blockquote><p><strong>信号来源</strong><br> <strong>信号是软件层次上对中断机制的一种模拟，是一种异步通信方式</strong>，信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件主要有两个来源：</p><ul><li>硬件来源：用户按键输入<code>Ctrl+C</code>退出、硬件异常如无效的存储访问等。</li><li>软件终止：终止进程信号、其他进程调用kill函数、软件异常产生信号。</li></ul><p><strong>信号生命周期和处理流程</strong><br> （1）信号被某个进程产生，并设置此信号传递的对象（一般为对应进程的<code>pid</code>），<strong>然后传递给操作系统</strong>； （2）操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），如果对应进程没有阻塞，操作系统将传递此信号。<br> （3）目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，<strong>暂时终止当前代码的执行，保护上下文（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、转而执行中断服务程序，执行完成后在回复到中断的位置。当然，对于抢占式内核，在中断返回时还将引发新的调度。</strong></p><p><img src="3.jpg" alt="img"></p><p>信号的生命周期</p><h3 id="消息-Message-队列"><a href="#消息-Message-队列" class="headerlink" title="消息(Message)队列"></a>消息(Message)队列</h3><ul><li><strong>消息队列是存放在内核中的消息链表</strong>，每个消息队列由消息队列标识符表示。</li><li>与管道（无名管道：<strong>只存在于内存中的文件</strong>；命名管道：<strong>存在于实际的磁盘介质或者文件系统</strong>）不同的是<strong>消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。</strong></li><li>另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。<a href="https://link.jianshu.com?t=http://blog.csdn.net/yang_yulei/article/details/19772649" target="_blank" rel="noopener">延伸阅读：消息队列C语言的实践</a> </li></ul><blockquote><p><strong>消息队列特点总结：</strong><br> （1）消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识.<br> （2）消息队列允许一个或多个进程向它写入与读取消息.<br> （3）管道和消息队列的通信数据都是先进先出的原则。<br> （4）消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比FIFO更有优势。<br> （5）<strong>消息队列克服了信号承载信息量少</strong>，<strong>管道只能承载无格式字节流以及缓冲区大小受限等缺点。</strong><br> （6）目前主要有两种类型的消息队列：POSIX消息队列以及System V消息队列，系统V消息队列目前被大量使用。系统V消息队列是随内核持续的，只有在内核重启或者人工删除时，该消息队列才会被删除。</p></blockquote><h3 id="共享内存-share-memory"><a href="#共享内存-share-memory" class="headerlink" title="共享内存(share memory)"></a>共享内存(share memory)</h3><ul><li><p>使得多个进程可以直接读写同一块内存空间，<strong>是最快的可用IPC形式</strong>。是针对其他通信机制运行效率较低而设计的。</p></li><li><p>为了在多个进程间交换信息，<strong>内核专门留出了一块内存区</strong>，可以<strong>由需要访问的进程将其映射到自己的私有地址空间</strong>。<strong>进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。</strong></p></li><li><p>由于多个进程共享一段内存，因此需要<strong>依靠某种同步机制（如信号量）来达到进程间的同步及互斥。</strong></p><p>延伸阅读：Linux支持的主要三种共享内存方式：mmap()系统调用、Posix共享内存，以及System V共享内存实践</p></li></ul><p>  <img src="4.jpg" alt="img"></p><p>  共享内存原理图</p><h3 id="信号量-semaphore"><a href="#信号量-semaphore" class="headerlink" title="信号量(semaphore)"></a>信号量(semaphore)</h3><p> <strong>信号量是一个计数器</strong>，用于多进程对共享数据的访问，<strong>信号量的意图在于进程间同步。</strong><br> 为了获得共享资源，进程需要执行下列操作：<br> （1）<strong>创建一个信号量</strong>：这要求调用者指定初始值，对于<strong>二值信号量</strong>来说，它通常是1，也可是0。<br> （2）<strong>等待一个信号量</strong>：<strong>该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作。</strong><br> （3）<strong>挂出一个信号量</strong>：<strong>该操作将信号量的值加1，也称为V操作。</strong></p><p>为了正确地实现信号量，<strong>信号量值的测试及减1操作应当是原子操作（即P、V操作都是原子操作）</strong>。为此，信号量通常是在内核中实现的。Linux环境中，有三种类型：<strong>Posix（可移植性操作系统接口）有名信号量（使用Posix IPC名字标识）</strong>、<strong>Posix基于内存的信号量（存放在共享内存区中）</strong>、<strong>System V信号量（在内核中维护）</strong>。这三种信号量都可用于进程间或线程间的同步。</p><p><img src="5.jpg" alt="img"></p><p>两个进程使用一个二值信号量</p><p><img src="6.jpg" alt="img"></p><p>两个进程所以用一个Posix有名二值信号量</p><p><img src="7.jpg" alt="img"></p><p>一个进程两个线程共享基于内存的信号量</p><blockquote><p><strong>信号量与普通整型变量的区别：</strong><br> （1）信号量是非负整型变量，除了初始化之外，它只能通过两个标准原子操作：wait(semap) , signal(semap) ; 来进行访问；<br> （2）操作也被成为PV原语（P来源于荷兰语proberen”测试”，V来源于荷兰语verhogen”增加”，P表示通过的意思，V表示释放的意思），而普通整型变量则可以在任何语句块中被访问；</p></blockquote><blockquote><p><strong>信号量与互斥量之间的区别：</strong><br> （1）<strong>互斥量用于线程的互斥，信号量用于线程的同步。这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。</strong><br> <strong>互斥：**</strong>是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。** <strong>同步：**</strong>是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。** <strong>在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源</strong><br> （2）互斥量值只能为0/1，信号量值可以为非负整数。<br> 也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。<br> （3）互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。</p></blockquote><h3 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字(socket)"></a>套接字(socket)</h3><p> 套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说<strong>它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。</strong></p><p><img src="8.jpg" alt="img"></p><p>Socket是应用层和传输层之间的桥梁</p><p>套接字是支持<code>TCP/IP</code>的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</p><p><strong>套接字特性</strong><br> 套接字的特性由3个属性确定，它们分别是：域、端口号、协议类型。<br> <strong>（1）套接字的域</strong><br> 它指定套接字通信中使用的网络介质，最常见的套接字域有两种：<br> <strong>一是AF_INET，它指的是Internet网络。</strong>当客户使用套接字进行跨网络的连接时，它就需要用到服务器计算机的IP地址和端口来指定一台联网机器上的某个特定服务，所以在使用socket作为通信的终点，<strong>服务器应用程序必须在开始通信之前绑定一个端口，服务器在指定的端口等待客户的连接。</strong><br> <strong>另一个域AF_UNIX，表示UNIX文件系统，</strong>它就是文件输入/输出，而它的地址就是文件名。<br> <strong>（2）套接字的端口号</strong><br> 每一个基于TCP/IP网络通讯的程序(进程)都被赋予了唯一的端口和端口号，端口是一个信息缓冲区，用于保留Socket中的输入/输出信息，<strong>端口号是一个16位无符号整数，范围是0-65535</strong>，以区别主机上的每一个程序（端口号就像房屋中的房间号），低于256的端口号保留给标准应用程序，比如pop3的端口号就是110，每一个套接字都组合进了IP地址、端口，这样形成的整体就可以区别每一个套接字。<br> <strong>（3）套接字协议类型</strong><br> 因特网提供三种通信机制，<br> <strong>一是流套接字，</strong>流套接字在域中通过TCP/IP连接实现，同时也是AF_UNIX中常用的套接字类型。流套接字提供的是一个<strong>有序</strong>、<strong>可靠</strong>、<strong>双向字节流</strong>的连接，因此发送的数据可以确保<strong>不会丢失、重复或乱序</strong>到达，<strong>而且它还有一定的出错后重新发送的机制。</strong><br> <strong>二个是数据报套接字，</strong>它不需要建立连接和维持一个连接，它们在域中通常是通过<code>UDP/IP</code>协议实现的。它对可以发送的数据的长度有限制，<strong>数据报作为一个单独的网络消息被传输,它可能会丢失、复制或错乱到达</strong>，UDP不是一个可靠的协议，但是它的速度比较高，因为它并一需要总是要建立和维持一个连接。<br> <strong>三是原始套接字，</strong><code>原始套接字允许对较低层次的协议直接访问，比如IP、 ICMP协议</code>，它常用于检验新的协议实现，或者访问现有服务中配置的新设备，因为RAW SOCKET可以自如地控制Windows下的多种协议，能够对网络底层的传输机制进行控制，所以可以应用原始套接字来操纵网络层和传输层应用。比如，<strong>我们可以通过RAW SOCKET来接收发向本机的ICMP、IGMP协议包，或者接收TCP/IP栈不能够处理的IP包，也可以用来发送一些自定包头或自定协议的IP包。网络监听技术很大程度上依赖于SOCKET_RAW。</strong></p><blockquote><p><strong>原始套接字与标准套接字的区别在于：</strong><br> <code>原始套接字可以读写内核没有处理的IP数据包，而流套接字只能读取TCP协议的数据，数据报套接字只能读取UDP协议的数据。因此，如果要访问其他协议发送数据必须使用原始套接字。</code></p></blockquote><p><strong>套接字通信的建立</strong></p><p><img src="9.jpg" alt="img"></p><p>Socket通信基本流程</p><p><strong>服务器端</strong><br> （1）首先服务器应用程序用系统调用socket来创建一个套接字，它是<strong>系统分配给该服务器进程的类似文件描述符的资源，它不能与其他的进程共享。</strong><br> （2）然后，服务器进程会给套接字起个名字，我们使用系统调用bind来给套接字命名。然后服务器进程就开始等待客户连接到这个套接字。<br> （3）接下来，系统调用listen来创建一个队列并将其用于存放来自客户的进入连接。<br> （4）最后，服务器通过系统调用accept来接受客户的连接。<strong>它会创建一个与原有的命名套接不同的新套接字</strong>，<strong>这个套接字只用于与这个特定客户端进行通信</strong>，而命名套接字（即原先的套接字）则被保留下来继续处理来自其他客户的连接（建立客户端和服务端的用于通信的流，进行通信）。</p><p><strong>客户端</strong><br> （1）客户应用程序首先调用socket来创建一个未命名的套接字，然后将服务器的命名套接字作为一个地址来调用connect与服务器建立连接。<br> （2）一旦连接建立，我们就可以像使用底层的文件描述符那样用套接字来实现双向数据的通信（通过流进行数据传输）。<br> <a href="https://link.jianshu.com?t=http://developer.51cto.com/art/201509/490775.htm" target="_blank" rel="noopener">延伸阅读 ：Java socket编程</a></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="http://blog.chinaunix.net/uid-26833883-id-3227144.html" target="_blank" rel="noopener">进程间通信–管道</a></li><li><a href="https://blog.csdn.net/ljianhui/article/details/10253345" target="_blank" rel="noopener">Linux进程间通信——使用共享内存</a></li><li><a href="http://blog.chinaunix.net/uid-26833883-id-3230564.html" target="_blank" rel="noopener">进程间通信—共享内存</a></li><li><a href="https://www.cnblogs.com/diyingyun/archive/2011/12/04/2275229.html" target="_blank" rel="noopener">信号量与互斥锁</a></li><li><a href="http://blog.chinaunix.net/uid-23193900-id-3194924.html" target="_blank" rel="noopener">信号量</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://www.jianshu.com/p/c1015f5ffa74&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;进程间通信IPC (InterProcess Communication)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;进程间通信的概念&quot;&gt;&lt;a href=&quot;#进程间通信的概念&quot; class=&quot;headerlink&quot; title=&quot;进程间通信的概念&quot;&gt;&lt;/a&gt;进程间通信的概念&lt;/h2&gt;&lt;p&gt;每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以&lt;strong&gt;进程之间要交换数据必须通过内核&lt;/strong&gt;，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为&lt;strong&gt;进程间通信（IPC，InterProcess Communication）&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://changsk.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="进程" scheme="http://changsk.top/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>进程和线程的区别</title>
    <link href="http://changsk.top/2019/07/13/process-thread/"/>
    <id>http://changsk.top/2019/07/13/process-thread/</id>
    <published>2019-07-13T15:04:13.000Z</published>
    <updated>2019-07-13T15:37:40.878Z</updated>
    
    <content type="html"><![CDATA[<p>根本区别：<strong>进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位</strong>。</p><a id="more"></a><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p><strong>线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位</strong>，<strong>一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。</strong></p><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><blockquote><p>根本区别：进程是资源分配的最小单位，线程是程序执行的最小单位。</p></blockquote><ol><li><strong>开销方面</strong>：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程<strong>共享代码和数据空间</strong>，<strong>每个线程都有自己独立的运行栈和程序计数器（PC）</strong>，<strong>线程之间切换的开销小</strong>。</li></ol><blockquote><p>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。</p></blockquote><ol start="2"><li><p><strong>通信方面</strong>：线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。</p></li><li><p><strong>所处环境</strong>：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</p></li><li><p><strong>内存分配</strong>方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），<strong>线程组之间只能共享资源</strong>。</p></li><li><p><strong>包含关系</strong>：<strong>一个程序至少有一个进程,一个进程至少有一个线程.</strong></p></li></ol><blockquote><p>参考：<br><a href="http://mp.weixin.qq.com/s/f_OezOorxInJqzx8WT7x2g" target="_blank" rel="noopener">一道面试题：说说进程和线程的区别</a><br><a href="https://blog.csdn.net/kuangsonghan/article/details/80674777" target="_blank" rel="noopener">进程和线程的主要区别（总结）</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根本区别：&lt;strong&gt;进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://changsk.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="进程" scheme="http://changsk.top/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="线程" scheme="http://changsk.top/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-变态青蛙跳台阶</title>
    <link href="http://changsk.top/2019/07/13/jianzhioffer-jumping-stairs/"/>
    <id>http://changsk.top/2019/07/13/jianzhioffer-jumping-stairs/</id>
    <published>2019-07-13T14:37:12.000Z</published>
    <updated>2019-07-13T15:00:04.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="青蛙跳"><a href="#青蛙跳" class="headerlink" title="青蛙跳"></a>青蛙跳</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><a id="more"></a><h3 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        helper(count, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> count, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count == target)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(count &gt; target) <span class="keyword">return</span>;</span><br><span class="line">        helper(count + <span class="number">1</span>,target); <span class="comment">// helper 的第一个参数不能是 ++count,因为这样的话 count 会自增1，影响后面的 helper 调用</span></span><br><span class="line">        helper(count + <span class="number">2</span>,target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> JumpFloor(target - <span class="number">1</span>) + JumpFloor(target - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法3"><a href="#解法3" class="headerlink" title="解法3"></a>解法3</h3><p>类似于求斐波那契数列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] steps = <span class="keyword">new</span> <span class="keyword">int</span>[target];</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        steps[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        steps[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; target;i++)</span><br><span class="line">            steps[i] = steps[i - <span class="number">1</span>] + steps[i - <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> steps[target - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法4"><a href="#解法4" class="headerlink" title="解法4"></a>解法4</h3><p>比解法3空间效率更高，常数级别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; target;i++)&#123;</span><br><span class="line">            c = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="蛙跳台阶"><a href="#蛙跳台阶" class="headerlink" title="蛙跳台阶"></a>蛙跳台阶</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>分析：因为n级台阶，第一步有n种跳法：跳1级、跳2级、到跳n级<br>跳1级，剩下n-1级，则剩下跳法是f(n-1)<br>跳2级，剩下n-2级，则剩下跳法是f(n-2)<br>所以f(n)=f(n-1)+f(n-2)+…+f(1)<br>因为f(n-1)=f(n-2)+f(n-3)+…+f(1)<br>所以f(n)=2*f(n-1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">        return 1&lt;&lt;--target</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;青蛙跳&quot;&gt;&lt;a href=&quot;#青蛙跳&quot; class=&quot;headerlink&quot; title=&quot;青蛙跳&quot;&gt;&lt;/a&gt;青蛙跳&lt;/h2&gt;&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="http://changsk.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="http://changsk.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer:矩阵覆盖</title>
    <link href="http://changsk.top/2019/07/12/jianzhioffer-matrix-coverage/"/>
    <id>http://changsk.top/2019/07/12/jianzhioffer-matrix-coverage/</id>
    <published>2019-07-12T10:30:39.000Z</published>
    <updated>2019-07-12T13:52:55.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>我们可以用<code>2 * 1</code>的小矩形横着或者竖着去覆盖更大的矩形。请问用n个<code>2 * 1</code>的小矩形无重叠地覆盖一个<code>2*n</code>的大矩形，总共有多少种方法？</p><a id="more"></a><h2 id="AC代码1"><a href="#AC代码1" class="headerlink" title="AC代码1"></a>AC代码1</h2><p>递归的方式。</p><p>设<code>2 * n</code>的大矩阵共有<code>f(n)</code>种覆盖方法，那么</p><p><code>f(n) = f(n - 1) + f(n - 2)</code>，即</p><p>f(n) 可以由<code>f(n - 1)</code> 加上一个竖着的2 * 1的小矩阵拼接，</p><p>也可以由<code>f(n - 2)</code> 加上两个横着的2 * 1的小矩阵拼接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>; </span><br><span class="line">        <span class="keyword">return</span> RectCover(target - <span class="number">1</span>) + RectCover(target - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AC代码2"><a href="#AC代码2" class="headerlink" title="AC代码2"></a>AC代码2</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[target];</span><br><span class="line">        nums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        nums[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; target;i++)&#123;</span><br><span class="line">            nums[i] = nums[i - <span class="number">1</span>] + nums[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[target - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;我们可以用&lt;code&gt;2 * 1&lt;/code&gt;的小矩形横着或者竖着去覆盖更大的矩形。请问用n个&lt;code&gt;2 * 1&lt;/code&gt;的小矩形无重叠地覆盖一个&lt;code&gt;2*n&lt;/code&gt;的大矩形，总共有多少种方法？&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="http://changsk.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="http://changsk.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-121:Best Time to Buy and Sell Stock</title>
    <link href="http://changsk.top/2019/07/12/leetcode-121/"/>
    <id>http://changsk.top/2019/07/12/leetcode-121/</id>
    <published>2019-07-12T10:02:29.000Z</published>
    <updated>2019-07-13T14:39:18.684Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p><p>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p><p>Note that you cannot sell a stock before you buy one.</p><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p><strong>Example 1:</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">Output: <span class="number">5</span></span><br><span class="line">Explanation: Buy <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">2</span> (price = <span class="number">1</span>) <span class="keyword">and</span> sell <span class="keyword">on</span> <span class="built_in">day</span> <span class="number">5</span> (price = <span class="number">6</span>), profit = <span class="number">6</span><span class="number">-1</span> = <span class="number">5.</span></span><br><span class="line">             Not <span class="number">7</span><span class="number">-1</span> = <span class="number">6</span>, <span class="keyword">as</span> selling price needs <span class="keyword">to</span> be larger than buying price.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Input:</span> [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line"><span class="string">Output:</span> <span class="number">0</span></span><br><span class="line"><span class="string">Explanation:</span> In <span class="keyword">this</span> <span class="keyword">case</span>, no transaction is done, i.e. max profit = <span class="number">0.</span></span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">int</span> maxPrice = prices[len - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i = len - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            max = Math.max(max, maxPrice - prices[i]);</span><br><span class="line">            maxPrice = Math.max(maxPrice, prices[i]);</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/best-time-to-buy-and-sell-stock/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer:二维数组中的查找</title>
    <link href="http://changsk.top/2019/07/12/jianzhioffer-find-two-dimensional-array/"/>
    <id>http://changsk.top/2019/07/12/jianzhioffer-find-two-dimensional-array/</id>
    <published>2019-07-12T09:47:11.000Z</published>
    <updated>2019-07-12T09:51:23.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><a id="more"></a><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><p><strong>从二维数组对应的矩阵的右上角或者左下角开始查找。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length == <span class="number">0</span> || array[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> rows = array.length;</span><br><span class="line">        <span class="keyword">int</span> clos = array[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> curX = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curY = clos - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(array[curX][curY] != target) &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[curX][curY] &gt; target) </span><br><span class="line">                <span class="keyword">if</span>(curY - <span class="number">1</span> &gt;= <span class="number">0</span>) curY--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(curX + <span class="number">1</span> &lt; rows) curX++;</span><br><span class="line">                 <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(array[curX][curY] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="http://changsk.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="http://changsk.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-21:Merge Two Sorted Lists(合并两个有序链表)</title>
    <link href="http://changsk.top/2019/07/11/leetcode-21/"/>
    <id>http://changsk.top/2019/07/11/leetcode-21/</id>
    <published>2019-07-11T02:41:25.000Z</published>
    <updated>2019-07-13T14:38:22.179Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-two-sorted-lists/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>题目难度：Easy</p></blockquote><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><p><strong>Example:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="AC代码1"><a href="#AC代码1" class="headerlink" title="AC代码1"></a>AC代码1</h2><p>普通的解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Merge(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">null</span>) <span class="keyword">return</span> list2;</span><br><span class="line">        <span class="keyword">if</span>(list2 == <span class="keyword">null</span>) <span class="keyword">return</span> list1;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode newhead = head;</span><br><span class="line">        <span class="keyword">while</span>(list1 != <span class="keyword">null</span> || list2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">                head.next = list2;</span><br><span class="line">                <span class="keyword">return</span> newhead.next;</span><br><span class="line">                <span class="comment">//head = head.next;</span></span><br><span class="line">                <span class="comment">//list2 = list2.next;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(list2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">                head.next = list1;</span><br><span class="line">                <span class="keyword">return</span> newhead.next;</span><br><span class="line">                <span class="comment">//head = head.next;</span></span><br><span class="line">                <span class="comment">//list1 = list1.next;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(list1.val &gt; list2.val)&#123;</span><br><span class="line">                    head.next = list2;</span><br><span class="line">                    head = head.next;</span><br><span class="line">                    list2 = list2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(list1.val &lt; list2.val)&#123;</span><br><span class="line">                    head.next = list1;</span><br><span class="line">                    head = head.next;</span><br><span class="line">                    list1 = list1.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    head.next = list1;</span><br><span class="line">                    head = head.next;</span><br><span class="line">                    head.next = list2;</span><br><span class="line">                    head = head.next;</span><br><span class="line">                    list1 = list1.next;</span><br><span class="line">                    list2 = list2.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><p>递归解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mergeCore(l1,l2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeCore</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">                l1.next = mergeCore(l1.next, l2);</span><br><span class="line">                <span class="keyword">return</span> l1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                l2.next = mergeCore(l1, l2.next);</span><br><span class="line">                <span class="keyword">return</span> l2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/merge-two-sorted-lists/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/merge-two-sorted-lists/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
</feed>
