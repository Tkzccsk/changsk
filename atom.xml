<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>changsk&#39;s blogs</title>
  
  <subtitle>chang.sk@foxmail.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://changsk.top/"/>
  <updated>2019-07-10T13:52:43.650Z</updated>
  <id>http://changsk.top/</id>
  
  <author>
    <name>changsk</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode-142:Linked List Cycle II</title>
    <link href="http://changsk.top/2019/07/10/leetcode-142/"/>
    <id>http://changsk.top/2019/07/10/leetcode-142/</id>
    <published>2019-07-10T13:47:14.000Z</published>
    <updated>2019-07-10T13:52:43.650Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/linked-list-cycle-ii/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>题目难度：Medium</p></blockquote><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p><p>To represent a cycle in the given linked list, we use an integer <code>pos</code> which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p><p><strong>Note:</strong> Do not modify the linked list.</p><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p><strong>Example 1:</strong></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input:<span class="built_in"> head</span> = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,-<span class="number">4</span>], pos = <span class="number">1</span></span><br><span class="line">Output:<span class="built_in"> tail</span> connects <span class="keyword">to</span> <span class="type">node</span> index <span class="number">1</span></span><br><span class="line">Explanation: There <span class="literal">is</span> a cycle <span class="keyword">in</span> the linked list, <span class="keyword">where</span><span class="built_in"> tail</span> connects <span class="keyword">to</span> the second <span class="type">node</span>.</span><br></pre></td></tr></table></figure><p><img src="1.jpg" alt="img"></p><p><strong>Example 2:</strong></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input:<span class="built_in"> head</span> = [<span class="number">1</span>,<span class="number">2</span>], pos = <span class="number">0</span></span><br><span class="line">Output:<span class="built_in"> tail</span> connects <span class="keyword">to</span> <span class="type">node</span> index <span class="number">0</span></span><br><span class="line">Explanation: There <span class="literal">is</span> a cycle <span class="keyword">in</span> the linked list, <span class="keyword">where</span><span class="built_in"> tail</span> connects <span class="keyword">to</span> the first <span class="type">node</span>.</span><br></pre></td></tr></table></figure><p><img src="2.jpg" alt="img"></p><p><strong>Example 3:</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Input:</span> <span class="string">head</span> <span class="string">=</span> <span class="string">[1],</span> <span class="string">pos</span> <span class="string">=</span> <span class="bullet">-1</span></span><br><span class="line"><span class="attr">Output:</span> <span class="literal">no</span> <span class="string">cycle</span></span><br><span class="line"><span class="attr">Explanation:</span> <span class="string">There</span> <span class="string">is</span> <span class="literal">no</span> <span class="string">cycle</span> <span class="string">in</span> <span class="string">the</span> <span class="string">linked</span> <span class="string">list.</span></span><br></pre></td></tr></table></figure><p><img src="3.jpg" alt="img"></p><p><strong>Follow-up</strong>:Can you solve it without using extra space?</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode slowNode = head;</span><br><span class="line">        ListNode quickNode = head;</span><br><span class="line">        <span class="keyword">while</span>(quickNode != <span class="keyword">null</span> &amp;&amp; quickNode.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slowNode = slowNode.next;</span><br><span class="line">            quickNode = quickNode.next.next;</span><br><span class="line">            <span class="keyword">if</span>(slowNode == quickNode)&#123;</span><br><span class="line">                quickNode = head;</span><br><span class="line">                <span class="keyword">while</span>(slowNode != quickNode)&#123;</span><br><span class="line">                    slowNode = slowNode.next;</span><br><span class="line">                    quickNode = quickNode.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> quickNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/linked-list-cycle-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/linked-list-cycle-ii/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-92:Reverse Linked List II</title>
    <link href="http://changsk.top/2019/07/10/leetcode-92/"/>
    <id>http://changsk.top/2019/07/10/leetcode-92/</id>
    <published>2019-07-10T13:14:58.000Z</published>
    <updated>2019-07-10T13:17:42.624Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-linked-list-ii/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Reverse a linked list from position <em>m</em> to <em>n</em>. Do it in one-pass.</p><p><strong>Note:</strong> 1 ≤ <em>m</em> ≤ <em>n</em> ≤ length of list.</p><p><strong>Example:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL, m = <span class="number">2</span>, n = <span class="number">4</span></span><br><span class="line">Output: <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br></pre></td></tr></table></figure><h2 id="AC代码1"><a href="#AC代码1" class="headerlink" title="AC代码1"></a>AC代码1</h2><p>朴素的解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m == n) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">        ListNode curNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">1</span>) &#123; <span class="comment">//从头节点开始</span></span><br><span class="line">            newHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            curNode = head;</span><br><span class="line">            ListNode end = head; <span class="comment">//m - n之间的元素翻转完成之后的尾节点</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; n - m + <span class="number">1</span>)&#123;</span><br><span class="line">                curNode = head;</span><br><span class="line">                head = head.next;</span><br><span class="line">                curNode.next = newHead.next;</span><br><span class="line">                newHead.next = curNode; </span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            end.next = head;</span><br><span class="line">            <span class="keyword">return</span> newHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            newHead = head;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; m - <span class="number">2</span>) &#123;</span><br><span class="line">                head = head.next;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode start = head; <span class="comment">// m 的前一个节点</span></span><br><span class="line">            ListNode end = head.next; <span class="comment">//m - n之间的元素翻转完成之后的尾节点</span></span><br><span class="line">            head = head.next;</span><br><span class="line">            ListNode fakeNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            curNode = head;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; n - m + <span class="number">1</span>)&#123;</span><br><span class="line">                curNode = head;</span><br><span class="line">                head = head.next;</span><br><span class="line">                curNode.next = fakeNode.next;</span><br><span class="line">                fakeNode.next = curNode; </span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(head != <span class="keyword">null</span>) end.next = head;</span><br><span class="line">            start.next = fakeNode.next;</span><br><span class="line">            <span class="keyword">return</span> newHead;</span><br><span class="line">        &#125;        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AC代码2"><a href="#AC代码2" class="headerlink" title="AC代码2"></a>AC代码2</h2><p>优雅的解法，借用<code>leetcode</code>上面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || m == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        ListNode cur = dummy.next;</span><br><span class="line">        <span class="keyword">int</span> i = m;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (n - m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ListNode temp = cur.next;</span><br><span class="line">            cur.next = temp.next;</span><br><span class="line">            temp.next = pre.next;</span><br><span class="line">            pre.next = temp;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/reverse-linked-list-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/reverse-linked-list-ii/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>https的交互过程</title>
    <link href="http://changsk.top/2019/07/10/https-interaction-process/"/>
    <id>http://changsk.top/2019/07/10/https-interaction-process/</id>
    <published>2019-07-10T12:33:51.000Z</published>
    <updated>2019-07-10T12:43:37.899Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://blog.csdn.net/yjclsx/article/details/81238010" target="_blank" rel="noopener">https的交互过程</a></p></blockquote><p>HTTPS其实是由两部分组成：<code>HTTP + SSL / TLS</code>，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会被加密，所以传输的数据都是加密后的数据。</p><a id="more"></a><p>下面介绍https具体是如何进行加密，解密，验证的，也就是https的交互过程。</p><h2 id="https的交互过程"><a href="#https的交互过程" class="headerlink" title="https的交互过程"></a>https的交互过程</h2><h3 id="客户端发起HTTPS请求"><a href="#客户端发起HTTPS请求" class="headerlink" title="客户端发起HTTPS请求"></a>客户端发起HTTPS请求</h3><p>比如在浏览器里输入<a href="https://blog.csdn.net/yjclsx，然后请求到server的**443**端口。浏览器会把自身支持的一系列Cipher" target="_blank" rel="noopener">https://blog.csdn.net/yjclsx，然后请求到server的**443**端口。浏览器会把自身支持的一系列Cipher</a> Suite（密钥算法套件，简称Cipher）发送给服务端。</p><h3 id="服务端返回"><a href="#服务端返回" class="headerlink" title="服务端返回"></a>服务端返回</h3><p>服务端接收到客户端所有的Cipher后与自身支持的对比，<strong>如果不支持则连接断开</strong>，反之则会从中选出一种<code>加密算法</code>和<code>HASH算法</code>以<strong>证书的形式返回给客户端</strong>，证书中还包含了<code>公钥、颁证机构、网址、失效日期</code>等等。</p><blockquote><p>采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥，用于非对称加密。</p></blockquote><h3 id="客户端验证证书并响应"><a href="#客户端验证证书并响应" class="headerlink" title="客户端验证证书并响应"></a>客户端验证证书并响应</h3><p>客户端收到服务端响应后会做以下几件事：</p><h4 id="验证证书的合法性"><a href="#验证证书的合法性" class="headerlink" title="验证证书的合法性"></a>验证证书的合法性</h4><p>颁发证书的机构是否合法与是否过期，证书中包含的网站地址是否与正在访问的地址一致等。证书验证通过后，在浏览器的地址栏提示网站安全。</p><h4 id="生成随机密码"><a href="#生成随机密码" class="headerlink" title="生成随机密码"></a>生成随机密码</h4><p>如果证书验证通过，或者用户接受了不授信的证书，此时客户端会生成一串随机数，用于后续进行对称加密，以后称之为密钥，然后<strong>用证书中的公钥加密这个密钥</strong>。</p><h4 id="HASH握手信息"><a href="#HASH握手信息" class="headerlink" title="HASH握手信息"></a>HASH握手信息</h4><p>用最开始约定好的<strong>HASH</strong>方式，<strong>把握手消息取HASH值</strong>，然后用密钥加密 “<code>握手消息+握手消息的HASH值(即签名)</code>”  。在这里之所以要加上握手消息的HASH值，主要是把握手消息做一个签名，<strong>用于验证握手消息在传输过程中没有被篡改过。</strong></p><p>最后将之前生成的所有信息发送给服务端。 </p><h3 id="服务端解析和验证"><a href="#服务端解析和验证" class="headerlink" title="服务端解析和验证"></a>服务端解析和验证</h3><p>服务端接收客户端发来的数据之后要做以下的操作：</p><h4 id="解析和验证"><a href="#解析和验证" class="headerlink" title="解析和验证"></a>解析和验证</h4><p>使用自己的私钥将客户端使用公钥加密的信息解密得到之前客户端生成的密钥。然后使用密钥解密客户端发来的加密后的握手消息得到 “握手消息+握手消息的HASH值(即签名)”  ，最后同样对握手信息进行HASH签名，比对和客户端传来的HASH值是否一致，如果一致则HASH验证通过，即表明握手消息在传输过程中没有被篡改过。</p><h4 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h4><p>同样使用密钥加密一段握手消息，发送给客户端。</p><h3 id="客户端解析和验证"><a href="#客户端解析和验证" class="headerlink" title="客户端解析和验证"></a>客户端解析和验证</h3><p>客户端用密钥解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束。</p><h3 id="后续通信"><a href="#后续通信" class="headerlink" title="后续通信"></a>后续通信</h3><p><strong>由于RSA等非对称加密算法的性能是非常低的</strong>，原因在于寻找大素数、大数计算、数据分割需要耗费很多的CPU周期，所以一般的HTTPS连接<strong>只在第一次握手时使用非对称加密</strong>，<strong>通过握手交换对称加密的密钥</strong>，之后所有的通信数据将由之前客户端生成的密钥进行对称加密。</p><p>因为这串密钥只有客户端和服务端知道，所以即使中间请求被拦截也是没法解密数据的，以此保证了通信的安全。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这里客户端与服务端互相发送加密的握手消息并验证，<strong>目的是为了保证双方都安全地获得了一致的密钥，并且可以正常的加密解密数据，为后续真正数据的传输做一次测试</strong>。另外，HTTPS一般使用的加密与HASH算法如下：<br>非对称加密算法：RSA，DSA/DSS<br>对称加密算法：AES，RC4，DES, 3DES<br>HASH算法：MD5，SHA1，SHA256</p><p>参考文献<br>1、<a href="http://www.cnblogs.com/zhuqil/archive/2012/07/23/2604572.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhuqil/archive/2012/07/23/2604572.html</a></p><p>2、<a href="https://www.cnblogs.com/zery/p/5164795.html" target="_blank" rel="noopener">https://www.cnblogs.com/zery/p/5164795.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://blog.csdn.net/yjclsx/article/details/81238010&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https的交互过程&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;HTTPS其实是由两部分组成：&lt;code&gt;HTTP + SSL / TLS&lt;/code&gt;，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会被加密，所以传输的数据都是加密后的数据。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://changsk.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTPS" scheme="http://changsk.top/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>Linux修改权限命令--chmod</title>
    <link href="http://changsk.top/2019/07/10/Linux-chmod/"/>
    <id>http://changsk.top/2019/07/10/Linux-chmod/</id>
    <published>2019-07-10T07:46:03.000Z</published>
    <updated>2019-07-10T07:56:19.586Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://blog.csdn.net/jerrytomcat/article/details/81744860" target="_blank" rel="noopener">Linux修改权限功能——chmod</a></p></blockquote><h2 id="chmod命令概况"><a href="#chmod命令概况" class="headerlink" title="chmod命令概况"></a>chmod命令概况</h2><p>chmod是<code>Linux/Unix</code>中修改文件或者目录权限的命令，通过修改权限可以让指定的人对文件可读、可写、可运行，极大地保证了数据的安全性。</p> <a id="more"></a><h2 id="chmod命令的语法"><a href="#chmod命令的语法" class="headerlink" title="chmod命令的语法"></a>chmod命令的语法</h2><blockquote><p>命令名称：  chmod</p><p>执行权限：  所有用户</p><p>功能描述：  改变文件或目录权限</p></blockquote><pre><code>语法：   第一种方法      chmod     [{ugoa}{+-=}{rwx}]      [文件或目录]        备注：             u：所有者    g：所属组    o：其他人    a：所有人                          +：为用户增加权限     -：为用户减少权限     =：为用户赋予权限                          r：读权限     w：写权限      x：执行权限         第二种方法      chmod   -R    [mode=421]     [文件或目录]     ←（这种方法用的比较多）        备注：            r：4   w：2   x：1                         r为读权限，可以用4来表示，                         w为写权限，可以用2来表示，                         x为执行权限，可以用1来表示。                        -R 递归修改（就是将嵌套在很多文件夹中的文件权限修改了，如果没有这个，只能到指定的文                                                                   件夹下进行修改）范例：         chmod     777     /etc/hurenxiang     将hurenxiang这个文件夹权限改为对所有用户可读，可写，可执行chmod     775     /etc/caiyao         将caiyao这个文件夹权限改为其他用户不可写             </code></pre><h2 id="chmod命令结构详解"><a href="#chmod命令结构详解" class="headerlink" title="chmod命令结构详解"></a>chmod命令结构详解</h2><p>在Linux中输入<code>ll</code>，会出现指定目录下文件/目录的详细信息，本文重点讲解权限部分，也就是下图中红色框中的部分。</p><p><img src="1.jpg" alt></p><p>详解下图：权限一共是10个字符，第1个字符分为1组，后面9个字符分为3组。</p><p>第1个字符有两种情况：如果是“d”则代表这是一个文件夹，如果是“—”代表这是一个文件；</p><p>第2、3、4个字符：这3个字符共同代表的是文件的拥有者，可以用u来表示，拥有四个权限：r：读权限 ， w：写权限，x：执行权限，—：无权限；</p><p>第5、6、7个字符：这3个字符代表的是文件所属群组，可以用g来表示，拥有四个权限：r：读权限 ， w：写权限，x：执行权限，—：无权限；</p><p>第8、9、10个字符：这3个字符代表的是除拥有者和所属群组之外的其他所有的用户，可以用o来表示，拥有四个权限：r：读权限 ， w：写权限，x：执行权限，—：无权限。</p><p>注意：后面9个字符除了u，g，o外，还有一个a，代表了所有用户。</p><p><img src="2.jpg" alt></p><h2 id="chmod命令的使用"><a href="#chmod命令的使用" class="headerlink" title="chmod命令的使用"></a>chmod命令的使用</h2><p>chmod命令都详细讲解完了，下面用几个例子巩固一下：</p><ol><li>这是通过两个实例，详细回顾了一波上面的知识点。</li></ol><blockquote><p>-rw–wx–x     //该文件的拥有者有读取和写入的权限，但没有执行权限；<br>                           所在群组没有读取的权限，但有写入和执行的权限；<br>                           其他用户没有读取和写入的权限，但有执行的权限</p></blockquote><blockquote><p>d–xr-xrw-     //该文件夹的拥有者没有读取和写入的权限，但有执行的权限；<br>                           所在群组没有写入的权限，但有读取和执行的权限；<br>                           其他用户没有执行权限，但有读取和写入的权限</p></blockquote><ol start="2"><li>这是修改权限的一种方法实例。</li></ol><blockquote><p>chmod  u-w , g+r  hurenxiang     //对hurenxiang文件设置本人没有写入的权限，设置所在群组有读取的权限<br>chmod  g+x , o+w  hurenxiang     //对hurenxiang文件设置群组有执行的权限，设置其他用户有写入的权限</p></blockquote><ol start="3"><li>这是修改权限的另一种方法实例（建议）。</li></ol><blockquote><p>chmod  777  hurenxiang       //对hurenxiang文件所有的用户都有读取，写入，执行的权限<br>chmod  751  hurenxiang       //对hurenxiang文件群组中的人没有写入的权限，其他的用户没有读取和写入的权限</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://blog.csdn.net/jerrytomcat/article/details/81744860&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux修改权限功能——chmod&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;chmod命令概况&quot;&gt;&lt;a href=&quot;#chmod命令概况&quot; class=&quot;headerlink&quot; title=&quot;chmod命令概况&quot;&gt;&lt;/a&gt;chmod命令概况&lt;/h2&gt;&lt;p&gt;chmod是&lt;code&gt;Linux/Unix&lt;/code&gt;中修改文件或者目录权限的命令，通过修改权限可以让指定的人对文件可读、可写、可运行，极大地保证了数据的安全性。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://changsk.top/categories/Linux/"/>
    
    
      <category term="chmod" scheme="http://changsk.top/tags/chmod/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-206:Reverse Linked List(翻转链表)</title>
    <link href="http://changsk.top/2019/07/10/leetcode-206/"/>
    <id>http://changsk.top/2019/07/10/leetcode-206/</id>
    <published>2019-07-10T07:33:48.000Z</published>
    <updated>2019-07-10T07:37:14.763Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-linked-list/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>题目难度：Easy</p></blockquote><p>Reverse a singly linked list.</p><p><strong>Example:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br><span class="line">Output: <span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>Follow up:</strong></p><p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode next;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next = dummyHead.next;</span><br><span class="line">            dummyHead.next = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/reverse-linked-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/reverse-linked-list/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-160:Intersection of Two Linked Lists(两个链表的交点)</title>
    <link href="http://changsk.top/2019/07/10/leetcode-160/"/>
    <id>http://changsk.top/2019/07/10/leetcode-160/</id>
    <published>2019-07-10T07:17:42.000Z</published>
    <updated>2019-07-10T07:28:16.315Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">https://leetcode.com/problems/intersection-of-two-linked-lists/</a></p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>题目难度：Easy</p></blockquote><p>Write a program to find the node at which the intersection of two singly linked lists begins.</p><p>For example, the following two linked lists:</p><p><img src="1.jpg" alt></p><p>begin to intersect at node c1.</p><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p><strong>Example 1:</strong></p><p><img src="2.jpg" alt></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intersectVal = <span class="number">8</span>, listA = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>], listB = [<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>], skipA = <span class="number">2</span>, skipB = <span class="number">3</span></span><br><span class="line">Output: <span class="keyword">Reference</span> of the <span class="keyword">node</span> <span class="title">with</span> value = <span class="number">8</span></span><br><span class="line">Input Explanation: The intersected <span class="keyword">node</span><span class="title">'s</span> value is <span class="number">8</span> (note that this must not be <span class="number">0</span> if the two lists intersect). From the head of A, it reads as [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]. From the head of B, it reads as [<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]. There are <span class="number">2</span> nodes before the intersected <span class="keyword">node</span> <span class="title">in</span> A; There are <span class="number">3</span> nodes before the intersected <span class="keyword">node</span> <span class="title">in</span> B.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="3.jpg" alt></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intersectVal = <span class="number">2</span>, listA = [<span class="number">0</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>], listB = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>], skipA = <span class="number">3</span>, skipB = <span class="number">1</span></span><br><span class="line">Output: <span class="keyword">Reference</span> of the <span class="keyword">node</span> <span class="title">with</span> value = <span class="number">2</span></span><br><span class="line">Input Explanation: The intersected <span class="keyword">node</span><span class="title">'s</span> value is <span class="number">2</span> (note that this must not be <span class="number">0</span> if the two lists intersect). From the head of A, it reads as [<span class="number">0</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]. From the head of B, it reads as [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>]. There are <span class="number">3</span> nodes before the intersected <span class="keyword">node</span> <span class="title">in</span> A; There are <span class="number">1</span> <span class="keyword">node</span> <span class="title">before</span> the intersected <span class="keyword">node</span> <span class="title">in</span> B.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><p><img src="4.jpg" alt></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: intersectVal = <span class="number">0</span>, listA = [<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>], listB = [<span class="number">1</span>,<span class="number">5</span>], skipA = <span class="number">3</span>, skipB = <span class="number">2</span></span><br><span class="line">Output: <span class="literal">null</span></span><br><span class="line">Input Explanation: From <span class="keyword">the</span> head <span class="keyword">of</span> A, <span class="keyword">it</span> reads <span class="keyword">as</span> [<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>]. From <span class="keyword">the</span> head <span class="keyword">of</span> B, <span class="keyword">it</span> reads <span class="keyword">as</span> [<span class="number">1</span>,<span class="number">5</span>]. Since <span class="keyword">the</span> <span class="literal">two</span> lists <span class="built_in">do</span> <span class="keyword">not</span> <span class="built_in">intersect</span>, intersectVal must be <span class="number">0</span>, <span class="keyword">while</span> skipA <span class="keyword">and</span> skipB can be arbitrary values.</span><br><span class="line">Explanation: The <span class="literal">two</span> lists <span class="built_in">do</span> <span class="keyword">not</span> <span class="built_in">intersect</span>, so <span class="literal">return</span> <span class="literal">null</span>.</span><br></pre></td></tr></table></figure><p><strong>Notes:</strong></p><ul><li>If the two linked lists have no intersection at all, return <code>null</code>.</li><li>The linked lists must retain their original structure after the function returns.</li><li>You may assume there are no cycles anywhere in the entire linked structure.</li><li>Your code should preferably run in O(n) time and use only O(1) memory.</li></ul><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode p1 = headA;</span><br><span class="line">        ListNode p2 = headB;</span><br><span class="line">        <span class="keyword">while</span>(p1 != p2)&#123;</span><br><span class="line">            p1 = (p1 == <span class="keyword">null</span> ? headB : p1.next);</span><br><span class="line">            p2 = (p2 == <span class="keyword">null</span> ? headA : p2.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/intersection-of-two-linked-lists/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/intersection-of-two-linked-lists/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>TCP中的粘包现象产生的原因以及解决办法</title>
    <link href="http://changsk.top/2019/07/10/tcp-sticky-bag/"/>
    <id>http://changsk.top/2019/07/10/tcp-sticky-bag/</id>
    <published>2019-07-10T03:14:51.000Z</published>
    <updated>2019-07-10T03:46:49.888Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://blog.csdn.net/qq_28764223/article/details/80610437" target="_blank" rel="noopener">TCP粘包，拆包及解决方法</a></p></blockquote><p>在进行<code>Java NIO</code>学习时，发现，如果客户端连续不断的向服务端发送数据包时，服务端接收的数据会出现两个数据包粘在一起的情况，这就是TCP协议中经常会遇到的粘包以及拆包的问题。</p><a id="more"></a><p>我们都知道TCP属于传输层的协议，传输层除了有TCP协议外还有UDP协议。那么UDP是否会发生粘包或拆包的现象呢？答案是不会。<strong>UDP是基于报文发送的</strong>，从UDP的帧结构可以看出，在UDP首部采用了16bit来指示UDP数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。而TCP是基于字节流的，虽然应用层和TCP传输层之间的数据交互是大小不等的数据块，但是<strong>TCP把这些数据块仅仅看成一连串无结构的字节流，没有边界</strong>；另外从TCP的帧结构也可以看出，在TCP的首部没有表示数据长度的字段，基于上面两点，在使用TCP传输数据时，才有粘包或者拆包现象发生的可能。</p><h3 id="粘包、拆包表现形式"><a href="#粘包、拆包表现形式" class="headerlink" title="粘包、拆包表现形式"></a>粘包、拆包表现形式</h3><p>现在假设客户端向服务端连续发送了两个数据包，用<code>packet1</code>和<code>packet2</code>来表示，那么服务端收到的数据可以分为三种，现列举如下：</p><p>第一种情况，接收端正常收到两个数据包，即没有发生拆包和粘包的现象，此种情况不在本文的讨论范围内。</p><p><img src="1.jpg" alt="normal"></p><p>第二种情况，接收端只收到一个数据包，由于TCP是不会出现丢包的，所以<strong>这一个数据包中包含了发送端发送的两个数据包的信息</strong>，这种现象即为粘包。这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。</p><p><img src="2.jpg" alt="one"></p><p>第三种情况，这种情况有两种表现形式，如下图。接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。这两种情况如果不加特殊处理，对于接收端同样是不好处理的。</p><p><img src="3.jpg" alt="half_one"></p><p><img src="4.jpg" alt></p><h3 id="粘包、拆包发生原因"><a href="#粘包、拆包发生原因" class="headerlink" title="粘包、拆包发生原因"></a>粘包、拆包发生原因</h3><p>发生TCP粘包或拆包有很多原因，现列出常见的几点，可能不全面，欢迎补充，</p><p>1、要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。</p><p>2、待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。</p><p>3、要发送的数据小于TCP发送缓冲区的大小，会启用Nagle算法（可配置是否启用），TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。</p><p>5、接收数据端的应用层没有及时读取接收缓冲区中的数据，导致接收缓冲区有多次收到的数据，将发生粘包。</p><p>等等。</p><h3 id="粘包、拆包解决办法"><a href="#粘包、拆包解决办法" class="headerlink" title="粘包、拆包解决办法"></a>粘包、拆包解决办法</h3><p>通过以上分析，我们清楚了粘包或拆包发生的原因，那么如何解决这个问题呢？解决问题的关键在于如何给每个数据包添加边界信息，常用的方法有如下几个：</p><p>1、发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。</p><p>2、发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</p><p>3、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。</p><p>等等。</p><h3 id="样例程序"><a href="#样例程序" class="headerlink" title="样例程序"></a>样例程序</h3><p>我将在程序中使用两种方法来解决粘包和拆包问题，固定数据包长度和添加长度首部，这两种方法各有优劣。固定数据包长度传输效率一般，尤其是在要发送的数据长度长短差别很大的时候效率会比较低，但是编程实现比较简单；添加长度首部虽然可以获得较高的传输效率，冗余信息少且固定，但是编程实现较为复杂。下面给出的样例程序是基于之前的文章《<a href="http://blog.insanecoder.top/javazhong-bio-niohe-aioshi-yong-yang-li/" target="_blank" rel="noopener">Java中BIO，NIO和AIO使用样例</a>》中提到的NIO实例的，如果对NIO的使用还不是很熟悉，可以先了解一下Java中NIO编程。</p><h4 id="固定数据包长度"><a href="#固定数据包长度" class="headerlink" title="固定数据包长度"></a>固定数据包长度</h4><p>这种处理方式的思路很简单，发送端在发送实际数据前先把数据封装为固定长度，然后在发送出去，接收端接收到数据后按照这个固定长度进行拆分即可。发送端程序如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送端</span></span><br><span class="line">String msg = <span class="string">"hello world "</span> + number++;  </span><br><span class="line">socketChannel.write(ByteBuffer.wrap(<span class="keyword">new</span> FixLengthWrapper(msg).getBytes()));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 封装固定长度的工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixLengthWrapper</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_LENGTH = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FixLengthWrapper</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(MAX_LENGTH);</span><br><span class="line">        byteBuffer.put(msg.getBytes());</span><br><span class="line">        <span class="keyword">byte</span>[] fillData = <span class="keyword">new</span> <span class="keyword">byte</span>[MAX_LENGTH - msg.length()];</span><br><span class="line">        byteBuffer.put(fillData);</span><br><span class="line">        data = byteBuffer.array();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FixLengthWrapper</span><span class="params">(<span class="keyword">byte</span>[] msg)</span> </span>&#123;</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(MAX_LENGTH);</span><br><span class="line">        byteBuffer.put(msg);</span><br><span class="line">        <span class="keyword">byte</span>[] fillData = <span class="keyword">new</span> <span class="keyword">byte</span>[MAX_LENGTH - msg.length];</span><br><span class="line">        byteBuffer.put(fillData);</span><br><span class="line">        data = byteBuffer.array();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes() &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : getBytes()) &#123;</span><br><span class="line">            sb.append(String.format(<span class="string">"0x%02X "</span>, b));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到客户端在发送数据前首先把数据封装为长度为32bytes的数据包，这个长度是根据目前实际数据包长度来规定的，这个长度必须要大于所有可能出现的数据包的长度，这样才不会出现把数据“截断”的情况。接收端程序如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processByFixLength</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">    <span class="keyword">while</span> (socketChannel.read(byteBuffer) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"> </span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        <span class="keyword">while</span> (byteBuffer.remaining() &gt;= FixLengthWrapper.MAX_LENGTH) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[FixLengthWrapper.MAX_LENGTH];</span><br><span class="line">            byteBuffer.get(data, <span class="number">0</span>, FixLengthWrapper.MAX_LENGTH);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(data) + <span class="string">" &lt;---&gt; "</span> + number++);</span><br><span class="line">        &#125;</span><br><span class="line">        byteBuffer.compact();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出接收端的处理很简单，只需要每次读取固定的长度即可区分出来不同的数据包。</p><h4 id="添加长度首部"><a href="#添加长度首部" class="headerlink" title="添加长度首部"></a>添加长度首部</h4><p>这种方式的处理较上面提到的方式稍微复杂一点。在发送端需要给待发送的数据添加固定的首部，然后再发送出去，然后在接收端需要根据这个首部的长度信息进行数据包的组合或拆分，发送端程序如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送端</span></span><br><span class="line">String msg = <span class="string">"hello world "</span> + number++;  </span><br><span class="line"><span class="comment">// add the head represent the data length</span></span><br><span class="line">socketChannel.write(ByteBuffer.wrap(<span class="keyword">new</span> PacketWrapper(msg).getBytes()));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 添加长度首部的工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PacketWrapper</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] payload;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PacketWrapper</span><span class="params">(String payload)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.payload = payload.getBytes();</span><br><span class="line">        <span class="keyword">this</span>.length = <span class="keyword">this</span>.payload.length;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PacketWrapper</span><span class="params">(<span class="keyword">byte</span>[] payload)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.payload = payload;</span><br><span class="line">        <span class="keyword">this</span>.length = <span class="keyword">this</span>.payload.length;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes() &#123;</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="keyword">this</span>.length + <span class="number">4</span>);</span><br><span class="line">        byteBuffer.putInt(<span class="keyword">this</span>.length);</span><br><span class="line">        byteBuffer.put(payload);</span><br><span class="line">        <span class="keyword">return</span> byteBuffer.array();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : getBytes()) &#123;</span><br><span class="line">            sb.append(String.format(<span class="string">"0x%02X "</span>, b));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从程序可以看到，发送端在发送数据前首先给待发送数据添加了代表长度的首部，首部长为4bytes（即int型长度），这样接收端在收到这个数据之后，首先需要读取首部，拿到实际数据长度，然后再继续读取实际长度的数据，即实现了组包和拆包的操作。程序如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processByHead</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (socketChannel.read(byteBuffer) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 保存bytebuffer状态</span></span><br><span class="line">        <span class="keyword">int</span> position = byteBuffer.position();</span><br><span class="line">        <span class="keyword">int</span> limit = byteBuffer.limit();</span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        <span class="comment">// 判断数据长度是否够首部长度</span></span><br><span class="line">        <span class="keyword">if</span> (byteBuffer.remaining() &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            byteBuffer.position(position);</span><br><span class="line">            byteBuffer.limit(limit);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断bytebuffer中剩余数据是否足够一个包</span></span><br><span class="line">        <span class="keyword">int</span> length = byteBuffer.getInt();</span><br><span class="line">        <span class="keyword">if</span> (byteBuffer.remaining() &lt; length) &#123;</span><br><span class="line">            byteBuffer.position(position);</span><br><span class="line">            byteBuffer.limit(limit);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 拿到实际数据包</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line"> </span><br><span class="line">        byteBuffer.get(data, <span class="number">0</span>, length);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(data) + <span class="string">" &lt;---&gt; "</span> + number++);</span><br><span class="line">        byteBuffer.compact();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键信息已经在程序中做了注释，可以很明显的感觉到这种方法的处理难度相对于固定长度要大一些，不过这种方式可以获取更大的传输效率。</p><p>这里需要提醒各位同学一个问题，由于我在测试的时候采用的是一台机器连续发送数据来模拟高并发的场景，所以在测试的时候会发现服务器端收到的数据包的个数经常会小于包的序号，好像发生了丢包。但经过仔细分析可以发现，这种情况是因为TCP发送缓存溢出导致的丢包，也就是这个数据包根本没有发出来。也就是说，发送端发送数据过快，导致接收端缓存很快被填满，这个时候接收端会把通知窗口设置为0从而控制发送端的流量，这样新到的数据只能暂存在发送端的发送缓存中，当发送缓存溢出后，就出现了我上面提到的丢包，这个问题可以通过增大发送端缓存来缓解这个问题，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.socket().setSendBufferSize(<span class="number">102400</span>);</span><br></pre></td></tr></table></figure><p>当然这个话题不在本文的讨论范围，如果有兴趣的同学可以参阅《TCP/IP详解卷一》中的拥塞窗口一章。</p><p>关于源码说明，源码默认是把粘包和拆包处理这一部分注释掉了，分别位于NIOTcpServer和NIOTcpClient文件中，需要测试粘包和拆包处理程序的同学需要把这一段注释给去掉。</p><p>详见：<a href="https://blog.csdn.net/scythe666/article/details/51996268（含源码下载）" target="_blank" rel="noopener">https://blog.csdn.net/scythe666/article/details/51996268（含源码下载）</a></p><p>tcp粘包udp不粘包的原因：<a href="https://blog.csdn.net/hik_zxw/article/details/48398935" target="_blank" rel="noopener">https://blog.csdn.net/hik_zxw/article/details/48398935</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://blog.csdn.net/qq_28764223/article/details/80610437&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TCP粘包，拆包及解决方法&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在进行&lt;code&gt;Java NIO&lt;/code&gt;学习时，发现，如果客户端连续不断的向服务端发送数据包时，服务端接收的数据会出现两个数据包粘在一起的情况，这就是TCP协议中经常会遇到的粘包以及拆包的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://changsk.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="TCP" scheme="http://changsk.top/tags/TCP/"/>
    
      <category term="粘包" scheme="http://changsk.top/tags/%E7%B2%98%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>redis分布式锁之redisson</title>
    <link href="http://changsk.top/2019/07/10/redis-distributed-lock-redisson/"/>
    <id>http://changsk.top/2019/07/10/redis-distributed-lock-redisson/</id>
    <published>2019-07-10T02:09:30.000Z</published>
    <updated>2019-07-10T02:33:58.286Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://mp.weixin.qq.com/s?__biz=MzU0OTk3ODQ3Ng==&mid=2247483893&idx=1&sn=32e7051116ab60e41f72e6c6e29876d9&chksm=fba6e9f6ccd160e0c9fa2ce4ea1051891482a95b1483a63d89d71b15b33afcdc1f2bec17c03c&mpshare=1&scene=1&srcid=0416Kx8ryElbpy4xfrPkSSdB&key=1eff032c36dd9b3716bab5844171cca99a4ea696da85eed0e4b2b7ea5c39a665110b82b4c975d2fd65c396e91f4c7b3e8590c2573c6b8925de0df7daa886be53d793e7f06b2c146270f7c0a5963dd26a&ascene=1&uin=MTg2ODMyMTYxNQ%3D%3D&devicetype=Windows+10&version=62060739&lang=zh_CN&pass_ticket=y1D2AijXbuJ8HCPhyIi0qPdkT0TXqKFYo%2FmW07fgvW%2FXxWFJiJjhjTsnInShv0ap" target="_blank" rel="noopener">拜托，面试请不要再问我Redis分布式锁的实现原理【石杉的架构笔记】</a></p></blockquote><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>现在面试，一般都会聊聊<strong>分布式系统</strong>这块的东西。通常面试官都会从服务框架（Spring Cloud、Dubbo）聊起，一路聊到分布式事务、分布式锁、ZooKeeper等知识。</p><p>所以咱们这篇文章就来聊聊分布式锁这块知识，具体的来看看<strong>Redis分布式锁的实现原理。</strong></p><a id="more"></a><p>说实话，如果在公司里落地生产环境用分布式锁的时候，一定是会用开源类库的，比如Redis分布式锁，一般就是用<strong>Redisson</strong>框架就好了，非常的简便易用。</p><p>大家如果有兴趣，可以去看看Redisson的官网，看看如何在项目中引入Redisson的依赖，然后基于Redis实现分布式锁的加锁与释放锁。</p><p>下面给大家看一段简单的使用代码片段，先直观的感受一下：</p><p><img src="1.jpg" alt="img"></p><p>怎么样，上面那段代码，是不是感觉简单的不行！</p><p>此外，人家还支持redis单实例、redis哨兵、redis cluster、redis master-slave等各种部署架构，都可以给你完美实现。</p><h2 id="Redisson实现Redis分布式锁的底层原理"><a href="#Redisson实现Redis分布式锁的底层原理" class="headerlink" title="Redisson实现Redis分布式锁的底层原理"></a>Redisson实现Redis分布式锁的底层原理</h2><p>好的，接下来就通过一张手绘图，给大家说说Redisson这个开源框架对Redis分布式锁的实现原理。</p><p><img src="2.jpg" alt="img"></p><h3 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h3><p>咱们来看上面那张图，现在某个客户端要加锁。如果该客户端面对的是一个redis cluster集群，他首先会根据hash节点选择一台机器。</p><p><strong>这里注意</strong>，仅仅只是选择一台机器！这点很关键！</p><p>紧接着，就会发送一段lua脚本到redis上，那段lua脚本如下所示：</p><p><img src="3.jpg" alt="img"></p><p>为啥要用<strong>lua脚本</strong>呢？</p><p>因为一大坨复杂的业务逻辑，可以通过封装在lua脚本中发送给redis，保证这段复杂业务逻辑执行的<strong>原子性</strong>。</p><p>那么，这段lua脚本是什么意思呢？</p><p><strong>KEYS[1]</strong>代表的是你加锁的那个key，比如说：</p><blockquote><p>RLock lock = redisson.getLock(“myLock”);</p></blockquote><p>这里你自己设置了加锁的那个锁key就是“myLock”。</p><p><strong>ARGV[1]</strong>代表的就是锁key的默认生存时间，默认30秒。</p><p><strong>ARGV[2]</strong>代表的是加锁的客户端的ID，类似于下面这样：</p><blockquote><p>8743c9c0-0795-4907-87fd-6c719a6b4586:1</p></blockquote><p>给大家解释一下，第一段if判断语句，就是用“exists myLock”命令判断一下，如果你要加锁的那个锁key不存在的话，你就进行加锁。</p><p>如何加锁呢？很简单，用下面的命令：</p><blockquote><p>hset myLock </p><p>8743c9c0-0795-4907-87fd-6c719a6b4586:1 1</p></blockquote><p>通过这个命令设置一个hash数据结构，这行命令执行后，会出现一个类似下面的数据结构：</p><p><img src="4.jpg" alt="img"></p><p>上述就代表“8743c9c0-0795-4907-87fd-6c719a6b4586:1”这个客户端对“myLock”这个锁key完成了加锁。</p><p>接着会执行“pexpire myLock 30000”命令，设置myLock这个锁key的生存时间是30秒。</p><p>好了，到此为止，ok，加锁完成了。</p><h3 id="锁互斥机制"><a href="#锁互斥机制" class="headerlink" title="锁互斥机制"></a>锁互斥机制</h3><p>那么在这个时候，如果客户端2来尝试加锁，执行了同样的一段lua脚本，会咋样呢？</p><p>很简单，第一个if判断会执行“exists myLock”，发现myLock这个锁key已经存在了。</p><p>接着第二个if判断，判断一下，myLock锁key的hash数据结构中，是否包含客户端2的ID，但是明显不是的，因为那里包含的是客户端1的ID。</p><p>所以，客户端2会获取到pttl myLock返回的一个数字，这个数字代表了myLock这个锁key的<strong>剩余生存时间。</strong>比如还剩15000毫秒的生存时间。</p><p>此时客户端2会进入一个<strong>while循环</strong>，不停的尝试加锁。</p><h3 id="watch-dog自动延期机"><a href="#watch-dog自动延期机" class="headerlink" title="watch dog自动延期机"></a>watch dog自动延期机</h3><p>客户端1加锁的锁key默认生存时间才30秒，如果超过了30秒，客户端1还想一直持有这把锁，怎么办呢？</p><p>简单！只要客户端1一旦加锁成功，就会启动一个watch dog看门狗，<strong>他是一个后台线程，会每隔10秒检查一下</strong>，如果客户端1还持有锁key，那么就会不断的延长锁key的生存时间。</p><h3 id="可重入加锁机制"><a href="#可重入加锁机制" class="headerlink" title="可重入加锁机制"></a>可重入加锁机制</h3><p>那如果客户端1都已经持有了这把锁了，结果可重入的加锁会怎么样呢？</p><p>比如下面这种代码：</p><p><img src="5.jpg" alt="img"></p><p>这时我们来分析一下上面那段lua脚本。</p><p>第一个if判断肯定不成立，“exists myLock”会显示锁key已经存在了。</p><p>第二个if判断会成立，因为myLock的hash数据结构中包含的那个ID，就是客户端1的那个ID，也就是“8743c9c0-0795-4907-87fd-6c719a6b4586:1”</p><p>此时就会执行可重入加锁的逻辑，他会用：</p><blockquote><p>incrby myLock </p><p>8743c9c0-0795-4907-87fd-6c71a6b4586:1 1</p></blockquote><p>通过这个命令，对客户端1的加锁次数，累加1。</p><p>此时myLock数据结构变为下面这样：</p><p><img src="6.jpg" alt="img"></p><p>大家看到了吧，那个myLock的hash数据结构中的那个客户端ID，就对应着加锁的次数</p><h3 id="释放锁机制"><a href="#释放锁机制" class="headerlink" title="释放锁机制"></a>释放锁机制</h3><p>如果执行lock.unlock()，就可以释放分布式锁，此时的业务逻辑也是非常简单的。</p><p>其实说白了，就是每次都对myLock数据结构中的那个加锁次数减1。</p><p>如果发现加锁次数是0了，说明这个客户端已经不再持有锁了，此时就会用：</p><p>“del myLock”命令，从redis里删除这个key。</p><p>然后呢，另外的客户端2就可以尝试完成加锁了。</p><p>这就是所谓的<strong>分布式锁的开源Redisson框架的实现机制。</strong></p><p>一般我们在生产系统中，可以用Redisson框架提供的这个类库来基于redis进行分布式锁的加锁与释放锁。</p><h2 id="上述Redis分布式锁的缺点"><a href="#上述Redis分布式锁的缺点" class="headerlink" title="上述Redis分布式锁的缺点"></a>上述Redis分布式锁的缺点</h2><p>其实上面那种方案最大的问题，就是如果你对某个redis master实例，写入了myLock这种锁key的value，此时会异步复制给对应的redis slave实例。</p><p>但是这个过程中一旦发生redis master宕机，主备切换，redis slave变为了redis master。(但是这个加锁的key还没有来得及同步到slave节点)。</p><p>接着就会导致，客户端2来尝试加锁的时候，在新的redis master上完成了加锁，而客户端1也以为自己成功加了锁。</p><p>此时就会导致多个客户端对一个分布式锁完成了加锁。</p><p>这时系统在业务语义上一定会出现问题，<strong>导致各种脏数据的产生</strong>。</p><p>所以这个就是redis cluster，或者是redis master-slave架构的<strong>主从异步复制</strong>导致的redis分布式锁的最大缺陷：<strong>在redis master实例宕机的时候，可能导致多个客户端同时完成加锁。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU0OTk3ODQ3Ng==&amp;mid=2247483893&amp;idx=1&amp;sn=32e7051116ab60e41f72e6c6e29876d9&amp;chksm=fba6e9f6ccd160e0c9fa2ce4ea1051891482a95b1483a63d89d71b15b33afcdc1f2bec17c03c&amp;mpshare=1&amp;scene=1&amp;srcid=0416Kx8ryElbpy4xfrPkSSdB&amp;key=1eff032c36dd9b3716bab5844171cca99a4ea696da85eed0e4b2b7ea5c39a665110b82b4c975d2fd65c396e91f4c7b3e8590c2573c6b8925de0df7daa886be53d793e7f06b2c146270f7c0a5963dd26a&amp;ascene=1&amp;uin=MTg2ODMyMTYxNQ%3D%3D&amp;devicetype=Windows+10&amp;version=62060739&amp;lang=zh_CN&amp;pass_ticket=y1D2AijXbuJ8HCPhyIi0qPdkT0TXqKFYo%2FmW07fgvW%2FXxWFJiJjhjTsnInShv0ap&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;拜托，面试请不要再问我Redis分布式锁的实现原理【石杉的架构笔记】&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;现在面试，一般都会聊聊&lt;strong&gt;分布式系统&lt;/strong&gt;这块的东西。通常面试官都会从服务框架（Spring Cloud、Dubbo）聊起，一路聊到分布式事务、分布式锁、ZooKeeper等知识。&lt;/p&gt;
&lt;p&gt;所以咱们这篇文章就来聊聊分布式锁这块知识，具体的来看看&lt;strong&gt;Redis分布式锁的实现原理。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://changsk.top/categories/Redis/"/>
    
    
      <category term="Redisson" scheme="http://changsk.top/tags/Redisson/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-用两个栈实现队列</title>
    <link href="http://changsk.top/2019/07/10/jianzhioffer-two-stack-queue/"/>
    <id>http://changsk.top/2019/07/10/jianzhioffer-two-stack-queue/</id>
    <published>2019-07-10T01:41:20.000Z</published>
    <updated>2019-07-10T01:46:49.627Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><a id="more"></a><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="http://changsk.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="http://changsk.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Spring中Bean的生命周期</title>
    <link href="http://changsk.top/2019/07/09/spring-bean-life-cycle/"/>
    <id>http://changsk.top/2019/07/09/spring-bean-life-cycle/</id>
    <published>2019-07-09T13:27:30.000Z</published>
    <updated>2019-07-10T01:35:22.736Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://segmentfault.com/a/1190000016065534" target="_blank" rel="noopener">Bean的生命周期</a></p></blockquote><p>正确理解spring容器中bean的生命周期很重要，有利于对bean的装配过程中进行一些自定义内容。如下图所示的生命周期：</p><a id="more"></a><p><img src="1.jpg" alt></p><p>如上图所见，在bean准备就绪之前，bean工厂执行了若干启动步骤，详细描述如下：</p><ul><li>spring对bean实例化；</li><li>spring将值和bean的引用注入到bean对应的属性中；</li><li>如果bean实现了BeanNameAware接口，spring将bean的id传递给setBeanName()方法，该方法的作用就是<strong>设置bean的id到BeanFactory中方便创建该bean，同时让bean知道自己在BeanFactory配置中的名字</strong>；</li><li>如果bean实现了BeanFactoryAware接口，spring将调用setBeanFactroy()方法，将BeanFactory容器实例传入，<strong>便于bean够获取配置他们的BeanFactory的引用</strong>；</li><li>如果bean实现了ApplicationContextAware接口，spring将调用setApplicationContext()方法，将bean所在应用上下文的引用传进来，<strong>便于bean获取它所在的Spring容器</strong>(ApplicationContext是BeanFactory的子接口，有更多的实现方法)；</li><li>如果bean实现了BeanPostProcessor接口，spring将调用它的postProcessBeforeInitialization()方法，该方法在bean初始化之前调用。BeanPostProcessor经常被用作对Bean内容的更改，并且由于这个是在Bean初始化结束时调用那个的方法，也可以被用于内存或者缓存技术；</li><li>如果bean实现了InitializingBean接口，spring将调用它的afterPropertiesSet()方法，当bean的所用属性被设置完成之后调用该方法；</li><li>如果bean实现了BeanPostProcessor接口，spring将调用它的postProcessAfterInitialization()方法，在bean初始化完成之后调用；完成以上工作之后就可以应用这个Bean了，默认的Bean是SingleTon。</li><li>如果bean实现了DisposableBean接口，spring将调用它的destory()方法；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://segmentfault.com/a/1190000016065534&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Bean的生命周期&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;正确理解spring容器中bean的生命周期很重要，有利于对bean的装配过程中进行一些自定义内容。如下图所示的生命周期：&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://changsk.top/categories/Java/"/>
    
    
      <category term="Spring" scheme="http://changsk.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC执行流程及源码解析</title>
    <link href="http://changsk.top/2019/07/09/spring-mvc/"/>
    <id>http://changsk.top/2019/07/09/spring-mvc/</id>
    <published>2019-07-09T13:02:51.000Z</published>
    <updated>2019-07-10T01:37:53.236Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="[http://cxis.me/2017/04/06/SpringMVC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/](http://cxis.me/2017/04/06/SpringMVC执行流程及源码解析/)">SpringMVC执行流程及源码解析</a></p></blockquote><p>在<code>SpringMVC</code>中主要是围绕着<code>DispatcherServlet</code>来设计，可以把它当做<strong>指挥中心</strong>。这里先说明一下SpringMVC文档给出的执行流程，然后是我们稍微具体的执行流程，最后是流程大致的源码跟踪。关于很很很详细的源码解析，这里暂先不做。</p><a id="more"></a><h2 id="官方文档中的流程"><a href="#官方文档中的流程" class="headerlink" title="官方文档中的流程"></a>官方文档中的流程</h2><p>首先看下<code>SpringMVC</code>文档上给的流程图：</p><p><img src="1.jpg" alt></p><p>这张图片给了我们大概的执行流程：</p><ol><li>用户请求首先发送到<strong>前端控制器DispatcherServlet</strong>，DispatcherServlet根据请求的信息来决定使用哪个页面控制器Controller（也就是我们通常编写的Controller）来处理该请求。找到控制器之后，DispatcherServlet将请求委托给控制器去处理。</li><li>接下来页面控制器开始处理用户请求，页面控制器会根据请求信息进行处理，<strong>调用业务层</strong>等等，处理完成之后，会把结果封装成一个<strong>ModelAndView</strong>返回给DispatcherServlet。</li><li>前端控制器DispatcherServlet接到页面控制器的返回结果后，根据返回的视图名选择相应的试图模板，并根据返回的数据进行渲染。</li><li>最后前端控制器DispatcherServlet将结果返回给用户。</li></ol><h2 id="更具体的流程"><a href="#更具体的流程" class="headerlink" title="更具体的流程"></a>更具体的流程</h2><p>上面只是总体流程，接下来我们稍微深入一点，看下更具体的流程，这里没有图，只有步骤解析：</p><ol><li>用户请求发送到前端控制器DispatcherServlet。</li><li>前端控制器DispatcherServlet接收到请求后，DispatcherServlet会使用<code>HandlerMapping</code>来处理，<strong>HandlerMapping会查找到具体进行处理请求的Handler对象。</strong></li><li>HandlerMapping找到对应的Handler之后，并不是返回一个Handler原始对象，而是一个<strong>Handler执行链</strong>，在这个执行链中包括了<strong>拦截器和处理请求的Handler</strong>。HandlerMapping返回一个执行链给DispatcherServlet。</li><li>DispatcherServlet接收到执行链之后，<strong>会调用Handler适配器去执行Handler。</strong></li><li>Handler适配器执行完成Handler（也就是我们写的Controller）之后会得到一个ModelAndView，并返回给DispatcherServlet。</li><li>DispatcherServlet接收到<strong>Handler适配器</strong>返回的ModelAndView之后，<strong>会根据其中的视图名调用视图解析器。</strong></li><li>视图解析器根据逻辑视图名解析成一个真正的<strong>View视图</strong>，并返回给DispatcherServlet。</li><li>DispatcherServlet接收到视图之后，会根据上面的ModelAndView中的model来进行视图中数据的填充，也就是所谓的视图渲染。</li><li>渲染完成之后，DispatcherServlet就可以将结果返回给用户了。</li></ol><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>DispatcherServlet是一个Servlet，我们知道在Servlet在处理一个请求的时候会交给<strong>service</strong>方法进行处理，这里也不例外，DispatcherServlet继承了FrameworkServlet，首先进入FrameworkServlet的service方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="comment">//请求方法</span></span><br><span class="line">    String method = request.getMethod();</span><br><span class="line">    <span class="comment">//PATCH方法单独处理</span></span><br><span class="line">    <span class="keyword">if</span> (method.equalsIgnoreCase(RequestMethod.PATCH.name())) &#123;</span><br><span class="line">        processRequest(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//其他的请求类型的方法经由父类，也就是HttpServlet处理</span></span><br><span class="line">        <span class="keyword">super</span>.service(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HttpServlet中会根据请求类型的不同分别调用<strong>doGet</strong>或者<strong>doPost</strong>等方法，FrameworkServlet中已经重写了这些方法，在这些方法中会调用processRequest进行处理，在processRequest中会调用doService方法，这个doService方法就是在DispatcherServlet中实现的。下面就看下DispatcherServlet中的doService方法的实现。</p><h3 id="请求到达DispatcherServlet"><a href="#请求到达DispatcherServlet" class="headerlink" title="请求到达DispatcherServlet"></a>请求到达DispatcherServlet</h3><p>doService方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给request中的属性做一份快照</span></span><br><span class="line">    Map&lt;String, Object&gt; attributesSnapshot = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Taking snapshot of request attributes before include"</span>);</span><br><span class="line">        attributesSnapshot = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</span><br><span class="line">        <span class="keyword">while</span> (attrNames.hasMoreElements()) &#123;</span><br><span class="line">            String attrName = (String) attrNames.nextElement();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.cleanupAfterInclude || attrName.startsWith(<span class="string">"org.springframework.web.servlet"</span>)) &#123;</span><br><span class="line">                attributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果我们没有配置类似本地化或者主题的处理器之类的</span></span><br><span class="line">    <span class="comment">//SpringMVC会使用默认的值</span></span><br><span class="line">    <span class="comment">//默认配置文件是DispatcherServlet.properties</span></span><br><span class="line">    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class="line">    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.localeResolver);</span><br><span class="line">    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.themeResolver);</span><br><span class="line">    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span><br><span class="line"></span><br><span class="line">    FlashMap inputFlashMap = <span class="keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line">    <span class="keyword">if</span> (inputFlashMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">        request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">    &#125;</span><br><span class="line">    request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> FlashMap());</span><br><span class="line">    request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="keyword">this</span>.flashMapManager);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//开始处理</span></span><br><span class="line">        doDispatch(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Restore the original attribute snapshot, in case of an include.</span></span><br><span class="line">        <span class="keyword">if</span> (attributesSnapshot != <span class="keyword">null</span>) &#123;</span><br><span class="line">            restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DispatcherServlet开始真正的处理，doDispatch方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HttpServletRequest processedRequest = request;</span><br><span class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//SpringMVC中异步请求的相关知识，暂先不解释</span></span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">        Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//先检查是不是Multipart类型的，比如上传等</span></span><br><span class="line">            <span class="comment">//如果是Multipart类型的，则转换为MultipartHttpServletRequest类型</span></span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = processedRequest != request;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取当前请求的Handler</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span> || mappedHandler.getHandler() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取当前请求的Handler适配器</span></span><br><span class="line">            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对于header中last-modified的处理</span></span><br><span class="line">            String method = request.getMethod();</span><br><span class="line">            <span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line">            <span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line">                <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//拦截器的preHandle方法进行处理</span></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//真正调用Handler的地方</span></span><br><span class="line">                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//处理成默认视图名，就是添加前缀和后缀等</span></span><br><span class="line">            applyDefaultViewName(request, mv);</span><br><span class="line">            <span class="comment">//拦截器postHandle方法进行处理</span></span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            dispatchException = ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理最后的结果，渲染之类的都在这里</span></span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line">        triggerAfterCompletionWithError(processedRequest, response, mappedHandler, err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">            mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">        <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">            cleanupMultipart(processedRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到大概的步骤还是按照我们上面分析的走的。</p><h3 id="查找请求对应的Handler对象"><a href="#查找请求对应的Handler对象" class="headerlink" title="查找请求对应的Handler对象"></a>查找请求对应的Handler对象</h3><p>对应着这句代码<code>mappedHandler = getHandler(processedRequest, false);</code>，看下具体的getHandler方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request, <span class="keyword">boolean</span> cache)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getHandler(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往下看getHandler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//遍历所有的handlerMappings进行处理</span></span><br><span class="line">    <span class="comment">//handlerMappings是在启动的时候预先注册好的</span></span><br><span class="line">    <span class="keyword">for</span> (HandlerMapping hm : <span class="keyword">this</span>.handlerMappings) &#123;</span><br><span class="line">        HandlerExecutionChain handler = hm.getHandler(request);</span><br><span class="line">        <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> handler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往下看getHandler，在AbstractHandlerMapping类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//根据request获取handler</span></span><br><span class="line">    Object handler = getHandlerInternal(request);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//如果没有找到就使用默认的handler</span></span><br><span class="line">        handler = getDefaultHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果Handler是String，表明是一个bean名称</span></span><br><span class="line">    <span class="comment">//需要超照对应bean</span></span><br><span class="line">    <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String handlerName = (String) handler;</span><br><span class="line">        handler = getApplicationContext().getBean(handlerName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//封装Handler执行链</span></span><br><span class="line">    <span class="keyword">return</span> getHandlerExecutionChain(handler, request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="根据requrst获取handler"><a href="#根据requrst获取handler" class="headerlink" title="根据requrst获取handler"></a>根据requrst获取handler</h4><p>首先看下根据requrst获取handler步骤getHandlerInternal方法，在AbstractHandlerMethodMapping中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//获取request中的url，用来匹配handler</span></span><br><span class="line">    String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);</span><br><span class="line">    <span class="comment">//根据路径寻找Handler</span></span><br><span class="line">    HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);</span><br><span class="line">    <span class="comment">//根据handlerMethod中的bean来实例化Handler并添加进HandlerMethod</span></span><br><span class="line">    <span class="keyword">return</span> (handlerMethod != <span class="keyword">null</span>) ? handlerMethod.createWithResolvedBean() : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下根据路径寻找handler的方法lookupHandlerMethod：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">lookupHandlerMethod</span><span class="params">(String lookupPath, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    List&lt;Match&gt; matches = <span class="keyword">new</span> ArrayList&lt;Match&gt;();</span><br><span class="line"><span class="comment">//直接匹配</span></span><br><span class="line">    List&lt;T&gt; directPathMatches = <span class="keyword">this</span>.urlMap.get(lookupPath);</span><br><span class="line">    <span class="comment">//如果有匹配的，就添加进匹配列表中</span></span><br><span class="line">    <span class="keyword">if</span> (directPathMatches != <span class="keyword">null</span>) &#123;</span><br><span class="line">        addMatchingMappings(directPathMatches, matches, request);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//还没有匹配的，就遍历所有的处理方法查找</span></span><br><span class="line">    <span class="keyword">if</span> (matches.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// No choice but to go through all mappings</span></span><br><span class="line">        addMatchingMappings(<span class="keyword">this</span>.handlerMethods.keySet(), matches, request);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//找到了匹配的</span></span><br><span class="line">    <span class="keyword">if</span> (!matches.isEmpty()) &#123;</span><br><span class="line">        Comparator&lt;Match&gt; comparator = <span class="keyword">new</span> MatchComparator(getMappingComparator(request));</span><br><span class="line">        Collections.sort(matches, comparator);</span><br><span class="line"><span class="comment">//排序之后，获取第一个</span></span><br><span class="line">        Match bestMatch = matches.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//如果有多个匹配的，会找到第二个最合适的进行比较一下</span></span><br><span class="line">        <span class="keyword">if</span> (matches.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            Match secondBestMatch = matches.get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (comparator.compare(bestMatch, secondBestMatch) == <span class="number">0</span>) &#123;</span><br><span class="line">                Method m1 = bestMatch.handlerMethod.getMethod();</span><br><span class="line">                Method m2 = secondBestMatch.handlerMethod.getMethod();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                        <span class="string">"Ambiguous handler methods mapped for HTTP path '"</span> + request.getRequestURL() + <span class="string">"': &#123;"</span> +</span><br><span class="line">                        m1 + <span class="string">", "</span> + m2 + <span class="string">"&#125;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//设置request参数</span></span><br><span class="line">        handleMatch(bestMatch.mapping, lookupPath, request);</span><br><span class="line">        <span class="comment">//返回匹配的url的处理的方法</span></span><br><span class="line">        <span class="keyword">return</span> bestMatch.handlerMethod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//最后还没有找到，返回null</span></span><br><span class="line">        <span class="keyword">return</span> handleNoMatch(handlerMethods.keySet(), lookupPath, request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取默认Handler"><a href="#获取默认Handler" class="headerlink" title="获取默认Handler"></a>获取默认Handler</h4><p>如果上面没有获取到Handler，就会获取默认的Handler。如果还获取不到就返回null。</p><h4 id="处理String类型的Handler"><a href="#处理String类型的Handler" class="headerlink" title="处理String类型的Handler"></a>处理String类型的Handler</h4><p>如果上面处理完的Handler是String类型的，就会根据这个handlerName获取bean。</p><h4 id="封装Handler执行链"><a href="#封装Handler执行链" class="headerlink" title="封装Handler执行链"></a>封装Handler执行链</h4><p>上面获取完Handler，就开始封装执行链了，就是将我们配置的拦截器加入到执行链中去，getHandlerExecutionChain：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandlerExecutionChain</span><span class="params">(Object handler, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果当前Handler不是执行链类型，就使用一个新的执行链实例封装起来</span></span><br><span class="line">    HandlerExecutionChain chain =</span><br><span class="line">        (handler <span class="keyword">instanceof</span> HandlerExecutionChain) ?</span><br><span class="line">            (HandlerExecutionChain) handler : <span class="keyword">new</span> HandlerExecutionChain(handler);</span><br><span class="line"><span class="comment">//先获取适配类型的拦截器添加进去拦截器链</span></span><br><span class="line">    chain.addInterceptors(getAdaptedInterceptors());</span><br><span class="line"><span class="comment">//当前的url</span></span><br><span class="line">    String lookupPath = urlPathHelper.getLookupPathForRequest(request);</span><br><span class="line">    <span class="comment">//遍历拦截器，找到跟当前url对应的，添加进执行链中去</span></span><br><span class="line">    <span class="keyword">for</span> (MappedInterceptor mappedInterceptor : mappedInterceptors) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mappedInterceptor.matches(lookupPath, pathMatcher)) &#123;</span><br><span class="line">            chain.addInterceptor(mappedInterceptor.getInterceptor());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取对应请求的Handler适配器"><a href="#获取对应请求的Handler适配器" class="headerlink" title="获取对应请求的Handler适配器"></a>获取对应请求的Handler适配器</h3><p>getHandlerAdapter：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerAdapter <span class="title">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="comment">//遍历所有的HandlerAdapter，找到和当前Handler匹配的就返回</span></span><br><span class="line">    <span class="comment">//我们这里会匹配到RequestMappingHandlerAdapter</span></span><br><span class="line">    <span class="keyword">for</span> (HandlerAdapter ha : <span class="keyword">this</span>.handlerAdapters) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ha.supports(handler)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ha;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓存的处理"><a href="#缓存的处理" class="headerlink" title="缓存的处理"></a>缓存的处理</h3><p>也就是对last-modified的处理</p><h3 id="执行拦截器的preHandle方法"><a href="#执行拦截器的preHandle方法" class="headerlink" title="执行拦截器的preHandle方法"></a>执行拦截器的preHandle方法</h3><p>就是遍历所有的我们定义的interceptor，执行preHandle方法</p><h3 id="使用Handler适配器执行当前的Handler"><a href="#使用Handler适配器执行当前的Handler" class="headerlink" title="使用Handler适配器执行当前的Handler"></a>使用Handler适配器执行当前的Handler</h3><p>ha.handle执行当前Handler，我们这里使用的是RequestMappingHandlerAdapter，首先会进入AbstractHandlerMethodAdapter的handle方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> handleInternal(request, response, (HandlerMethod) handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>handleInternal方法，在RequestMappingHandlerAdapter中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> ModelAndView <span class="title">handleInternal</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">        HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123;</span><br><span class="line">        <span class="comment">// Always prevent caching in case of session attribute management.</span></span><br><span class="line">        checkAndPrepare(request, response, <span class="keyword">this</span>.cacheSecondsForSessionAttributeHandlers, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Uses configured default cacheSeconds setting.</span></span><br><span class="line">        checkAndPrepare(request, response, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute invokeHandlerMethod in synchronized block if required.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.synchronizeOnSession) &#123;</span><br><span class="line">        HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object mutex = WebUtils.getSessionMutex(session);</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">                <span class="keyword">return</span> invokeHandleMethod(request, response, handlerMethod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//执行方法，封装ModelAndView</span></span><br><span class="line">    <span class="keyword">return</span> invokeHandleMethod(request, response, handlerMethod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组装默认视图名称"><a href="#组装默认视图名称" class="headerlink" title="组装默认视图名称"></a>组装默认视图名称</h3><p>前缀和后缀名都加上</p><h3 id="执行拦截器的postHandle方法"><a href="#执行拦截器的postHandle方法" class="headerlink" title="执行拦截器的postHandle方法"></a>执行拦截器的postHandle方法</h3><p>遍历intercepter的postHandle方法。</p><h3 id="处理最后的结果，渲染之类的"><a href="#处理最后的结果，渲染之类的" class="headerlink" title="处理最后的结果，渲染之类的"></a>处理最后的结果，渲染之类的</h3><p>processDispatchResult方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">        HandlerExecutionChain mappedHandler, ModelAndView mv, Exception exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> errorView = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ModelAndViewDefiningException) &#123;</span><br><span class="line">            mv = ((ModelAndViewDefiningException) exception).getModelAndView();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object handler = (mappedHandler != <span class="keyword">null</span> ? mappedHandler.getHandler() : <span class="keyword">null</span>);</span><br><span class="line">            mv = processHandlerException(request, response, handler, exception);</span><br><span class="line">            errorView = (mv != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Did the handler return a view to render?</span></span><br><span class="line">    <span class="keyword">if</span> (mv != <span class="keyword">null</span> &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">    <span class="comment">//渲染</span></span><br><span class="line">        render(mv, request, response);</span><br><span class="line">        <span class="keyword">if</span> (errorView) &#123;</span><br><span class="line">            WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">        <span class="comment">// Concurrent handling started during a forward</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mappedHandler.triggerAfterCompletion(request, response, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点看下render方法，进行渲染：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//设置本地化</span></span><br><span class="line">    Locale locale = <span class="keyword">this</span>.localeResolver.resolveLocale(request);</span><br><span class="line">    response.setLocale(locale);</span><br><span class="line"></span><br><span class="line">    View view;</span><br><span class="line">    <span class="keyword">if</span> (mv.isReference()) &#123;</span><br><span class="line">        <span class="comment">//解析视图名，得到视图</span></span><br><span class="line">        view = resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No need to lookup: the ModelAndView object contains the actual View object.</span></span><br><span class="line">        view = mv.getView();</span><br><span class="line">        <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"ModelAndView ["</span> + mv + <span class="string">"] neither contains a view name nor a "</span> +</span><br><span class="line">                    <span class="string">"View object in servlet with name '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//委托给视图进行渲染</span></span><br><span class="line">    view.render(mv.getModelInternal(), request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>view.render就是进行视图的渲染，然后跳转页面等处理。</p><p>到这里大概的流程就走完了。其中涉及到的东西还有很多，暂先不做详细处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;[http://cxis.me/2017/04/06/SpringMVC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/](http://cxis.me/2017/04/06/SpringMVC执行流程及源码解析/)&quot;&gt;SpringMVC执行流程及源码解析&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;code&gt;SpringMVC&lt;/code&gt;中主要是围绕着&lt;code&gt;DispatcherServlet&lt;/code&gt;来设计，可以把它当做&lt;strong&gt;指挥中心&lt;/strong&gt;。这里先说明一下SpringMVC文档给出的执行流程，然后是我们稍微具体的执行流程，最后是流程大致的源码跟踪。关于很很很详细的源码解析，这里暂先不做。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://changsk.top/categories/Java/"/>
    
    
      <category term="Spring" scheme="http://changsk.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>常见加密算法原理及概念</title>
    <link href="http://changsk.top/2019/07/09/common-encryption-algorithm/"/>
    <id>http://changsk.top/2019/07/09/common-encryption-algorithm/</id>
    <published>2019-07-09T12:30:42.000Z</published>
    <updated>2019-07-09T12:53:48.498Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://www.jianshu.com/p/ce3893a7be09" target="_blank" rel="noopener">常见加密算法原理及概念</a></p></blockquote><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>在安全领域，利用<strong>密钥加密算法</strong>来对通信的过程进行加密是一种常见的安全手段。利用该手段能够保障数据安全通信的三个目标：</p><blockquote><p>1、数据的保密性，防止用户的数据被窃取或泄露；<br> 2、保证数据的完整性，防止用户传输的数据被篡改；<br> 3、通信双方的身份确认，确保数据来源与合法的用户；</p></blockquote><p>而常见的密钥加密算法类型大体可以分为三类：<strong>对称加密</strong>、<strong>非对称加密</strong>、<strong>单向加密</strong>。下面我们来了解下相关的算法原理及其常见的算法。</p><a id="more"></a><h4 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h4><p>对称加密算法采用<strong>单密钥加密</strong>，在通信过程中，数据发送方将原始数据分割成固定大小的块，经过密钥和加密算法逐个加密后，发送给接收方；接收方收到加密后的报文后，结合密钥和解密算法解密组合后得出原始数据。由于<strong>加解密算法是公开的</strong>，因此在这过程中，密钥的安全传递就成为了至关重要的事了。而密钥通常来说是通过双方协商，以物理的方式传递给对方，或者利用第三方平台传递给对方，一旦这过程出现了密钥泄露，不怀好意的人就能结合相应的算法拦截解密出其加密传输的内容。</p><p><img src="1.jpg" alt="img"></p><p>对称加密算法原理</p><p>对称加密算法拥有着<strong>算法公开</strong>、<strong>计算量小</strong>、<strong>加密速度和效率高</strong>的特点，但是也有着<strong>密钥单一</strong>、<strong>密钥管理困难</strong>等缺点。</p><p>常见的对称加密算法有：<br> <strong>DES</strong>：分组式加密算法，以64位为分组对数据加密，加解密使用同一个算法。<br> <strong>3DES</strong>：三重数据加密算法，<strong>对每个数据块应用三次DES加密算法。</strong><br> <strong>AES</strong>：高级加密标准算法，是美国联邦政府采用的一种区块加密标准，用于替代原先的DES，目前已被广泛应用。<br> <strong>Blowfish</strong>：Blowfish算法是一个64位分组及可变密钥长度的对称密钥分组密码算法，可用来加密64比特长度的字符串。</p><h4 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h4><p>非对称加密算法采用<strong>公钥</strong>和<strong>私钥</strong>两种不同的密码来进行加解密。<strong>公钥和私钥是成对存在</strong>，公钥是从私钥中提取产生公开给所有人的，如果使用公钥对数据进行加密，那么只有对应的私钥才能解密，反之亦然。<br> 下图为简单非对称加密算法的常见流程：</p><p><img src="2.jpg" alt="img"></p><p>非对称加密流程</p><p>发送方Bob从接收方Alice获取其对应的公钥，并结合相应的非对称算法将明文加密后发送给Alice；Alice接收到加密的密文后，结合自己的私钥和非对称算法解密得到明文。这种简单的非对称加密算法的应用其安全性比对称加密算法来说要高，但是其不足之处在于<strong>无法确认公钥的来源合法性</strong>以及<strong>数据的完整性</strong>。 非对称加密算法具有<strong>安全性高</strong>、<strong>算法强度负复杂</strong>的优点，其缺点为<strong>加解密耗时长</strong>、<strong>速度慢</strong>，<strong>只适合对少量数据进行加密</strong>，其常见算法包括：<br> <strong>RSA</strong>：RSA算法基于一个十分简单的数论事实：<strong>将两个大素数相乘十分容易，但那时想要对其乘积进行因式分解却极其困难</strong>，<strong>因此可以将乘积公开作为加密密钥，可用于加密，也能用于签名。</strong><br> <strong>DSA</strong>：数字签名算法，仅能用于签名，不能用于加解密。<br> <strong>DSS</strong>：数字签名标准，技能用于签名，也可以用于加解密。<br> <strong>ELGamal</strong>：利用离散对数的原理对数据进行加解密或数据签名，其速度是最慢的。</p><h4 id="单向加密"><a href="#单向加密" class="headerlink" title="单向加密"></a>单向加密</h4><p>单向加密算法常用于提取数据指纹，<strong>验证数据的完整性</strong>。发送者将明文通过单向加密算法加密生成<strong>定长的密文串</strong>，然后传递给接收方。接收方在收到加密的报文后进行解密，将解密获取到的明文使用相同的单向加密算法进行加密，得出加密后的密文串。随后将之与发送者发送过来的密文串进行对比，若发送前和发送后的密文串相一致，则说明传输过程中数据没有损坏；若不一致，说明传输过程中数据丢失了。单向加密算法只能用于对数据的加密，无法被解密，其特点为定长输出、雪崩效应。常见的算法包括：<strong>MD5</strong>、<strong>sha1</strong>、<strong>sha224</strong>等等，其常见用途包括：<strong>数字摘要</strong>、<strong>数字签名</strong>等等。</p><p><img src="3.jpg" alt="img"></p><p>单向加密校验过程</p><h4 id="密钥交换"><a href="#密钥交换" class="headerlink" title="密钥交换"></a>密钥交换</h4><p>密钥交换IKE（Internet Key Exchange）通常是指<strong>双方通过交换密钥来实现数据加密和解密</strong>，常见的密钥交换方式有下面两种：<br> 1、公钥加密，将公钥加密后通过网络传输到对方进行解密，这种方式缺点在于具有很大的可能性被拦截破解，因此不常用；<br> 2、Diffie-Hellman，<strong>DH算法是一种密钥交换算法</strong>，其既不用于加密，也不产生数字签名。DH算法的巧妙在于需要安全通信的双方可以用这个方法确定对称密钥。然后可以用这个密钥进行加密和解密。但是注意，<strong>这个密钥交换协议/算法只能用于密钥的交换，而不能进行消息的加密和解密</strong>。双方确定要用的密钥后，要使用其他对称密钥操作加密算法实际加密和解密消息。DH算法通过双方共有的参数、私有参数和算法信息来进行加密，然后双方将计算后的结果进行交换，交换完成后再和属于自己私有的参数进行特殊算法，经过双方计算后的结果是相同的，此结果即为密钥。<br> 如：</p><blockquote><p>A 有p和g两个参数，A还有一个属于自己的私有参数x；<br> B 有p和g两个参数，B还有一个属于自己的私有参数y；<br> A和B均使用相同的加密算法计算其对应的值：value_A=px%g，value_B=py%g<br> 随后双方交换计算后的值，然后再分别使用自己的私有参数对去求次方，如：<br> A拿到value_B值后，对其求x次方得(py%g)x=p^xy%g；<br> B拿到value_A值后，对其求y次方得(px%g)y=p^xy%g；<br> 最终得到的结果是一致的。</p></blockquote><p>在整个过程中，<strong>第三方人员只能获取p、g两个值</strong>，AB双方交换的是计算后的结果，因此这种方式是很安全的。</p><h4 id="公钥基础设施（PKI）"><a href="#公钥基础设施（PKI）" class="headerlink" title="公钥基础设施（PKI）"></a>公钥基础设施（PKI）</h4><p><strong>公钥基础设施</strong>是一个包括硬件、软件、人员、策略和规程的集合，用于实现基于公钥密码机制的密钥和证书的生成、管理、存储、分发和撤销的功能，其组成包括：<strong>签证机构CA</strong>、注册机构RA、证书吊销列表CRL和证书存取库CB。<br> PKI采用<strong>证书管理公钥</strong>，通过第三方可信任CA中心，<strong>把用户的公钥和其他用户信息组生成证书，用于验证用户的身份。</strong><br> 公钥证书是以数字签名的方式声明，它将公钥的值绑定到持有对应私钥的个人、设备或服务身份。公钥证书的生成遵循X.509协议的规定，其内容包括：<code>证书名称、证书版本、序列号、算法标识、颁发者、有效期、有效起始日期、有效终止日期、公钥 、证书签名等等的内容</code>。</p><p>CA证书认证的流程如下图，Bob为了向Alice证明<strong>自己是Bob和某个公钥是自己的</strong>，她便向一个Bob和Alice<strong>都信任的CA机构申请证书</strong>，Bob先自己生成了一对密钥对（私钥和公钥），把自己的私钥保存在自己电脑上，然后把公钥给CA申请证书，<strong>CA接受申请于是给Bob颁发了一个数字证书，证书中包含了Bob的那个公钥以及其它身份信息</strong>，当然，<strong>CA会计算这些信息的消息摘要并用自己的私钥加密消息摘要（数字签名）一并附在Bob的证书上，以此来证明这个证书就是CA自己颁发的。</strong>Alice得到Bob的证书后用CA的证书（自签署的）中的公钥来解密消息摘要，随后将摘要和Bob的公钥发送到CA服务器上进行核对。CA在接收到Alice的核对请求后，会根据Alice提供的信息核对Bob的证书是否合法，如果确认合法则回复Alice证书合法。Alice收到CA的确认回复后，再去使用从证书中<strong>获取的Bob的公钥加密邮件然后发送给Bob，Bob接收后再以自己的私钥进行解密。</strong></p><p><img src="4.jpg" alt="img"></p><p>​                                                                          CA证书认证流程</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://www.jianshu.com/p/ce3893a7be09&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;常见加密算法原理及概念&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;p&gt;在安全领域，利用&lt;strong&gt;密钥加密算法&lt;/strong&gt;来对通信的过程进行加密是一种常见的安全手段。利用该手段能够保障数据安全通信的三个目标：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、数据的保密性，防止用户的数据被窃取或泄露；&lt;br&gt; 2、保证数据的完整性，防止用户传输的数据被篡改；&lt;br&gt; 3、通信双方的身份确认，确保数据来源与合法的用户；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而常见的密钥加密算法类型大体可以分为三类：&lt;strong&gt;对称加密&lt;/strong&gt;、&lt;strong&gt;非对称加密&lt;/strong&gt;、&lt;strong&gt;单向加密&lt;/strong&gt;。下面我们来了解下相关的算法原理及其常见的算法。&lt;/p&gt;
    
    </summary>
    
      <category term="密码学" scheme="http://changsk.top/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL存储引擎-InnoDB与MyISAM的区别</title>
    <link href="http://changsk.top/2019/07/09/mysql-innodb-myisam/"/>
    <id>http://changsk.top/2019/07/09/mysql-innodb-myisam/</id>
    <published>2019-07-09T11:46:02.000Z</published>
    <updated>2019-07-09T12:20:19.394Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://segmentfault.com/a/1190000008227211" target="_blank" rel="noopener">MySQL存储引擎－－MyISAM与InnoDB区别</a></p></blockquote><p>MyISAM是MySQL的默认数据库引擎（5.5版之前），由早期的ISAM（Indexed Sequential Access Method：有索引的顺序访问方法）所改良。虽然性能极佳，但却有一个缺点：<strong>不支持事务处理</strong>（transaction）。不过，在这几年的发展下，MySQL也导入了InnoDB（另一种数据库引擎），以强化参考完整性与并发违规处理机制，后来就逐渐取代MyISAM。</p><p>InnoDB，是MySQL的数据库引擎之一，为MySQL AB发布binary的标准之一。InnoDB由Innobase Oy公司所开发，2006年五月时由甲骨文公司并购。与传统的ISAM与MyISAM相比，<strong>InnoDB的最大特色就是支持了ACID兼容的事务（Transaction）功能</strong>，类似于PostgreSQL。目前InnoDB采用双轨制授权，一是GPL授权，另一是专有软件授权。</p><a id="more"></a><h2 id="MyISAM与InnoDB的区别是什么？"><a href="#MyISAM与InnoDB的区别是什么？" class="headerlink" title="MyISAM与InnoDB的区别是什么？"></a>MyISAM与InnoDB的区别是什么？</h2><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>MyISAM：每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。<strong>.frm文件存储表定义</strong>。<strong>数据文件</strong>的扩展名为.MYD (MYData)。<strong>索引文件</strong>的扩展名是.MYI (MYIndex)。<br>InnoDB：<strong>所有的表都保存在同一个数据文件中</strong>（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。</p><h3 id="存储空间"><a href="#存储空间" class="headerlink" title="存储空间"></a>存储空间</h3><p>MyISAM：<strong>可被压缩，存储空间较小</strong>。支持三种不同的存储格式：<strong>静态表</strong>(默认，但是注意数据末尾不能有空格，会被去掉)、<strong>动态表</strong>、<strong>压缩表</strong>。InnoDB：需要更多的内存和存储，<strong>它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。</strong></p><h3 id="可移植性、备份及恢复"><a href="#可移植性、备份及恢复" class="headerlink" title="可移植性、备份及恢复"></a>可移植性、备份及恢复</h3><p>MyISAM：数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。<br>InnoDB：免费的方案可以是拷贝数据文件、备份 binlog，或者用 <strong>mysqldump</strong>，在数据量达到几十G的时候就相对痛苦了。</p><h3 id="事务支持"><a href="#事务支持" class="headerlink" title="事务支持"></a>事务支持</h3><p>MyISAM：<strong>强调的是性能</strong>，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。<br>InnoDB：<strong>提供事务支持事务</strong>，<strong>外部键</strong>等高级数据库功能。 <strong>具有事务(commit)、回滚(rollback)和崩溃修复能力</strong>(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</p><h3 id="AUTO-INCREMENT"><a href="#AUTO-INCREMENT" class="headerlink" title="AUTO_INCREMENT"></a>AUTO_INCREMENT</h3><p>MyISAM：可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。<br>InnoDB：InnoDB中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。</p><h3 id="表锁差异"><a href="#表锁差异" class="headerlink" title="表锁差异"></a>表锁差异</h3><p>MyISAM：<strong>只支持表级锁</strong>，用户在操作myisam表时，<strong>select，update，delete，insert语句都会给表自动加锁</strong>，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。<br>InnoDB：<strong>支持事务和行级锁</strong>，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，<strong>只是在WHERE的主键是有效的</strong>，非主键的WHERE都会锁全表的。</p><h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>MyISAM：支持 FULLTEXT类型的全文索引<br>InnoDB：不支持FULLTEXT类型的全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好。</p><h3 id="表主键"><a href="#表主键" class="headerlink" title="表主键"></a>表主键</h3><p>MyISAM：<strong>允许没有任何索引和主键的表存在</strong>，索引都是保存行的地址。<br>InnoDB：如果没有设定<strong>主键</strong>或者<strong>非空唯一索引</strong>，<strong>就会自动生成一个6字节的主键(用户不可见)</strong>，<strong>数据是主索引的一部分，附加索引保存的是主索引的值。</strong></p><h3 id="表的具体行数"><a href="#表的具体行数" class="headerlink" title="表的具体行数"></a>表的具体行数</h3><p>MyISAM：保存有表的总行数，如果select count(<em>) from table;会直接取出出该值。<br>InnoDB：没有保存表的总行数，如果使用select count(</em>) from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。</p><h3 id="CURD操作"><a href="#CURD操作" class="headerlink" title="CURD操作"></a>CURD操作</h3><p>MyISAM：<strong>如果执行大量的SELECT</strong>，MyISAM是更好的选择。<br>InnoDB：如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE 从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，<strong>在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。</strong></p><h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><p>MyISAM：不支持<br>InnoDB：支持</p><p>通过上述的分析，基本上可以考虑使用InnoDB来替代MyISAM引擎了，原因是InnoDB自身很多良好的特点，比如<strong>事务支持</strong>、存储 过程、视图、<strong>行级锁定</strong>等等，在并发很多的情况下，相信InnoDB的表现肯定要比MyISAM强很多。另外，任何一种表都不是万能的，<strong>只用恰当的针对业务类型来选择合适的表类型</strong>，才能最大的发挥MySQL的性能优势。如果不是很复杂的Web应用，非关键应用，还是可以继续考虑MyISAM的，这个具体情况可以自己斟酌。</p><p>存储引擎选择的基本原则</p><p>采用MyISAM引擎</p><ul><li><strong>R/W &gt; 100:1 且update相对较少(读多写少)</strong></li><li><strong>并发不高</strong></li><li><strong>表数据量小</strong></li><li>硬件资源有限</li></ul><p>采用InnoDB引擎</p><ul><li>R/W比较小，频繁更新大字段</li><li>表数据量超过1000万，并发高</li><li>安全性和可用性要求高</li></ul><p>采用Memory引擎</p><ul><li><p>有足够的内存</p></li><li><p>对数据一致性要求不高，如在线人数和session等应用</p></li><li><p>需要定期归档数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">摘自：《PHP核心技术与最佳实践》</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://segmentfault.com/a/1190000008227211&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MySQL存储引擎－－MyISAM与InnoDB区别&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;MyISAM是MySQL的默认数据库引擎（5.5版之前），由早期的ISAM（Indexed Sequential Access Method：有索引的顺序访问方法）所改良。虽然性能极佳，但却有一个缺点：&lt;strong&gt;不支持事务处理&lt;/strong&gt;（transaction）。不过，在这几年的发展下，MySQL也导入了InnoDB（另一种数据库引擎），以强化参考完整性与并发违规处理机制，后来就逐渐取代MyISAM。&lt;/p&gt;
&lt;p&gt;InnoDB，是MySQL的数据库引擎之一，为MySQL AB发布binary的标准之一。InnoDB由Innobase Oy公司所开发，2006年五月时由甲骨文公司并购。与传统的ISAM与MyISAM相比，&lt;strong&gt;InnoDB的最大特色就是支持了ACID兼容的事务（Transaction）功能&lt;/strong&gt;，类似于PostgreSQL。目前InnoDB采用双轨制授权，一是GPL授权，另一是专有软件授权。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://changsk.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="InnoDB" scheme="http://changsk.top/tags/InnoDB/"/>
    
      <category term="MyISAM" scheme="http://changsk.top/tags/MyISAM/"/>
    
  </entry>
  
  <entry>
    <title>一条SQL语句执行得很慢的原因有哪些？</title>
    <link href="http://changsk.top/2019/07/09/mysql-sql-slow/"/>
    <id>http://changsk.top/2019/07/09/mysql-sql-slow/</id>
    <published>2019-07-09T08:34:18.000Z</published>
    <updated>2019-07-09T08:51:14.393Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自公众号:苦逼的码农 作者：帅地</p></blockquote><p>说实话，这个问题可以涉及到 <code>MySQL</code> 的很多核心知识，可以扯出一大堆，就像要考你计算机网络的知识时，问你“输入URL回车之后，究竟发生了什么”一样，看看你能说出多少了。</p><p>之前腾讯面试的实话，也问到这个问题了，不过答的很不好，之前没去想过相关原因，导致一时之间扯不出来。所以今天，我带大家来详细扯一下有哪些原因，相信你看完之后一定会有所收获，不然你打我。</p><a id="more"></a><h2 id="开始装逼：分类讨论"><a href="#开始装逼：分类讨论" class="headerlink" title="开始装逼：分类讨论"></a>开始装逼：分类讨论</h2><p>一条 SQL 语句执行的很慢，那是每次执行都很慢呢？还是大多数情况下是正常的，偶尔出现很慢呢？所以我觉得，我们还得分以下两种情况来讨论。</p><p><strong>1、大多数情况是正常的，只是偶尔会出现很慢的情况。</strong></p><p><strong>2、在数据量不变的情况下，这条SQL语句一直以来都执行的很慢。</strong></p><p>针对这两种情况，我们来分析下可能是哪些原因导致的。</p><h2 id="针对偶尔很慢的情况"><a href="#针对偶尔很慢的情况" class="headerlink" title="针对偶尔很慢的情况"></a>针对偶尔很慢的情况</h2><p>一条 SQL 大多数情况正常，偶尔才能出现很慢的情况，针对这种情况，我觉得<strong>这条SQL语句的书写本身是没什么问题的</strong>，而是其他原因导致的，那会是什么原因呢？</p><h3 id="数据库在刷新脏页（flush）我也无奈啊"><a href="#数据库在刷新脏页（flush）我也无奈啊" class="headerlink" title="数据库在刷新脏页（flush）我也无奈啊"></a>数据库在刷新脏页（flush）我也无奈啊</h3><p>当我们要往数据库插入一条数据、或者要更新一条数据的时候，我们知道数据库会在<strong>内存</strong>中把对应字段的数据更新了，但是更新之后，这些更新的字段并不会马上同步持久化到<strong>磁盘</strong>中去，而是把这些更新的记录写入到 <code>redo log</code>日记中去，等到空闲的时候，在通过 redo log 里的日记把最新的数据同步到<strong>磁盘</strong>中去。</p><blockquote><p>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。</p></blockquote><p><strong>刷脏页有下面4种场景（后两种不用太关注“性能”问题）：</strong></p><ul><li><strong>redolog写满了：</strong>redo log 里的容量是有限的，如果数据库一直很忙，更新又很频繁，这个时候 redo log 很快就会被写满了，这个时候就没办法等到空闲的时候再把数据同步到磁盘的，只能暂停其他操作，全身心来把数据同步到磁盘中去的，而这个时候，<strong>就会导致我们平时正常的SQL语句突然执行的很慢</strong>，所以说，数据库在在同步数据到磁盘的时候，就有可能导致我们的SQL语句执行的很慢了。</li><li><strong>内存不够用了：</strong>如果一次查询较多的数据，恰好碰到所查数据页不在内存中时，需要申请内存，而此时恰好内存不足的时候就需要淘汰一部分内存数据页，如果是干净页，就直接释放，如果恰好是脏页就需要刷脏页。</li><li><strong>MySQL 认为系统“空闲”的时候：</strong>这时系统没什么压力。</li><li><strong>MySQL 正常关闭的时候：</strong>这时候，MySQL 会把内存的脏页都 flush 到磁盘上，这样下次 MySQL 启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</li></ul><h3 id="拿不到锁我能怎么办"><a href="#拿不到锁我能怎么办" class="headerlink" title="拿不到锁我能怎么办"></a>拿不到锁我能怎么办</h3><p>这个就比较容易想到了，我们要执行的这条语句，刚好这条语句涉及到的<strong>表</strong>，别人在用，并且加锁了，我们拿不到锁，只能慢慢等待别人释放锁了。或者，表没有加锁，但要使用到的某个一行被加锁了，这个时候，我也没办法啊。</p><p>如果要判断是否真的在等待锁，我们可以用 <strong>show processlist</strong>这个命令来查看当前的状态哦，这里我要提醒一下，有些命令最好记录一下，反正，我被问了好几个命令，都不知道怎么写，呵呵。</p><p>下来我们来访分析下第二种情况，我觉得第二种情况的分析才是最重要的</p><h2 id="针对一直都这么慢的情况"><a href="#针对一直都这么慢的情况" class="headerlink" title="针对一直都这么慢的情况"></a>针对一直都这么慢的情况</h2><p>如果在数据量一样大的情况下，这条 SQL 语句每次都执行的这么慢，那就就要好好考虑下你的 <code>SQL</code> 书写了，下面我们来分析下哪些原因会导致我们的 SQL 语句执行的很不理想。</p><p>我们先来假设我们有一个表，表里有下面两个字段,分别是主键 id，和两个普通字段 c 和 d。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  `d` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure><h3 id="扎心了，没用到索引"><a href="#扎心了，没用到索引" class="headerlink" title="扎心了，没用到索引"></a>扎心了，没用到索引</h3><p>没有用上索引，我觉得这个原因是很多人都能想到的，例如你要查询这条语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="number">100</span> &lt;c <span class="keyword">and</span> c &lt; <span class="number">100000</span>;</span><br></pre></td></tr></table></figure><p><strong>（1）、字段没有索引</strong></p><p>刚好你的 c 字段上没有索引，那么抱歉，只能走<strong>全表扫描</strong>了，你就体验不会索引带来的乐趣了，所以，这回导致这条查询语句很慢。</p><p><strong>（2）、字段有索引，但却没有用索引</strong></p><p>好吧，这个时候你给 c 这个字段加上了索引，然后又查询了一条语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> c - <span class="number">1</span> = <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><p>我想问大家一个问题，这样子在查询的时候会用索引查询吗？</p><p>答是不会，如果我们在字段的左边做了运算，那么很抱歉，在查询的时候，就不会用上索引了，所以呢，大家要注意这种<strong>字段上有索引，但由于自己的疏忽，导致系统没有使用索引</strong>的情况了。</p><p>正确的查询应该如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> c = <span class="number">1000</span> + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>有人可能会说，右边有运算就能用上索引？难道数据库就不会自动帮我们优化一下，自动把 c - 1=1000 自动转换为 c = 1000+1。</p><p>不好意思，确实不会帮你，所以，你要注意了。</p><p><strong>（3）、函数操作导致没有用上索引</strong></p><p>如果我们在查询的时候，对字段进行了函数操作，也是会导致没有用上索引的，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where pow(c,2) = 1000;</span><br></pre></td></tr></table></figure><p>这里我只是做一个例子，假设函数 pow 是求 c 的 n 次方，实际上可能并没有 pow(c,2)这个函数。其实这个和上面在左边做运算也是很类似的。</p><p>所以呢，一条语句执行都很慢的时候，可能是该语句没有用上索引了，不过具体是啥原因导致没有用上索引的呢，你就要会分析了，我上面列举的三个原因，应该是出现的比较多的吧。</p><h3 id="呵呵，数据库自己选错索引了"><a href="#呵呵，数据库自己选错索引了" class="headerlink" title="呵呵，数据库自己选错索引了"></a>呵呵，数据库自己选错索引了</h3><p>我们在进行查询操作的时候，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where 100 &lt; c and c &lt; 100000;</span><br></pre></td></tr></table></figure><p>我们知道，主键索引和非主键索引是有区别的，主键索引存放的值是<strong>整行字段的数据</strong>，而非主键索引上存放的值不是整行字段的数据，而且存放<strong>主键字段的值</strong>。不大懂的可以看这篇文章：  <a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484848&idx=1&sn=77a0e6e82944ec385f5df17e91ce3bf2&chksm=cea24a7bf9d5c36d4b289cccb017292f9f36da9f3c887fd2b93ecd6af021fcf30121ba09799f&token=1082669959&lang=zh_CN&scene=21#wechat_redirect" target="_blank" rel="noopener">【思维导图-索引篇】搞定数据库索引就是这么简单</a>  里面有说到主键索引和非主键索引的区别</p><p>也就是说，我们如果走 c 这个字段的索引的话，最后会查询到对应主键的值，然后，再根据主键的值走主键索引，查询到整行数据返回。</p><p>好吧扯了这么多，其实我就是想告诉你，就算你在 c 字段上有索引，系统也并不一定会走 c 这个字段上的索引，而是有可能会直接扫描扫描全表，找出所有符合 100 &lt; c and c &lt; 100000 的数据。</p><p><strong>为什么会这样呢？</strong></p><p>其实是这样的，系统在执行这条语句的时候，会进行预测：<strong>究竟是走 c 索引扫描的行数少，还是直接扫描全表扫描的行数少呢？</strong>显然，扫描行数越少当然越好了，因为扫描行数越少，意味着<strong>I/O操作的次数越少。</strong></p><p>如果是扫描全表的话，那么扫描的次数就是这个表的总行数了，假设为 n；而如果走索引 c 的话，我们通过索引 c 找到主键之后，还得再通过主键索引来找我们整行的数据，也就是说，需要走两次索引。而且，我们也不知道符合 100 c &lt; and c &lt; 10000 这个条件的数据有多少行，万一这个表是全部数据都符合呢？这个时候意味着，走 c 索引不仅扫描的行数是 n，同时还得每行数据走两次索引。</p><p><strong>所以呢，系统是有可能走全表扫描而不走索引的。那系统是怎么判断呢？</strong></p><p>判断来源于系统的预测，也就是说，如果要走 c 字段索引的话，系统会预测走 c 字段索引大概需要扫描多少行。如果预测到要扫描的行数很多，它可能就不走索引而直接扫描全表了。</p><p>那么问题来了，<strong>系统是怎么预测判断的呢？</strong>这里我给你讲下系统是怎么判断的吧，虽然这个时候我已经写到脖子有点酸了。</p><p>系统是通过<strong>索引的区分度</strong>来判断的，一个索引上不同的值越多，意味着出现相同数值的索引越少，意味着索引的区分度越高。我们也把区分度称之为<strong>基数</strong>，即区分度越高，基数越大。所以呢，基数越大，意味着符合 100 &lt; c and c &lt; 10000 这个条件的行数越少。</p><p>所以呢，<strong>一个索引的基数越大，意味着走索引查询越有优势。</strong></p><p><strong>那么问题来了，怎么知道这个索引的基数呢？</strong></p><p>系统当然是不会遍历全部来获得一个索引的基数的，代价太大了，索引系统是通过遍历部分数据，也就是通过<strong>采样</strong>的方式，来预测索引的基数的。</p><p><strong>扯了这么多，重点的来了</strong>，居然是采样，那就有可能出现<strong>失误</strong>的情况，也就是说，c 这个索引的基数实际上是很大的，但是采样的时候，却很不幸，把这个索引的基数预测成很小。例如你采样的那一部分数据刚好基数很小，然后就误以为索引的基数很小。<strong>然后就呵呵，系统就不走 c 索引了，直接走全部扫描了</strong>。</p><p>所以呢，说了这么多，得出结论：<strong>由于统计的失误，导致系统没有走索引，而是走了全表扫描</strong>，而这，也是导致我们 SQL 语句执行的很慢的原因。</p><blockquote><p>这里我声明一下，系统判断是否走索引，扫描行数的预测其实只是原因之一，这条查询语句是否需要使用使用<strong>临时表</strong>、是否需要<strong>排序</strong>等也是会影响系统的选择的。</p></blockquote><p>不过呢，我们有时候也可以通过强制走索引的方式来查询，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t force index(a) where c &lt; 100 and c &lt; 100000;</span><br></pre></td></tr></table></figure><p>我们也可以通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show index from t;</span><br></pre></td></tr></table></figure><p>来查询索引的基数和实际是否符合，如果和实际很不符合的话，我们可以重新来统计索引的基数，可以用这条命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">analyze table t;</span><br></pre></td></tr></table></figure><p>来重新统计分析。</p><p><strong>既然会预测错索引的基数，这也意味着，当我们的查询语句有多个索引的时候，系统有可能也会选错索引哦</strong>，这也可能是 SQL 执行的很慢的一个原因。</p><p>好吧，就先扯这么多了，你到时候能扯出这么多，我觉得已经很棒了，下面做一个总结。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上是我的总结与理解，最后一个部分，我怕很多人不大懂<strong>数据库居然会选错索引</strong>，所以我详细解释了一下，下面我对以上做一个总结。</p><p>一个 SQL 执行的很慢，我们要分两种情况讨论：</p><p>1、大多数情况下很正常，偶尔很慢，则有如下原因</p><p>(1)、数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘。</p><p>(2)、执行的时候，遇到锁，如表锁、行锁。</p><p>2、这条 SQL 语句一直执行的很慢，则有如下原因。</p><p>(1)、没有用上索引：例如该字段没有索引；该字段有索引，但是索引失效，由于对字段进行运算、函数操作导致无法用索引。</p><p>(2)、数据库选错了索引。</p><p>大家如果有补充的，也是可以留言区补充一波哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自公众号:苦逼的码农 作者：帅地&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说实话，这个问题可以涉及到 &lt;code&gt;MySQL&lt;/code&gt; 的很多核心知识，可以扯出一大堆，就像要考你计算机网络的知识时，问你“输入URL回车之后，究竟发生了什么”一样，看看你能说出多少了。&lt;/p&gt;
&lt;p&gt;之前腾讯面试的实话，也问到这个问题了，不过答的很不好，之前没去想过相关原因，导致一时之间扯不出来。所以今天，我带大家来详细扯一下有哪些原因，相信你看完之后一定会有所收获，不然你打我。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://changsk.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>java8之LinkedHashMap</title>
    <link href="http://changsk.top/2019/07/09/java8-LinkedHashMap/"/>
    <id>http://changsk.top/2019/07/09/java8-LinkedHashMap/</id>
    <published>2019-07-09T02:00:02.000Z</published>
    <updated>2019-07-09T07:22:45.371Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://segmentfault.com/a/1190000012964859" target="_blank" rel="noopener">LinkedHashMap 源码详细分析（JDK1.8）</a></p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>LinkedHashMap</code> <strong>继承自 HashMap</strong>，在 HashMap 基础上，通过<strong>维护一条双向链表</strong>，<strong>解决了 HashMap 不能随时保持遍历顺序和插入顺序一致的问题</strong>。除此之外，LinkedHashMap 对<strong>访问顺序</strong>也提供了相关支持。在一些场景下，该特性很有用，比如<strong>缓存</strong>。在实现上，<code>LinkedHashMap</code> 很多方法直接继承自 HashMap，<strong>仅为维护双向链表覆写了部分方法</strong>。所以，要看懂 LinkedHashMap 的源码，需要先看懂 HashMap 的源码。关于 HashMap 的源码分析，本文并不打算展开讲了。大家可以参考我之前的一篇文章“<a href="http://www.coolblog.xyz/2018/01/18/HashMap-源码详细分析-JDK1-8/" target="_blank" rel="noopener">HashMap 源码详细分析(JDK1.8)</a>”。在那篇文章中，我配了十多张图帮助大家学习 HashMap 源码。</p><p>本篇文章的结构与我之前两篇关于 Java 集合类（<a href="http://www.coolblog.xyz/categories/foundation-of-java/collection/" target="_blank" rel="noopener">集合框架</a>）的源码分析文章不同，本文将不再分析集合类的基本操作（查找、遍历、插入、删除），而是把重点放在双向链表的维护上。包括链表的建立过程，删除节点的过程，以及访问顺序维护的过程等。好了，接下里开始分析吧。</p><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>上一章说了 LinkedHashMap 继承自 HashMap，所以它的底层仍然是<strong>基于拉链式散列结构</strong>。该结构由<strong>数组和链表或红黑树</strong>组成，结构示意图大致如下：</p><p><img src="1.jpg" alt="img">]</p><p>LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。其结构可能如下图：</p><p><img src="2.jpg" alt="img">]</p><p>上图中，淡蓝色的箭头表示<strong>前驱引用</strong>，红色箭头表示<strong>后继引用</strong>。每当有新键值对节点插入，新节点最终会接在 tail 引用指向的节点后面。而 tail 引用则会移动到新的节点上，这样一个双向链表就建立起来了。</p><p>上面的结构并不是很难理解，虽然引入了红黑树，导致结构看起来略为复杂了一些。但大家完全可以忽略红黑树，而只关注链表结构本身。好了，接下来进入细节分析吧。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="Entry-的继承体系"><a href="#Entry-的继承体系" class="headerlink" title="Entry 的继承体系"></a>Entry 的继承体系</h3><p>在对核心内容展开分析之前，这里先插队分析一下键值对节点的继承体系。先来看看继承体系结构图：</p><p><img src="3.jpg" alt="img"></p><p>上面的继承体系乍一看还是有点复杂的，同时也有点让人迷惑。HashMap 的内部类 TreeNode 不继承它的了一个内部类 Node，却继承自 Node 的子类 LinkedHashMap 内部类 Entry。这里这样做是有一定原因的，这里先不说。先来简单说明一下上面的继承体系。LinkedHashMap 内部类 Entry 继承自 HashMap 内部类 Node，并新增了两个引用，分别是 <strong>before</strong> 和 <strong>after</strong>。这两个引用的用途不难理解，也就是用于维护双向链表。同时，TreeNode 继承 LinkedHashMap 的内部类 Entry 后，就具备了和其他 Entry 一起组成链表的能力。但是这里需要大家考虑一个问题。当我们使用 HashMap 时，TreeNode 并不需要具备组成链表能力。如果继承 LinkedHashMap 内部类 Entry ，TreeNode 就多了两个用不到的引用，这样做不是会浪费空间吗？简单说明一下这个问题（水平有限，不保证完全正确），这里这么做确实会浪费空间，但与 TreeNode 通过继承获取的组成链表的能力相比，这点浪费是值得的。在 HashMap 的设计思路注释中，有这样一段话：</p><blockquote><p>Because TreeNodes are about twice the size of regular nodes, we<br>use them only when bins contain enough nodes to warrant use<br>(see TREEIFY_THRESHOLD). And when they become too small (due to<br>removal or resizing) they are converted back to plain bins. In<br>usages with well-distributed user hashCodes, tree bins are<br>rarely used.</p></blockquote><p>大致的意思是 TreeNode 对象的大小约是普通 Node 对象的2倍，我们仅在桶（bin）中包含足够多的节点时再使用。当桶中的节点数量变少时（取决于删除和扩容），TreeNode 会被转成 Node。当用户实现的 hashCode 方法具有良好分布性时，树类型的桶将会很少被使用。</p><p>通过上面的注释，我们可以了解到。一般情况下，只要 hashCode 的实现不糟糕，Node 组成的链表很少会被转成由 TreeNode 组成的红黑树。也就是说 TreeNode 使用的并不多，浪费那点空间是可接受的。假如 TreeNode 机制继承自 Node 类，那么它要想具备组成链表的能力，就需要 Node 去继承 LinkedHashMap 的内部类 Entry。这个时候就得不偿失了，浪费很多空间去获取不一定用得到的能力。</p><p>说到这里，大家应该能明白节点类型的继承体系了。这里单独拿出来说一下，为下面的分析做铺垫。叙述略为啰嗦，见谅。</p><h3 id="链表的建立过程"><a href="#链表的建立过程" class="headerlink" title="链表的建立过程"></a>链表的建立过程</h3><p>链表的建立过程是在插入键值对节点时开始的，初始情况下，让 LinkedHashMap 的 head 和 tail 引用同时指向新节点，链表就算建立起来了。随后不断有新节点插入，通过将新节点接在 tail 引用指向节点的后面，即可实现链表的更新。</p><p>Map 类型的集合类是通过 <code>put(K,V)</code> 方法插入键值对，<strong>LinkedHashMap 本身并没有覆写父类的 put 方法</strong>，而是直接使用了父类的实现。但在 HashMap 中，put 方法插入的是 HashMap 内部类 Node 类型的节点，该类型的节点并不具备与 LinkedHashMap 内部类 Entry 及其子类型节点组成链表的能力。那么，LinkedHashMap 是怎样建立链表的呢？在展开说明之前，我们先看一下 LinkedHashMap 插入操作相关的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap 中实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap 中实现</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;...&#125;</span><br><span class="line">    <span class="comment">// 通过节点 hash 定位节点所在的桶位置，并检测桶中是否包含节点引用</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) &#123;...&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) &#123;...&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历链表，并统计链表长度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 未在单链表中找到要插入的节点，将新节点接在单链表的后面</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) &#123;...&#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 插入的节点已经存在于单链表中</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>) &#123;...&#125;</span><br><span class="line">            afterNodeAccess(e);    <span class="comment">// 回调方法，后续说明</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold) &#123;...&#125;</span><br><span class="line">    afterNodeInsertion(evict);    <span class="comment">// 回调方法，后续说明</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap 中实现</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashMap 中覆写</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    <span class="comment">// 将 Entry 接在双向链表的尾部</span></span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashMap 中实现</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="comment">// last 为 null，表明链表还未建立</span></span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将新节点 p 接在链表尾部</span></span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是 LinkedHashMap 插入相关的源码，这里省略了部分非关键的代码。我根据上面的代码，可以知道 LinkedHashMap 插入操作的调用过程。如下：</p><p><img src="4.jpg" alt="img"></p><p>我把 newNode 方法红色背景标注了出来，这一步比较关键。LinkedHashMap 覆写了该方法。在这个方法中，LinkedHashMap 创建了 Entry，并通过 <strong>linkNodeLast</strong> 方法将 Entry 接在双向链表的尾部，实现了双向链表的建立。双向链表建立之后，我们就可以<strong>按照插入顺序</strong>去遍历 LinkedHashMap，大家可以自己写点测试代码验证一下插入顺序。</p><p>以上就是 LinkedHashMap 维护插入顺序的相关分析。本节的最后，再额外补充一些东西。大家如果仔细看上面的代码的话，会发现有两个以<code>after</code>开头方法，在上文中没有被提及。在 JDK 1.8 HashMap 的源码中，相关的方法有3个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>根据这三个方法的注释可以看出，这些方法的用途是在增删查等操作后，通过回调的方式，让 LinkedHashMap 有机会做一些后置操作。上述三个方法的具体实现在 LinkedHashMap 中，本节先不分析这些实现，相关分析会在后续章节中进行。</p><h3 id="链表节点的删除过程"><a href="#链表节点的删除过程" class="headerlink" title="链表节点的删除过程"></a>链表节点的删除过程</h3><p>与插入操作一样，LinkedHashMap 删除操作相关的代码也是直接用父类的实现。在删除节点时，父类的删除逻辑并不会修复 LinkedHashMap 所维护的双向链表，这不是它的职责。那么删除及节点后，被删除的节点该如何从双链表中移除呢？当然，办法还算是有的。上一节最后提到 HashMap 中三个回调方法运行 LinkedHashMap 对一些操作做出响应。所以，<strong>在删除节点后，回调方法 <code>afterNodeRemoval</code> 会被调用。LinkedHashMap 覆写该方法，并在该方法中完成了移除被删除节点的操作。</strong>相关源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap 中实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap 中实现</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) &#123;...&#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 遍历单链表，寻找要删除的节点，并赋值给 node 变量</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode) &#123;...&#125;</span><br><span class="line">            <span class="comment">// 将要删除的节点从单链表中移除</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);    <span class="comment">// 调用删除回调方法进行后续操作</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashMap 中覆写</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    <span class="comment">// 将 p 节点的前驱后后继引用置空</span></span><br><span class="line">    p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// b 为 null，表明 p 是头节点</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="comment">// a 为 null，表明 p 是尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除的过程并不复杂，上面这么多代码其实就做了三件事：</p><ol><li>根据 hash 定位到桶位置</li><li>遍历链表或调用红黑树相关的删除方法</li><li>从 LinkedHashMap 维护的双链表中移除要删除的节点</li></ol><p>举个例子说明一下，假如我们要删除下图键值为 3 的节点。</p><p><img src="5.jpg" alt="img"></p><p>根据 hash 定位到该节点属于3号桶，然后在对3号桶保存的单链表进行遍历。找到要删除的节点后，先从单链表中移除该节点。如下：</p><p><img src="6.jpg" alt></p><p>然后再双向链表中移除该节点：</p><p><img src="7.jpg" alt></p><p>删除及相关修复过程并不复杂，结合上面的图片，大家应该很容易就能理解，这里就不多说了。</p><h3 id="访问顺序的维护过程"><a href="#访问顺序的维护过程" class="headerlink" title="访问顺序的维护过程"></a>访问顺序的维护过程</h3><p>前面说了插入顺序的实现，本节来讲讲访问顺序。<strong>默认情况下，LinkedHashMap 是按插入顺序维护链表</strong>。不过我们可以在初始化 LinkedHashMap，<strong>指定 accessOrder 参数为 true</strong>，即可让它按访问顺序维护链表。访问顺序的原理上并不复杂，当我们调用<code>get/getOrDefault/replace</code>等方法时，<strong>只需要将这些方法访问的节点移动到链表的尾部即可</strong>。相应的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkedHashMap 中覆写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 如果 accessOrder 为 true，则调用 afterNodeAccess 将被访问节点移动到链表最后</span></span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashMap 中覆写</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 如果 b 为 null，表明 p 为头节点</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这里存疑，父条件分支已经确保节点 e 不会是尾节点，</span></span><br><span class="line"><span class="comment">         * 那么 e.after 必然不会为 null，不知道 else 分支有什么作用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将 p 接在链表的最后</span></span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是访问顺序的实现代码，并不复杂。下面举例演示一下，帮助大家理解。假设我们访问下图键值为3的节点，访问前结构为：</p><p><img src="8.jpg" alt></p><p>访问后，键值为3的节点将会被移动到双向链表的最后位置，其前驱和后继也会跟着更新。访问后的结构如下：</p><p><img src="9.jpg" alt></p><h3 id="基于-LinkedHashMap-实现缓存"><a href="#基于-LinkedHashMap-实现缓存" class="headerlink" title="基于 LinkedHashMap 实现缓存"></a>基于 LinkedHashMap 实现缓存</h3><p>前面介绍了 LinkedHashMap 是如何维护插入和访问顺序的，大家对 LinkedHashMap 的原理应该有了一定的认识。本节我们来写一些代码实践一下，这里通过继承 LinkedHashMap 实现了一个简单的 LRU 策略的缓存。在写代码之前，先介绍一下前置知识。</p><p>在3.1节分析链表建立过程时，我故意忽略了部分源码分析。本节就把忽略的部分补上，先看源码吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="comment">// 根据条件判断是否移除最近最少被访问的节点</span></span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除最近最少被访问条件之一，通过覆盖此方法可实现不同策略的缓存</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的源码的核心逻辑在一般情况下都不会被执行，所以之前并没有进行分析。上面的代码做的事情比较简单，就是<strong>通过一些条件，判断是否移除最近最少被访问的节点</strong>。看到这里，大家应该知道上面两个方法的用途了。当我们基于 LinkedHashMap 实现缓存时，通过覆写<code>removeEldestEntry</code>方法可以<strong>实现自定义策略的 LRU 缓存</strong>。比如我们可以<strong>根据节点数量判断是否移除最近最少被访问的节点</strong>，或者<strong>根据节点的存活时间判断是否移除该节点</strong>等。本节所实现的缓存是基于判断节点数量是否超限的策略。在构造缓存对象时，传入最大节点数。当插入的节点数超过最大节点数时，移除最近最少被访问的节点。实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_NODE_NUM = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> limit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(MAX_NODE_NUM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleCache</span><span class="params">(<span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(limit, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.limit = limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">save</span><span class="params">(K key, V val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> put(key, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getOne</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> containsKey(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断节点数是否超限</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> eldest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 超限返回 true，否则返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; limit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCacheTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SimpleCache&lt;Integer, Integer&gt; cache = <span class="keyword">new</span> SimpleCache&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            cache.save(i, i * i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"插入10个键值对后，缓存内容："</span>);</span><br><span class="line">        System.out.println(cache + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"访问键值为7的节点后，缓存内容："</span>);</span><br><span class="line">        cache.getOne(<span class="number">7</span>);</span><br><span class="line">        System.out.println(cache + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"插入键值为1的键值对后，缓存内容："</span>);</span><br><span class="line">        cache.save(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(cache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><p><img src="10.jpg" alt></p><p>在测试代码中，设定缓存大小为3。在向缓存中插入10个键值对后，只有最后3个被保存下来了，其他的都被移除了。然后通过访问键值为7的节点，使得该节点被移到双向链表的最后位置。当我们再次插入一个键值对时，键值为7的节点就不会被移除。</p><p>本节作为对前面内的补充，简单介绍了 LinkedHashMap 在其他方面的应用。本节内容及相关代码并不难理解，这里就不在赘述了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从 LinkedHashMap 维护双向链表的角度对 LinkedHashMap 的源码进行了分析，并在文章的结尾基于 LinkedHashMap 实现了一个简单的 Cache。在日常开发中，LinkedHashMap 的使用频率虽不及 HashMap，但它也个重要的实现。在 Java 集合框架中，HashMap、LinkedHashMap 和 TreeMap 三个映射类基于不同的数据结构，并实现了不同的功能。<strong>HashMap 底层基于拉链式的散列结构，并在 JDK 1.8 中引入红黑树优化过长链表的问题</strong>。基于这样结构，HashMap 可提供高效的增删改查操作。LinkedHashMap 在其之上，通过维护一条双向链表，<strong>实现了散列数据结构的有序遍历</strong>。<strong>TreeMap 底层基于红黑树实现</strong>，利用红黑树的性质，实现了键值对排序功能。</p><p>到此，本篇文章就写完了，感谢大家的阅读！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://segmentfault.com/a/1190000012964859&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LinkedHashMap 源码详细分析（JDK1.8）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;code&gt;LinkedHashMap&lt;/code&gt; &lt;strong&gt;继承自 HashMap&lt;/strong&gt;，在 HashMap 基础上，通过&lt;strong&gt;维护一条双向链表&lt;/strong&gt;，&lt;strong&gt;解决了 HashMap 不能随时保持遍历顺序和插入顺序一致的问题&lt;/strong&gt;。除此之外，LinkedHashMap 对&lt;strong&gt;访问顺序&lt;/strong&gt;也提供了相关支持。在一些场景下，该特性很有用，比如&lt;strong&gt;缓存&lt;/strong&gt;。在实现上，&lt;code&gt;LinkedHashMap&lt;/code&gt; 很多方法直接继承自 HashMap，&lt;strong&gt;仅为维护双向链表覆写了部分方法&lt;/strong&gt;。所以，要看懂 LinkedHashMap 的源码，需要先看懂 HashMap 的源码。关于 HashMap 的源码分析，本文并不打算展开讲了。大家可以参考我之前的一篇文章“&lt;a href=&quot;http://www.coolblog.xyz/2018/01/18/HashMap-源码详细分析-JDK1-8/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HashMap 源码详细分析(JDK1.8)&lt;/a&gt;”。在那篇文章中，我配了十多张图帮助大家学习 HashMap 源码。&lt;/p&gt;
&lt;p&gt;本篇文章的结构与我之前两篇关于 Java 集合类（&lt;a href=&quot;http://www.coolblog.xyz/categories/foundation-of-java/collection/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;集合框架&lt;/a&gt;）的源码分析文章不同，本文将不再分析集合类的基本操作（查找、遍历、插入、删除），而是把重点放在双向链表的维护上。包括链表的建立过程，删除节点的过程，以及访问顺序维护的过程等。好了，接下里开始分析吧。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://changsk.top/categories/Java/"/>
    
    
      <category term="LinkedHashMap" scheme="http://changsk.top/tags/LinkedHashMap/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-数组中只出现一次的数字</title>
    <link href="http://changsk.top/2019/07/09/jianzhioffer-appear-once/"/>
    <id>http://changsk.top/2019/07/09/jianzhioffer-appear-once/</id>
    <published>2019-07-09T01:47:16.000Z</published>
    <updated>2019-07-09T12:06:35.244Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。</p><a id="more"></a><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>先来个简单题，如果题目是这样子的：<br>一个整型数组里除了一个数字之外，其他的数字都出现了偶数次。请写程序找出这一个只出现一次的数字。<br>这个题就so easy了。xor（异或）有个重要的性质：<br><strong>任何数字异或它自己都等于0（异或，一种位运算，两个比特相同结果则为0，否则为1）</strong><br>用0依次异或数组的元素，最后的结果就是只出现一次或者只出现奇数次的数字（因为偶数次的数字在异或运算中都抵消了）。</p><p>现在的问题是有两个出现次数为一次的数字。那么只要把数组分成两部分，每一部分分别含有一个出现次数为1（或者奇数次也可以的）的数字就可以了。</p><p>先用0对整个数字进行异或运算，结果为xor，是两个只出现一次的数字的异或的结果。出现次数为1的两个数字肯定不相同，那么xor中至少有一位为1。我们在xor中找到第一位为1的位置，记为n。根据第n为是不是1可以把整个数组分为两部分。每一部分都只含有一个出现次数为1的数字，然后剩余的数字都出现偶数次。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//num1,num2分别为长度为1的数组。传出参数</span></span><br><span class="line"><span class="comment">//将num1[0],num2[0]设置为返回结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> xor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> partion = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; array.length;i++) xor ^= array[i];</span><br><span class="line">        <span class="comment">// xor 中从右往左第一次出现 1 的位置</span></span><br><span class="line">        <span class="comment">// 如: 10 &amp; -10 = 2 (10的二进制为 1010)</span></span><br><span class="line">        partion = xor &amp; -xor; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((partion &amp; array[i]) == <span class="number">0</span>) num1[<span class="number">0</span>] ^= array[i];</span><br><span class="line">            <span class="keyword">else</span> num2[<span class="number">0</span>] ^= array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="http://changsk.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="http://changsk.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>java中集合类的继承体系</title>
    <link href="http://changsk.top/2019/07/08/java-collection-map/"/>
    <id>http://changsk.top/2019/07/08/java-collection-map/</id>
    <published>2019-07-08T13:45:01.000Z</published>
    <updated>2019-07-08T13:52:34.499Z</updated>
    
    <content type="html"><![CDATA[<p>Java中集合类存放在java.util包中，主要有三种：set、list、map。</p><a id="more"></a><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>继承体系如下：</p><p><img src="1.jpg" alt></p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>继承体系如下：</p><p><img src="2.jpg" alt></p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>继承体系如下：</p><p><img src="3.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java中集合类存放在java.util包中，主要有三种：set、list、map。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://changsk.top/categories/Java/"/>
    
    
      <category term="集合类" scheme="http://changsk.top/tags/%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>java7新特性-catch捕获多个异常</title>
    <link href="http://changsk.top/2019/07/08/java7-catch-more-exception/"/>
    <id>http://changsk.top/2019/07/08/java7-catch-more-exception/</id>
    <published>2019-07-08T12:50:02.000Z</published>
    <updated>2019-07-08T13:28:12.975Z</updated>
    
    <content type="html"><![CDATA[<p>java 7使得我们能够在同一个catch语句块中捕获多种不同的异常，这也叫做多重异常捕获。</p><p>在java7以前，我们可能要这样做：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// execute code that may throw 1 of the 3 exceptions below.</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">    logger.log(e);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">    logger.log(e);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">    logger.severe(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如上面看到的，SQLException 和IOException 这两个异常都是以相同的方式来处理的，但是你仍然要为这两个异常写两个独立的catch语句块。</p><p>java 7中你可以像下面这样捕获多个异常：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">    //<span class="built_in"> execute </span>code that may<span class="built_in"> throw </span>1 of the 3 exceptions below.</span><br><span class="line"></span><br><span class="line">&#125; catch(&lt;strong&gt;SQLException | IOException e&lt;/strong&gt;) &#123;</span><br><span class="line">    logger.log(e);</span><br><span class="line"></span><br><span class="line">&#125; catch(Exception e) &#123;</span><br><span class="line">    logger.severe(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，第一个catch语句块中的两个异常名字是被管道字符|分割的。两个异常类名之间的管道字符就是在同一个catch语句块中声明多个异常的方法。</p><blockquote><p>参考：<a href="http://ifeve.com/catching-multiple-exceptions/" target="_blank" rel="noopener">在java 7中捕获多个异常</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java 7使得我们能够在同一个catch语句块中捕获多种不同的异常，这也叫做多重异常捕获。&lt;/p&gt;
&lt;p&gt;在java7以前，我们可能要这样做：&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://changsk.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>java7新特性-增强try(Try-with-resources)</title>
    <link href="http://changsk.top/2019/07/08/java7-Try-with-resources/"/>
    <id>http://changsk.top/2019/07/08/java7-Try-with-resources/</id>
    <published>2019-07-08T12:43:43.000Z</published>
    <updated>2019-07-08T12:51:06.793Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://www.jianshu.com/p/97fdbd48f581" target="_blank" rel="noopener">增强 try （Try-with-resources</a></p></blockquote><h3 id="Try-with-resources"><a href="#Try-with-resources" class="headerlink" title="Try-with-resources"></a>Try-with-resources</h3><p>Try-with-resources是Java7出现的一个新的异常处理机制，它能够很容易地关闭在try-catch语句块中使用的资源。</p><p>传统的关闭资源方式是利用Try-Catch-Finally管理资源（旧的代码风格） 即在Java7以前程序中使用的资源需要被明确地关闭。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStream input = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        input = <span class="keyword">new</span> FileInputStream(<span class="string">"d:\\hello.txt"</span>);</span><br><span class="line">        <span class="keyword">int</span> data = input.read();</span><br><span class="line">        <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) data);</span><br><span class="line">            data = input.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(input != <span class="keyword">null</span>)&#123;</span><br><span class="line">            input.close();</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序 try语句块中有3处能抛出异常，finally语句块中有一处会抛出异常。</p><p>不论try语句块中是否有异常抛出，finally语句块始终会被执行。这意味着，不论try语句块中发生什么，InputStream 都会被关闭，或者说都会试图被关闭。如果关闭失败，close()方法也可能会抛出异常。</p><p>假设try语句块抛出一个异常，然后finally语句块被执行。同样假设finally语句块也抛出了一个异常。那么哪个异常会根据调用栈往外传播？</p><p>即使try语句块中抛出的异常与异常传播更相关，<strong>最终还是finally语句块中抛出的异常会根据调用栈向外传播</strong>。</p><p>在Java7以后，对于上面的例子可以用try-with-resource 结构这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFileJava7</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(FileInputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"d:\\hello.txt"</span>)) &#123;</span><br><span class="line">        <span class="keyword">int</span> data = input.read();</span><br><span class="line">        <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) data);</span><br><span class="line">            data = input.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意方法中的第一行：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(FileInputStream input = <span class="keyword">new</span> <span class="type">FileInputStream</span>(<span class="string">"d:\\hello.txt"</span>))</span><br></pre></td></tr></table></figure><p>这就是try-with-resource 结构的用法。FileInputStream 类型变量就在try关键字后面的括号中声明。而且一个FileInputStream 类型被实例化并被赋给了这个变量。</p><p>当try语句块运行结束时，<strong>FileInputStream 会被自动关闭</strong>。这是因为FileInputStream 实现了java中的    <code>java.lang.AutoCloseable</code>接口。所有实现了这个接口的类都可以在try-with-resources结构中使用。</p><p>当try-with-resources结构中抛出一个异常，同时FileInputStream被关闭时（调用了其close方法）也抛出一个异常，<strong>try-with-resources结构中抛出的异常会向外传播</strong>，而FileInputStream被关闭时抛出的异常被抑制了。这与文章开始处利用旧风格代码的例子（在finally语句块中关闭资源）相反。</p><h5 id="使用多个资源"><a href="#使用多个资源" class="headerlink" title="使用多个资源"></a>使用多个资源</h5><p>你也可以在块中使用多个资源而且这些资源都能被自动地关闭。下面是例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFileJava7</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(FileInputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"d:\\hello.txt"</span>); BufferedInputStream bufferedInput = <span class="keyword">new</span> BufferedInputStream(input))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> data = buffereInput.read();</span><br><span class="line">        <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println( (<span class="keyword">char</span>) data);</span><br><span class="line">            data = bufferedInput.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子在try关键字后的括号里创建了两个资源——FileInputStream 和BufferedInputStream。当程序运行离开try语句块时，这两个资源都会被自动关闭。</p><p>这些资源将按照他们被创建顺序的逆序来关闭。首先BufferedInputStream 会被关闭，然后FileInputStream会被关闭。</p><h5 id="自定义AutoCloseable-实现"><a href="#自定义AutoCloseable-实现" class="headerlink" title="自定义AutoCloseable 实现"></a>自定义AutoCloseable 实现</h5><p>这个try-with-resources结构里不仅能够操作java内置的类。你也可以在自己的类中实现java.lang.AutoCloseable接口，然后在try-with-resources结构里使用这个类。</p><p>AutoClosable 接口仅仅有一个方法，接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AutoClosable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何实现了这个接口的方法都可以在try-with-resources结构中使用。下面是一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAutoClosable</span> <span class="keyword">implements</span> <span class="title">AutoClosable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doIt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyAutoClosable doing it!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyAutoCloseable Closed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是MyAutoClosable 在try-with-resources结构中使用的例子：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">myAutoClosable</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(MyAutoClosable myAutoClosable = <span class="keyword">new</span> MyAutoClosable())&#123;</span><br><span class="line">        myAutoClosable.doIt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当方法myAutoClosable.doIt()被调用时，下面是打印到System.out的输出：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyAutoClosable doing it!</span><br><span class="line">MyAutoClosable closed!</span><br></pre></td></tr></table></figure><p>通过上面这些你可以看到，不论try-catch中使用的资源是自己创造的还是java内置的类型，try-with-resources都是一个能够确保资源能被正确地关闭的强大方法。</p><h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><ul><li>自动关闭资源的try语句相当于包含了隐式的finally块（用于关闭资源），<strong>因此这个try语句可以既没有catch块，也没有finally块。</strong></li><li><strong>被自动关闭的资源必须实现Closeable或AutoCloseable接口。</strong>（Closeable是AutoCloseable的子接口，Closeeable接口里的close()方法声明抛出了IOException,;AutoCloseable接口里的close()方法声明抛出了Exception）<ul><li>Java7几乎把所有的“<strong>资源类</strong>”（包括文件IO的各种类，JDBC编程的Connection、Statement等接口……）进行了改写，改写后的资源类都实现了AutoCloseable或Closeable接口</li></ul></li><li>Java7新增的自动关闭资源的try语句允许在try关键字后紧跟一对圆括号，里面可以声明、初始化一个或多个资源，此处的资源指的是那些必须在程序结束时显示关闭的资源（数据库连接、网络连接等），try语句会在该语句结束时自动关闭这些资源。<ul><li>被关闭的资源必须放在try语句后的圆括号中声明、初始化。如果程序有需要自动关闭资源的try语句后可以带多个catch块和一个finally块。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://www.jianshu.com/p/97fdbd48f581&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;增强 try （Try-with-resources&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Try-with-resources&quot;&gt;&lt;a href=&quot;#Try-with-resources&quot; class=&quot;headerlink&quot; title=&quot;Try-with-resources&quot;&gt;&lt;/a&gt;Try-with-resources&lt;/h3&gt;&lt;p&gt;Try-with-resources是Java7出现的一个新的异常处理机制，它能够很容易地关闭在try-catch语句块中使用的资源。&lt;/p&gt;
&lt;p&gt;传统的关闭资源方式是利用Try-Catch-Finally管理资源（旧的代码风格） 即在Java7以前程序中使用的资源需要被明确地关闭。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://changsk.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>java8的新特性</title>
    <link href="http://changsk.top/2019/07/08/java8-new-feature/"/>
    <id>http://changsk.top/2019/07/08/java8-new-feature/</id>
    <published>2019-07-08T11:34:50.000Z</published>
    <updated>2019-07-08T12:14:16.186Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://cloud.tencent.com/developer/article/1378091" target="_blank" rel="noopener">Java8 新特性</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>北京时间2018年9月26日，Oracle官方发布Java 11。既然版本都更新到11了，现在才来学8是不是太晚了？其实不是的，目前应该大部分都还是使用的Java 7和Java 8，这两个应该还是主流。而Java 8 又有一些激动人心的新特性，所以还是值得学习的。Java 8 新特性主要有以下几点：</p><a id="more"></a><ul><li><strong>Lambda表达式(重点)；</strong></li><li>函数式接口；</li><li>方法引用与构造器引用；</li><li><strong>Stream API(重点)；</strong></li><li><strong>接口中的默认方法与静态方法；</strong></li><li><strong>新时间日期API；</strong></li><li>其他新特性。</li></ul><p>有了以上新特性，Java 8就可以做到：</p><ul><li>速度更快；</li><li>代码更少(增加了新的语法 Lambda 表达式)；</li><li>方便操作集合(Stream API)</li><li>便于并行；</li><li>最大化减少空指针异常 Optional。</li></ul><p>接下来一起来了解一下Java 8的这些新特性。</p><h1 id="Lambada表达式"><a href="#Lambada表达式" class="headerlink" title="Lambada表达式"></a>Lambada表达式</h1><p><strong>1、什么是lambda？</strong>  Lambda 是一个匿名函数，我们可以把 Lambda 表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。可以写出更简洁、更灵活的代码。</p><p><strong>2、了解新操作符：</strong>  Java 8引入了新的操作符，-&gt;，叫<code>箭头操作符</code>或者叫<code>lambda操作符</code>。当使用lambda表达式时就需要使用这个操作符。</p><p><strong>3、lambda表达式语法：</strong>  箭头操作符将lambda表达式分成了两部分：</p><ul><li>左侧：<code>lambda表达式的参数列表</code>(接口中抽象方法的参数列表)</li><li>右侧：<code>lambda表达式中所需执行的功能</code>(lambda体，对抽象方法的实现)</li></ul><p>语法有如下几种格式：</p><ul><li>语法格式一(无参数无返回值)：  () -&gt; 具体实现</li><li>语法格式二(有一个参数无返回值)： (x) -&gt; 具体实现 或  x -&gt; 具体实现</li><li>语法格式三(有多个参数，有返回值，并且lambda体中有多条语句)：(x,y) -&gt; {具体实现}</li><li>语法格式四：若方法体只有一条语句，那么大括号和return都可以省略  <strong>注：</strong>lambda表达式的参数列表的参数类型可以省略不写，可以进行类型推断。</li></ul><p>看几个例子：  例一：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public <span class="keyword">void</span> test1()&#123;</span><br><span class="line">     <span class="comment">// 实现一个线程</span></span><br><span class="line">     int num = <span class="number">0</span>;<span class="comment">//jdk1.8以前，这个必须定义为final，下面才能用，1.8后默认就为final</span></span><br><span class="line">     Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public <span class="keyword">void</span> run() &#123;</span><br><span class="line">             System.out.println(<span class="string">"hello world"</span>+ num);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     runnable.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个线程，重写run方法，在run方法里面打印一句话。我们想要的就是<code>System.out.println(&quot;hello world&quot;+ num);</code>这行代码，但是为了实现这行代码，不得不多写了好多行。lambda就可以解决这一点，看看用lambda如何实现:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runnable runnable1 = () -&gt; System.out.println(<span class="string">"hello world"</span>+num);</span><br><span class="line">runnable1.run();</span><br></pre></td></tr></table></figure><p>用lambda这样就搞定了。首先还是<code>Runnable runnable1 =</code>，但是不用new了，右边就用lambda实现。我们要使用的是该接口的run方法，run方法不需要参数，所以lambda表达式左边就是()，lambda表达式右边是抽象方法的实现，也就是第一种方式中run方法的方法体写到lambda表达式右边就可以了。</p><p>例二：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; comparator = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">         <span class="keyword">return</span> Integer.compare(o1,o2);<span class="comment">//就这一行关键代码</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以前写一个比较器就要像上面那样写，先new比较器类，然后在其compare方法里写核心代码。用lambda实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; comparator = (x,y) -&gt; Integer.compare(x,y);</span><br></pre></td></tr></table></figure><p>compare方法需要两个参数，所以箭头操作符左边写(x,y)，右边是compare方法的实现，所以应该写<code>return Integer.compare(o1,o2);</code>，但是根据上面的语法格式四可知，return可以省略，因此就写成了上面那样。</p><p>通过这两个例子可以感受到lambda表达式的简洁，但是问题来了：我们说lambda表达式就是一个匿名函数，我们只需要指定<code>参数</code>和<code>lambda体</code>即可，那么它是如何判断重写的是哪个方法呢？比如一个接口中有多个方法，如果使用lambda表达式来写，那么如何判断我们使用的是该接口的哪个方法？其实是<strong>不能判断</strong>的！通过上面两个例子可以发现，Runnable接口和Comparator接口都是只有一个方法的接口，所以可以使用lambda。</p><h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><p><strong>1、什么是函数式接口？</strong>  <code>像Runnable和Comparator这样只有一个方法的接口，称为函数式接口</code>。也可以在接口上加上<code>@FunctionalInterface</code>注解，如果编译通过，则该接口就是函数式接口。lambda表达式就需要函数式接口的支持。</p><p><strong>2、看一个需求：</strong>  需求：需要对两个数进行加减乘除等运算，怎么实现？</p><ul><li>传统做法：传统做法中，需要进行几种运算，我们就要写几个方法。一种运算对应一个方法。</li><li>lambda做法：首先要定义一个函数式接口，接口中只有一个方法，接收两个参数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface MyInterface &#123;</span><br><span class="line">    public Integer getValue(Integer num1,Integer num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以使用了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public <span class="keyword">void</span> test5()&#123;</span><br><span class="line">      MyInterface myInterface = (x,y) -&gt; x*y;<span class="comment">//乘法运算</span></span><br><span class="line">      MyInterface myInterface1 = (x,y) -&gt; x+y;<span class="comment">//加法运算</span></span><br><span class="line">      Integer result1 = myInterface.getValue(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line">      Integer result2 = myInterface1.getValue(<span class="number">1024</span>,<span class="number">2048</span>);</span><br><span class="line">      System.out.println(result1);</span><br><span class="line">      System.out.println(result2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以用lambda的话，只需要定义一个<strong>函数式接口</strong>，不管进行什么操作，都可以用lambda解决，不用再一种运算对应一个方法。但是，还需要自己定义函数式接口，好像也没简单很多。Java考虑到这点了，所以内置了函数式接口。</p><p><strong>3、四大内置函数式接口：</strong>  为了不需要我们自己定义函数式接口，Java内置了四大函数式接口，这四大接口加上它们的子类，完全满足我们的使用了。四大函数式接口是：</p><ul><li>Consumer<t>：消费型接口(void accept(T t))，接收一个参数，无返回值。</t></li><li>Supplier<t>：供给型接口(T get())，无参数，有返回值。</t></li><li>Function&lt;T,R&gt;：函数型接口(R apply(T t))，接收一个参数，有返回值。</li><li>Predicate<t>：断言型接口(boolean test(T t))，接收一个参数，返回Boolean值。</t></li></ul><p><strong>4、四大函数式接口的使用：</strong>  接下来看看具体如何使用这四大函数式接口。  </p><p>消费型接口的使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Consumer consumer = (x) -&gt; System.out.println(<span class="string">"消费了"</span>+x+<span class="string">"元"</span>);</span><br><span class="line">consumer.accept(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>供给型接口的使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Integer&gt; supplier = () -&gt; (int)(<span class="built_in">Math</span>.random() * <span class="number">100</span>);<span class="comment">//生成随机数</span></span><br><span class="line">System.out.println(supplier.get());</span><br></pre></td></tr></table></figure><p>函数型接口的使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>&lt;<span class="built_in">String</span>,<span class="built_in">String</span>&gt; <span class="function"><span class="keyword">function</span> = <span class="title">str</span> -&gt; <span class="title">str</span>.<span class="title">toUpperCase</span>(<span class="params"></span>);//将传入的字符串转成大写</span></span><br><span class="line"><span class="function"><span class="title">String</span> <span class="title">s</span> = <span class="title">function</span>.<span class="title">apply</span>(<span class="params"><span class="string">"adcdefggffs"</span></span>);</span></span><br><span class="line"><span class="function"><span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span>(<span class="params">s</span>);</span></span><br></pre></td></tr></table></figure><p>断言型接口的使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//需求：将满足条件的字符串添加到集合中去</span></span><br><span class="line">  public List&lt;<span class="built_in">String</span>&gt; filterString(List&lt;<span class="built_in">String</span>&gt; strings, Predicate&lt;<span class="built_in">String</span>&gt; predicate)&#123;</span><br><span class="line">      List&lt;<span class="built_in">String</span>&gt; stringList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">String</span> string : strings) &#123;</span><br><span class="line">          <span class="keyword">if</span> (predicate.test(string))&#123;</span><br><span class="line">              stringList.add(string);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> stringList;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line">@Test</span><br><span class="line"> public <span class="keyword">void</span> test4()&#123;</span><br><span class="line">      List&lt;<span class="built_in">String</span>&gt; list = Arrays.asList(<span class="string">"hello"</span>,<span class="string">"world"</span>,<span class="string">"niu"</span>,<span class="string">"bi"</span>);</span><br><span class="line">      List&lt;<span class="built_in">String</span>&gt; newList = filterString(list,str -&gt; str.length() &gt; <span class="number">3</span>);<span class="comment">//选出长度大于3的字符串</span></span><br><span class="line">      newList.forEach(System.out::println);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="方法引用与构造器引用"><a href="#方法引用与构造器引用" class="headerlink" title="方法引用与构造器引用"></a>方法引用与构造器引用</h1><p>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用。不过实现抽象方法的参数列表，必须与引用方法的参数列表保持一致。  </p><p><strong>1、方法引用语法：</strong></p><ul><li>对象::实例方法</li><li>类::静态方法</li><li>类::实例方法</li></ul><p><strong>2、方法引用具体用法：</strong>  说了那么多可能还不清楚到底什么意思，一起来看几个例子。  </p><p>语法一例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;<span class="built_in">String</span>&gt; consumer = x -&gt; System.out.println(x);<span class="comment">//传统写法</span></span><br><span class="line">Consumer&lt;<span class="built_in">String</span>&gt; consumer = System.out::println;<span class="comment">//使用方法引用</span></span><br></pre></td></tr></table></figure><p>println方法和Consumer的accept方法都是无返回值，接收一个参数，所以可以这样写。</p><p>语法二例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; comparator = (x,y) -&gt; Integer.compare(x,y);</span><br><span class="line"><span class="comment">//因为compare方法已经被Integer实现了，且是静态的，所以这样用就行。</span></span><br><span class="line">Comparator&lt;Integer&gt; comparator1 = Integer::compare;</span><br></pre></td></tr></table></figure><p>语法三例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BiPredicate&lt;<span class="built_in">String</span>,<span class="built_in">String</span>&gt; biPredicate = (x,y) -&gt; x.equals(y);</span><br><span class="line"><span class="comment">//可以改成如下写法</span></span><br><span class="line"><span class="comment">//不过要满足：第一个参数是实例方法的调用者，第二个参数是实例方法的参数时，就可以这样用</span></span><br><span class="line">BiPredicate&lt;<span class="built_in">String</span>,<span class="built_in">String</span>&gt; biPredicate1 = <span class="built_in">String</span>::equals;</span><br></pre></td></tr></table></figure><p><strong>3、构造器引用：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Employee&gt; supplier = () -&gt; <span class="keyword">new</span> Employee();</span><br><span class="line"><span class="comment">//可以改写成这样</span></span><br><span class="line"><span class="comment">//注意：需要调用的构造器的参数列表要与函数接口中抽象方法的参数列表一致</span></span><br><span class="line">Supplier&lt;Employee&gt; supplier1 = Employee::<span class="keyword">new</span>;</span><br><span class="line">Employee employee = supplier.get();</span><br></pre></td></tr></table></figure><h1 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h1><p>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的<code>查找</code>、<code>过滤</code>和<code>映射数据</code>等操作。使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来<strong>并行执行</strong>操作。简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</p><p><strong>1、理解Stream:</strong>  Stream被称作流，是用来处理集合以及数组的数据的。它有如下特点：</p><ul><li>Stream 自己不会存储元素。</li><li>Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</li><li>Stream 操作是延迟执行的。<strong>这意味着他们会等到需要结果的时候才执行。</strong></li></ul><p><strong>2、使用Stream的三个步骤：</strong></p><ul><li>创建Stream：一个数据源（如：集合、数组），获取一个流</li><li>中间操作：一个中间操作链，对数据源的数据进行处理</li><li>终止操作：一个终止操作，执行中间操作链，并产生结果</li></ul><p><strong>3、创建Stream:</strong>  直接看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、通过集合提供的stream方法或parallelStream()方法创建</span></span><br><span class="line">List&lt;<span class="built_in">String</span>&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Stream&lt;<span class="built_in">String</span>&gt; stringStream = list.stream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、通过Arrays中的静态方法stream获取数组流</span></span><br><span class="line">Employee[] employees = <span class="keyword">new</span> Employee[<span class="number">10</span>];</span><br><span class="line">Stream&lt;Employee&gt; stream = Arrays.stream(employees);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、通过Stream类的静态方法of()创建流</span></span><br><span class="line">Stream&lt;<span class="built_in">String</span>&gt; stream1 = Stream.of(<span class="string">"aa"</span>,<span class="string">"bb"</span>,<span class="string">"cc"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、创建无限流</span></span><br><span class="line"><span class="comment">//迭代方式创建无限流</span></span><br><span class="line"><span class="comment">//从0开始，每次加2，生成无限个</span></span><br><span class="line">Stream&lt;Integer&gt; stream2 = Stream.iterate(<span class="number">0</span>,(x) -&gt; x+<span class="number">2</span>);</span><br><span class="line"><span class="comment">//生成10个</span></span><br><span class="line">stream2.limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成方式创建无限流</span></span><br><span class="line">Stream.generate(() -&gt; <span class="built_in">Math</span>.random())</span><br><span class="line">                .limit(<span class="number">5</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>上面介绍了集合、数组创建流的几种方式，都有对应的注解。</p><p><strong>4、中间操作：</strong>  <strong>筛选与切片：</strong></p><ul><li>filter – 接收lambda，从流中排除某些数据。</li><li>limit – 截断流，使其元素不超过给定数量。</li><li>skip(n) – 跳过元素，返回一个扔掉了前n个元素的流，若不足n个元素，则返回空流。</li><li>distinct – 筛选，通过流所生成元素的hashCode()和equals()去除重复元素,所以对象必须重新hashCode方法和equals方法。</li></ul><p>看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">employees.stream()<span class="comment">//已有employees集合</span></span><br><span class="line">         .filter((e) -&gt; e.getAge() &gt; <span class="number">18</span>)<span class="comment">//中间操作(选出年龄大于18的)</span></span><br><span class="line">         .limit(<span class="number">1</span>)<span class="comment">//中间操作(只返回一个)</span></span><br><span class="line">         .forEach(System.out::println);<span class="comment">//终止操作</span></span><br></pre></td></tr></table></figure><p><strong>映射：</strong></p><ul><li>map – 接收lambda，将元素转换成其他形式或提取信息。接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</li><li>flatMap – 接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所以流连接成一个流。</li></ul><p>看例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">String</span>&gt; list = Arrays.asList(<span class="string">"aa"</span>,<span class="string">"bb"</span>,<span class="string">"cc"</span>,<span class="string">"dd"</span>);</span><br><span class="line">list.stream()</span><br><span class="line">    .map(str -&gt; str.toUpperCase())<span class="comment">//将所有的转成大写</span></span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p><strong>排序：</strong></p><ul><li>sorted() – 自然排序(按照Comparable来排序)。</li><li>sorted(Comparator com) – 定制排序(按照Comparator来排序)。</li></ul><p>看例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">String</span>&gt; list = Arrays.asList(<span class="string">"ccc"</span>,<span class="string">"bbb"</span>,<span class="string">"aaa"</span>,<span class="string">"ddd"</span>);</span><br><span class="line">list.stream()</span><br><span class="line">    .sorted()<span class="comment">//自然排序</span></span><br><span class="line">    .forEach(System.out::print);<span class="comment">//aaa,bbb,ccc,ddd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定制排序</span></span><br><span class="line">employees.stream()<span class="comment">//employees是一个存有多名员工的集合</span></span><br><span class="line">      .sorted((e1, e2) -&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (e1.getAge().equals(e2.getAge()))&#123; <span class="comment">//如果年龄一样</span></span><br><span class="line">               <span class="keyword">return</span> e1.getName().compareTo(e2.getName());<span class="comment">//就比较姓名</span></span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> e1.getAge().compareTo(e2.getAge());<span class="comment">//年龄不一样就比较年龄</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p><strong>5、终止操作：</strong>  <strong>查找与匹配：</strong></p><ul><li>allMatch – 检查是否匹配所有元素。</li><li>anyMatch – 检查是否至少匹配一个元素。</li><li>noneMatch – 检查是否没有匹配所有元素。</li><li>findFirst – 返回第一个元素。</li><li>findAny – 返回当前流中任意元素。</li><li>count – 返回流中元素总个数。</li><li>max – 返回流中最大值。</li><li>min – 返回流中最小值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//看看employee集合中是不是所有都是男的</span></span><br><span class="line">boolean b = employees.stream()</span><br><span class="line">                     .allMatch(e -&gt; e.getGender().equals(<span class="string">"男"</span>));</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure><p><strong>规约：</strong></p><ul><li>reduce(T identity,BinaryOperator) – 可以将流中元素反复结合起来，得到一个值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//规约求和</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>);</span><br><span class="line">Integer sum = list.stream()</span><br><span class="line">                 .reduce(<span class="number">0</span>,(x,y) -&gt; x+y);<span class="comment">//首先把0作为x，把1作为y，进行加法运算得到1，把1再作为x，把3作为y，以此类推</span></span><br><span class="line">System.out.println(sum);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取工资总和</span></span><br><span class="line">Optional&lt;Double&gt; optional = employees.stream()</span><br><span class="line">                .map(Employee::getSalary)<span class="comment">//提取工资</span></span><br><span class="line">                .reduce(Double::sum);<span class="comment">//求工资总和</span></span><br><span class="line">System.out.println(optional2.get());</span><br></pre></td></tr></table></figure><p><strong>收集：</strong></p><ul><li>collect – 将流转换为其他形式。接收一个Collector接口的实现，用于给Stream中元素做汇总的方法。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把公司中所有员工的姓名提取出来并收集到一个集合中去</span></span><br><span class="line">List&lt;<span class="built_in">String</span>&gt; stringList = employees.stream()</span><br><span class="line">                .map(Employee::getName)<span class="comment">//提取员工姓名</span></span><br><span class="line">                <span class="comment">//.collect(Collectors.toList());//收集到list集合</span></span><br><span class="line">                <span class="comment">//.collect(Collectors.toSet());//收集到set集合</span></span><br><span class="line">                .collect(Collectors.toCollection(LinkedList::<span class="keyword">new</span>));<span class="comment">//这种方式可收集到任意集合</span></span><br><span class="line">stringList.forEach(System.out::println);<span class="comment">//遍历集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算工资平均值</span></span><br><span class="line">Double avgSalary = employees.stream()</span><br><span class="line">                .collect(Collectors.averagingDouble(Employee::getSalary));</span><br><span class="line">System.out.println(avgSalary);</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据年龄分组</span></span><br><span class="line"><span class="built_in">Map</span>&lt;Integer,List&lt;Employee&gt;&gt; map = employees.stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Employee::getAge));</span><br><span class="line">System.out.println(map);</span><br><span class="line"></span><br><span class="line"><span class="comment">//先按性别分组，性别一样时按年龄分组</span></span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>,<span class="built_in">Map</span>&lt;Integer,List&lt;Employee&gt;&gt;&gt; map1 = employees.stream()       </span><br><span class="line"> .collect(Collectors.groupingBy(Employee::getGender,Collectors.groupingBy(Employee::getAge)));</span><br><span class="line">System.out.println(map1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//分区，满足条件的一个区，不满足的另一个区</span></span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">Boolean</span>,List&lt;Employee&gt;&gt; map2 = employees.stream()</span><br><span class="line">         .collect(Collectors.partitioningBy(e -&gt; e.getSalary() &gt; <span class="number">6000</span>));<span class="comment">//工资大于6000的为true区，否则为false区</span></span><br><span class="line">System.out.println(map2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取工资的总额、平均值等</span></span><br><span class="line">DoubleSummaryStatistics dss = employees.stream()</span><br><span class="line">           .collect(Collectors.summarizingDouble(Employee::getSalary));</span><br><span class="line">System.out.println(dss.getSum());</span><br><span class="line">System.out.println(dss.getAverage());</span><br><span class="line">System.out.println(dss.getMax());</span><br></pre></td></tr></table></figure><h1 id="并行流与串行流"><a href="#并行流与串行流" class="headerlink" title="并行流与串行流"></a>并行流与串行流</h1><p><strong>1、fork/join框架：</strong>  此框架就是在必要的情况下，将一个大任务，进行拆分(fork)成若干个小任务（拆到不可再拆时），再将一个个的小任务运算的结果进行 join 汇总。  </p><p><img src="1.jpg" alt="img"></p><p>fork/join</p><p><strong>2、并行流与串行流：</strong>  通过上面的图可以知道，使用fork/join框架可以提高效率(<strong>运算量越大越明显，运算量可能反而更慢，因为拆分也需要时间</strong>)，但是在Java 8之前需要自己实现fork/join，还是挺麻烦的，Java 8就方便多了，因为提供了并行流，底层就是使用了fork/join。Stream API 可以声明性地通过<code>parallel()</code>与 <code>sequential()</code> 在并行流与顺序流之间进行切换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public <span class="keyword">void</span> test()&#123;</span><br><span class="line">      Instant start = Instant.now();</span><br><span class="line">      <span class="comment">//普通做法求0加到10000000000的和</span></span><br><span class="line">      LongStream.rangeClosed(<span class="number">0</span>,<span class="number">100000000000</span>L)</span><br><span class="line">              .reduce(<span class="number">0</span>,<span class="attr">Long</span>::sum);</span><br><span class="line">      Instant end = Instant.now();</span><br><span class="line">      System.out.println(<span class="string">"耗费"</span>+ Duration.between(end ,start) + <span class="string">"秒"</span>);<span class="comment">//55秒</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public <span class="keyword">void</span> test2()&#123;</span><br><span class="line">     Instant start = Instant.now();</span><br><span class="line">     <span class="comment">//并行流求0加到10000000000的和</span></span><br><span class="line">     LongStream.rangeClosed(<span class="number">0</span>,<span class="number">100000000000</span>L)</span><br><span class="line">             .parallel()<span class="comment">//使用并行流</span></span><br><span class="line">             .reduce(<span class="number">0</span>,<span class="attr">Long</span>::sum);</span><br><span class="line">     Instant end = Instant.now();</span><br><span class="line">     System.out.println(<span class="string">"耗费"</span>+ Duration.between(end ,start) + <span class="string">"秒"</span>);<span class="comment">//30秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过运行上面的程序可以明显感受到并行流的高效。</p><h1 id="新时间日期API"><a href="#新时间日期API" class="headerlink" title="新时间日期API"></a>新时间日期API</h1><p><strong>Java 8之前的Date和Calendar都是线程不安全的</strong>，而且使用起来比较麻烦，Java 8提供了全新的时间日期API，LocalDate(日期)、LocalTime(时间)、LocalDateTime(时间和日期) 、Instant (时间戳)、Duration(用于计算两个“时间”间隔)、Period(用于计算两个“日期”间隔)等。</p><p><strong>1、LocalDate、LocalTime、LocalDateTime：</strong>  这三个用法一样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前系统时间</span></span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now();<span class="comment">//当前时间日期</span></span><br><span class="line">LocalDateTime localDateTime2 = localDateTime.plusYears(<span class="number">2</span>);<span class="comment">//加两年</span></span><br><span class="line">System.out.println(localDateTime.getMonth());</span><br><span class="line">System.out.println(localDateTime);</span><br><span class="line">System.out.println(localDateTime2);</span><br><span class="line"><span class="comment">//指定时间</span></span><br><span class="line">LocalDateTime localDateTime1 = LocalDateTime.of(<span class="number">2018</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">8</span>);</span><br><span class="line">System.out.println(localDateTime1);</span><br></pre></td></tr></table></figure><p><strong>2、Instant 时间戳：</strong>  时间戳就是计算机读的时间，它是以<strong>Unix元年</strong>(传统的设定为UTC时区1970年1月1日午夜时分)开始算起的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//计算机读的时间：时间戳(Instant)，1970年1月1日0时0分0秒到此时的毫秒值</span></span><br><span class="line">Instant instant = Instant.now();</span><br><span class="line">System.out.println(instant);<span class="comment">//默认是美国时区，8个时差</span></span><br><span class="line">OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));<span class="comment">//加上时差</span></span><br><span class="line">System.out.println(offsetDateTime);</span><br><span class="line">System.out.println(instant.toEpochMilli());<span class="comment">//显示毫秒值</span></span><br></pre></td></tr></table></figure><p><strong>3、Duration 和 Period：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LocalTime localTime = LocalTime.now();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">LocalTime localTime1 = LocalTime.now();</span><br><span class="line">System.out.println(Duration.between(localTime,localTime1).toMillis());</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取两个日期之间的间隔</span></span><br><span class="line">LocalDate localDate = LocalDate.of(<span class="number">2012</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">LocalDate localDate1 = LocalDate.now();</span><br><span class="line">Period period = Period.between(localDate,localDate1);</span><br><span class="line">System.out.println(period);</span><br><span class="line">System.out.println(period.getYears()+<span class="string">"年"</span>+period.getMonths()+<span class="string">"月"</span>+period.getDays()+<span class="string">"日"</span>);</span><br></pre></td></tr></table></figure><p><strong>4、时间校正器(TemporalAdjuster)：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">System.out.println(localDateTime);</span><br><span class="line"></span><br><span class="line">LocalDateTime localDateTime1 = localDateTime.withDayOfMonth(<span class="number">1</span>);<span class="comment">//localDate日期中月份的1号</span></span><br><span class="line">System.out.println(localDateTime1);</span><br><span class="line">localDateTime1.with(TemporalAdjusters.firstDayOfNextMonth());<span class="comment">//下一个月的第一天</span></span><br><span class="line">localDateTime.with(TemporalAdjusters.next(DayOfWeek.SUNDAY));<span class="comment">//下周日</span></span><br></pre></td></tr></table></figure><p><strong>5、格式化日期(.DateTimeFormatter )：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public <span class="keyword">void</span> test6()&#123;</span><br><span class="line">        <span class="comment">//DateTimeFormatter:格式化</span></span><br><span class="line">        <span class="comment">//使用预设格式</span></span><br><span class="line">        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ISO_DATE_TIME;</span><br><span class="line">        LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">        <span class="built_in">String</span> str = localDateTime.format(dateTimeFormatter);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        System.out.println(<span class="string">"=========================="</span>);</span><br><span class="line">        <span class="comment">//自定义格式</span></span><br><span class="line">        DateTimeFormatter dateTimeFormatter1 = DateTimeFormatter.ofPattern(<span class="string">"yyyy年MM月dd日 HH:mm:ss"</span>);</span><br><span class="line">        <span class="built_in">String</span> str2 = localDateTime.format(dateTimeFormatter1);</span><br><span class="line">        <span class="comment">//这样格式化也可以</span></span><br><span class="line">        <span class="built_in">String</span> str3 = dateTimeFormatter1.format(localDateTime);</span><br><span class="line">        System.out.println(str2);</span><br><span class="line">        System.out.println(str3);</span><br><span class="line">        <span class="comment">//退回到解析前的格式</span></span><br><span class="line">        LocalDateTime newDate = localDateTime.parse(str,dateTimeFormatter);</span><br><span class="line">        System.out.println(newDate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6、时区的处理：</strong>  Java8 中加入了对时区的支持，带时区的时间为分别为：ZonedDate、ZonedTime、ZonedDateTime。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> @Test</span><br><span class="line"> public <span class="keyword">void</span> test7()&#123;</span><br><span class="line">   <span class="comment">//ZonedDate ZonedTime ZonedDateTime</span></span><br><span class="line">   LocalDateTime dateTime = LocalDateTime.now(ZoneId.of(<span class="string">"Europe/Tallinn"</span>));</span><br><span class="line">   System.out.println(dateTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="接口中的默认方法和静态方法"><a href="#接口中的默认方法和静态方法" class="headerlink" title="接口中的默认方法和静态方法"></a>接口中的默认方法和静态方法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface MyInterface &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="built_in">String</span> test()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"允许存在有具体实现的方法"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="built_in">String</span> test2()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"接口中还可以有静态方法"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，Java 8的接口中允许有<strong>默认方法</strong>和静态方法。如果一个类继承了一个类还实现了一个接口，而且接口中的默认方法和父类中的方法同名，这时采用类优先原则。也就是说，<strong>子类使用的是父类的方法，而不是接口中的同名方法。</strong></p><h1 id="其他新特性"><a href="#其他新特性" class="headerlink" title="其他新特性"></a>其他新特性</h1><p><strong>1、Optional类：</strong>  这个类是为了尽可能减少空指针异常的。就是把普通对象用Optional包起来，做了一些封装。看看其用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Man</span> </span>&#123; <span class="comment">//男人类</span></span><br><span class="line">    private Godness godness;<span class="comment">//女神</span></span><br><span class="line">&#125;</span><br><span class="line">@Data</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Godness</span> </span>&#123;</span><br><span class="line">    private <span class="built_in">String</span> name;</span><br><span class="line">    public Godness(<span class="built_in">String</span> name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public Godness()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取男人心中的女神的名字(有的人不一定有女神，也就是说女神可能为空)</span></span><br><span class="line">    <span class="comment">//常规做法要加很多判断</span></span><br><span class="line">    public <span class="built_in">String</span> getGodnessName(Man man)&#123;</span><br><span class="line">        <span class="keyword">if</span> (man != <span class="literal">null</span>)&#123;</span><br><span class="line">            Godness godness = man.getGodness();</span><br><span class="line">            <span class="keyword">if</span> (godness != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> godness.getName();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"我心中没有女神"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"男人为空"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>一个man类，有一个成员变量女神，女神也是一个类，有一个成员变量，名字。要获取man心中的女神，为了防止控制针异常，要做很多的判断。如果使用Optional呢？做法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新男人类</span></span><br><span class="line">@Data</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">NewMan</span> </span>&#123;</span><br><span class="line">    private Optional&lt;Godness&gt; godness = Optional.empty();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用optional后的方法</span></span><br><span class="line">public <span class="built_in">String</span> getGodnessName2(Optional&lt;NewMan&gt; man)&#123;</span><br><span class="line">    <span class="keyword">return</span> man.orElse(<span class="keyword">new</span> NewMan())</span><br><span class="line">                .getGodness()</span><br><span class="line">                .orElse(<span class="keyword">new</span> Godness(<span class="string">"我没有女神"</span>))</span><br><span class="line">                .getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就简单多了。</p><p><strong>2、重复注解与类型注解：</strong>  Java 8 可以使用重复注解和类型注解，如下图：  </p><p><img src="2.jpg" alt="img"></p><p>重复注解&amp;类型注解</p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>本文说了一些Java 8 的新特性，重点就是lambda表达式和Stream API，可以简化很多操作。肯可能还有些文中未涉及的，在此抛砖引玉，望各位大佬指点！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://cloud.tencent.com/developer/article/1378091&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java8 新特性&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;北京时间2018年9月26日，Oracle官方发布Java 11。既然版本都更新到11了，现在才来学8是不是太晚了？其实不是的，目前应该大部分都还是使用的Java 7和Java 8，这两个应该还是主流。而Java 8 又有一些激动人心的新特性，所以还是值得学习的。Java 8 新特性主要有以下几点：&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://changsk.top/categories/Java/"/>
    
    
  </entry>
  
</feed>
