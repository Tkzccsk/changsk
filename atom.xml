<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>changsk&#39;s blogs</title>
  
  <subtitle>chang.sk@foxmail.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://changsk.top/"/>
  <updated>2019-07-09T13:47:31.923Z</updated>
  <id>http://changsk.top/</id>
  
  <author>
    <name>changsk</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring中Bean的生命周期</title>
    <link href="http://changsk.top/2019/07/09/spring-bean-life-cycle/"/>
    <id>http://changsk.top/2019/07/09/spring-bean-life-cycle/</id>
    <published>2019-07-09T13:27:30.000Z</published>
    <updated>2019-07-09T13:47:31.923Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://segmentfault.com/a/1190000016065534" target="_blank" rel="noopener">Bean的生命周期</a></p></blockquote><p>正确理解spring容器中bean的生命周期很重要，有利于对bean的装配过程中进行一些自定义内容。如下图所示的生命周期：</p><a id="more"></a><p><img src="1.jpg" alt></p><p>如上图所见，在bean准备就绪之前，bean工厂执行了若干启动步骤，详细描述如下：</p><ul><li>spring对bean实例化；</li><li>spring将值和bean的引用注入到bean对应的属性中；</li><li>如果bean实现了BeanNameAware接口，spring将bean的id传递给setBeanName()方法，该方法的作用就是<strong>设置bean的id到BeanFactory中方便创建该bean，同时让bean知道自己在BeanFactory配置中的名字</strong>；</li><li>如果bean实现了BeanFactoryAware接口，spring将调用setBeanFactroy()方法，将BeanFactory容器实例传入，<strong>便于bean够获取配置他们的BeanFactory的引用</strong>；</li><li>如果bean实现了ApplicationContextAware接口，spring将调用setApplicationContext()方法，将bean所在应用上下文的引用传进来，<strong>便于bean获取它所在的Spring容器</strong>；</li><li>如果bean实现了BeanPostProcessor接口，spring将调用它的postProcessBeforeInitialization()方法，该方法在bean初始化之前调用；</li><li>如果bean实现了InitializingBean接口，spring将调用它的afterPropertiesSet()方法，当bean的所用属性被设置完成之后调用该方法；</li><li>如果bean实现了BeanPostProcessor接口，spring将调用它的postProcessAfterInitialization()方法，在bean初始化完成之后调用；</li><li>如果bean实现了DisposableBean接口，spring将调用它的destory()方法；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://segmentfault.com/a/1190000016065534&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Bean的生命周期&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;正确理解spring容器中bean的生命周期很重要，有利于对bean的装配过程中进行一些自定义内容。如下图所示的生命周期：&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://changsk.top/categories/Java/"/>
    
    
      <category term="Spring" scheme="http://changsk.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC执行流程及源码解析</title>
    <link href="http://changsk.top/2019/07/09/spring-mvc/"/>
    <id>http://changsk.top/2019/07/09/spring-mvc/</id>
    <published>2019-07-09T13:02:51.000Z</published>
    <updated>2019-07-09T13:16:41.263Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="[http://cxis.me/2017/04/06/SpringMVC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/](http://cxis.me/2017/04/06/SpringMVC执行流程及源码解析/)">SpringMVC执行流程及源码解析</a></p></blockquote><p>在<code>SpringMVC</code>中主要是围绕着<code>DispatcherServlet</code>来设计，可以把它当做<strong>指挥中心</strong>。这里先说明一下SpringMVC文档给出的执行流程，然后是我们稍微具体的执行流程，最后是流程大致的源码跟踪。关于很很很详细的源码解析，这里暂先不做。</p><a id="more"></a><h2 id="官方文档中的流程"><a href="#官方文档中的流程" class="headerlink" title="官方文档中的流程"></a>官方文档中的流程</h2><p>首先看下<code>SpringMVC</code>文档上给的流程图：</p><p><img src="1.jpg" alt></p><p>这张图片给了我们大概的执行流程：</p><ol><li>用户请求首先发送到<strong>前端控制器DispatcherServlet</strong>，DispatcherServlet根据请求的信息来决定使用哪个页面控制器Controller（也就是我们通常编写的Controller）来处理该请求。找到控制器之后，DispatcherServlet将请求委托给控制器去处理。</li><li>接下来页面控制器开始处理用户请求，页面控制器会根据请求信息进行处理，<strong>调用业务层</strong>等等，处理完成之后，会把结果封装成一个<strong>ModelAndView</strong>返回给DispatcherServlet。</li><li>前端控制器DispatcherServlet接到页面控制器的返回结果后，根据返回的视图名选择相应的试图模板，并根据返回的数据进行渲染。</li><li>最后前端控制器DispatcherServlet将结果返回给用户。</li></ol><h2 id="更具体的流程"><a href="#更具体的流程" class="headerlink" title="更具体的流程"></a>更具体的流程</h2><p>上面只是总体流程，接下来我们稍微深入一点，看下更具体的流程，这里没有图，只有步骤解析：</p><ol><li>用户请求发送到前端控制器DispatcherServlet。</li><li>前端控制器DispatcherServlet接收到请求后，DispatcherServlet会使用<code>HandlerMapping</code>来处理，<strong>HandlerMapping会查找到具体进行处理请求的Handler对象。</strong></li><li>HandlerMapping找到对应的Handler之后，并不是返回一个Handler原始对象，而是一个<strong>Handler执行链</strong>，在这个执行链中包括了拦截器和处理请求的Handler。HandlerMapping返回一个执行链给DispatcherServlet。</li><li>DispatcherServlet接收到执行链之后，<strong>会调用Handler适配器去执行Handler。</strong></li><li>Handler适配器执行完成Handler（也就是我们写的Controller）之后会得到一个ModelAndView，并返回给DispatcherServlet。</li><li>DispatcherServlet接收到<strong>Handler适配器</strong>返回的ModelAndView之后，<strong>会根据其中的视图名调用视图解析器。</strong></li><li>视图解析器根据逻辑视图名解析成一个真正的<strong>View视图</strong>，并返回给DispatcherServlet。</li><li>DispatcherServlet接收到视图之后，会根据上面的ModelAndView中的model来进行视图中数据的填充，也就是所谓的视图渲染。</li><li>渲染完成之后，DispatcherServlet就可以将结果返回给用户了。</li></ol><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>DispatcherServlet是一个Servlet，我们知道在Servlet在处理一个请求的时候会交给<strong>service</strong>方法进行处理，这里也不例外，DispatcherServlet继承了FrameworkServlet，首先进入FrameworkServlet的service方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="comment">//请求方法</span></span><br><span class="line">    String method = request.getMethod();</span><br><span class="line">    <span class="comment">//PATCH方法单独处理</span></span><br><span class="line">    <span class="keyword">if</span> (method.equalsIgnoreCase(RequestMethod.PATCH.name())) &#123;</span><br><span class="line">        processRequest(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//其他的请求类型的方法经由父类，也就是HttpServlet处理</span></span><br><span class="line">        <span class="keyword">super</span>.service(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HttpServlet中会根据请求类型的不同分别调用<strong>doGet</strong>或者<strong>doPost</strong>等方法，FrameworkServlet中已经重写了这些方法，在这些方法中会调用processRequest进行处理，在processRequest中会调用doService方法，这个doService方法就是在DispatcherServlet中实现的。下面就看下DispatcherServlet中的doService方法的实现。</p><h3 id="请求到达DispatcherServlet"><a href="#请求到达DispatcherServlet" class="headerlink" title="请求到达DispatcherServlet"></a>请求到达DispatcherServlet</h3><p>doService方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给request中的属性做一份快照</span></span><br><span class="line">    Map&lt;String, Object&gt; attributesSnapshot = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Taking snapshot of request attributes before include"</span>);</span><br><span class="line">        attributesSnapshot = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</span><br><span class="line">        <span class="keyword">while</span> (attrNames.hasMoreElements()) &#123;</span><br><span class="line">            String attrName = (String) attrNames.nextElement();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.cleanupAfterInclude || attrName.startsWith(<span class="string">"org.springframework.web.servlet"</span>)) &#123;</span><br><span class="line">                attributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果我们没有配置类似本地化或者主题的处理器之类的</span></span><br><span class="line">    <span class="comment">//SpringMVC会使用默认的值</span></span><br><span class="line">    <span class="comment">//默认配置文件是DispatcherServlet.properties</span></span><br><span class="line">    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class="line">    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.localeResolver);</span><br><span class="line">    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.themeResolver);</span><br><span class="line">    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span><br><span class="line"></span><br><span class="line">    FlashMap inputFlashMap = <span class="keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line">    <span class="keyword">if</span> (inputFlashMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">        request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">    &#125;</span><br><span class="line">    request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> FlashMap());</span><br><span class="line">    request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="keyword">this</span>.flashMapManager);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//开始处理</span></span><br><span class="line">        doDispatch(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Restore the original attribute snapshot, in case of an include.</span></span><br><span class="line">        <span class="keyword">if</span> (attributesSnapshot != <span class="keyword">null</span>) &#123;</span><br><span class="line">            restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DispatcherServlet开始真正的处理，doDispatch方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HttpServletRequest processedRequest = request;</span><br><span class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//SpringMVC中异步请求的相关知识，暂先不解释</span></span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">        Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//先检查是不是Multipart类型的，比如上传等</span></span><br><span class="line">            <span class="comment">//如果是Multipart类型的，则转换为MultipartHttpServletRequest类型</span></span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = processedRequest != request;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取当前请求的Handler</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span> || mappedHandler.getHandler() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取当前请求的Handler适配器</span></span><br><span class="line">            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对于header中last-modified的处理</span></span><br><span class="line">            String method = request.getMethod();</span><br><span class="line">            <span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line">            <span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line">                <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//拦截器的preHandle方法进行处理</span></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//真正调用Handler的地方</span></span><br><span class="line">                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//处理成默认视图名，就是添加前缀和后缀等</span></span><br><span class="line">            applyDefaultViewName(request, mv);</span><br><span class="line">            <span class="comment">//拦截器postHandle方法进行处理</span></span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            dispatchException = ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理最后的结果，渲染之类的都在这里</span></span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line">        triggerAfterCompletionWithError(processedRequest, response, mappedHandler, err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">            mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">        <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">            cleanupMultipart(processedRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到大概的步骤还是按照我们上面分析的走的。</p><h3 id="查找请求对应的Handler对象"><a href="#查找请求对应的Handler对象" class="headerlink" title="查找请求对应的Handler对象"></a>查找请求对应的Handler对象</h3><p>对应着这句代码<code>mappedHandler = getHandler(processedRequest, false);</code>，看下具体的getHandler方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request, <span class="keyword">boolean</span> cache)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getHandler(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往下看getHandler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//遍历所有的handlerMappings进行处理</span></span><br><span class="line">    <span class="comment">//handlerMappings是在启动的时候预先注册好的</span></span><br><span class="line">    <span class="keyword">for</span> (HandlerMapping hm : <span class="keyword">this</span>.handlerMappings) &#123;</span><br><span class="line">        HandlerExecutionChain handler = hm.getHandler(request);</span><br><span class="line">        <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> handler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往下看getHandler，在AbstractHandlerMapping类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//根据request获取handler</span></span><br><span class="line">    Object handler = getHandlerInternal(request);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//如果没有找到就使用默认的handler</span></span><br><span class="line">        handler = getDefaultHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果Handler是String，表明是一个bean名称</span></span><br><span class="line">    <span class="comment">//需要超照对应bean</span></span><br><span class="line">    <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String handlerName = (String) handler;</span><br><span class="line">        handler = getApplicationContext().getBean(handlerName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//封装Handler执行链</span></span><br><span class="line">    <span class="keyword">return</span> getHandlerExecutionChain(handler, request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="根据requrst获取handler"><a href="#根据requrst获取handler" class="headerlink" title="根据requrst获取handler"></a>根据requrst获取handler</h4><p>首先看下根据requrst获取handler步骤getHandlerInternal方法，在AbstractHandlerMethodMapping中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//获取request中的url，用来匹配handler</span></span><br><span class="line">    String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);</span><br><span class="line">    <span class="comment">//根据路径寻找Handler</span></span><br><span class="line">    HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);</span><br><span class="line">    <span class="comment">//根据handlerMethod中的bean来实例化Handler并添加进HandlerMethod</span></span><br><span class="line">    <span class="keyword">return</span> (handlerMethod != <span class="keyword">null</span>) ? handlerMethod.createWithResolvedBean() : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下根据路径寻找handler的方法lookupHandlerMethod：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">lookupHandlerMethod</span><span class="params">(String lookupPath, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    List&lt;Match&gt; matches = <span class="keyword">new</span> ArrayList&lt;Match&gt;();</span><br><span class="line"><span class="comment">//直接匹配</span></span><br><span class="line">    List&lt;T&gt; directPathMatches = <span class="keyword">this</span>.urlMap.get(lookupPath);</span><br><span class="line">    <span class="comment">//如果有匹配的，就添加进匹配列表中</span></span><br><span class="line">    <span class="keyword">if</span> (directPathMatches != <span class="keyword">null</span>) &#123;</span><br><span class="line">        addMatchingMappings(directPathMatches, matches, request);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//还没有匹配的，就遍历所有的处理方法查找</span></span><br><span class="line">    <span class="keyword">if</span> (matches.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// No choice but to go through all mappings</span></span><br><span class="line">        addMatchingMappings(<span class="keyword">this</span>.handlerMethods.keySet(), matches, request);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//找到了匹配的</span></span><br><span class="line">    <span class="keyword">if</span> (!matches.isEmpty()) &#123;</span><br><span class="line">        Comparator&lt;Match&gt; comparator = <span class="keyword">new</span> MatchComparator(getMappingComparator(request));</span><br><span class="line">        Collections.sort(matches, comparator);</span><br><span class="line"><span class="comment">//排序之后，获取第一个</span></span><br><span class="line">        Match bestMatch = matches.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//如果有多个匹配的，会找到第二个最合适的进行比较一下</span></span><br><span class="line">        <span class="keyword">if</span> (matches.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            Match secondBestMatch = matches.get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (comparator.compare(bestMatch, secondBestMatch) == <span class="number">0</span>) &#123;</span><br><span class="line">                Method m1 = bestMatch.handlerMethod.getMethod();</span><br><span class="line">                Method m2 = secondBestMatch.handlerMethod.getMethod();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                        <span class="string">"Ambiguous handler methods mapped for HTTP path '"</span> + request.getRequestURL() + <span class="string">"': &#123;"</span> +</span><br><span class="line">                        m1 + <span class="string">", "</span> + m2 + <span class="string">"&#125;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//设置request参数</span></span><br><span class="line">        handleMatch(bestMatch.mapping, lookupPath, request);</span><br><span class="line">        <span class="comment">//返回匹配的url的处理的方法</span></span><br><span class="line">        <span class="keyword">return</span> bestMatch.handlerMethod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//最后还没有找到，返回null</span></span><br><span class="line">        <span class="keyword">return</span> handleNoMatch(handlerMethods.keySet(), lookupPath, request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取默认Handler"><a href="#获取默认Handler" class="headerlink" title="获取默认Handler"></a>获取默认Handler</h4><p>如果上面没有获取到Handler，就会获取默认的Handler。如果还获取不到就返回null。</p><h4 id="处理String类型的Handler"><a href="#处理String类型的Handler" class="headerlink" title="处理String类型的Handler"></a>处理String类型的Handler</h4><p>如果上面处理完的Handler是String类型的，就会根据这个handlerName获取bean。</p><h4 id="封装Handler执行链"><a href="#封装Handler执行链" class="headerlink" title="封装Handler执行链"></a>封装Handler执行链</h4><p>上面获取完Handler，就开始封装执行链了，就是将我们配置的拦截器加入到执行链中去，getHandlerExecutionChain：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandlerExecutionChain</span><span class="params">(Object handler, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果当前Handler不是执行链类型，就使用一个新的执行链实例封装起来</span></span><br><span class="line">    HandlerExecutionChain chain =</span><br><span class="line">        (handler <span class="keyword">instanceof</span> HandlerExecutionChain) ?</span><br><span class="line">            (HandlerExecutionChain) handler : <span class="keyword">new</span> HandlerExecutionChain(handler);</span><br><span class="line"><span class="comment">//先获取适配类型的拦截器添加进去拦截器链</span></span><br><span class="line">    chain.addInterceptors(getAdaptedInterceptors());</span><br><span class="line"><span class="comment">//当前的url</span></span><br><span class="line">    String lookupPath = urlPathHelper.getLookupPathForRequest(request);</span><br><span class="line">    <span class="comment">//遍历拦截器，找到跟当前url对应的，添加进执行链中去</span></span><br><span class="line">    <span class="keyword">for</span> (MappedInterceptor mappedInterceptor : mappedInterceptors) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mappedInterceptor.matches(lookupPath, pathMatcher)) &#123;</span><br><span class="line">            chain.addInterceptor(mappedInterceptor.getInterceptor());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取对应请求的Handler适配器"><a href="#获取对应请求的Handler适配器" class="headerlink" title="获取对应请求的Handler适配器"></a>获取对应请求的Handler适配器</h3><p>getHandlerAdapter：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerAdapter <span class="title">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="comment">//遍历所有的HandlerAdapter，找到和当前Handler匹配的就返回</span></span><br><span class="line">    <span class="comment">//我们这里会匹配到RequestMappingHandlerAdapter</span></span><br><span class="line">    <span class="keyword">for</span> (HandlerAdapter ha : <span class="keyword">this</span>.handlerAdapters) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ha.supports(handler)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ha;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓存的处理"><a href="#缓存的处理" class="headerlink" title="缓存的处理"></a>缓存的处理</h3><p>也就是对last-modified的处理</p><h3 id="执行拦截器的preHandle方法"><a href="#执行拦截器的preHandle方法" class="headerlink" title="执行拦截器的preHandle方法"></a>执行拦截器的preHandle方法</h3><p>就是遍历所有的我们定义的interceptor，执行preHandle方法</p><h3 id="使用Handler适配器执行当前的Handler"><a href="#使用Handler适配器执行当前的Handler" class="headerlink" title="使用Handler适配器执行当前的Handler"></a>使用Handler适配器执行当前的Handler</h3><p>ha.handle执行当前Handler，我们这里使用的是RequestMappingHandlerAdapter，首先会进入AbstractHandlerMethodAdapter的handle方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> handleInternal(request, response, (HandlerMethod) handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>handleInternal方法，在RequestMappingHandlerAdapter中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> ModelAndView <span class="title">handleInternal</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">        HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123;</span><br><span class="line">        <span class="comment">// Always prevent caching in case of session attribute management.</span></span><br><span class="line">        checkAndPrepare(request, response, <span class="keyword">this</span>.cacheSecondsForSessionAttributeHandlers, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Uses configured default cacheSeconds setting.</span></span><br><span class="line">        checkAndPrepare(request, response, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute invokeHandlerMethod in synchronized block if required.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.synchronizeOnSession) &#123;</span><br><span class="line">        HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object mutex = WebUtils.getSessionMutex(session);</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">                <span class="keyword">return</span> invokeHandleMethod(request, response, handlerMethod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//执行方法，封装ModelAndView</span></span><br><span class="line">    <span class="keyword">return</span> invokeHandleMethod(request, response, handlerMethod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组装默认视图名称"><a href="#组装默认视图名称" class="headerlink" title="组装默认视图名称"></a>组装默认视图名称</h3><p>前缀和后缀名都加上</p><h3 id="执行拦截器的postHandle方法"><a href="#执行拦截器的postHandle方法" class="headerlink" title="执行拦截器的postHandle方法"></a>执行拦截器的postHandle方法</h3><p>遍历intercepter的postHandle方法。</p><h3 id="处理最后的结果，渲染之类的"><a href="#处理最后的结果，渲染之类的" class="headerlink" title="处理最后的结果，渲染之类的"></a>处理最后的结果，渲染之类的</h3><p>processDispatchResult方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">        HandlerExecutionChain mappedHandler, ModelAndView mv, Exception exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> errorView = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ModelAndViewDefiningException) &#123;</span><br><span class="line">            mv = ((ModelAndViewDefiningException) exception).getModelAndView();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object handler = (mappedHandler != <span class="keyword">null</span> ? mappedHandler.getHandler() : <span class="keyword">null</span>);</span><br><span class="line">            mv = processHandlerException(request, response, handler, exception);</span><br><span class="line">            errorView = (mv != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Did the handler return a view to render?</span></span><br><span class="line">    <span class="keyword">if</span> (mv != <span class="keyword">null</span> &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">    <span class="comment">//渲染</span></span><br><span class="line">        render(mv, request, response);</span><br><span class="line">        <span class="keyword">if</span> (errorView) &#123;</span><br><span class="line">            WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">        <span class="comment">// Concurrent handling started during a forward</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mappedHandler.triggerAfterCompletion(request, response, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点看下render方法，进行渲染：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//设置本地化</span></span><br><span class="line">    Locale locale = <span class="keyword">this</span>.localeResolver.resolveLocale(request);</span><br><span class="line">    response.setLocale(locale);</span><br><span class="line"></span><br><span class="line">    View view;</span><br><span class="line">    <span class="keyword">if</span> (mv.isReference()) &#123;</span><br><span class="line">        <span class="comment">//解析视图名，得到视图</span></span><br><span class="line">        view = resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No need to lookup: the ModelAndView object contains the actual View object.</span></span><br><span class="line">        view = mv.getView();</span><br><span class="line">        <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"ModelAndView ["</span> + mv + <span class="string">"] neither contains a view name nor a "</span> +</span><br><span class="line">                    <span class="string">"View object in servlet with name '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//委托给视图进行渲染</span></span><br><span class="line">    view.render(mv.getModelInternal(), request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>view.render就是进行视图的渲染，然后跳转页面等处理。</p><p>到这里大概的流程就走完了。其中涉及到的东西还有很多，暂先不做详细处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;[http://cxis.me/2017/04/06/SpringMVC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/](http://cxis.me/2017/04/06/SpringMVC执行流程及源码解析/)&quot;&gt;SpringMVC执行流程及源码解析&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;code&gt;SpringMVC&lt;/code&gt;中主要是围绕着&lt;code&gt;DispatcherServlet&lt;/code&gt;来设计，可以把它当做&lt;strong&gt;指挥中心&lt;/strong&gt;。这里先说明一下SpringMVC文档给出的执行流程，然后是我们稍微具体的执行流程，最后是流程大致的源码跟踪。关于很很很详细的源码解析，这里暂先不做。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://changsk.top/categories/Java/"/>
    
    
      <category term="Spring" scheme="http://changsk.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>常见加密算法原理及概念</title>
    <link href="http://changsk.top/2019/07/09/common-encryption-algorithm/"/>
    <id>http://changsk.top/2019/07/09/common-encryption-algorithm/</id>
    <published>2019-07-09T12:30:42.000Z</published>
    <updated>2019-07-09T12:53:48.498Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://www.jianshu.com/p/ce3893a7be09" target="_blank" rel="noopener">常见加密算法原理及概念</a></p></blockquote><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>在安全领域，利用<strong>密钥加密算法</strong>来对通信的过程进行加密是一种常见的安全手段。利用该手段能够保障数据安全通信的三个目标：</p><blockquote><p>1、数据的保密性，防止用户的数据被窃取或泄露；<br> 2、保证数据的完整性，防止用户传输的数据被篡改；<br> 3、通信双方的身份确认，确保数据来源与合法的用户；</p></blockquote><p>而常见的密钥加密算法类型大体可以分为三类：<strong>对称加密</strong>、<strong>非对称加密</strong>、<strong>单向加密</strong>。下面我们来了解下相关的算法原理及其常见的算法。</p><a id="more"></a><h4 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h4><p>对称加密算法采用<strong>单密钥加密</strong>，在通信过程中，数据发送方将原始数据分割成固定大小的块，经过密钥和加密算法逐个加密后，发送给接收方；接收方收到加密后的报文后，结合密钥和解密算法解密组合后得出原始数据。由于<strong>加解密算法是公开的</strong>，因此在这过程中，密钥的安全传递就成为了至关重要的事了。而密钥通常来说是通过双方协商，以物理的方式传递给对方，或者利用第三方平台传递给对方，一旦这过程出现了密钥泄露，不怀好意的人就能结合相应的算法拦截解密出其加密传输的内容。</p><p><img src="1.jpg" alt="img"></p><p>对称加密算法原理</p><p>对称加密算法拥有着<strong>算法公开</strong>、<strong>计算量小</strong>、<strong>加密速度和效率高</strong>的特点，但是也有着<strong>密钥单一</strong>、<strong>密钥管理困难</strong>等缺点。</p><p>常见的对称加密算法有：<br> <strong>DES</strong>：分组式加密算法，以64位为分组对数据加密，加解密使用同一个算法。<br> <strong>3DES</strong>：三重数据加密算法，<strong>对每个数据块应用三次DES加密算法。</strong><br> <strong>AES</strong>：高级加密标准算法，是美国联邦政府采用的一种区块加密标准，用于替代原先的DES，目前已被广泛应用。<br> <strong>Blowfish</strong>：Blowfish算法是一个64位分组及可变密钥长度的对称密钥分组密码算法，可用来加密64比特长度的字符串。</p><h4 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h4><p>非对称加密算法采用<strong>公钥</strong>和<strong>私钥</strong>两种不同的密码来进行加解密。<strong>公钥和私钥是成对存在</strong>，公钥是从私钥中提取产生公开给所有人的，如果使用公钥对数据进行加密，那么只有对应的私钥才能解密，反之亦然。<br> 下图为简单非对称加密算法的常见流程：</p><p><img src="2.jpg" alt="img"></p><p>非对称加密流程</p><p>发送方Bob从接收方Alice获取其对应的公钥，并结合相应的非对称算法将明文加密后发送给Alice；Alice接收到加密的密文后，结合自己的私钥和非对称算法解密得到明文。这种简单的非对称加密算法的应用其安全性比对称加密算法来说要高，但是其不足之处在于<strong>无法确认公钥的来源合法性</strong>以及<strong>数据的完整性</strong>。 非对称加密算法具有<strong>安全性高</strong>、<strong>算法强度负复杂</strong>的优点，其缺点为<strong>加解密耗时长</strong>、<strong>速度慢</strong>，<strong>只适合对少量数据进行加密</strong>，其常见算法包括：<br> <strong>RSA</strong>：RSA算法基于一个十分简单的数论事实：<strong>将两个大素数相乘十分容易，但那时想要对其乘积进行因式分解却极其困难</strong>，<strong>因此可以将乘积公开作为加密密钥，可用于加密，也能用于签名。</strong><br> <strong>DSA</strong>：数字签名算法，仅能用于签名，不能用于加解密。<br> <strong>DSS</strong>：数字签名标准，技能用于签名，也可以用于加解密。<br> <strong>ELGamal</strong>：利用离散对数的原理对数据进行加解密或数据签名，其速度是最慢的。</p><h4 id="单向加密"><a href="#单向加密" class="headerlink" title="单向加密"></a>单向加密</h4><p>单向加密算法常用于提取数据指纹，<strong>验证数据的完整性</strong>。发送者将明文通过单向加密算法加密生成<strong>定长的密文串</strong>，然后传递给接收方。接收方在收到加密的报文后进行解密，将解密获取到的明文使用相同的单向加密算法进行加密，得出加密后的密文串。随后将之与发送者发送过来的密文串进行对比，若发送前和发送后的密文串相一致，则说明传输过程中数据没有损坏；若不一致，说明传输过程中数据丢失了。单向加密算法只能用于对数据的加密，无法被解密，其特点为定长输出、雪崩效应。常见的算法包括：<strong>MD5</strong>、<strong>sha1</strong>、<strong>sha224</strong>等等，其常见用途包括：<strong>数字摘要</strong>、<strong>数字签名</strong>等等。</p><p><img src="3.jpg" alt="img"></p><p>单向加密校验过程</p><h4 id="密钥交换"><a href="#密钥交换" class="headerlink" title="密钥交换"></a>密钥交换</h4><p>密钥交换IKE（Internet Key Exchange）通常是指<strong>双方通过交换密钥来实现数据加密和解密</strong>，常见的密钥交换方式有下面两种：<br> 1、公钥加密，将公钥加密后通过网络传输到对方进行解密，这种方式缺点在于具有很大的可能性被拦截破解，因此不常用；<br> 2、Diffie-Hellman，<strong>DH算法是一种密钥交换算法</strong>，其既不用于加密，也不产生数字签名。DH算法的巧妙在于需要安全通信的双方可以用这个方法确定对称密钥。然后可以用这个密钥进行加密和解密。但是注意，<strong>这个密钥交换协议/算法只能用于密钥的交换，而不能进行消息的加密和解密</strong>。双方确定要用的密钥后，要使用其他对称密钥操作加密算法实际加密和解密消息。DH算法通过双方共有的参数、私有参数和算法信息来进行加密，然后双方将计算后的结果进行交换，交换完成后再和属于自己私有的参数进行特殊算法，经过双方计算后的结果是相同的，此结果即为密钥。<br> 如：</p><blockquote><p>A 有p和g两个参数，A还有一个属于自己的私有参数x；<br> B 有p和g两个参数，B还有一个属于自己的私有参数y；<br> A和B均使用相同的加密算法计算其对应的值：value_A=px%g，value_B=py%g<br> 随后双方交换计算后的值，然后再分别使用自己的私有参数对去求次方，如：<br> A拿到value_B值后，对其求x次方得(py%g)x=p^xy%g；<br> B拿到value_A值后，对其求y次方得(px%g)y=p^xy%g；<br> 最终得到的结果是一致的。</p></blockquote><p>在整个过程中，<strong>第三方人员只能获取p、g两个值</strong>，AB双方交换的是计算后的结果，因此这种方式是很安全的。</p><h4 id="公钥基础设施（PKI）"><a href="#公钥基础设施（PKI）" class="headerlink" title="公钥基础设施（PKI）"></a>公钥基础设施（PKI）</h4><p><strong>公钥基础设施</strong>是一个包括硬件、软件、人员、策略和规程的集合，用于实现基于公钥密码机制的密钥和证书的生成、管理、存储、分发和撤销的功能，其组成包括：<strong>签证机构CA</strong>、注册机构RA、证书吊销列表CRL和证书存取库CB。<br> PKI采用<strong>证书管理公钥</strong>，通过第三方可信任CA中心，<strong>把用户的公钥和其他用户信息组生成证书，用于验证用户的身份。</strong><br> 公钥证书是以数字签名的方式声明，它将公钥的值绑定到持有对应私钥的个人、设备或服务身份。公钥证书的生成遵循X.509协议的规定，其内容包括：<code>证书名称、证书版本、序列号、算法标识、颁发者、有效期、有效起始日期、有效终止日期、公钥 、证书签名等等的内容</code>。</p><p>CA证书认证的流程如下图，Bob为了向Alice证明<strong>自己是Bob和某个公钥是自己的</strong>，她便向一个Bob和Alice<strong>都信任的CA机构申请证书</strong>，Bob先自己生成了一对密钥对（私钥和公钥），把自己的私钥保存在自己电脑上，然后把公钥给CA申请证书，<strong>CA接受申请于是给Bob颁发了一个数字证书，证书中包含了Bob的那个公钥以及其它身份信息</strong>，当然，<strong>CA会计算这些信息的消息摘要并用自己的私钥加密消息摘要（数字签名）一并附在Bob的证书上，以此来证明这个证书就是CA自己颁发的。</strong>Alice得到Bob的证书后用CA的证书（自签署的）中的公钥来解密消息摘要，随后将摘要和Bob的公钥发送到CA服务器上进行核对。CA在接收到Alice的核对请求后，会根据Alice提供的信息核对Bob的证书是否合法，如果确认合法则回复Alice证书合法。Alice收到CA的确认回复后，再去使用从证书中<strong>获取的Bob的公钥加密邮件然后发送给Bob，Bob接收后再以自己的私钥进行解密。</strong></p><p><img src="4.jpg" alt="img"></p><p>​                                                                          CA证书认证流程</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://www.jianshu.com/p/ce3893a7be09&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;常见加密算法原理及概念&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;p&gt;在安全领域，利用&lt;strong&gt;密钥加密算法&lt;/strong&gt;来对通信的过程进行加密是一种常见的安全手段。利用该手段能够保障数据安全通信的三个目标：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、数据的保密性，防止用户的数据被窃取或泄露；&lt;br&gt; 2、保证数据的完整性，防止用户传输的数据被篡改；&lt;br&gt; 3、通信双方的身份确认，确保数据来源与合法的用户；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而常见的密钥加密算法类型大体可以分为三类：&lt;strong&gt;对称加密&lt;/strong&gt;、&lt;strong&gt;非对称加密&lt;/strong&gt;、&lt;strong&gt;单向加密&lt;/strong&gt;。下面我们来了解下相关的算法原理及其常见的算法。&lt;/p&gt;
    
    </summary>
    
      <category term="密码学" scheme="http://changsk.top/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL存储引擎-InnoDB与MyISAM的区别</title>
    <link href="http://changsk.top/2019/07/09/mysql-innodb-myisam/"/>
    <id>http://changsk.top/2019/07/09/mysql-innodb-myisam/</id>
    <published>2019-07-09T11:46:02.000Z</published>
    <updated>2019-07-09T12:20:19.394Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://segmentfault.com/a/1190000008227211" target="_blank" rel="noopener">MySQL存储引擎－－MyISAM与InnoDB区别</a></p></blockquote><p>MyISAM是MySQL的默认数据库引擎（5.5版之前），由早期的ISAM（Indexed Sequential Access Method：有索引的顺序访问方法）所改良。虽然性能极佳，但却有一个缺点：<strong>不支持事务处理</strong>（transaction）。不过，在这几年的发展下，MySQL也导入了InnoDB（另一种数据库引擎），以强化参考完整性与并发违规处理机制，后来就逐渐取代MyISAM。</p><p>InnoDB，是MySQL的数据库引擎之一，为MySQL AB发布binary的标准之一。InnoDB由Innobase Oy公司所开发，2006年五月时由甲骨文公司并购。与传统的ISAM与MyISAM相比，<strong>InnoDB的最大特色就是支持了ACID兼容的事务（Transaction）功能</strong>，类似于PostgreSQL。目前InnoDB采用双轨制授权，一是GPL授权，另一是专有软件授权。</p><a id="more"></a><h2 id="MyISAM与InnoDB的区别是什么？"><a href="#MyISAM与InnoDB的区别是什么？" class="headerlink" title="MyISAM与InnoDB的区别是什么？"></a>MyISAM与InnoDB的区别是什么？</h2><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>MyISAM：每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。<strong>.frm文件存储表定义</strong>。<strong>数据文件</strong>的扩展名为.MYD (MYData)。<strong>索引文件</strong>的扩展名是.MYI (MYIndex)。<br>InnoDB：<strong>所有的表都保存在同一个数据文件中</strong>（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。</p><h3 id="存储空间"><a href="#存储空间" class="headerlink" title="存储空间"></a>存储空间</h3><p>MyISAM：<strong>可被压缩，存储空间较小</strong>。支持三种不同的存储格式：<strong>静态表</strong>(默认，但是注意数据末尾不能有空格，会被去掉)、<strong>动态表</strong>、<strong>压缩表</strong>。InnoDB：需要更多的内存和存储，<strong>它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。</strong></p><h3 id="可移植性、备份及恢复"><a href="#可移植性、备份及恢复" class="headerlink" title="可移植性、备份及恢复"></a>可移植性、备份及恢复</h3><p>MyISAM：数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。<br>InnoDB：免费的方案可以是拷贝数据文件、备份 binlog，或者用 <strong>mysqldump</strong>，在数据量达到几十G的时候就相对痛苦了。</p><h3 id="事务支持"><a href="#事务支持" class="headerlink" title="事务支持"></a>事务支持</h3><p>MyISAM：<strong>强调的是性能</strong>，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。<br>InnoDB：<strong>提供事务支持事务</strong>，<strong>外部键</strong>等高级数据库功能。 <strong>具有事务(commit)、回滚(rollback)和崩溃修复能力</strong>(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</p><h3 id="AUTO-INCREMENT"><a href="#AUTO-INCREMENT" class="headerlink" title="AUTO_INCREMENT"></a>AUTO_INCREMENT</h3><p>MyISAM：可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。<br>InnoDB：InnoDB中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。</p><h3 id="表锁差异"><a href="#表锁差异" class="headerlink" title="表锁差异"></a>表锁差异</h3><p>MyISAM：<strong>只支持表级锁</strong>，用户在操作myisam表时，<strong>select，update，delete，insert语句都会给表自动加锁</strong>，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。<br>InnoDB：<strong>支持事务和行级锁</strong>，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，<strong>只是在WHERE的主键是有效的</strong>，非主键的WHERE都会锁全表的。</p><h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>MyISAM：支持 FULLTEXT类型的全文索引<br>InnoDB：不支持FULLTEXT类型的全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好。</p><h3 id="表主键"><a href="#表主键" class="headerlink" title="表主键"></a>表主键</h3><p>MyISAM：<strong>允许没有任何索引和主键的表存在</strong>，索引都是保存行的地址。<br>InnoDB：如果没有设定<strong>主键</strong>或者<strong>非空唯一索引</strong>，<strong>就会自动生成一个6字节的主键(用户不可见)</strong>，<strong>数据是主索引的一部分，附加索引保存的是主索引的值。</strong></p><h3 id="表的具体行数"><a href="#表的具体行数" class="headerlink" title="表的具体行数"></a>表的具体行数</h3><p>MyISAM：保存有表的总行数，如果select count(<em>) from table;会直接取出出该值。<br>InnoDB：没有保存表的总行数，如果使用select count(</em>) from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。</p><h3 id="CURD操作"><a href="#CURD操作" class="headerlink" title="CURD操作"></a>CURD操作</h3><p>MyISAM：<strong>如果执行大量的SELECT</strong>，MyISAM是更好的选择。<br>InnoDB：如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE 从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，<strong>在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。</strong></p><h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><p>MyISAM：不支持<br>InnoDB：支持</p><p>通过上述的分析，基本上可以考虑使用InnoDB来替代MyISAM引擎了，原因是InnoDB自身很多良好的特点，比如<strong>事务支持</strong>、存储 过程、视图、<strong>行级锁定</strong>等等，在并发很多的情况下，相信InnoDB的表现肯定要比MyISAM强很多。另外，任何一种表都不是万能的，<strong>只用恰当的针对业务类型来选择合适的表类型</strong>，才能最大的发挥MySQL的性能优势。如果不是很复杂的Web应用，非关键应用，还是可以继续考虑MyISAM的，这个具体情况可以自己斟酌。</p><p>存储引擎选择的基本原则</p><p>采用MyISAM引擎</p><ul><li><strong>R/W &gt; 100:1 且update相对较少(读多写少)</strong></li><li><strong>并发不高</strong></li><li><strong>表数据量小</strong></li><li>硬件资源有限</li></ul><p>采用InnoDB引擎</p><ul><li>R/W比较小，频繁更新大字段</li><li>表数据量超过1000万，并发高</li><li>安全性和可用性要求高</li></ul><p>采用Memory引擎</p><ul><li><p>有足够的内存</p></li><li><p>对数据一致性要求不高，如在线人数和session等应用</p></li><li><p>需要定期归档数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">摘自：《PHP核心技术与最佳实践》</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://segmentfault.com/a/1190000008227211&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MySQL存储引擎－－MyISAM与InnoDB区别&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;MyISAM是MySQL的默认数据库引擎（5.5版之前），由早期的ISAM（Indexed Sequential Access Method：有索引的顺序访问方法）所改良。虽然性能极佳，但却有一个缺点：&lt;strong&gt;不支持事务处理&lt;/strong&gt;（transaction）。不过，在这几年的发展下，MySQL也导入了InnoDB（另一种数据库引擎），以强化参考完整性与并发违规处理机制，后来就逐渐取代MyISAM。&lt;/p&gt;
&lt;p&gt;InnoDB，是MySQL的数据库引擎之一，为MySQL AB发布binary的标准之一。InnoDB由Innobase Oy公司所开发，2006年五月时由甲骨文公司并购。与传统的ISAM与MyISAM相比，&lt;strong&gt;InnoDB的最大特色就是支持了ACID兼容的事务（Transaction）功能&lt;/strong&gt;，类似于PostgreSQL。目前InnoDB采用双轨制授权，一是GPL授权，另一是专有软件授权。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://changsk.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="InnoDB" scheme="http://changsk.top/tags/InnoDB/"/>
    
      <category term="MyISAM" scheme="http://changsk.top/tags/MyISAM/"/>
    
  </entry>
  
  <entry>
    <title>一条SQL语句执行得很慢的原因有哪些？</title>
    <link href="http://changsk.top/2019/07/09/mysql-sql-slow/"/>
    <id>http://changsk.top/2019/07/09/mysql-sql-slow/</id>
    <published>2019-07-09T08:34:18.000Z</published>
    <updated>2019-07-09T08:51:14.393Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自公众号:苦逼的码农 作者：帅地</p></blockquote><p>说实话，这个问题可以涉及到 <code>MySQL</code> 的很多核心知识，可以扯出一大堆，就像要考你计算机网络的知识时，问你“输入URL回车之后，究竟发生了什么”一样，看看你能说出多少了。</p><p>之前腾讯面试的实话，也问到这个问题了，不过答的很不好，之前没去想过相关原因，导致一时之间扯不出来。所以今天，我带大家来详细扯一下有哪些原因，相信你看完之后一定会有所收获，不然你打我。</p><a id="more"></a><h2 id="开始装逼：分类讨论"><a href="#开始装逼：分类讨论" class="headerlink" title="开始装逼：分类讨论"></a>开始装逼：分类讨论</h2><p>一条 SQL 语句执行的很慢，那是每次执行都很慢呢？还是大多数情况下是正常的，偶尔出现很慢呢？所以我觉得，我们还得分以下两种情况来讨论。</p><p><strong>1、大多数情况是正常的，只是偶尔会出现很慢的情况。</strong></p><p><strong>2、在数据量不变的情况下，这条SQL语句一直以来都执行的很慢。</strong></p><p>针对这两种情况，我们来分析下可能是哪些原因导致的。</p><h2 id="针对偶尔很慢的情况"><a href="#针对偶尔很慢的情况" class="headerlink" title="针对偶尔很慢的情况"></a>针对偶尔很慢的情况</h2><p>一条 SQL 大多数情况正常，偶尔才能出现很慢的情况，针对这种情况，我觉得<strong>这条SQL语句的书写本身是没什么问题的</strong>，而是其他原因导致的，那会是什么原因呢？</p><h3 id="数据库在刷新脏页（flush）我也无奈啊"><a href="#数据库在刷新脏页（flush）我也无奈啊" class="headerlink" title="数据库在刷新脏页（flush）我也无奈啊"></a>数据库在刷新脏页（flush）我也无奈啊</h3><p>当我们要往数据库插入一条数据、或者要更新一条数据的时候，我们知道数据库会在<strong>内存</strong>中把对应字段的数据更新了，但是更新之后，这些更新的字段并不会马上同步持久化到<strong>磁盘</strong>中去，而是把这些更新的记录写入到 <code>redo log</code>日记中去，等到空闲的时候，在通过 redo log 里的日记把最新的数据同步到<strong>磁盘</strong>中去。</p><blockquote><p>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。</p></blockquote><p><strong>刷脏页有下面4种场景（后两种不用太关注“性能”问题）：</strong></p><ul><li><strong>redolog写满了：</strong>redo log 里的容量是有限的，如果数据库一直很忙，更新又很频繁，这个时候 redo log 很快就会被写满了，这个时候就没办法等到空闲的时候再把数据同步到磁盘的，只能暂停其他操作，全身心来把数据同步到磁盘中去的，而这个时候，<strong>就会导致我们平时正常的SQL语句突然执行的很慢</strong>，所以说，数据库在在同步数据到磁盘的时候，就有可能导致我们的SQL语句执行的很慢了。</li><li><strong>内存不够用了：</strong>如果一次查询较多的数据，恰好碰到所查数据页不在内存中时，需要申请内存，而此时恰好内存不足的时候就需要淘汰一部分内存数据页，如果是干净页，就直接释放，如果恰好是脏页就需要刷脏页。</li><li><strong>MySQL 认为系统“空闲”的时候：</strong>这时系统没什么压力。</li><li><strong>MySQL 正常关闭的时候：</strong>这时候，MySQL 会把内存的脏页都 flush 到磁盘上，这样下次 MySQL 启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</li></ul><h3 id="拿不到锁我能怎么办"><a href="#拿不到锁我能怎么办" class="headerlink" title="拿不到锁我能怎么办"></a>拿不到锁我能怎么办</h3><p>这个就比较容易想到了，我们要执行的这条语句，刚好这条语句涉及到的<strong>表</strong>，别人在用，并且加锁了，我们拿不到锁，只能慢慢等待别人释放锁了。或者，表没有加锁，但要使用到的某个一行被加锁了，这个时候，我也没办法啊。</p><p>如果要判断是否真的在等待锁，我们可以用 <strong>show processlist</strong>这个命令来查看当前的状态哦，这里我要提醒一下，有些命令最好记录一下，反正，我被问了好几个命令，都不知道怎么写，呵呵。</p><p>下来我们来访分析下第二种情况，我觉得第二种情况的分析才是最重要的</p><h2 id="针对一直都这么慢的情况"><a href="#针对一直都这么慢的情况" class="headerlink" title="针对一直都这么慢的情况"></a>针对一直都这么慢的情况</h2><p>如果在数据量一样大的情况下，这条 SQL 语句每次都执行的这么慢，那就就要好好考虑下你的 <code>SQL</code> 书写了，下面我们来分析下哪些原因会导致我们的 SQL 语句执行的很不理想。</p><p>我们先来假设我们有一个表，表里有下面两个字段,分别是主键 id，和两个普通字段 c 和 d。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  `d` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure><h3 id="扎心了，没用到索引"><a href="#扎心了，没用到索引" class="headerlink" title="扎心了，没用到索引"></a>扎心了，没用到索引</h3><p>没有用上索引，我觉得这个原因是很多人都能想到的，例如你要查询这条语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="number">100</span> &lt;c <span class="keyword">and</span> c &lt; <span class="number">100000</span>;</span><br></pre></td></tr></table></figure><p><strong>（1）、字段没有索引</strong></p><p>刚好你的 c 字段上没有索引，那么抱歉，只能走<strong>全表扫描</strong>了，你就体验不会索引带来的乐趣了，所以，这回导致这条查询语句很慢。</p><p><strong>（2）、字段有索引，但却没有用索引</strong></p><p>好吧，这个时候你给 c 这个字段加上了索引，然后又查询了一条语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> c - <span class="number">1</span> = <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><p>我想问大家一个问题，这样子在查询的时候会用索引查询吗？</p><p>答是不会，如果我们在字段的左边做了运算，那么很抱歉，在查询的时候，就不会用上索引了，所以呢，大家要注意这种<strong>字段上有索引，但由于自己的疏忽，导致系统没有使用索引</strong>的情况了。</p><p>正确的查询应该如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> c = <span class="number">1000</span> + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>有人可能会说，右边有运算就能用上索引？难道数据库就不会自动帮我们优化一下，自动把 c - 1=1000 自动转换为 c = 1000+1。</p><p>不好意思，确实不会帮你，所以，你要注意了。</p><p><strong>（3）、函数操作导致没有用上索引</strong></p><p>如果我们在查询的时候，对字段进行了函数操作，也是会导致没有用上索引的，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where pow(c,2) = 1000;</span><br></pre></td></tr></table></figure><p>这里我只是做一个例子，假设函数 pow 是求 c 的 n 次方，实际上可能并没有 pow(c,2)这个函数。其实这个和上面在左边做运算也是很类似的。</p><p>所以呢，一条语句执行都很慢的时候，可能是该语句没有用上索引了，不过具体是啥原因导致没有用上索引的呢，你就要会分析了，我上面列举的三个原因，应该是出现的比较多的吧。</p><h3 id="呵呵，数据库自己选错索引了"><a href="#呵呵，数据库自己选错索引了" class="headerlink" title="呵呵，数据库自己选错索引了"></a>呵呵，数据库自己选错索引了</h3><p>我们在进行查询操作的时候，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where 100 &lt; c and c &lt; 100000;</span><br></pre></td></tr></table></figure><p>我们知道，主键索引和非主键索引是有区别的，主键索引存放的值是<strong>整行字段的数据</strong>，而非主键索引上存放的值不是整行字段的数据，而且存放<strong>主键字段的值</strong>。不大懂的可以看这篇文章：  <a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484848&idx=1&sn=77a0e6e82944ec385f5df17e91ce3bf2&chksm=cea24a7bf9d5c36d4b289cccb017292f9f36da9f3c887fd2b93ecd6af021fcf30121ba09799f&token=1082669959&lang=zh_CN&scene=21#wechat_redirect" target="_blank" rel="noopener">【思维导图-索引篇】搞定数据库索引就是这么简单</a>  里面有说到主键索引和非主键索引的区别</p><p>也就是说，我们如果走 c 这个字段的索引的话，最后会查询到对应主键的值，然后，再根据主键的值走主键索引，查询到整行数据返回。</p><p>好吧扯了这么多，其实我就是想告诉你，就算你在 c 字段上有索引，系统也并不一定会走 c 这个字段上的索引，而是有可能会直接扫描扫描全表，找出所有符合 100 &lt; c and c &lt; 100000 的数据。</p><p><strong>为什么会这样呢？</strong></p><p>其实是这样的，系统在执行这条语句的时候，会进行预测：<strong>究竟是走 c 索引扫描的行数少，还是直接扫描全表扫描的行数少呢？</strong>显然，扫描行数越少当然越好了，因为扫描行数越少，意味着<strong>I/O操作的次数越少。</strong></p><p>如果是扫描全表的话，那么扫描的次数就是这个表的总行数了，假设为 n；而如果走索引 c 的话，我们通过索引 c 找到主键之后，还得再通过主键索引来找我们整行的数据，也就是说，需要走两次索引。而且，我们也不知道符合 100 c &lt; and c &lt; 10000 这个条件的数据有多少行，万一这个表是全部数据都符合呢？这个时候意味着，走 c 索引不仅扫描的行数是 n，同时还得每行数据走两次索引。</p><p><strong>所以呢，系统是有可能走全表扫描而不走索引的。那系统是怎么判断呢？</strong></p><p>判断来源于系统的预测，也就是说，如果要走 c 字段索引的话，系统会预测走 c 字段索引大概需要扫描多少行。如果预测到要扫描的行数很多，它可能就不走索引而直接扫描全表了。</p><p>那么问题来了，<strong>系统是怎么预测判断的呢？</strong>这里我给你讲下系统是怎么判断的吧，虽然这个时候我已经写到脖子有点酸了。</p><p>系统是通过<strong>索引的区分度</strong>来判断的，一个索引上不同的值越多，意味着出现相同数值的索引越少，意味着索引的区分度越高。我们也把区分度称之为<strong>基数</strong>，即区分度越高，基数越大。所以呢，基数越大，意味着符合 100 &lt; c and c &lt; 10000 这个条件的行数越少。</p><p>所以呢，<strong>一个索引的基数越大，意味着走索引查询越有优势。</strong></p><p><strong>那么问题来了，怎么知道这个索引的基数呢？</strong></p><p>系统当然是不会遍历全部来获得一个索引的基数的，代价太大了，索引系统是通过遍历部分数据，也就是通过<strong>采样</strong>的方式，来预测索引的基数的。</p><p><strong>扯了这么多，重点的来了</strong>，居然是采样，那就有可能出现<strong>失误</strong>的情况，也就是说，c 这个索引的基数实际上是很大的，但是采样的时候，却很不幸，把这个索引的基数预测成很小。例如你采样的那一部分数据刚好基数很小，然后就误以为索引的基数很小。<strong>然后就呵呵，系统就不走 c 索引了，直接走全部扫描了</strong>。</p><p>所以呢，说了这么多，得出结论：<strong>由于统计的失误，导致系统没有走索引，而是走了全表扫描</strong>，而这，也是导致我们 SQL 语句执行的很慢的原因。</p><blockquote><p>这里我声明一下，系统判断是否走索引，扫描行数的预测其实只是原因之一，这条查询语句是否需要使用使用<strong>临时表</strong>、是否需要<strong>排序</strong>等也是会影响系统的选择的。</p></blockquote><p>不过呢，我们有时候也可以通过强制走索引的方式来查询，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t force index(a) where c &lt; 100 and c &lt; 100000;</span><br></pre></td></tr></table></figure><p>我们也可以通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show index from t;</span><br></pre></td></tr></table></figure><p>来查询索引的基数和实际是否符合，如果和实际很不符合的话，我们可以重新来统计索引的基数，可以用这条命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">analyze table t;</span><br></pre></td></tr></table></figure><p>来重新统计分析。</p><p><strong>既然会预测错索引的基数，这也意味着，当我们的查询语句有多个索引的时候，系统有可能也会选错索引哦</strong>，这也可能是 SQL 执行的很慢的一个原因。</p><p>好吧，就先扯这么多了，你到时候能扯出这么多，我觉得已经很棒了，下面做一个总结。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上是我的总结与理解，最后一个部分，我怕很多人不大懂<strong>数据库居然会选错索引</strong>，所以我详细解释了一下，下面我对以上做一个总结。</p><p>一个 SQL 执行的很慢，我们要分两种情况讨论：</p><p>1、大多数情况下很正常，偶尔很慢，则有如下原因</p><p>(1)、数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘。</p><p>(2)、执行的时候，遇到锁，如表锁、行锁。</p><p>2、这条 SQL 语句一直执行的很慢，则有如下原因。</p><p>(1)、没有用上索引：例如该字段没有索引；该字段有索引，但是索引失效，由于对字段进行运算、函数操作导致无法用索引。</p><p>(2)、数据库选错了索引。</p><p>大家如果有补充的，也是可以留言区补充一波哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自公众号:苦逼的码农 作者：帅地&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说实话，这个问题可以涉及到 &lt;code&gt;MySQL&lt;/code&gt; 的很多核心知识，可以扯出一大堆，就像要考你计算机网络的知识时，问你“输入URL回车之后，究竟发生了什么”一样，看看你能说出多少了。&lt;/p&gt;
&lt;p&gt;之前腾讯面试的实话，也问到这个问题了，不过答的很不好，之前没去想过相关原因，导致一时之间扯不出来。所以今天，我带大家来详细扯一下有哪些原因，相信你看完之后一定会有所收获，不然你打我。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://changsk.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>java8之LinkedHashMap</title>
    <link href="http://changsk.top/2019/07/09/java8-LinkedHashMap/"/>
    <id>http://changsk.top/2019/07/09/java8-LinkedHashMap/</id>
    <published>2019-07-09T02:00:02.000Z</published>
    <updated>2019-07-09T07:22:45.371Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://segmentfault.com/a/1190000012964859" target="_blank" rel="noopener">LinkedHashMap 源码详细分析（JDK1.8）</a></p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>LinkedHashMap</code> <strong>继承自 HashMap</strong>，在 HashMap 基础上，通过<strong>维护一条双向链表</strong>，<strong>解决了 HashMap 不能随时保持遍历顺序和插入顺序一致的问题</strong>。除此之外，LinkedHashMap 对<strong>访问顺序</strong>也提供了相关支持。在一些场景下，该特性很有用，比如<strong>缓存</strong>。在实现上，<code>LinkedHashMap</code> 很多方法直接继承自 HashMap，<strong>仅为维护双向链表覆写了部分方法</strong>。所以，要看懂 LinkedHashMap 的源码，需要先看懂 HashMap 的源码。关于 HashMap 的源码分析，本文并不打算展开讲了。大家可以参考我之前的一篇文章“<a href="http://www.coolblog.xyz/2018/01/18/HashMap-源码详细分析-JDK1-8/" target="_blank" rel="noopener">HashMap 源码详细分析(JDK1.8)</a>”。在那篇文章中，我配了十多张图帮助大家学习 HashMap 源码。</p><p>本篇文章的结构与我之前两篇关于 Java 集合类（<a href="http://www.coolblog.xyz/categories/foundation-of-java/collection/" target="_blank" rel="noopener">集合框架</a>）的源码分析文章不同，本文将不再分析集合类的基本操作（查找、遍历、插入、删除），而是把重点放在双向链表的维护上。包括链表的建立过程，删除节点的过程，以及访问顺序维护的过程等。好了，接下里开始分析吧。</p><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>上一章说了 LinkedHashMap 继承自 HashMap，所以它的底层仍然是<strong>基于拉链式散列结构</strong>。该结构由<strong>数组和链表或红黑树</strong>组成，结构示意图大致如下：</p><p><img src="1.jpg" alt="img">]</p><p>LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。其结构可能如下图：</p><p><img src="2.jpg" alt="img">]</p><p>上图中，淡蓝色的箭头表示<strong>前驱引用</strong>，红色箭头表示<strong>后继引用</strong>。每当有新键值对节点插入，新节点最终会接在 tail 引用指向的节点后面。而 tail 引用则会移动到新的节点上，这样一个双向链表就建立起来了。</p><p>上面的结构并不是很难理解，虽然引入了红黑树，导致结构看起来略为复杂了一些。但大家完全可以忽略红黑树，而只关注链表结构本身。好了，接下来进入细节分析吧。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="Entry-的继承体系"><a href="#Entry-的继承体系" class="headerlink" title="Entry 的继承体系"></a>Entry 的继承体系</h3><p>在对核心内容展开分析之前，这里先插队分析一下键值对节点的继承体系。先来看看继承体系结构图：</p><p><img src="3.jpg" alt="img"></p><p>上面的继承体系乍一看还是有点复杂的，同时也有点让人迷惑。HashMap 的内部类 TreeNode 不继承它的了一个内部类 Node，却继承自 Node 的子类 LinkedHashMap 内部类 Entry。这里这样做是有一定原因的，这里先不说。先来简单说明一下上面的继承体系。LinkedHashMap 内部类 Entry 继承自 HashMap 内部类 Node，并新增了两个引用，分别是 <strong>before</strong> 和 <strong>after</strong>。这两个引用的用途不难理解，也就是用于维护双向链表。同时，TreeNode 继承 LinkedHashMap 的内部类 Entry 后，就具备了和其他 Entry 一起组成链表的能力。但是这里需要大家考虑一个问题。当我们使用 HashMap 时，TreeNode 并不需要具备组成链表能力。如果继承 LinkedHashMap 内部类 Entry ，TreeNode 就多了两个用不到的引用，这样做不是会浪费空间吗？简单说明一下这个问题（水平有限，不保证完全正确），这里这么做确实会浪费空间，但与 TreeNode 通过继承获取的组成链表的能力相比，这点浪费是值得的。在 HashMap 的设计思路注释中，有这样一段话：</p><blockquote><p>Because TreeNodes are about twice the size of regular nodes, we<br>use them only when bins contain enough nodes to warrant use<br>(see TREEIFY_THRESHOLD). And when they become too small (due to<br>removal or resizing) they are converted back to plain bins. In<br>usages with well-distributed user hashCodes, tree bins are<br>rarely used.</p></blockquote><p>大致的意思是 TreeNode 对象的大小约是普通 Node 对象的2倍，我们仅在桶（bin）中包含足够多的节点时再使用。当桶中的节点数量变少时（取决于删除和扩容），TreeNode 会被转成 Node。当用户实现的 hashCode 方法具有良好分布性时，树类型的桶将会很少被使用。</p><p>通过上面的注释，我们可以了解到。一般情况下，只要 hashCode 的实现不糟糕，Node 组成的链表很少会被转成由 TreeNode 组成的红黑树。也就是说 TreeNode 使用的并不多，浪费那点空间是可接受的。假如 TreeNode 机制继承自 Node 类，那么它要想具备组成链表的能力，就需要 Node 去继承 LinkedHashMap 的内部类 Entry。这个时候就得不偿失了，浪费很多空间去获取不一定用得到的能力。</p><p>说到这里，大家应该能明白节点类型的继承体系了。这里单独拿出来说一下，为下面的分析做铺垫。叙述略为啰嗦，见谅。</p><h3 id="链表的建立过程"><a href="#链表的建立过程" class="headerlink" title="链表的建立过程"></a>链表的建立过程</h3><p>链表的建立过程是在插入键值对节点时开始的，初始情况下，让 LinkedHashMap 的 head 和 tail 引用同时指向新节点，链表就算建立起来了。随后不断有新节点插入，通过将新节点接在 tail 引用指向节点的后面，即可实现链表的更新。</p><p>Map 类型的集合类是通过 <code>put(K,V)</code> 方法插入键值对，<strong>LinkedHashMap 本身并没有覆写父类的 put 方法</strong>，而是直接使用了父类的实现。但在 HashMap 中，put 方法插入的是 HashMap 内部类 Node 类型的节点，该类型的节点并不具备与 LinkedHashMap 内部类 Entry 及其子类型节点组成链表的能力。那么，LinkedHashMap 是怎样建立链表的呢？在展开说明之前，我们先看一下 LinkedHashMap 插入操作相关的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap 中实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap 中实现</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;...&#125;</span><br><span class="line">    <span class="comment">// 通过节点 hash 定位节点所在的桶位置，并检测桶中是否包含节点引用</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) &#123;...&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) &#123;...&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历链表，并统计链表长度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 未在单链表中找到要插入的节点，将新节点接在单链表的后面</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) &#123;...&#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 插入的节点已经存在于单链表中</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>) &#123;...&#125;</span><br><span class="line">            afterNodeAccess(e);    <span class="comment">// 回调方法，后续说明</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold) &#123;...&#125;</span><br><span class="line">    afterNodeInsertion(evict);    <span class="comment">// 回调方法，后续说明</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap 中实现</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashMap 中覆写</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    <span class="comment">// 将 Entry 接在双向链表的尾部</span></span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashMap 中实现</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="comment">// last 为 null，表明链表还未建立</span></span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将新节点 p 接在链表尾部</span></span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是 LinkedHashMap 插入相关的源码，这里省略了部分非关键的代码。我根据上面的代码，可以知道 LinkedHashMap 插入操作的调用过程。如下：</p><p><img src="4.jpg" alt="img"></p><p>我把 newNode 方法红色背景标注了出来，这一步比较关键。LinkedHashMap 覆写了该方法。在这个方法中，LinkedHashMap 创建了 Entry，并通过 <strong>linkNodeLast</strong> 方法将 Entry 接在双向链表的尾部，实现了双向链表的建立。双向链表建立之后，我们就可以<strong>按照插入顺序</strong>去遍历 LinkedHashMap，大家可以自己写点测试代码验证一下插入顺序。</p><p>以上就是 LinkedHashMap 维护插入顺序的相关分析。本节的最后，再额外补充一些东西。大家如果仔细看上面的代码的话，会发现有两个以<code>after</code>开头方法，在上文中没有被提及。在 JDK 1.8 HashMap 的源码中，相关的方法有3个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>根据这三个方法的注释可以看出，这些方法的用途是在增删查等操作后，通过回调的方式，让 LinkedHashMap 有机会做一些后置操作。上述三个方法的具体实现在 LinkedHashMap 中，本节先不分析这些实现，相关分析会在后续章节中进行。</p><h3 id="链表节点的删除过程"><a href="#链表节点的删除过程" class="headerlink" title="链表节点的删除过程"></a>链表节点的删除过程</h3><p>与插入操作一样，LinkedHashMap 删除操作相关的代码也是直接用父类的实现。在删除节点时，父类的删除逻辑并不会修复 LinkedHashMap 所维护的双向链表，这不是它的职责。那么删除及节点后，被删除的节点该如何从双链表中移除呢？当然，办法还算是有的。上一节最后提到 HashMap 中三个回调方法运行 LinkedHashMap 对一些操作做出响应。所以，<strong>在删除节点后，回调方法 <code>afterNodeRemoval</code> 会被调用。LinkedHashMap 覆写该方法，并在该方法中完成了移除被删除节点的操作。</strong>相关源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap 中实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap 中实现</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) &#123;...&#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 遍历单链表，寻找要删除的节点，并赋值给 node 变量</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode) &#123;...&#125;</span><br><span class="line">            <span class="comment">// 将要删除的节点从单链表中移除</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);    <span class="comment">// 调用删除回调方法进行后续操作</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashMap 中覆写</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    <span class="comment">// 将 p 节点的前驱后后继引用置空</span></span><br><span class="line">    p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// b 为 null，表明 p 是头节点</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="comment">// a 为 null，表明 p 是尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除的过程并不复杂，上面这么多代码其实就做了三件事：</p><ol><li>根据 hash 定位到桶位置</li><li>遍历链表或调用红黑树相关的删除方法</li><li>从 LinkedHashMap 维护的双链表中移除要删除的节点</li></ol><p>举个例子说明一下，假如我们要删除下图键值为 3 的节点。</p><p><img src="5.jpg" alt="img"></p><p>根据 hash 定位到该节点属于3号桶，然后在对3号桶保存的单链表进行遍历。找到要删除的节点后，先从单链表中移除该节点。如下：</p><p><img src="6.jpg" alt></p><p>然后再双向链表中移除该节点：</p><p><img src="7.jpg" alt></p><p>删除及相关修复过程并不复杂，结合上面的图片，大家应该很容易就能理解，这里就不多说了。</p><h3 id="访问顺序的维护过程"><a href="#访问顺序的维护过程" class="headerlink" title="访问顺序的维护过程"></a>访问顺序的维护过程</h3><p>前面说了插入顺序的实现，本节来讲讲访问顺序。<strong>默认情况下，LinkedHashMap 是按插入顺序维护链表</strong>。不过我们可以在初始化 LinkedHashMap，<strong>指定 accessOrder 参数为 true</strong>，即可让它按访问顺序维护链表。访问顺序的原理上并不复杂，当我们调用<code>get/getOrDefault/replace</code>等方法时，<strong>只需要将这些方法访问的节点移动到链表的尾部即可</strong>。相应的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkedHashMap 中覆写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 如果 accessOrder 为 true，则调用 afterNodeAccess 将被访问节点移动到链表最后</span></span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkedHashMap 中覆写</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 如果 b 为 null，表明 p 为头节点</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这里存疑，父条件分支已经确保节点 e 不会是尾节点，</span></span><br><span class="line"><span class="comment">         * 那么 e.after 必然不会为 null，不知道 else 分支有什么作用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将 p 接在链表的最后</span></span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是访问顺序的实现代码，并不复杂。下面举例演示一下，帮助大家理解。假设我们访问下图键值为3的节点，访问前结构为：</p><p><img src="8.jpg" alt></p><p>访问后，键值为3的节点将会被移动到双向链表的最后位置，其前驱和后继也会跟着更新。访问后的结构如下：</p><p><img src="9.jpg" alt></p><h3 id="基于-LinkedHashMap-实现缓存"><a href="#基于-LinkedHashMap-实现缓存" class="headerlink" title="基于 LinkedHashMap 实现缓存"></a>基于 LinkedHashMap 实现缓存</h3><p>前面介绍了 LinkedHashMap 是如何维护插入和访问顺序的，大家对 LinkedHashMap 的原理应该有了一定的认识。本节我们来写一些代码实践一下，这里通过继承 LinkedHashMap 实现了一个简单的 LRU 策略的缓存。在写代码之前，先介绍一下前置知识。</p><p>在3.1节分析链表建立过程时，我故意忽略了部分源码分析。本节就把忽略的部分补上，先看源码吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="comment">// 根据条件判断是否移除最近最少被访问的节点</span></span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除最近最少被访问条件之一，通过覆盖此方法可实现不同策略的缓存</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的源码的核心逻辑在一般情况下都不会被执行，所以之前并没有进行分析。上面的代码做的事情比较简单，就是<strong>通过一些条件，判断是否移除最近最少被访问的节点</strong>。看到这里，大家应该知道上面两个方法的用途了。当我们基于 LinkedHashMap 实现缓存时，通过覆写<code>removeEldestEntry</code>方法可以<strong>实现自定义策略的 LRU 缓存</strong>。比如我们可以<strong>根据节点数量判断是否移除最近最少被访问的节点</strong>，或者<strong>根据节点的存活时间判断是否移除该节点</strong>等。本节所实现的缓存是基于判断节点数量是否超限的策略。在构造缓存对象时，传入最大节点数。当插入的节点数超过最大节点数时，移除最近最少被访问的节点。实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_NODE_NUM = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> limit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(MAX_NODE_NUM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleCache</span><span class="params">(<span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(limit, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.limit = limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">save</span><span class="params">(K key, V val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> put(key, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getOne</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> containsKey(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断节点数是否超限</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> eldest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 超限返回 true，否则返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; limit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCacheTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SimpleCache&lt;Integer, Integer&gt; cache = <span class="keyword">new</span> SimpleCache&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            cache.save(i, i * i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"插入10个键值对后，缓存内容："</span>);</span><br><span class="line">        System.out.println(cache + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"访问键值为7的节点后，缓存内容："</span>);</span><br><span class="line">        cache.getOne(<span class="number">7</span>);</span><br><span class="line">        System.out.println(cache + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"插入键值为1的键值对后，缓存内容："</span>);</span><br><span class="line">        cache.save(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(cache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><p><img src="10.jpg" alt></p><p>在测试代码中，设定缓存大小为3。在向缓存中插入10个键值对后，只有最后3个被保存下来了，其他的都被移除了。然后通过访问键值为7的节点，使得该节点被移到双向链表的最后位置。当我们再次插入一个键值对时，键值为7的节点就不会被移除。</p><p>本节作为对前面内的补充，简单介绍了 LinkedHashMap 在其他方面的应用。本节内容及相关代码并不难理解，这里就不在赘述了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从 LinkedHashMap 维护双向链表的角度对 LinkedHashMap 的源码进行了分析，并在文章的结尾基于 LinkedHashMap 实现了一个简单的 Cache。在日常开发中，LinkedHashMap 的使用频率虽不及 HashMap，但它也个重要的实现。在 Java 集合框架中，HashMap、LinkedHashMap 和 TreeMap 三个映射类基于不同的数据结构，并实现了不同的功能。<strong>HashMap 底层基于拉链式的散列结构，并在 JDK 1.8 中引入红黑树优化过长链表的问题</strong>。基于这样结构，HashMap 可提供高效的增删改查操作。LinkedHashMap 在其之上，通过维护一条双向链表，<strong>实现了散列数据结构的有序遍历</strong>。<strong>TreeMap 底层基于红黑树实现</strong>，利用红黑树的性质，实现了键值对排序功能。</p><p>到此，本篇文章就写完了，感谢大家的阅读！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://segmentfault.com/a/1190000012964859&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LinkedHashMap 源码详细分析（JDK1.8）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;code&gt;LinkedHashMap&lt;/code&gt; &lt;strong&gt;继承自 HashMap&lt;/strong&gt;，在 HashMap 基础上，通过&lt;strong&gt;维护一条双向链表&lt;/strong&gt;，&lt;strong&gt;解决了 HashMap 不能随时保持遍历顺序和插入顺序一致的问题&lt;/strong&gt;。除此之外，LinkedHashMap 对&lt;strong&gt;访问顺序&lt;/strong&gt;也提供了相关支持。在一些场景下，该特性很有用，比如&lt;strong&gt;缓存&lt;/strong&gt;。在实现上，&lt;code&gt;LinkedHashMap&lt;/code&gt; 很多方法直接继承自 HashMap，&lt;strong&gt;仅为维护双向链表覆写了部分方法&lt;/strong&gt;。所以，要看懂 LinkedHashMap 的源码，需要先看懂 HashMap 的源码。关于 HashMap 的源码分析，本文并不打算展开讲了。大家可以参考我之前的一篇文章“&lt;a href=&quot;http://www.coolblog.xyz/2018/01/18/HashMap-源码详细分析-JDK1-8/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HashMap 源码详细分析(JDK1.8)&lt;/a&gt;”。在那篇文章中，我配了十多张图帮助大家学习 HashMap 源码。&lt;/p&gt;
&lt;p&gt;本篇文章的结构与我之前两篇关于 Java 集合类（&lt;a href=&quot;http://www.coolblog.xyz/categories/foundation-of-java/collection/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;集合框架&lt;/a&gt;）的源码分析文章不同，本文将不再分析集合类的基本操作（查找、遍历、插入、删除），而是把重点放在双向链表的维护上。包括链表的建立过程，删除节点的过程，以及访问顺序维护的过程等。好了，接下里开始分析吧。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://changsk.top/categories/Java/"/>
    
    
      <category term="LinkedHashMap" scheme="http://changsk.top/tags/LinkedHashMap/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-数组中只出现一次的数字</title>
    <link href="http://changsk.top/2019/07/09/jianzhioffer-appear-once/"/>
    <id>http://changsk.top/2019/07/09/jianzhioffer-appear-once/</id>
    <published>2019-07-09T01:47:16.000Z</published>
    <updated>2019-07-09T12:06:35.244Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。</p><a id="more"></a><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>先来个简单题，如果题目是这样子的：<br>一个整型数组里除了一个数字之外，其他的数字都出现了偶数次。请写程序找出这一个只出现一次的数字。<br>这个题就so easy了。xor（异或）有个重要的性质：<br><strong>任何数字异或它自己都等于0（异或，一种位运算，两个比特相同结果则为0，否则为1）</strong><br>用0依次异或数组的元素，最后的结果就是只出现一次或者只出现奇数次的数字（因为偶数次的数字在异或运算中都抵消了）。</p><p>现在的问题是有两个出现次数为一次的数字。那么只要把数组分成两部分，每一部分分别含有一个出现次数为1（或者奇数次也可以的）的数字就可以了。</p><p>先用0对整个数字进行异或运算，结果为xor，是两个只出现一次的数字的异或的结果。出现次数为1的两个数字肯定不相同，那么xor中至少有一位为1。我们在xor中找到第一位为1的位置，记为n。根据第n为是不是1可以把整个数组分为两部分。每一部分都只含有一个出现次数为1的数字，然后剩余的数字都出现偶数次。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//num1,num2分别为长度为1的数组。传出参数</span></span><br><span class="line"><span class="comment">//将num1[0],num2[0]设置为返回结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> xor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> partion = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; array.length;i++) xor ^= array[i];</span><br><span class="line">        <span class="comment">// xor 中从右往左第一次出现 1 的位置</span></span><br><span class="line">        <span class="comment">// 如: 10 &amp; -10 = 2 (10的二进制为 1010)</span></span><br><span class="line">        partion = xor &amp; -xor; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((partion &amp; array[i]) == <span class="number">0</span>) num1[<span class="number">0</span>] ^= array[i];</span><br><span class="line">            <span class="keyword">else</span> num2[<span class="number">0</span>] ^= array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="http://changsk.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="http://changsk.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>java中集合类的继承体系</title>
    <link href="http://changsk.top/2019/07/08/java-collection-map/"/>
    <id>http://changsk.top/2019/07/08/java-collection-map/</id>
    <published>2019-07-08T13:45:01.000Z</published>
    <updated>2019-07-08T13:52:34.499Z</updated>
    
    <content type="html"><![CDATA[<p>Java中集合类存放在java.util包中，主要有三种：set、list、map。</p><a id="more"></a><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>继承体系如下：</p><p><img src="1.jpg" alt></p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>继承体系如下：</p><p><img src="2.jpg" alt></p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>继承体系如下：</p><p><img src="3.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java中集合类存放在java.util包中，主要有三种：set、list、map。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://changsk.top/categories/Java/"/>
    
    
      <category term="集合类" scheme="http://changsk.top/tags/%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>java7新特性-catch捕获多个异常</title>
    <link href="http://changsk.top/2019/07/08/java7-catch-more-exception/"/>
    <id>http://changsk.top/2019/07/08/java7-catch-more-exception/</id>
    <published>2019-07-08T12:50:02.000Z</published>
    <updated>2019-07-08T13:28:12.975Z</updated>
    
    <content type="html"><![CDATA[<p>java 7使得我们能够在同一个catch语句块中捕获多种不同的异常，这也叫做多重异常捕获。</p><p>在java7以前，我们可能要这样做：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// execute code that may throw 1 of the 3 exceptions below.</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">    logger.log(e);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">    logger.log(e);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">    logger.severe(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如上面看到的，SQLException 和IOException 这两个异常都是以相同的方式来处理的，但是你仍然要为这两个异常写两个独立的catch语句块。</p><p>java 7中你可以像下面这样捕获多个异常：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">    //<span class="built_in"> execute </span>code that may<span class="built_in"> throw </span>1 of the 3 exceptions below.</span><br><span class="line"></span><br><span class="line">&#125; catch(&lt;strong&gt;SQLException | IOException e&lt;/strong&gt;) &#123;</span><br><span class="line">    logger.log(e);</span><br><span class="line"></span><br><span class="line">&#125; catch(Exception e) &#123;</span><br><span class="line">    logger.severe(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，第一个catch语句块中的两个异常名字是被管道字符|分割的。两个异常类名之间的管道字符就是在同一个catch语句块中声明多个异常的方法。</p><blockquote><p>参考：<a href="http://ifeve.com/catching-multiple-exceptions/" target="_blank" rel="noopener">在java 7中捕获多个异常</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java 7使得我们能够在同一个catch语句块中捕获多种不同的异常，这也叫做多重异常捕获。&lt;/p&gt;
&lt;p&gt;在java7以前，我们可能要这样做：&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://changsk.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>java7新特性-增强try(Try-with-resources)</title>
    <link href="http://changsk.top/2019/07/08/java7-Try-with-resources/"/>
    <id>http://changsk.top/2019/07/08/java7-Try-with-resources/</id>
    <published>2019-07-08T12:43:43.000Z</published>
    <updated>2019-07-08T12:51:06.793Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://www.jianshu.com/p/97fdbd48f581" target="_blank" rel="noopener">增强 try （Try-with-resources</a></p></blockquote><h3 id="Try-with-resources"><a href="#Try-with-resources" class="headerlink" title="Try-with-resources"></a>Try-with-resources</h3><p>Try-with-resources是Java7出现的一个新的异常处理机制，它能够很容易地关闭在try-catch语句块中使用的资源。</p><p>传统的关闭资源方式是利用Try-Catch-Finally管理资源（旧的代码风格） 即在Java7以前程序中使用的资源需要被明确地关闭。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStream input = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        input = <span class="keyword">new</span> FileInputStream(<span class="string">"d:\\hello.txt"</span>);</span><br><span class="line">        <span class="keyword">int</span> data = input.read();</span><br><span class="line">        <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) data);</span><br><span class="line">            data = input.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(input != <span class="keyword">null</span>)&#123;</span><br><span class="line">            input.close();</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序 try语句块中有3处能抛出异常，finally语句块中有一处会抛出异常。</p><p>不论try语句块中是否有异常抛出，finally语句块始终会被执行。这意味着，不论try语句块中发生什么，InputStream 都会被关闭，或者说都会试图被关闭。如果关闭失败，close()方法也可能会抛出异常。</p><p>假设try语句块抛出一个异常，然后finally语句块被执行。同样假设finally语句块也抛出了一个异常。那么哪个异常会根据调用栈往外传播？</p><p>即使try语句块中抛出的异常与异常传播更相关，<strong>最终还是finally语句块中抛出的异常会根据调用栈向外传播</strong>。</p><p>在Java7以后，对于上面的例子可以用try-with-resource 结构这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFileJava7</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(FileInputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"d:\\hello.txt"</span>)) &#123;</span><br><span class="line">        <span class="keyword">int</span> data = input.read();</span><br><span class="line">        <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) data);</span><br><span class="line">            data = input.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意方法中的第一行：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(FileInputStream input = <span class="keyword">new</span> <span class="type">FileInputStream</span>(<span class="string">"d:\\hello.txt"</span>))</span><br></pre></td></tr></table></figure><p>这就是try-with-resource 结构的用法。FileInputStream 类型变量就在try关键字后面的括号中声明。而且一个FileInputStream 类型被实例化并被赋给了这个变量。</p><p>当try语句块运行结束时，<strong>FileInputStream 会被自动关闭</strong>。这是因为FileInputStream 实现了java中的    <code>java.lang.AutoCloseable</code>接口。所有实现了这个接口的类都可以在try-with-resources结构中使用。</p><p>当try-with-resources结构中抛出一个异常，同时FileInputStream被关闭时（调用了其close方法）也抛出一个异常，<strong>try-with-resources结构中抛出的异常会向外传播</strong>，而FileInputStream被关闭时抛出的异常被抑制了。这与文章开始处利用旧风格代码的例子（在finally语句块中关闭资源）相反。</p><h5 id="使用多个资源"><a href="#使用多个资源" class="headerlink" title="使用多个资源"></a>使用多个资源</h5><p>你也可以在块中使用多个资源而且这些资源都能被自动地关闭。下面是例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFileJava7</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(FileInputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"d:\\hello.txt"</span>); BufferedInputStream bufferedInput = <span class="keyword">new</span> BufferedInputStream(input))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> data = buffereInput.read();</span><br><span class="line">        <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println( (<span class="keyword">char</span>) data);</span><br><span class="line">            data = bufferedInput.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子在try关键字后的括号里创建了两个资源——FileInputStream 和BufferedInputStream。当程序运行离开try语句块时，这两个资源都会被自动关闭。</p><p>这些资源将按照他们被创建顺序的逆序来关闭。首先BufferedInputStream 会被关闭，然后FileInputStream会被关闭。</p><h5 id="自定义AutoCloseable-实现"><a href="#自定义AutoCloseable-实现" class="headerlink" title="自定义AutoCloseable 实现"></a>自定义AutoCloseable 实现</h5><p>这个try-with-resources结构里不仅能够操作java内置的类。你也可以在自己的类中实现java.lang.AutoCloseable接口，然后在try-with-resources结构里使用这个类。</p><p>AutoClosable 接口仅仅有一个方法，接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AutoClosable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何实现了这个接口的方法都可以在try-with-resources结构中使用。下面是一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAutoClosable</span> <span class="keyword">implements</span> <span class="title">AutoClosable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doIt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyAutoClosable doing it!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyAutoCloseable Closed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是MyAutoClosable 在try-with-resources结构中使用的例子：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">myAutoClosable</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(MyAutoClosable myAutoClosable = <span class="keyword">new</span> MyAutoClosable())&#123;</span><br><span class="line">        myAutoClosable.doIt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当方法myAutoClosable.doIt()被调用时，下面是打印到System.out的输出：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyAutoClosable doing it!</span><br><span class="line">MyAutoClosable closed!</span><br></pre></td></tr></table></figure><p>通过上面这些你可以看到，不论try-catch中使用的资源是自己创造的还是java内置的类型，try-with-resources都是一个能够确保资源能被正确地关闭的强大方法。</p><h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><ul><li>自动关闭资源的try语句相当于包含了隐式的finally块（用于关闭资源），<strong>因此这个try语句可以既没有catch块，也没有finally块。</strong></li><li><strong>被自动关闭的资源必须实现Closeable或AutoCloseable接口。</strong>（Closeable是AutoCloseable的子接口，Closeeable接口里的close()方法声明抛出了IOException,;AutoCloseable接口里的close()方法声明抛出了Exception）<ul><li>Java7几乎把所有的“<strong>资源类</strong>”（包括文件IO的各种类，JDBC编程的Connection、Statement等接口……）进行了改写，改写后的资源类都实现了AutoCloseable或Closeable接口</li></ul></li><li>Java7新增的自动关闭资源的try语句允许在try关键字后紧跟一对圆括号，里面可以声明、初始化一个或多个资源，此处的资源指的是那些必须在程序结束时显示关闭的资源（数据库连接、网络连接等），try语句会在该语句结束时自动关闭这些资源。<ul><li>被关闭的资源必须放在try语句后的圆括号中声明、初始化。如果程序有需要自动关闭资源的try语句后可以带多个catch块和一个finally块。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://www.jianshu.com/p/97fdbd48f581&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;增强 try （Try-with-resources&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Try-with-resources&quot;&gt;&lt;a href=&quot;#Try-with-resources&quot; class=&quot;headerlink&quot; title=&quot;Try-with-resources&quot;&gt;&lt;/a&gt;Try-with-resources&lt;/h3&gt;&lt;p&gt;Try-with-resources是Java7出现的一个新的异常处理机制，它能够很容易地关闭在try-catch语句块中使用的资源。&lt;/p&gt;
&lt;p&gt;传统的关闭资源方式是利用Try-Catch-Finally管理资源（旧的代码风格） 即在Java7以前程序中使用的资源需要被明确地关闭。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://changsk.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>java8的新特性</title>
    <link href="http://changsk.top/2019/07/08/java8-new-feature/"/>
    <id>http://changsk.top/2019/07/08/java8-new-feature/</id>
    <published>2019-07-08T11:34:50.000Z</published>
    <updated>2019-07-08T12:14:16.186Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://cloud.tencent.com/developer/article/1378091" target="_blank" rel="noopener">Java8 新特性</a></p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>北京时间2018年9月26日，Oracle官方发布Java 11。既然版本都更新到11了，现在才来学8是不是太晚了？其实不是的，目前应该大部分都还是使用的Java 7和Java 8，这两个应该还是主流。而Java 8 又有一些激动人心的新特性，所以还是值得学习的。Java 8 新特性主要有以下几点：</p><a id="more"></a><ul><li><strong>Lambda表达式(重点)；</strong></li><li>函数式接口；</li><li>方法引用与构造器引用；</li><li><strong>Stream API(重点)；</strong></li><li><strong>接口中的默认方法与静态方法；</strong></li><li><strong>新时间日期API；</strong></li><li>其他新特性。</li></ul><p>有了以上新特性，Java 8就可以做到：</p><ul><li>速度更快；</li><li>代码更少(增加了新的语法 Lambda 表达式)；</li><li>方便操作集合(Stream API)</li><li>便于并行；</li><li>最大化减少空指针异常 Optional。</li></ul><p>接下来一起来了解一下Java 8的这些新特性。</p><h1 id="Lambada表达式"><a href="#Lambada表达式" class="headerlink" title="Lambada表达式"></a>Lambada表达式</h1><p><strong>1、什么是lambda？</strong>  Lambda 是一个匿名函数，我们可以把 Lambda 表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。可以写出更简洁、更灵活的代码。</p><p><strong>2、了解新操作符：</strong>  Java 8引入了新的操作符，-&gt;，叫<code>箭头操作符</code>或者叫<code>lambda操作符</code>。当使用lambda表达式时就需要使用这个操作符。</p><p><strong>3、lambda表达式语法：</strong>  箭头操作符将lambda表达式分成了两部分：</p><ul><li>左侧：<code>lambda表达式的参数列表</code>(接口中抽象方法的参数列表)</li><li>右侧：<code>lambda表达式中所需执行的功能</code>(lambda体，对抽象方法的实现)</li></ul><p>语法有如下几种格式：</p><ul><li>语法格式一(无参数无返回值)：  () -&gt; 具体实现</li><li>语法格式二(有一个参数无返回值)： (x) -&gt; 具体实现 或  x -&gt; 具体实现</li><li>语法格式三(有多个参数，有返回值，并且lambda体中有多条语句)：(x,y) -&gt; {具体实现}</li><li>语法格式四：若方法体只有一条语句，那么大括号和return都可以省略  <strong>注：</strong>lambda表达式的参数列表的参数类型可以省略不写，可以进行类型推断。</li></ul><p>看几个例子：  例一：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public <span class="keyword">void</span> test1()&#123;</span><br><span class="line">     <span class="comment">// 实现一个线程</span></span><br><span class="line">     int num = <span class="number">0</span>;<span class="comment">//jdk1.8以前，这个必须定义为final，下面才能用，1.8后默认就为final</span></span><br><span class="line">     Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public <span class="keyword">void</span> run() &#123;</span><br><span class="line">             System.out.println(<span class="string">"hello world"</span>+ num);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     runnable.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个线程，重写run方法，在run方法里面打印一句话。我们想要的就是<code>System.out.println(&quot;hello world&quot;+ num);</code>这行代码，但是为了实现这行代码，不得不多写了好多行。lambda就可以解决这一点，看看用lambda如何实现:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runnable runnable1 = () -&gt; System.out.println(<span class="string">"hello world"</span>+num);</span><br><span class="line">runnable1.run();</span><br></pre></td></tr></table></figure><p>用lambda这样就搞定了。首先还是<code>Runnable runnable1 =</code>，但是不用new了，右边就用lambda实现。我们要使用的是该接口的run方法，run方法不需要参数，所以lambda表达式左边就是()，lambda表达式右边是抽象方法的实现，也就是第一种方式中run方法的方法体写到lambda表达式右边就可以了。</p><p>例二：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; comparator = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">         <span class="keyword">return</span> Integer.compare(o1,o2);<span class="comment">//就这一行关键代码</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以前写一个比较器就要像上面那样写，先new比较器类，然后在其compare方法里写核心代码。用lambda实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; comparator = (x,y) -&gt; Integer.compare(x,y);</span><br></pre></td></tr></table></figure><p>compare方法需要两个参数，所以箭头操作符左边写(x,y)，右边是compare方法的实现，所以应该写<code>return Integer.compare(o1,o2);</code>，但是根据上面的语法格式四可知，return可以省略，因此就写成了上面那样。</p><p>通过这两个例子可以感受到lambda表达式的简洁，但是问题来了：我们说lambda表达式就是一个匿名函数，我们只需要指定<code>参数</code>和<code>lambda体</code>即可，那么它是如何判断重写的是哪个方法呢？比如一个接口中有多个方法，如果使用lambda表达式来写，那么如何判断我们使用的是该接口的哪个方法？其实是<strong>不能判断</strong>的！通过上面两个例子可以发现，Runnable接口和Comparator接口都是只有一个方法的接口，所以可以使用lambda。</p><h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><p><strong>1、什么是函数式接口？</strong>  <code>像Runnable和Comparator这样只有一个方法的接口，称为函数式接口</code>。也可以在接口上加上<code>@FunctionalInterface</code>注解，如果编译通过，则该接口就是函数式接口。lambda表达式就需要函数式接口的支持。</p><p><strong>2、看一个需求：</strong>  需求：需要对两个数进行加减乘除等运算，怎么实现？</p><ul><li>传统做法：传统做法中，需要进行几种运算，我们就要写几个方法。一种运算对应一个方法。</li><li>lambda做法：首先要定义一个函数式接口，接口中只有一个方法，接收两个参数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface MyInterface &#123;</span><br><span class="line">    public Integer getValue(Integer num1,Integer num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以使用了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public <span class="keyword">void</span> test5()&#123;</span><br><span class="line">      MyInterface myInterface = (x,y) -&gt; x*y;<span class="comment">//乘法运算</span></span><br><span class="line">      MyInterface myInterface1 = (x,y) -&gt; x+y;<span class="comment">//加法运算</span></span><br><span class="line">      Integer result1 = myInterface.getValue(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line">      Integer result2 = myInterface1.getValue(<span class="number">1024</span>,<span class="number">2048</span>);</span><br><span class="line">      System.out.println(result1);</span><br><span class="line">      System.out.println(result2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以用lambda的话，只需要定义一个<strong>函数式接口</strong>，不管进行什么操作，都可以用lambda解决，不用再一种运算对应一个方法。但是，还需要自己定义函数式接口，好像也没简单很多。Java考虑到这点了，所以内置了函数式接口。</p><p><strong>3、四大内置函数式接口：</strong>  为了不需要我们自己定义函数式接口，Java内置了四大函数式接口，这四大接口加上它们的子类，完全满足我们的使用了。四大函数式接口是：</p><ul><li>Consumer<t>：消费型接口(void accept(T t))，接收一个参数，无返回值。</t></li><li>Supplier<t>：供给型接口(T get())，无参数，有返回值。</t></li><li>Function&lt;T,R&gt;：函数型接口(R apply(T t))，接收一个参数，有返回值。</li><li>Predicate<t>：断言型接口(boolean test(T t))，接收一个参数，返回Boolean值。</t></li></ul><p><strong>4、四大函数式接口的使用：</strong>  接下来看看具体如何使用这四大函数式接口。  </p><p>消费型接口的使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Consumer consumer = (x) -&gt; System.out.println(<span class="string">"消费了"</span>+x+<span class="string">"元"</span>);</span><br><span class="line">consumer.accept(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>供给型接口的使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Integer&gt; supplier = () -&gt; (int)(<span class="built_in">Math</span>.random() * <span class="number">100</span>);<span class="comment">//生成随机数</span></span><br><span class="line">System.out.println(supplier.get());</span><br></pre></td></tr></table></figure><p>函数型接口的使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>&lt;<span class="built_in">String</span>,<span class="built_in">String</span>&gt; <span class="function"><span class="keyword">function</span> = <span class="title">str</span> -&gt; <span class="title">str</span>.<span class="title">toUpperCase</span>(<span class="params"></span>);//将传入的字符串转成大写</span></span><br><span class="line"><span class="function"><span class="title">String</span> <span class="title">s</span> = <span class="title">function</span>.<span class="title">apply</span>(<span class="params"><span class="string">"adcdefggffs"</span></span>);</span></span><br><span class="line"><span class="function"><span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span>(<span class="params">s</span>);</span></span><br></pre></td></tr></table></figure><p>断言型接口的使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//需求：将满足条件的字符串添加到集合中去</span></span><br><span class="line">  public List&lt;<span class="built_in">String</span>&gt; filterString(List&lt;<span class="built_in">String</span>&gt; strings, Predicate&lt;<span class="built_in">String</span>&gt; predicate)&#123;</span><br><span class="line">      List&lt;<span class="built_in">String</span>&gt; stringList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">String</span> string : strings) &#123;</span><br><span class="line">          <span class="keyword">if</span> (predicate.test(string))&#123;</span><br><span class="line">              stringList.add(string);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> stringList;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line">@Test</span><br><span class="line"> public <span class="keyword">void</span> test4()&#123;</span><br><span class="line">      List&lt;<span class="built_in">String</span>&gt; list = Arrays.asList(<span class="string">"hello"</span>,<span class="string">"world"</span>,<span class="string">"niu"</span>,<span class="string">"bi"</span>);</span><br><span class="line">      List&lt;<span class="built_in">String</span>&gt; newList = filterString(list,str -&gt; str.length() &gt; <span class="number">3</span>);<span class="comment">//选出长度大于3的字符串</span></span><br><span class="line">      newList.forEach(System.out::println);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="方法引用与构造器引用"><a href="#方法引用与构造器引用" class="headerlink" title="方法引用与构造器引用"></a>方法引用与构造器引用</h1><p>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用。不过实现抽象方法的参数列表，必须与引用方法的参数列表保持一致。  </p><p><strong>1、方法引用语法：</strong></p><ul><li>对象::实例方法</li><li>类::静态方法</li><li>类::实例方法</li></ul><p><strong>2、方法引用具体用法：</strong>  说了那么多可能还不清楚到底什么意思，一起来看几个例子。  </p><p>语法一例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;<span class="built_in">String</span>&gt; consumer = x -&gt; System.out.println(x);<span class="comment">//传统写法</span></span><br><span class="line">Consumer&lt;<span class="built_in">String</span>&gt; consumer = System.out::println;<span class="comment">//使用方法引用</span></span><br></pre></td></tr></table></figure><p>println方法和Consumer的accept方法都是无返回值，接收一个参数，所以可以这样写。</p><p>语法二例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; comparator = (x,y) -&gt; Integer.compare(x,y);</span><br><span class="line"><span class="comment">//因为compare方法已经被Integer实现了，且是静态的，所以这样用就行。</span></span><br><span class="line">Comparator&lt;Integer&gt; comparator1 = Integer::compare;</span><br></pre></td></tr></table></figure><p>语法三例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BiPredicate&lt;<span class="built_in">String</span>,<span class="built_in">String</span>&gt; biPredicate = (x,y) -&gt; x.equals(y);</span><br><span class="line"><span class="comment">//可以改成如下写法</span></span><br><span class="line"><span class="comment">//不过要满足：第一个参数是实例方法的调用者，第二个参数是实例方法的参数时，就可以这样用</span></span><br><span class="line">BiPredicate&lt;<span class="built_in">String</span>,<span class="built_in">String</span>&gt; biPredicate1 = <span class="built_in">String</span>::equals;</span><br></pre></td></tr></table></figure><p><strong>3、构造器引用：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Employee&gt; supplier = () -&gt; <span class="keyword">new</span> Employee();</span><br><span class="line"><span class="comment">//可以改写成这样</span></span><br><span class="line"><span class="comment">//注意：需要调用的构造器的参数列表要与函数接口中抽象方法的参数列表一致</span></span><br><span class="line">Supplier&lt;Employee&gt; supplier1 = Employee::<span class="keyword">new</span>;</span><br><span class="line">Employee employee = supplier.get();</span><br></pre></td></tr></table></figure><h1 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h1><p>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的<code>查找</code>、<code>过滤</code>和<code>映射数据</code>等操作。使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来<strong>并行执行</strong>操作。简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</p><p><strong>1、理解Stream:</strong>  Stream被称作流，是用来处理集合以及数组的数据的。它有如下特点：</p><ul><li>Stream 自己不会存储元素。</li><li>Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</li><li>Stream 操作是延迟执行的。<strong>这意味着他们会等到需要结果的时候才执行。</strong></li></ul><p><strong>2、使用Stream的三个步骤：</strong></p><ul><li>创建Stream：一个数据源（如：集合、数组），获取一个流</li><li>中间操作：一个中间操作链，对数据源的数据进行处理</li><li>终止操作：一个终止操作，执行中间操作链，并产生结果</li></ul><p><strong>3、创建Stream:</strong>  直接看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、通过集合提供的stream方法或parallelStream()方法创建</span></span><br><span class="line">List&lt;<span class="built_in">String</span>&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Stream&lt;<span class="built_in">String</span>&gt; stringStream = list.stream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、通过Arrays中的静态方法stream获取数组流</span></span><br><span class="line">Employee[] employees = <span class="keyword">new</span> Employee[<span class="number">10</span>];</span><br><span class="line">Stream&lt;Employee&gt; stream = Arrays.stream(employees);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、通过Stream类的静态方法of()创建流</span></span><br><span class="line">Stream&lt;<span class="built_in">String</span>&gt; stream1 = Stream.of(<span class="string">"aa"</span>,<span class="string">"bb"</span>,<span class="string">"cc"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、创建无限流</span></span><br><span class="line"><span class="comment">//迭代方式创建无限流</span></span><br><span class="line"><span class="comment">//从0开始，每次加2，生成无限个</span></span><br><span class="line">Stream&lt;Integer&gt; stream2 = Stream.iterate(<span class="number">0</span>,(x) -&gt; x+<span class="number">2</span>);</span><br><span class="line"><span class="comment">//生成10个</span></span><br><span class="line">stream2.limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成方式创建无限流</span></span><br><span class="line">Stream.generate(() -&gt; <span class="built_in">Math</span>.random())</span><br><span class="line">                .limit(<span class="number">5</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>上面介绍了集合、数组创建流的几种方式，都有对应的注解。</p><p><strong>4、中间操作：</strong>  <strong>筛选与切片：</strong></p><ul><li>filter – 接收lambda，从流中排除某些数据。</li><li>limit – 截断流，使其元素不超过给定数量。</li><li>skip(n) – 跳过元素，返回一个扔掉了前n个元素的流，若不足n个元素，则返回空流。</li><li>distinct – 筛选，通过流所生成元素的hashCode()和equals()去除重复元素,所以对象必须重新hashCode方法和equals方法。</li></ul><p>看代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">employees.stream()<span class="comment">//已有employees集合</span></span><br><span class="line">         .filter((e) -&gt; e.getAge() &gt; <span class="number">18</span>)<span class="comment">//中间操作(选出年龄大于18的)</span></span><br><span class="line">         .limit(<span class="number">1</span>)<span class="comment">//中间操作(只返回一个)</span></span><br><span class="line">         .forEach(System.out::println);<span class="comment">//终止操作</span></span><br></pre></td></tr></table></figure><p><strong>映射：</strong></p><ul><li>map – 接收lambda，将元素转换成其他形式或提取信息。接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</li><li>flatMap – 接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所以流连接成一个流。</li></ul><p>看例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">String</span>&gt; list = Arrays.asList(<span class="string">"aa"</span>,<span class="string">"bb"</span>,<span class="string">"cc"</span>,<span class="string">"dd"</span>);</span><br><span class="line">list.stream()</span><br><span class="line">    .map(str -&gt; str.toUpperCase())<span class="comment">//将所有的转成大写</span></span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p><strong>排序：</strong></p><ul><li>sorted() – 自然排序(按照Comparable来排序)。</li><li>sorted(Comparator com) – 定制排序(按照Comparator来排序)。</li></ul><p>看例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">String</span>&gt; list = Arrays.asList(<span class="string">"ccc"</span>,<span class="string">"bbb"</span>,<span class="string">"aaa"</span>,<span class="string">"ddd"</span>);</span><br><span class="line">list.stream()</span><br><span class="line">    .sorted()<span class="comment">//自然排序</span></span><br><span class="line">    .forEach(System.out::print);<span class="comment">//aaa,bbb,ccc,ddd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定制排序</span></span><br><span class="line">employees.stream()<span class="comment">//employees是一个存有多名员工的集合</span></span><br><span class="line">      .sorted((e1, e2) -&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (e1.getAge().equals(e2.getAge()))&#123; <span class="comment">//如果年龄一样</span></span><br><span class="line">               <span class="keyword">return</span> e1.getName().compareTo(e2.getName());<span class="comment">//就比较姓名</span></span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> e1.getAge().compareTo(e2.getAge());<span class="comment">//年龄不一样就比较年龄</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p><strong>5、终止操作：</strong>  <strong>查找与匹配：</strong></p><ul><li>allMatch – 检查是否匹配所有元素。</li><li>anyMatch – 检查是否至少匹配一个元素。</li><li>noneMatch – 检查是否没有匹配所有元素。</li><li>findFirst – 返回第一个元素。</li><li>findAny – 返回当前流中任意元素。</li><li>count – 返回流中元素总个数。</li><li>max – 返回流中最大值。</li><li>min – 返回流中最小值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//看看employee集合中是不是所有都是男的</span></span><br><span class="line">boolean b = employees.stream()</span><br><span class="line">                     .allMatch(e -&gt; e.getGender().equals(<span class="string">"男"</span>));</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure><p><strong>规约：</strong></p><ul><li>reduce(T identity,BinaryOperator) – 可以将流中元素反复结合起来，得到一个值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//规约求和</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>);</span><br><span class="line">Integer sum = list.stream()</span><br><span class="line">                 .reduce(<span class="number">0</span>,(x,y) -&gt; x+y);<span class="comment">//首先把0作为x，把1作为y，进行加法运算得到1，把1再作为x，把3作为y，以此类推</span></span><br><span class="line">System.out.println(sum);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取工资总和</span></span><br><span class="line">Optional&lt;Double&gt; optional = employees.stream()</span><br><span class="line">                .map(Employee::getSalary)<span class="comment">//提取工资</span></span><br><span class="line">                .reduce(Double::sum);<span class="comment">//求工资总和</span></span><br><span class="line">System.out.println(optional2.get());</span><br></pre></td></tr></table></figure><p><strong>收集：</strong></p><ul><li>collect – 将流转换为其他形式。接收一个Collector接口的实现，用于给Stream中元素做汇总的方法。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把公司中所有员工的姓名提取出来并收集到一个集合中去</span></span><br><span class="line">List&lt;<span class="built_in">String</span>&gt; stringList = employees.stream()</span><br><span class="line">                .map(Employee::getName)<span class="comment">//提取员工姓名</span></span><br><span class="line">                <span class="comment">//.collect(Collectors.toList());//收集到list集合</span></span><br><span class="line">                <span class="comment">//.collect(Collectors.toSet());//收集到set集合</span></span><br><span class="line">                .collect(Collectors.toCollection(LinkedList::<span class="keyword">new</span>));<span class="comment">//这种方式可收集到任意集合</span></span><br><span class="line">stringList.forEach(System.out::println);<span class="comment">//遍历集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算工资平均值</span></span><br><span class="line">Double avgSalary = employees.stream()</span><br><span class="line">                .collect(Collectors.averagingDouble(Employee::getSalary));</span><br><span class="line">System.out.println(avgSalary);</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据年龄分组</span></span><br><span class="line"><span class="built_in">Map</span>&lt;Integer,List&lt;Employee&gt;&gt; map = employees.stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Employee::getAge));</span><br><span class="line">System.out.println(map);</span><br><span class="line"></span><br><span class="line"><span class="comment">//先按性别分组，性别一样时按年龄分组</span></span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>,<span class="built_in">Map</span>&lt;Integer,List&lt;Employee&gt;&gt;&gt; map1 = employees.stream()       </span><br><span class="line"> .collect(Collectors.groupingBy(Employee::getGender,Collectors.groupingBy(Employee::getAge)));</span><br><span class="line">System.out.println(map1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//分区，满足条件的一个区，不满足的另一个区</span></span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">Boolean</span>,List&lt;Employee&gt;&gt; map2 = employees.stream()</span><br><span class="line">         .collect(Collectors.partitioningBy(e -&gt; e.getSalary() &gt; <span class="number">6000</span>));<span class="comment">//工资大于6000的为true区，否则为false区</span></span><br><span class="line">System.out.println(map2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取工资的总额、平均值等</span></span><br><span class="line">DoubleSummaryStatistics dss = employees.stream()</span><br><span class="line">           .collect(Collectors.summarizingDouble(Employee::getSalary));</span><br><span class="line">System.out.println(dss.getSum());</span><br><span class="line">System.out.println(dss.getAverage());</span><br><span class="line">System.out.println(dss.getMax());</span><br></pre></td></tr></table></figure><h1 id="并行流与串行流"><a href="#并行流与串行流" class="headerlink" title="并行流与串行流"></a>并行流与串行流</h1><p><strong>1、fork/join框架：</strong>  此框架就是在必要的情况下，将一个大任务，进行拆分(fork)成若干个小任务（拆到不可再拆时），再将一个个的小任务运算的结果进行 join 汇总。  </p><p><img src="1.jpg" alt="img"></p><p>fork/join</p><p><strong>2、并行流与串行流：</strong>  通过上面的图可以知道，使用fork/join框架可以提高效率(<strong>运算量越大越明显，运算量可能反而更慢，因为拆分也需要时间</strong>)，但是在Java 8之前需要自己实现fork/join，还是挺麻烦的，Java 8就方便多了，因为提供了并行流，底层就是使用了fork/join。Stream API 可以声明性地通过<code>parallel()</code>与 <code>sequential()</code> 在并行流与顺序流之间进行切换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public <span class="keyword">void</span> test()&#123;</span><br><span class="line">      Instant start = Instant.now();</span><br><span class="line">      <span class="comment">//普通做法求0加到10000000000的和</span></span><br><span class="line">      LongStream.rangeClosed(<span class="number">0</span>,<span class="number">100000000000</span>L)</span><br><span class="line">              .reduce(<span class="number">0</span>,<span class="attr">Long</span>::sum);</span><br><span class="line">      Instant end = Instant.now();</span><br><span class="line">      System.out.println(<span class="string">"耗费"</span>+ Duration.between(end ,start) + <span class="string">"秒"</span>);<span class="comment">//55秒</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public <span class="keyword">void</span> test2()&#123;</span><br><span class="line">     Instant start = Instant.now();</span><br><span class="line">     <span class="comment">//并行流求0加到10000000000的和</span></span><br><span class="line">     LongStream.rangeClosed(<span class="number">0</span>,<span class="number">100000000000</span>L)</span><br><span class="line">             .parallel()<span class="comment">//使用并行流</span></span><br><span class="line">             .reduce(<span class="number">0</span>,<span class="attr">Long</span>::sum);</span><br><span class="line">     Instant end = Instant.now();</span><br><span class="line">     System.out.println(<span class="string">"耗费"</span>+ Duration.between(end ,start) + <span class="string">"秒"</span>);<span class="comment">//30秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过运行上面的程序可以明显感受到并行流的高效。</p><h1 id="新时间日期API"><a href="#新时间日期API" class="headerlink" title="新时间日期API"></a>新时间日期API</h1><p><strong>Java 8之前的Date和Calendar都是线程不安全的</strong>，而且使用起来比较麻烦，Java 8提供了全新的时间日期API，LocalDate(日期)、LocalTime(时间)、LocalDateTime(时间和日期) 、Instant (时间戳)、Duration(用于计算两个“时间”间隔)、Period(用于计算两个“日期”间隔)等。</p><p><strong>1、LocalDate、LocalTime、LocalDateTime：</strong>  这三个用法一样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前系统时间</span></span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now();<span class="comment">//当前时间日期</span></span><br><span class="line">LocalDateTime localDateTime2 = localDateTime.plusYears(<span class="number">2</span>);<span class="comment">//加两年</span></span><br><span class="line">System.out.println(localDateTime.getMonth());</span><br><span class="line">System.out.println(localDateTime);</span><br><span class="line">System.out.println(localDateTime2);</span><br><span class="line"><span class="comment">//指定时间</span></span><br><span class="line">LocalDateTime localDateTime1 = LocalDateTime.of(<span class="number">2018</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">8</span>);</span><br><span class="line">System.out.println(localDateTime1);</span><br></pre></td></tr></table></figure><p><strong>2、Instant 时间戳：</strong>  时间戳就是计算机读的时间，它是以<strong>Unix元年</strong>(传统的设定为UTC时区1970年1月1日午夜时分)开始算起的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//计算机读的时间：时间戳(Instant)，1970年1月1日0时0分0秒到此时的毫秒值</span></span><br><span class="line">Instant instant = Instant.now();</span><br><span class="line">System.out.println(instant);<span class="comment">//默认是美国时区，8个时差</span></span><br><span class="line">OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));<span class="comment">//加上时差</span></span><br><span class="line">System.out.println(offsetDateTime);</span><br><span class="line">System.out.println(instant.toEpochMilli());<span class="comment">//显示毫秒值</span></span><br></pre></td></tr></table></figure><p><strong>3、Duration 和 Period：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LocalTime localTime = LocalTime.now();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">LocalTime localTime1 = LocalTime.now();</span><br><span class="line">System.out.println(Duration.between(localTime,localTime1).toMillis());</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取两个日期之间的间隔</span></span><br><span class="line">LocalDate localDate = LocalDate.of(<span class="number">2012</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">LocalDate localDate1 = LocalDate.now();</span><br><span class="line">Period period = Period.between(localDate,localDate1);</span><br><span class="line">System.out.println(period);</span><br><span class="line">System.out.println(period.getYears()+<span class="string">"年"</span>+period.getMonths()+<span class="string">"月"</span>+period.getDays()+<span class="string">"日"</span>);</span><br></pre></td></tr></table></figure><p><strong>4、时间校正器(TemporalAdjuster)：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">System.out.println(localDateTime);</span><br><span class="line"></span><br><span class="line">LocalDateTime localDateTime1 = localDateTime.withDayOfMonth(<span class="number">1</span>);<span class="comment">//localDate日期中月份的1号</span></span><br><span class="line">System.out.println(localDateTime1);</span><br><span class="line">localDateTime1.with(TemporalAdjusters.firstDayOfNextMonth());<span class="comment">//下一个月的第一天</span></span><br><span class="line">localDateTime.with(TemporalAdjusters.next(DayOfWeek.SUNDAY));<span class="comment">//下周日</span></span><br></pre></td></tr></table></figure><p><strong>5、格式化日期(.DateTimeFormatter )：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public <span class="keyword">void</span> test6()&#123;</span><br><span class="line">        <span class="comment">//DateTimeFormatter:格式化</span></span><br><span class="line">        <span class="comment">//使用预设格式</span></span><br><span class="line">        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ISO_DATE_TIME;</span><br><span class="line">        LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">        <span class="built_in">String</span> str = localDateTime.format(dateTimeFormatter);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        System.out.println(<span class="string">"=========================="</span>);</span><br><span class="line">        <span class="comment">//自定义格式</span></span><br><span class="line">        DateTimeFormatter dateTimeFormatter1 = DateTimeFormatter.ofPattern(<span class="string">"yyyy年MM月dd日 HH:mm:ss"</span>);</span><br><span class="line">        <span class="built_in">String</span> str2 = localDateTime.format(dateTimeFormatter1);</span><br><span class="line">        <span class="comment">//这样格式化也可以</span></span><br><span class="line">        <span class="built_in">String</span> str3 = dateTimeFormatter1.format(localDateTime);</span><br><span class="line">        System.out.println(str2);</span><br><span class="line">        System.out.println(str3);</span><br><span class="line">        <span class="comment">//退回到解析前的格式</span></span><br><span class="line">        LocalDateTime newDate = localDateTime.parse(str,dateTimeFormatter);</span><br><span class="line">        System.out.println(newDate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6、时区的处理：</strong>  Java8 中加入了对时区的支持，带时区的时间为分别为：ZonedDate、ZonedTime、ZonedDateTime。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> @Test</span><br><span class="line"> public <span class="keyword">void</span> test7()&#123;</span><br><span class="line">   <span class="comment">//ZonedDate ZonedTime ZonedDateTime</span></span><br><span class="line">   LocalDateTime dateTime = LocalDateTime.now(ZoneId.of(<span class="string">"Europe/Tallinn"</span>));</span><br><span class="line">   System.out.println(dateTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="接口中的默认方法和静态方法"><a href="#接口中的默认方法和静态方法" class="headerlink" title="接口中的默认方法和静态方法"></a>接口中的默认方法和静态方法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface MyInterface &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="built_in">String</span> test()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"允许存在有具体实现的方法"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="built_in">String</span> test2()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"接口中还可以有静态方法"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，Java 8的接口中允许有<strong>默认方法</strong>和静态方法。如果一个类继承了一个类还实现了一个接口，而且接口中的默认方法和父类中的方法同名，这时采用类优先原则。也就是说，<strong>子类使用的是父类的方法，而不是接口中的同名方法。</strong></p><h1 id="其他新特性"><a href="#其他新特性" class="headerlink" title="其他新特性"></a>其他新特性</h1><p><strong>1、Optional类：</strong>  这个类是为了尽可能减少空指针异常的。就是把普通对象用Optional包起来，做了一些封装。看看其用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Man</span> </span>&#123; <span class="comment">//男人类</span></span><br><span class="line">    private Godness godness;<span class="comment">//女神</span></span><br><span class="line">&#125;</span><br><span class="line">@Data</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Godness</span> </span>&#123;</span><br><span class="line">    private <span class="built_in">String</span> name;</span><br><span class="line">    public Godness(<span class="built_in">String</span> name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public Godness()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取男人心中的女神的名字(有的人不一定有女神，也就是说女神可能为空)</span></span><br><span class="line">    <span class="comment">//常规做法要加很多判断</span></span><br><span class="line">    public <span class="built_in">String</span> getGodnessName(Man man)&#123;</span><br><span class="line">        <span class="keyword">if</span> (man != <span class="literal">null</span>)&#123;</span><br><span class="line">            Godness godness = man.getGodness();</span><br><span class="line">            <span class="keyword">if</span> (godness != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> godness.getName();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"我心中没有女神"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"男人为空"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>一个man类，有一个成员变量女神，女神也是一个类，有一个成员变量，名字。要获取man心中的女神，为了防止控制针异常，要做很多的判断。如果使用Optional呢？做法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新男人类</span></span><br><span class="line">@Data</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">NewMan</span> </span>&#123;</span><br><span class="line">    private Optional&lt;Godness&gt; godness = Optional.empty();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用optional后的方法</span></span><br><span class="line">public <span class="built_in">String</span> getGodnessName2(Optional&lt;NewMan&gt; man)&#123;</span><br><span class="line">    <span class="keyword">return</span> man.orElse(<span class="keyword">new</span> NewMan())</span><br><span class="line">                .getGodness()</span><br><span class="line">                .orElse(<span class="keyword">new</span> Godness(<span class="string">"我没有女神"</span>))</span><br><span class="line">                .getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就简单多了。</p><p><strong>2、重复注解与类型注解：</strong>  Java 8 可以使用重复注解和类型注解，如下图：  </p><p><img src="2.jpg" alt="img"></p><p>重复注解&amp;类型注解</p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>本文说了一些Java 8 的新特性，重点就是lambda表达式和Stream API，可以简化很多操作。肯可能还有些文中未涉及的，在此抛砖引玉，望各位大佬指点！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://cloud.tencent.com/developer/article/1378091&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java8 新特性&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;北京时间2018年9月26日，Oracle官方发布Java 11。既然版本都更新到11了，现在才来学8是不是太晚了？其实不是的，目前应该大部分都还是使用的Java 7和Java 8，这两个应该还是主流。而Java 8 又有一些激动人心的新特性，所以还是值得学习的。Java 8 新特性主要有以下几点：&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://changsk.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>java8中foreach原理</title>
    <link href="http://changsk.top/2019/07/08/java8-foreach/"/>
    <id>http://changsk.top/2019/07/08/java8-foreach/</id>
    <published>2019-07-08T10:02:40.000Z</published>
    <updated>2019-07-08T10:09:02.384Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://blog.csdn.net/wangjun5159/article/details/61415263" target="_blank" rel="noopener">java foreach原理</a></p></blockquote><h2 id="foreach语法糖"><a href="#foreach语法糖" class="headerlink" title="foreach语法糖"></a>foreach语法糖</h2><p>foreach是java的语法糖，<strong>所谓语法糖就是通过编译器或者其它手段优化了代码，给使用带来了遍历。</strong>比如，没有forach之前，我们需要这样遍历一个集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size; i++)&#123;</span><br><span class="line"><span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是很麻烦？</p><p>如果用foreach只需要这样</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">for</span>(String e : list)&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是省事多了，不用索引值，不用判断是否越界。</p><h2 id="foreach集合原理"><a href="#foreach集合原理" class="headerlink" title="foreach集合原理"></a>foreach集合原理</h2><p>但是，今天探讨的是foreach是什么，我们还是通过反编译代码来看吧。<br>源代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; a = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">       a.add(<span class="string">"1"</span>);</span><br><span class="line">       a.add(<span class="string">"2"</span>);</span><br><span class="line">       a.add(<span class="string">"3"</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(String temp : a)&#123;</span><br><span class="line">          System.out.print(temp);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>反编译后的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List a = <span class="keyword">new</span> ArrayList();</span><br><span class="line">a.add(<span class="string">"1"</span>);</span><br><span class="line"> a.add(<span class="string">"2"</span>);</span><br><span class="line"> a.add(<span class="string">"3"</span>);</span><br><span class="line"> String temp;</span><br><span class="line"> <span class="keyword">for</span>(Iterator i$ = a.iterator(); i$.hasNext(); System.out.print(temp))&#123;</span><br><span class="line">    temp = (String)i$.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>foreach集合相当于获取迭代器（a.iterator），通过判断是否有下一个元素(i.hasNext())，，然后移动光标(i.hasNext())，执行操作(System.out.print(temp))</p><p>我们知道集合都实现了iterator接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="foreach数组"><a href="#foreach数组" class="headerlink" title="foreach数组"></a>foreach数组</h2><p>好了，foreach集合的真面目，我们看懂了。因为集合实现了Iterator接口，所以遍历时走的Iterator的方法，但是foreach不只可以遍历集合，还可以遍历数组，难道数组也实现了Iterator接口？</p><p>同样，看源代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">"1"</span>,<span class="string">"2"</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(String e : arr)&#123;</span><br><span class="line">     System.out.println(e);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>反编译后代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String arr[] = &#123; <span class="string">"1"</span>, <span class="string">"2"</span>  &#125;;</span><br><span class="line"> String arr$[] = arr;</span><br><span class="line"> <span class="keyword">int</span> len$ = arr$.length;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i$ = <span class="number">0</span>; i$ &lt; len$; i$++)</span><br><span class="line"> &#123;</span><br><span class="line">     String e = arr$[i$];</span><br><span class="line">     System.out.println(e);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>可以看到foreach数组，走的是for(int i=0; i&lt; len; i++)经典模式。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://blog.csdn.net/wangjun5159/article/details/61415263&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;java foreach原理&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;foreach语法糖&quot;&gt;&lt;a href=&quot;#foreach语法糖&quot; class=&quot;headerlink&quot; title=&quot;foreach语法糖&quot;&gt;&lt;/a&gt;foreach语法糖&lt;/h2&gt;&lt;p&gt;foreach是java的语法糖，&lt;strong&gt;所谓语法糖就是通过编译器或者其它手段优化了代码，给使用带来了遍历。&lt;/strong&gt;比如，没有forach之前，我们需要这样遍历一个集合&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;list.size; i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//.....&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;是不是很麻烦？&lt;/p&gt;
&lt;p&gt;如果用foreach只需要这样&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://changsk.top/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>JDK1.8中jvm的变化以及理由</title>
    <link href="http://changsk.top/2019/07/08/java8-jvm/"/>
    <id>http://changsk.top/2019/07/08/java8-jvm/</id>
    <published>2019-07-08T09:30:26.000Z</published>
    <updated>2019-07-08T09:53:27.541Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://www.jianshu.com/p/4b4cecc8e262" target="_blank" rel="noopener">选择JDK1.8的理由之JVM内存变化</a></p></blockquote><p>jvm运行时内存区域主要分为：程序计数器，jvm栈，本地方法栈，堆，方法区。</p><a id="more"></a><p><img src="1.jpg" alt="img"></p><h2 id="JVM中内存"><a href="#JVM中内存" class="headerlink" title="JVM中内存"></a>JVM中内存</h2><p>JVM中内存通常划分为两个部分，分别为<code>堆内存</code>与<code>栈内存</code>，栈内存主要用<code>执行线程方法</code>,<code>存放本地临时变量</code>与线程中方法执行时候需要的<code>引用对象地址</code>。</p><p>JVM所有的<code>对象</code>数据都存放在<code>堆内存</code>中，相比栈内存，堆内存可以大的多，<strong>所以JVM一直通过对堆内存划分不同的功能区块实现对堆内存中对象管理。</strong></p><p>堆内存不够最常见的错误就<strong>是OOM(OutOfMemoryError)</strong></p><p>栈内存溢出最常见的错误就是<strong>StackOverflowError</strong>，程序有递归调用时候最容易发生</p><h2 id="堆内存划分"><a href="#堆内存划分" class="headerlink" title="堆内存划分"></a>堆内存划分</h2><p>在JDK7以及其前期的JDK版本中，堆内存通常被分为三块区域Nursery内存(young generation)、长时内存(old generation)、永久内存(Permanent Generation for VM Matedata)，显示如下图：</p><p><img src="2.jpg" alt="img"></p><p>其中最上一层是Nursery内存，一个对象被创建以后首先被放到Nursery中的Eden内存中，<strong>如果存活期超两个Survivor之后就会被转移到长时内存中(Old Generation)中</strong>。</p><p><strong>永久内存中存放着类的方法、变量等元数据信息</strong>。如果永久内存不够，我们就会得到如下错误：</p><p><strong>java.lang.OutOfMemoryError: PermGen</strong></p><p>而在JDK8中情况发生了明显的变化，就是一般情况下你都不会得到这个错误，原因在于JDK8中把存放元数据中的永久内存从堆内存中移到了本地内存(native memory)中，JDK8中JVM堆内存结构就变成了如下：</p><p><img src="3.jpg" alt="img"></p><p><strong>这样永久内存就不再占用堆内存</strong>，它可以通过<strong>自动增长</strong>来避免JDK7以及前期版本中常见的永久内存错误(java.lang.OutOfMemoryError: PermGen)，也许这个就是你的JDK升级到JDK8的理由之一吧。当然JDK8也提供了一个新的设置Matespace内存大小的参数，通过这个参数可以设置Matespace内存大小，这样我们可以根据自己项目的实际情况，避免过度浪费本地内存，达到有效利用。</p><h2 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h2><p><code>-XX:MaxMetaspaceSize=128m</code>设置最大的元内存空间128兆</p><p><strong>注意：</strong>如果不设置JVM将会根据一定的策略<code>自动增加</code>本地元内存空间。<br> 如果你设置的元内存空间过小，你的应用程序可能得到以下错误：<br> <code>java.lang.OutOfMemoryError: Metadata space</code></p><ul><li><strong>jdk8移除了PermGen，取而代之的是MetaSpace元空间（Metaspace）：</strong><br> 一种新的内存空间的诞生。JDK8 HotSpot JVM 使用本地内存来存储类元数据信息并称之为：元空间（Metaspace）；这与Oracle JRockit 和IBM JVM’s很相似。这将是一个好消息：意味着不会再有<code>java.lang.OutOfMemoryError:PermGen</code>问题，<strong>也不再需要你进行调优及监控内存空间的使用</strong>，但是新特性不能消除<code>类</code>和<code>类加载器</code>导致的<code>内存泄漏</code>。你需要使用不同的方法以及遵守新的命名约定来追踪这些问题。</li><li><strong>PermGen 空间的状况</strong><br> 这部分内存空间将全部移除。</li></ul><p>JVM的参数：<strong>PermSize</strong> 和 <strong>MaxPermSize</strong> 会被忽略并给出警告（如果在启用时设置了这两个参数）。</p><ul><li><p><strong>Metaspace 内存分配模型</strong><br> （最大区别）大部分类元数据都在本地内存中分配。</p></li><li><p><strong>Metaspace 容量</strong><br> 默认情况下，类元数据只受可用的本地内存限制（容量取决于是32位或是64位操作系统的可用<strong>虚拟内存</strong>大小）。</p></li><li><p><strong>新参数（MaxMetaspaceSize）</strong><br> 用于限制本地内存分配给类元数据的大小。如果没有指定这个参数，元空间会在运行时根据需要动态调整。</p></li><li><p><strong>Metaspace 垃圾回收</strong><br> 对于僵死的类及类加载器的垃圾回收将在元数据使用达到“MaxMetaspaceSize”参数的设定值时进行。</p><p>适时地监控和调整元空间对于减小垃圾回收频率和减少延时是很有必要的。持续的元空间垃圾回收说明，可能存在类、类加载器导致的<strong>内存泄漏</strong>或是大小设置不合适。</p><p>Java 堆内存的影响一些杂项数据已经移到Java堆空间中。<strong>升级到JDK8之后，会发现Java堆 空间有所增长。</strong></p></li><li><p><strong>Metaspace 监控</strong><br> 元空间的使用情况可以从HotSpot1.8的详细GC日志输出中得到。</p></li><li><p><strong>参数设置</strong><br>默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：</p></li></ul><p><strong>-XX:MetaspaceSize</strong>，初始空间大小，<strong>达到该值就会触发垃圾收集进行类型卸载</strong>，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。</p><p><strong>-XX:MaxMetaspaceSize</strong>，最大空间，默认是没有限制的。</p><p>除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：<br> <strong>-XX:MinMetaspaceFreeRatio</strong>，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集</p><p><strong>-XX:MaxMetaspaceFreeRatio</strong>，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</p><h2 id="更新原因"><a href="#更新原因" class="headerlink" title="更新原因"></a>更新原因</h2><p>   1、<code>字符串</code>存在永久代中，容易出现<strong>性能问题</strong>和<strong>内存溢出</strong>。   2、类及方法的信息等比较难确定其大小，<strong>因此对于永久代的大小指定比较困难</strong>，<strong>太小容易出现永久代溢出，太大则容易导致老年代(就小了）溢出。</strong><br>   3、<strong>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</strong><br>   4、Oracle 可能会将HotSpot 与 JRockit 合二为一。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://www.jianshu.com/p/4b4cecc8e262&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;选择JDK1.8的理由之JVM内存变化&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;jvm运行时内存区域主要分为：程序计数器，jvm栈，本地方法栈，堆，方法区。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://changsk.top/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://changsk.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>死锁</title>
    <link href="http://changsk.top/2019/07/08/deadlock/"/>
    <id>http://changsk.top/2019/07/08/deadlock/</id>
    <published>2019-07-08T03:23:11.000Z</published>
    <updated>2019-07-08T13:32:26.435Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://blog.csdn.net/wljliujuan/article/details/79614019" target="_blank" rel="noopener">死锁，死锁的四个必要条件以及处理策略</a></p></blockquote><h2 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h2><p>多线程以及多进程<code>改善了系统资源的利用率并提高了系统的处理能力</code>。然而，并发执行也带来了新的问题——<strong>死锁</strong>。 </p><blockquote><p>死锁是指两个或两个以上的进程（线程）在运行过程中因争夺资源而造成的一种僵局（Deadly-Embrace) ) ，若无外力作用，这些进程（线程）都将无法向前推进。</p></blockquote><p>下面我们通过一些实例来说明死锁现象。</p><p>先看生活中的一个实例，2个人一起吃饭但是只有一双筷子，2人轮流吃（同时拥有2只筷子才能吃）。某一个时候，一个拿了左筷子，一人拿了右筷子，2个人都同时占用一个资源，等待另一个资源，这个时候甲在等待乙吃完并释放它占有的筷子，同理，乙也在等待甲吃完并释放它占有的筷子，这样就陷入了一个死循环，谁也无法继续吃饭。。。<br>在计算机系统中也存在类似的情况。例如，某计算机系统中只有一台打印机和一台输入设备，进程P1正占用输入设备，同时又提出使用打印机的请求，但此时打印机正被进程P2 所占用，而P2在未释放打印机之前，又提出请求使用正被P1占用着的输入设备。这样两个进程相互无休止地等待下去，均无法继续执行，此时两个进程陷入死锁状态。</p><p>关于死锁的一些结论：</p><ul><li>参与死锁的进程数至少为两个</li><li>参与死锁的所有进程均等待资源</li><li>参与死锁的进程至少有两个已经占有资源</li><li>死锁进程是系统中当前进程集合的一个子集</li><li>死锁会浪费大量系统资源，甚至导致系统崩溃。<h2 id="死锁与饥饿"><a href="#死锁与饥饿" class="headerlink" title="死锁与饥饿"></a>死锁与饥饿</h2></li></ul><p><strong>饥饿（Starvation）指一个进程一直得不到资源。</strong></p><p>死锁和饥饿都是由于进程竞争资源而引起的。饥饿一般不占有资源，死锁进程一定占有资源。</p><h2 id="资源的类型"><a href="#资源的类型" class="headerlink" title="资源的类型"></a>资源的类型</h2><h3 id="可重用资源和消耗性资源"><a href="#可重用资源和消耗性资源" class="headerlink" title="可重用资源和消耗性资源"></a>可重用资源和消耗性资源</h3><h4 id="可重用资源（永久性资源）"><a href="#可重用资源（永久性资源）" class="headerlink" title="可重用资源（永久性资源）"></a>可重用资源（永久性资源）</h4><p>可被多个进程多次使用，如所有硬件。</p><p>只能分配给一个进程使用，不允许多个进程共享。<br>进程在对可重用资源的使用时，须按照<code>请求资源</code>、<code>使用资源</code>、<code>释放资源</code>这样的顺序。<br>系统中每一类可重用资源中的单元数目是相对固定的，进程在运行期间，既不能创建，也不能删除。</p><h4 id="消耗性资源（临时性资源）"><a href="#消耗性资源（临时性资源）" class="headerlink" title="消耗性资源（临时性资源）"></a>消耗性资源（临时性资源）</h4><p>又称临时性资源，<strong>是由进程在运行期间动态的创建和消耗的。</strong></p><p>消耗性资源在进程运行期间是可以不断变化的，有时可能为0。<br>进程在运行过程中，可以不断地创造可消耗性资源的单元，将它们放入该资源类的缓冲区中，以增加该资源类的单元数目。<br>进程在运行过程中，可以请求若干个可消耗性资源单元，用于进程自己消耗，不再将它们返回给该资源类中。<br><strong>可消耗资源通常是由生产者进程创建，由消费者进程消耗。最典型的可消耗资源是用于进程间通信的消息。</strong></p><h3 id="可抢占资源和不可抢占资源"><a href="#可抢占资源和不可抢占资源" class="headerlink" title="可抢占资源和不可抢占资源"></a>可抢占资源和不可抢占资源</h3><h4 id="可抢占资源"><a href="#可抢占资源" class="headerlink" title="可抢占资源"></a>可抢占资源</h4><p>可抢占资源指某进程在获得这类资源后，该资源可以再被其他进程或系统抢占。<strong>对于这类资源是不会引起死锁的。</strong></p><p><strong>CPU 和主存均属于可抢占性资源。</strong></p><h4 id="不可抢占资源"><a href="#不可抢占资源" class="headerlink" title="不可抢占资源"></a>不可抢占资源</h4><p>一旦系统把某资源分配给该进程后，就不能将它强行收回，只能在进程用完后自行释放。</p><p><strong>磁带机、打印机等属于不可抢占性资源。</strong></p><h2 id="死锁产生的原因"><a href="#死锁产生的原因" class="headerlink" title="死锁产生的原因"></a>死锁产生的原因</h2><ul><li>竞争不可抢占资源引起死锁<br>通常系统中拥有的不可抢占资源，其数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局，如<strong>磁带机、打印机</strong>等。只有对不可抢占资源的竞争才可能产生死锁，对可抢占资源的竞争是不会引起死锁的。</li><li>竞争可消耗资源引起死锁</li><li>进程推进顺序不当引起死锁<br>进程在运行过程中，请求和释放资源的顺序不当，也同样会导致死锁。例如，并发进程 P1、P2分别保持了资源R1、R2，而进程P1申请资源R2，进程P2申请资源R1时，两者都会因为所需资源被占用而阻塞。<br>信号量使用不当也会造成死锁。进程间彼此相互等待对方发来的消息，结果也会使得这 些进程间无法继续向前推进。例如，进程A等待进程B发的消息，进程B又在等待进程A 发的消息，可以看出进程A和B不是因为竞争同一资源，而是在等待对方的资源导致死锁。<h3 id="竞争不可抢占资源引起死锁"><a href="#竞争不可抢占资源引起死锁" class="headerlink" title="竞争不可抢占资源引起死锁"></a>竞争不可抢占资源引起死锁</h3>如：共享文件时引起死锁<br>系统中拥有两个进程P1和P2，它们都准备写两个文件F1和F2。而这两者都属于可重用和不可抢占性资源。如果进程P1在打开F1的同时，P2进程打开F2文件，当P1想打开F2时由于F2已结被占用而阻塞，当P2想打开1时由于F1已结被占用而阻塞，此时就会无线等待下去，形成死锁。 </li></ul><p><img src="1.jpg" alt></p><h3 id="竞争可消耗资源引起死锁"><a href="#竞争可消耗资源引起死锁" class="headerlink" title="竞争可消耗资源引起死锁"></a>竞争可消耗资源引起死锁</h3><p>如：进程通信时引起死锁<br>系统中拥有三个进程P1、P2和P3，m1、m2、m3是3可消耗资源。进程P1一方面产生消息m1，将其发送给P2，另一方面要从P3接收消息m3。而进程P2一方面产生消息m2，将其发送给P3，另一方面要从P1接收消息m1。类似的，进程P3一方面产生消息m3，将其发送给P1，另一方面要从P2接收消息m2。<br>如果三个进程都先发送自己产生的消息后接收别人发来的消息，则可以顺利的运行下去不会产生死锁，但要是三个进程都先接收别人的消息而不产生消息则会永远等待下去，产生死锁。 </p><p><img src="2.jpg" alt></p><h3 id="进程推进顺序不当引起死锁"><a href="#进程推进顺序不当引起死锁" class="headerlink" title="进程推进顺序不当引起死锁"></a>进程推进顺序不当引起死锁</h3><p>上图中，如果按曲线1的顺序推进，两个进程可顺利完成；如果按曲线2的顺序推进，两个进程可顺利完成；如果按曲线3的顺序推进，两个进程可顺利完成；如果按曲线4的顺序推进，两个进程将进入不安全区D中，此时P1保持了资源R1，P2保持了资源R2，系统处于不安全状态，如果继续向前推进，则可能产生死锁。</p><p><img src="3.jpg" alt></p><h2 id="产生死锁的四个必要条件"><a href="#产生死锁的四个必要条件" class="headerlink" title="产生死锁的四个必要条件"></a>产生死锁的四个必要条件</h2><h3 id="互斥条件"><a href="#互斥条件" class="headerlink" title="互斥条件"></a>互斥条件</h3><p>进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</p><h3 id="不可剥夺条件"><a href="#不可剥夺条件" class="headerlink" title="不可剥夺条件"></a>不可剥夺条件</h3><p>进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。</p><h3 id="请求与保持条件"><a href="#请求与保持条件" class="headerlink" title="请求与保持条件"></a>请求与保持条件</h3><p>进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</p><h3 id="循环等待条件"><a href="#循环等待条件" class="headerlink" title="循环等待条件"></a>循环等待条件</h3><p>存在一种<strong>进程资源的循环等待链</strong>，链中每一个进程已获得的资源同时被链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中Pi等待的资源被P(i+1)占有（i=0, 1, …, n-1)，Pn等待的资源被P0占有，如图2-15所示。</p><p>直观上看，循环等待条件似乎和死锁的定义一样，其实不然。按死锁定义构成等待环所要求的条件更严，它要求Pi等待的资源必须由P(i+1)来满足，而循环等待条件则无此限制。 例如，系统中有两台输出设备，P0占有一台，PK占有另一台，且K不属于集合{0, 1, …, n}。</p><p>Pn等待一台输出设备，它可以从P0获得，也可能从PK获得。因此，虽然Pn、P0和其他 一些进程形成了循环等待圈，但PK不在圈内，若PK释放了输出设备，则可打破循环等待, 如图2-16所示。<strong>因此循环等待只是死锁的必要条件。</strong></p><p><img src="4.jpg" alt></p><p>资源分配图含圈而系统又不一定有死锁的原因是<strong>同类资源数大于1</strong>。但若系统中每类资 源都只有一个资源，则资源分配图含圈就变成了系统出现死锁的充分必要条件。</p><p><strong>以上这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</strong></p><p>产生死锁的一个例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个简单的死锁类</span></span><br><span class="line"><span class="comment"> * 当DeadLock类的对象flag==1时（td1），先锁定o1,睡眠500毫秒</span></span><br><span class="line"><span class="comment"> * 而td1在睡眠的时候另一个flag==0的对象（td2）线程启动，先锁定o2,睡眠500毫秒</span></span><br><span class="line"><span class="comment"> * td1睡眠结束后需要锁定o2才能继续执行，而此时o2已被td2锁定；</span></span><br><span class="line"><span class="comment"> * td2睡眠结束后需要锁定o1才能继续执行，而此时o1已被td1锁定；</span></span><br><span class="line"><span class="comment"> * td1、td2相互等待，都需要得到对方锁定的资源才能继续执行，从而死锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> flag = <span class="number">1</span>;  </span><br><span class="line">    <span class="comment">//静态对象是类的所有对象共享的  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object o1 = <span class="keyword">new</span> Object(), o2 = <span class="keyword">new</span> Object();  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"flag="</span> + flag);  </span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (o1) &#123;  </span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">synchronized</span> (o2) &#123;  </span><br><span class="line">                    System.out.println(<span class="string">"1"</span>);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (o2) &#123;  </span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">synchronized</span> (o1) &#123;  </span><br><span class="line">                    System.out.println(<span class="string">"0"</span>);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DeadLock td1 = <span class="keyword">new</span> DeadLock();</span><br><span class="line">        DeadLock td2 = <span class="keyword">new</span> DeadLock();</span><br><span class="line">        td1.flag = <span class="number">1</span>;</span><br><span class="line">        td2.flag = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//td1,td2都处于可执行状态，但JVM线程调度先执行哪个线程是不确定的。  </span></span><br><span class="line">        <span class="comment">//td2的run()可能在td1的run()之前运行  </span></span><br><span class="line">        <span class="keyword">new</span> Thread(td1).start();  </span><br><span class="line">        <span class="keyword">new</span> Thread(td2).start();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="处理死锁的方法"><a href="#处理死锁的方法" class="headerlink" title="处理死锁的方法"></a>处理死锁的方法</h2><ul><li>预防死锁：通过设置某些限制条件，去<strong>破坏产生死锁的四个必要条件中的一个或几个条件</strong>，来防止死锁的发生。</li><li>避免死锁：在资源的动态分配过程中，用<strong>某种方法去防止系统进入不安全状态</strong>，从而避免死锁的发生。</li><li>检测死锁：允许系统在运行过程中发生死锁，但可设置检测机构及时检测死锁的发生，并采取适当措施加以清除。</li><li>解除死锁：当检测出死锁后，便采取适当措施将进程从死锁状态中解脱出来。</li></ul><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><h4 id="破坏“互斥”条件"><a href="#破坏“互斥”条件" class="headerlink" title="破坏“互斥”条件:"></a>破坏“互斥”条件:</h4><p>就是在系统里取消互斥。若资源不被一个进程独占使用，那么死锁是肯定不会发生的。但一般来说在所列的四个条件中，“互斥”条件是无法破坏的。因此，在死锁预防里主要是破坏其他几个必要条件，而不去涉及破坏“互斥”条件。</p><blockquote><p>注意：<strong>互斥条件不能被破坏</strong>，否则会造成结果的不可再现性。</p></blockquote><h4 id="破坏“占有并等待”条件"><a href="#破坏“占有并等待”条件" class="headerlink" title="破坏“占有并等待”条件:"></a>破坏“占有并等待”条件:</h4><p>破坏“占有并等待”条件，就是在系统中不允许进程在已获得某种资源的情况下，申请其他资源。即要想出一个办法，阻止进程在持有资源的同时申请其他资源。<br>方法一：创建进程时，要求它申请所需的全部资源，系统或满足其所有要求，或什么也不给它。这是所谓的 “ <strong>一次性分配</strong>”方案。<br>方法二：要求每个进程提出新的资源申请前，释放它所占有的资源。这样，一个进程在需要资源S时，须先把它先前占有的资源R释放掉，然后才能提出对S的申请，即使它可能很快又要用到资源R。</p><h4 id="破坏“不可抢占”条件："><a href="#破坏“不可抢占”条件：" class="headerlink" title="破坏“不可抢占”条件："></a>破坏“不可抢占”条件：</h4><p>破坏“不可抢占”条件就是<strong>允许对资源实行抢夺。</strong><br>方法一：如果占有某些资源的一个进程进行进一步资源请求被拒绝，则该进程必须释放它最初占有的资源，如果有必要，可再次请求这些资源和另外的资源。<br>方法二：如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以抢占另一个进程，要求它释放资源。<strong>只有在任意两个进程的优先级都不相同的条件下，方法二才能预防死锁。</strong></p><h4 id="破坏“循环等待”条件："><a href="#破坏“循环等待”条件：" class="headerlink" title="破坏“循环等待”条件："></a>破坏“循环等待”条件：</h4><p>破坏“循环等待”条件的一种方法，<strong>是将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序（升序）提出。这样做就能保证系统不出现死锁。</strong></p><h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何让这四个必要条件不成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。</p><blockquote><p>预防死锁和避免死锁的区别：<br>预防死锁是设法至少破坏产生死锁的四个必要条件之一,严格的防止死锁的出现,而避免死锁则不那么严格的限制产生死锁的必要条件的存在,因为即使死锁的必要条件存在,也不一定发生死锁。避免死锁是在系统运行过程中注意避免死锁的最终发生。</p></blockquote><h4 id="常用避免死锁的方法"><a href="#常用避免死锁的方法" class="headerlink" title="常用避免死锁的方法"></a>常用避免死锁的方法</h4><h5 id="有序资源分配法"><a href="#有序资源分配法" class="headerlink" title="有序资源分配法"></a>有序资源分配法</h5><p>这种算法资源按某种规则系统中的所有资源统一编号（例如打印机为1、磁带机为2、磁盘为3、等等），申请时必须以上升的次序。系统要求申请进程：<br>　　1、对它所必须使用的而且属于同一类的所有资源，必须一次申请完；<br>　　2、在申请不同类资源时，必须按各类设备的编号依次申请。例如：进程PA，使用资源的顺序是R1，R2； 进程PB，使用资源的顺序是R2，R1；若采用动态分配有可能形成环路条件，造成死锁。<br>　　采用有序资源分配法：R1的编号为1，R2的编号为2；<br>　　PA：申请次序应是：R1，R2<br>　　PB：申请次序应是：R1，R2<br>　　这样就破坏了环路条件，避免了死锁的发生。 　　</p><h5 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h5><p>详见银行家算法.</p><h4 id="常用避免死锁的技术"><a href="#常用避免死锁的技术" class="headerlink" title="常用避免死锁的技术"></a>常用避免死锁的技术</h4><ol><li><p>加锁顺序（线程按照一定的顺序加锁）</p></li><li><p>加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）</p></li><li><p>死锁检测</p><h5 id="加锁顺序"><a href="#加锁顺序" class="headerlink" title="加锁顺序"></a>加锁顺序</h5><p>当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。</p></li></ol><p>如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。看下面这个例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread 1: </span><br><span class="line"><span class="keyword">lock</span> A </span><br><span class="line"><span class="keyword">lock</span> B </span><br><span class="line"><span class="keyword">Thread</span> <span class="number">2</span>: </span><br><span class="line"><span class="keyword">wait</span> <span class="keyword">for</span> A </span><br><span class="line"><span class="keyword">lock</span> C (<span class="keyword">when</span> A <span class="keyword">locked</span>) </span><br><span class="line"><span class="keyword">Thread</span> <span class="number">3</span>: </span><br><span class="line"><span class="keyword">wait</span> <span class="keyword">for</span> A </span><br><span class="line"><span class="keyword">wait</span> <span class="keyword">for</span> B </span><br><span class="line"><span class="keyword">wait</span> <span class="keyword">for</span> C</span><br></pre></td></tr></table></figure><p>如果一个线程（比如线程3）需要一些锁，那么它必须按照确定的顺序获取锁。它只有获得了从顺序上排在前面的锁之后，才能获取后面的锁。</p><p>例如，线程2和线程3只有在获取了锁A之后才能尝试获取锁C(译者注：获取锁A是获取锁C的必要条件)。因为线程1已经拥有了锁A，所以线程2和3需要一直等到锁A被释放。然后在它们尝试对B或C加锁之前，必须成功地对A加了锁。</p><p>按照顺序加锁是一种有效的死锁预防机制。但是，这种方式需要你事先知道所有可能会用到的锁(译者注：并对这些锁做适当的排序)，但总有些时候是无法预知的。</p><h5 id="加锁时限"><a href="#加锁时限" class="headerlink" title="加锁时限"></a>加锁时限</h5><p>另外一个可以避免死锁的方法是在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。若一个线程没有在给定的时限内成功获得所有需要的锁，<strong>则会进行回退并释放所有已经获得的锁</strong>，然后等待一段随机的时间再重试。这段随机的等待时间让其它线程有机会尝试获取相同的这些锁，并且让该应用在没有获得锁的时候可以继续运行(译者注：加锁超时后可以先继续运行干点其它事情，再回头来重复之前加锁的逻辑)。</p><p>以下是一个例子，展示了两个线程以不同的顺序尝试获取相同的两个锁，在发生超时后回退并重试的场景：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread 1 locks A </span><br><span class="line">Thread 2 locks B </span><br><span class="line">Thread 1 attempts to <span class="keyword">lock</span> B but <span class="keyword">is</span> blocked </span><br><span class="line"><span class="keyword">Thread</span> <span class="number">2</span> attempts <span class="keyword">to</span> <span class="keyword">lock</span> A but <span class="keyword">is</span> blocked </span><br><span class="line"><span class="keyword">Thread</span> <span class="number">1</span>’s <span class="keyword">lock</span> attempt <span class="keyword">on</span> B times <span class="keyword">out</span> </span><br><span class="line"><span class="keyword">Thread</span> <span class="number">1</span> backs up <span class="keyword">and</span> releases A <span class="keyword">as</span> well </span><br><span class="line"><span class="keyword">Thread</span> <span class="number">1</span> waits randomly (e.g. <span class="number">257</span> millis) <span class="keyword">before</span> retrying. </span><br><span class="line"><span class="keyword">Thread</span> <span class="number">2</span>’s <span class="keyword">lock</span> attempt <span class="keyword">on</span> A times <span class="keyword">out</span> </span><br><span class="line"><span class="keyword">Thread</span> <span class="number">2</span> backs up <span class="keyword">and</span> releases B <span class="keyword">as</span> well </span><br><span class="line"><span class="keyword">Thread</span> <span class="number">2</span> waits randomly (e.g. <span class="number">43</span> millis) <span class="keyword">before</span> retrying.</span><br></pre></td></tr></table></figure><p>在上面的例子中，线程2比线程1早200毫秒进行重试加锁，因此它可以先成功地获取到两个锁。这时，线程1尝试获取锁A并且处于等待状态。当线程2结束时，线程1也可以顺利的获得这两个锁（除非线程2或者其它线程在线程1成功获得两个锁之前又获得其中的一些锁）。</p><p>需要注意的是，由于存在锁的超时，所以我们不能认为这种场景就一定是出现了死锁。也可能是因为获得了锁的线程（导致其它线程超时）需要很长的时间去完成它的任务。</p><p>此外，如果有非常多的线程同一时间去竞争同一批资源，就算有超时和回退机制，还是可能会导致这些线程重复地尝试但却始终得不到锁。如果只有两个线程，并且重试的超时时间设定为0到500毫秒之间，这种现象可能不会发生，但是如果是10个或20个线程情况就不同了。因为这些线程等待相等的重试时间的概率就高的多（或者非常接近以至于会出现问题）。<br>(译者注：超时和重试机制是为了避免在同一时间出现的竞争，但是当线程很多时，其中两个或多个线程的超时时间一样或者接近的可能性就会很大，因此就算出现竞争而导致超时后，由于超时时间一样，它们又会同时开始重试，导致新一轮的竞争，带来了新的问题。)</p><p>这种机制存在一个问题，在Java中不能对synchronized同步块设置超时时间。你需要创建一个自定义锁，或使用Java5中java.util.concurrent包下的工具。写一个自定义锁类不复杂，但超出了本文的内容。后续的Java并发系列会涵盖自定义锁的内容。</p><h3 id="检测死锁"><a href="#检测死锁" class="headerlink" title="检测死锁"></a>检测死锁</h3><p>一般来说，由于操作系统有并发，共享以及随机性等特点，通过预防和避免的手段达到排除死锁的目的是很困难的。这需要较大的系统开销，而且不能充分利用资源。为此，一种简便的方法是系统为进程分配资源时，不采取任何限制性措施，但是提供了检测和解脱死锁的手段：<strong>能发现死锁并从死锁状态中恢复出来</strong>。因此，<strong>在实际的操作系统中往往采用死锁的检测与恢复方法来排除死锁。</strong><br>*<em>死锁检测与恢复是指系统设有专门的机构，当死锁发生时，该机构能够检测到死锁发生的位置和原因，并能通过外力破坏死锁发生的必要条件，从而使得并发进程从死锁状态中恢复出来。 *</em></p><p>死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。</p><p>每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph等等）将其记下。除此之外，每当有线程请求锁，也需要记录在这个数据结构中。</p><p>当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。例如，线程A请求锁7，但是锁7这个时候被线程B持有，这时线程A就可以检查一下线程B是否已经请求了线程A当前所持有的锁。如果线程B确实有这样的请求，那么就是发生了死锁（线程A拥有锁1，请求锁7；线程B拥有锁7，请求锁1）。</p><p>当然，死锁一般要比两个线程互相持有对方的锁这种情况要复杂的多。线程A等待线程B，线程B等待线程C，线程C等待线程D，线程D又在等待线程A。线程A为了检测死锁，它需要递进地检测所有被B请求的锁。从线程B所请求的锁开始，线程A找到了线程C，然后又找到了线程D，发现线程D请求的锁被线程A自己持有着。这是它就知道发生了死锁。</p><p>下面是一幅关于四个线程（A,B,C和D）之间锁占有和请求的关系图。像这样的数据结构就可以被用来检测死锁。</p><p><img src="5.jpg" alt></p><h3 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁"></a>解除死锁</h3><p>一旦检测出死锁，就应立即釆取相应的措施，以解除死锁。<br>死锁解除的主要方法有：<br>1) 资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。<br>2) 撤销进程法。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。<br>3) 进程回退法。让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://blog.csdn.net/wljliujuan/article/details/79614019&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;死锁，死锁的四个必要条件以及处理策略&lt;
      
    
    </summary>
    
      <category term="操作系统" scheme="http://changsk.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="DeadLock" scheme="http://changsk.top/tags/DeadLock/"/>
    
  </entry>
  
  <entry>
    <title>免密登陆原理</title>
    <link href="http://changsk.top/2019/07/08/login-without-password/"/>
    <id>http://changsk.top/2019/07/08/login-without-password/</id>
    <published>2019-07-08T02:55:37.000Z</published>
    <updated>2019-07-08T03:09:20.703Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="https://www.cnblogs.com/wangdy0707/p/9080021.html" target="_blank" rel="noopener">[靠谱原创！] SSH免密登录设置—-原理详解+具体操作(全国人民看完都懂了！)</a></p><p>首先介绍一下SSH：</p><a id="more"></a><p><img src="1.jpg" alt></p><p>当我们用一台服务器登录另一台服务器可直接使用SSH协议进行<strong>登陆</strong>：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体格式：</span></span><br><span class="line"><span class="comment">//ssh  [用户名]@[IP]</span></span><br><span class="line"></span><br><span class="line">ssh wdy@<span class="number">192.168</span><span class="number">.33</span><span class="number">.12</span></span><br></pre></td></tr></table></figure><p>也可以直接<strong>远程传送文件</strong>到另一台服务器，具体格式如下：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//具体格式：</span><br><span class="line">//scp <span class="string">[文件名]</span> <span class="string">[目标服务器用户名]</span>@<span class="string">[目标服务器IP]</span> : <span class="string">[目标复制位置]</span></span><br><span class="line"></span><br><span class="line">scp test.txt root@<span class="number">192.168.33.12</span>:/home</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：以上操作方法存在弊端，每次操作都需要输入目标服务器的密码，<strong>不适合集群服务器的批量操作。</strong>所以一般我们会用SSH的第二种身份验证机制：<strong>密钥验证。</strong>验证流程如下图：</p><p><img src="2.jpg" alt></p><p>即在源服务器上先生成一份<strong>公钥</strong>和一份<strong>密钥</strong>，<strong>将公钥复制到目标服务器</strong>，利用命令将公钥添加至目标服务器的授权列表(authorized_keys)。当有服务器带着公钥申请连接服务器时，目标服务器首先在authorized_keys中查找是否存在该公钥，如果存在则开始进行验证。首先生成一个随机字符串，利用对应公钥进行加密，然后返回给申请连接的服务器，申请连接服务器利用私钥进行解密，再将字符串返回给目标服务器完成验证，进行后续操作。</p><p>首先在源服务器上生成公钥和密钥：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span>具体格式：</span><br><span class="line"><span class="regexp">//</span>其中  -t  [加密方式]        </span><br><span class="line">                ssh-keygen -t rsa</span><br><span class="line"><span class="regexp">//</span>默认会在 <span class="regexp">/root/</span>.ssh<span class="regexp">/ 重生成公钥和密钥  id_rsa   id_rsa.pub</span></span><br></pre></td></tr></table></figure><p>如下图：</p><p><img src="3.jpg" alt></p><p>接下来我们需要将源服务器生成的公钥拷贝到目标服务器中并添加至<code>authorized_keys</code>列表中，这两步可以使用一个简便命令进行执行：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将公钥添加至目标服务器的authorized_keys列表中</span></span><br><span class="line"><span class="comment">//具体格式：</span></span><br><span class="line"><span class="comment">//ssh-copy-id [目标服务器IP]</span></span><br><span class="line">    ssh-copy-id <span class="number">192.168</span><span class="number">.33</span><span class="number">.12</span></span><br></pre></td></tr></table></figure><p>截图如下：</p><p><img src="4.jpg" alt></p><p>我们在目标服务器的 <code>/root/.ssh</code> 文件夹中查看授权列表<code>authorized_keys</code>发现原服务器的公钥已经添加进去：</p><p><img src="5.jpg" alt></p><p>至此我们已经完成了SSH免密登录的设置，可以再源服务器上进行登录验证，已经不需要再输入密码：</p><p><img src="6.jpg" alt></p><p>同样我们可以在目标服务器上进行同样的设置使两台服务器相互免密登录。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自：&lt;a href=&quot;https://www.cnblogs.com/wangdy0707/p/9080021.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[靠谱原创！] SSH免密登录设置—-原理详解+具体操作(全国人民看完都懂了！)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先介绍一下SSH：&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://changsk.top/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode-3:Longest Substring Without Repeating Characters(最长无重复字串)</title>
    <link href="http://changsk.top/2019/07/08/leetcode3/"/>
    <id>http://changsk.top/2019/07/08/leetcode3/</id>
    <published>2019-07-08T02:49:01.000Z</published>
    <updated>2019-07-08T02:53:06.574Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>题目难度:Medium</p></blockquote><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p><a id="more"></a><p><strong>Example 1:</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="string">"abcabcbb"</span></span><br><span class="line">Output: <span class="number">3</span> </span><br><span class="line">Explanation: The answer <span class="keyword">is</span> <span class="string">"abc"</span>, <span class="keyword">with</span> <span class="keyword">the</span> <span class="built_in">length</span> <span class="keyword">of</span> <span class="number">3.</span></span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="string">"bbbbb"</span></span><br><span class="line">Output: <span class="number">1</span></span><br><span class="line">Explanation: The answer <span class="keyword">is</span> <span class="string">"b"</span>, <span class="keyword">with</span> <span class="keyword">the</span> <span class="built_in">length</span> <span class="keyword">of</span> <span class="number">1.</span></span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="string">"pwwkew"</span></span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is <span class="string">"wke"</span>, with the length of 3. </span><br><span class="line">            <span class="built_in"> Note </span>that the answer must be a substring, <span class="string">"pwke"</span> is a subsequence <span class="keyword">and</span> <span class="keyword">not</span> a substring.</span><br></pre></td></tr></table></figure><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] charHashMap = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">256</span>;i++) charHashMap[i] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = s.charAt(i);</span><br><span class="line">            start = Math.max(start, charHashMap[index] + <span class="number">1</span>);</span><br><span class="line">            charHashMap[index] = i;</span><br><span class="line">            max = Math.max(max, i - start + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更简洁的解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] index = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">            i = Math.max(index[s.charAt(j)], i);</span><br><span class="line">            max = Math.max(max, j - i + <span class="number">1</span>);</span><br><span class="line">            index[s.charAt(j)] = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;题目难度:Medium&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Given a string, find the length of the &lt;strong&gt;longest substring&lt;/strong&gt; without repeating characters.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://changsk.top/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="http://changsk.top/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>linux之inode</title>
    <link href="http://changsk.top/2019/07/08/linux-inode/"/>
    <id>http://changsk.top/2019/07/08/linux-inode/</id>
    <published>2019-07-08T02:31:31.000Z</published>
    <updated>2019-07-08T02:42:08.524Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自:<a href="http://www.ruanyifeng.com/blog/2011/12/inode.html" target="_blank" rel="noopener">理解inode</a></p></blockquote><h2 id="inode是什么"><a href="#inode是什么" class="headerlink" title="inode是什么"></a>inode是什么</h2><p>理解<strong>inode</strong>，要从文件储存说起。</p><p>文件储存在硬盘上，<strong>硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。</strong></p><p>操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即<strong>一次性读取一个”块”（block）。</strong>这种由多个扇区组成的”块”，<strong>是文件存取的最小单位</strong>。<strong>“块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。</strong></p><p>文件数据都储存在”块”中，那么很显然，我们还必须<strong>找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。</strong></p><p><strong>每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。</strong></p><a id="more"></a><h2 id="inode的内容"><a href="#inode的内容" class="headerlink" title="inode的内容"></a>inode的内容</h2><p>inode包含文件的元信息，具体来说有以下内容：</p><blockquote><ul><li>文件的字节数</li><li>文件拥有者的User ID</li><li>文件的Group ID</li><li>文件的读、写、执行权限</li><li>文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。</li><li>链接数，即有多少文件名指向这个inode</li><li>文件数据block的位置</li></ul></blockquote><p>可以用stat命令，查看某个文件的inode信息：</p><blockquote><p>　　stat example.txt</p></blockquote><p><img src="1.jpg" alt="img"></p><p>总之，<strong>除了文件名以外的所有文件信息，都存在inode之中</strong>。至于为什么没有文件名，下文会有详细解释。</p><h2 id="inode的大小"><a href="#inode的大小" class="headerlink" title="inode的大小"></a>inode的大小</h2><p><strong>inode也会消耗硬盘空间</strong>，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。</p><p><strong>每个inode节点的大小，一般是128字节或256字节。</strong>inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。</p><p>查看每个硬盘分区的inode总数和已经使用的数量，可以使用df命令。</p><blockquote><p>　　df -i</p></blockquote><p><img src="2.jpg" alt="img"></p><p>查看每个inode节点的大小，可以用如下命令：</p><blockquote><p>　　sudo dumpe2fs -h /dev/hda | grep “Inode size”</p></blockquote><p><img src="3.jpg" alt="img"></p><p><strong>由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件。</strong></p><h2 id="inode号码"><a href="#inode号码" class="headerlink" title="inode号码"></a>inode号码</h2><p>每个inode都有一个号码，操作系统用inode号码来识别不同的文件。</p><p>这里值得重复一遍，Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。</p><p>表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：<strong>首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。</strong></p><p>使用ls -i命令，可以看到文件名对应的inode号码：</p><blockquote><p>　　ls -i example.txt</p></blockquote><p><img src="4.jpg" alt="img"></p><h2 id="目录文件"><a href="#目录文件" class="headerlink" title="目录文件"></a>目录文件</h2><p>Unix/Linux系统中，<strong>目录（directory）也是一种文件。打开目录，实际上就是打开目录文件。</strong></p><p>目录文件的结构非常简单，就是一系列目录项（dirent）的列表。每个目录项，由两部分组成：所包含文件的文件名，以及该文件名对应的inode号码。</p><p>ls命令只列出目录文件中的所有文件名：</p><blockquote><p>　　ls /etc</p></blockquote><p><img src="5.jpg" alt="img"></p><p>ls -i命令列出整个目录文件，即文件名和inode号码：</p><blockquote><p>　　ls -i /etc</p></blockquote><p><img src="6.jpg" alt="img"></p><p>如果要查看文件的详细信息，就必须根据inode号码，访问inode节点，读取信息。ls -l命令列出文件的详细信息。</p><blockquote><p>　　ls -l /etc</p></blockquote><p><img src="7.jpg" alt="img"></p><p><strong>理解了上面这些知识，就能理解目录的权限。目录文件的读权限（r）和写权限（w），都是针对目录文件本身。由于目录文件内只有文件名和inode号码，所以如果只有读权限，只能获取文件名，无法获取其他信息，因为其他信息都储存在inode节点中，而读取inode节点内的信息需要目录文件的执行权限（x）。</strong></p><h2 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h2><p>一般情况下，文件名和inode号码是”一一对应”关系，每个inode号码对应一个文件名。但是，Unix/Linux系统允许，<strong>多个文件名指向同一个inode号码。</strong></p><p>这意味着，可以用不同的文件名访问同样的内容；<strong>对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为”硬链接”（hard link）。</strong></p><p>ln命令可以创建硬链接：</p><blockquote><p>　　ln 源文件 目标文件</p></blockquote><p><img src="8.jpg" alt="img"></p><p>运行上面这条命令以后，<strong>源文件与目标文件的inode号码相同，都指向同一个inode。inode信息中有一项叫做”链接数”，记录指向该inode的文件名总数，这时就会增加1。</strong></p><p><strong>反过来，删除一个文件名，就会使得inode节点中的”链接数”减1。当这个值减到0，表明没有文件名指向这个inode，系统就会回收这个inode号码，以及其所对应block区域。</strong></p><p><strong>这里顺便说一下目录文件的”链接数”。创建目录时，默认会生成两个目录项：”.”和”..”。前者的inode号码就是当前目录的inode号码，等同于当前目录的”硬链接”；后者的inode号码就是当前目录的父目录的inode号码，等同于父目录的”硬链接”。所以，任何一个目录的”硬链接”总数，总是等于2加上它的子目录总数（含隐藏目录）。</strong></p><h2 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h2><p>除了硬链接以外，还有一种特殊情况。</p><p><strong>文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的”软链接”（soft link）或者”符号链接（symbolic link）。</strong></p><p>这意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错：”<strong>No such file or directory</strong>“。这是软链接与硬链接最大的不同：<strong>文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode”链接数”不会因此发生变化。</strong></p><p>ln -s命令可以创建软链接。</p><blockquote><p>　　ln -s 源文文件或目录 目标文件或目录</p></blockquote><p><img src="9.jpg" alt="img"></p><h2 id="inode的特殊作用"><a href="#inode的特殊作用" class="headerlink" title="inode的特殊作用"></a>inode的特殊作用</h2><p>由于inode号码与文件名分离，这种机制导致了一些Unix/Linux系统特有的现象。</p><ol><li>有时，文件名包含特殊字符，无法正常删除。这时，直接删除inode节点，就能起到删除文件的作用。</li><li><strong>移动文件或重命名文件，只是改变文件名，不影响inode号码。</strong></li><li>打开一个文件以后，系统就以inode号码来识别这个文件，不再考虑文件名。因此，通常来说，系统无法从inode号码得知文件名。</li></ol><p><strong>第3点使得软件更新变得简单，可以在不关闭软件的情况下进行更新，不需要重启。因为系统通过inode号码，识别运行中的文件，不通过文件名。更新的时候，新版文件以同样的文件名，生成一个新的inode，不会影响到运行中的文件。等到下一次运行这个软件的时候，文件名就自动指向新版文件，旧版文件的inode则被回收。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自:&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/12/inode.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;理解inode&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;inode是什么&quot;&gt;&lt;a href=&quot;#inode是什么&quot; class=&quot;headerlink&quot; title=&quot;inode是什么&quot;&gt;&lt;/a&gt;inode是什么&lt;/h2&gt;&lt;p&gt;理解&lt;strong&gt;inode&lt;/strong&gt;，要从文件储存说起。&lt;/p&gt;
&lt;p&gt;文件储存在硬盘上，&lt;strong&gt;硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即&lt;strong&gt;一次性读取一个”块”（block）。&lt;/strong&gt;这种由多个扇区组成的”块”，&lt;strong&gt;是文件存取的最小单位&lt;/strong&gt;。&lt;strong&gt;“块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文件数据都储存在”块”中，那么很显然，我们还必须&lt;strong&gt;找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://changsk.top/categories/Linux/"/>
    
    
      <category term="inode" scheme="http://changsk.top/tags/inode/"/>
    
  </entry>
  
  <entry>
    <title>tcp和udp的区别与应用场景</title>
    <link href="http://changsk.top/2019/07/08/tcp-udp/"/>
    <id>http://changsk.top/2019/07/08/tcp-udp/</id>
    <published>2019-07-08T02:16:03.000Z</published>
    <updated>2019-07-08T02:31:04.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>面向报文</li></ul><p>面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即<strong>一次发送一个报文</strong>。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会使IP太小。UDP对应用层交下来的报文，<strong>既不合并，也不拆分</strong>，<strong>而是保留这些报文的边界</strong>。这也就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。<strong>UDP面向无连接。</strong></p><a id="more"></a><ul><li>面向字节流</li></ul><p>面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但<strong>TCP把应用程序的传输数据看成是一连串的无结构的字节流</strong>。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。<strong>TCP面向连接。</strong></p><h2 id="TCP和UDP介绍"><a href="#TCP和UDP介绍" class="headerlink" title="TCP和UDP介绍"></a>TCP和UDP介绍</h2><h3 id="TCP（可靠-有序-无丢失-不重复）"><a href="#TCP（可靠-有序-无丢失-不重复）" class="headerlink" title="TCP（可靠  有序 无丢失 不重复）"></a>TCP（可靠  有序 无丢失 不重复）</h3><ul><li>TCP是面向连接的；</li><li>每条TCP连接只能有两个端点，一对一通信；</li><li>TCP提供<strong>可靠</strong>的交付服务，传输数据<strong>无差错</strong>，<strong>不丢失</strong>，<strong>不重复</strong>，且<strong>按时序到达</strong>；</li><li>TCP提供全双工通信；</li><li>面向字节流，TCP根据对方给出的窗口和当前的网络拥塞程度决定一个报文应该包含多少个字节。</li></ul><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><ul><li><p>面向无连接；</p></li><li><p>UDP使用<strong>尽最大努力交付</strong>，不保证可靠性。UDP是面向报文的，UDP对应用层交付下来的报文，既不合并，也不拆分，而是保留报文的边界；</p></li><li><p>UDP面向报文，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文；</p></li><li><p>UDP没有拥塞控制；</p></li><li><p>UDP支持一对一，一对多，多对一和多对多的交互通信。</p></li><li><p>UDP的首部开销小，只有8字节。</p></li></ul><h3 id="TCP-和UDP区别"><a href="#TCP-和UDP区别" class="headerlink" title="TCP 和UDP区别"></a>TCP 和UDP区别</h3><ol><li><p>TCP是面向连接(Connection oriented)的协议，UDP是无连接(Connection less)协议；<br>TCP用三次握手建立连接：1) Client向server发送SYN；2) Server接收到SYN，回复Client一个SYN-ACK；3) Client接收到SYN_ACK，回复Server一个ACK。到此，连接建成。UDP发送数据前不需要建立连接。</p></li><li><p>TCP可靠，UDP不可靠；TCP丢包会自动重传，UDP不会。</p></li><li><p>TCP有序，UDP无序；消息在传输过程中可能会乱序，后发送的消息可能会先到达，TCP会对其进行重排序，UDP不会。</p></li><li><p>TCP无界，UDP有界；TCP通过字节流传输，UDP中每一个包都是单独的。</p></li><li><p>TCP有流量控制（拥塞控制），UDP没有；主要靠三次握手实现。</p></li><li><p>TCP传输慢，UDP传输快；因为TCP需要建立连接、保证可靠性和有序性，所以比较耗时。这就是为什么视频流、广播电视、在线多媒体游戏等选择使用UDP。</p></li><li><p>TCP是重量级的，UDP是轻量级的；TCP要建立连接、保证可靠性和有序性，就会传输更多的信息，如TCP的包头比较大。</p></li><li><p>TCP的头部比UDP大；TCP头部需要20字节，UDP头部只要8个字节</p></li></ol><h2 id="TCP和UDP协议的一些应用"><a href="#TCP和UDP协议的一些应用" class="headerlink" title="TCP和UDP协议的一些应用"></a>TCP和UDP协议的一些应用</h2><p><img src="1.jpg" alt="在这里插入图片描述"></p><p><strong>TCP和UDP协议的比较</strong></p><p><img src="2.jpg" alt="在这里插入图片描述"></p><p><strong>TCP/UDP编程模型</strong></p><p><img src="3.jpg" alt="在这里插入图片描述"></p><p>从上图也能清晰的看出，TCP通信需要服务器端侦听<strong>listen</strong>、接收客户端连接请求<strong>accept</strong>，等待客户端<strong>connect</strong>建立连接后才能进行数据包的收发（recv/send）工作。而UDP则服务器和客户端的概念不明显，服务器端即接收端需要绑定端口，等待客户端的数据的到来。后续便可以进行数据的收发（recvfrom/sendto）工作。</p><p>在前面讲解UDP时，提到了UDP保留了报文的边界，下面我们来谈谈TCP和UDP中报文的边界问题。在默认的阻塞模式下，TCP无边界，UDP有边界。</p><p>对于TCP协议，客户端连续发送数据，只要服务端的这个函数的缓冲区足够大，会一次性接收过来，即客户端是分好几次发过来，是有边界的，而服务端却一次性接收过来，所以证明是无边界的；</p><p>而对于UDP协议，客户端连续发送数据，即使服务端的这个函数的缓冲区足够大，也只会一次一次的接收，发送多少次接收多少次，即客户端分几次发送过来，服务端就必须按几次接收，从而证明，这种UDP的通讯模式是有边界的。</p><h2 id="TCP-UDP的优缺点"><a href="#TCP-UDP的优缺点" class="headerlink" title="TCP/UDP的优缺点"></a>TCP/UDP的优缺点</h2><h3 id="TCP的优点"><a href="#TCP的优点" class="headerlink" title="TCP的优点"></a>TCP的优点</h3><p>可靠，稳定，有序，无丢失，不重复，</p><p>TCP的可靠体现在TCP在传递数据之前，会有<strong>三次握手来建立连接</strong>，而且在数据传递时，有<strong>确认机制（可靠）</strong>、滑动<strong>窗口（流量控制）</strong>、<strong>重传（可靠）</strong>、<strong>拥塞控制机制</strong>，在数据传完后，还会断开连接用来节约系统资源。</p><h3 id="TCP的缺点"><a href="#TCP的缺点" class="headerlink" title="TCP的缺点"></a>TCP的缺点</h3><p>慢，效率低，占用系统资源高，易被攻击</p><p>TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，<strong>确认机制、重传机制、拥塞控制机制</strong>等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。</p><p>而且，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。</p><h3 id="UDP的优点"><a href="#UDP的优点" class="headerlink" title="UDP的优点"></a>UDP的优点</h3><p>快，比TCP稍安全</p><p>UDP没有TCP的<strong>握手、确认、窗口、重传、拥塞控制等机制</strong>，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击……</p><h3 id="UDP的缺点"><a href="#UDP的缺点" class="headerlink" title="UDP的缺点"></a>UDP的缺点</h3><p>不可靠，不稳定</p><p>因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。</p><h2 id="TCP-UDP应用场景"><a href="#TCP-UDP应用场景" class="headerlink" title="TCP/UDP应用场景"></a>TCP/UDP应用场景</h2><p>基于上面的优缺点，那么：</p><ul><li>什么时候应该使用TCP：</li></ul><p>当对<strong>网络通讯质量有要求</strong>的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如<strong>HTTP</strong>、<strong>HTTPS</strong>、<strong>FTP</strong>等传输文件的协议，POP、SMTP等邮件传输的协议。</p><p>在日常生活中，常见使用TCP协议的应用如下：</p><blockquote><p>浏览器，用的<strong>HTTP</strong></p><p>FlashFXP，用的<strong>FTP</strong></p><p>Outlook，用的<strong>POP</strong>、<strong>SMTP</strong></p><p>Putty，用的<strong>Telnet</strong>、SSH</p><p>QQ文件传输</p></blockquote><ul><li>那么什么时候应该使用UDP：</li></ul><p>当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。</p><p>比如，日常生活中，常见使用UDP协议的应用如下：</p><blockquote><p>QQ语音</p><p>QQ视频</p><p>TFTP</p><p>直播</p><p>DNS</p><p>DHCP</p><p>RIP</p></blockquote><blockquote><p>参考:<br><a href="https://blog.csdn.net/u013777351/article/details/49226101" target="_blank" rel="noopener">传输层TCP和UDP的区别分析与应用场景【转载】</a><br><a href="https://blog.csdn.net/weixin_42385626/article/details/81983594" target="_blank" rel="noopener">TCP,UDP通信使用场景及区别比较</a><br><a href="https://juejin.im/post/583d2d6a67f356006bb7d535" target="_blank" rel="noopener">TCP 和 UDP</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;面向报文&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即&lt;strong&gt;一次发送一个报文&lt;/strong&gt;。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会使IP太小。UDP对应用层交下来的报文，&lt;strong&gt;既不合并，也不拆分&lt;/strong&gt;，&lt;strong&gt;而是保留这些报文的边界&lt;/strong&gt;。这也就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。&lt;strong&gt;UDP面向无连接。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://changsk.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="TCP" scheme="http://changsk.top/tags/TCP/"/>
    
      <category term="UDP" scheme="http://changsk.top/tags/UDP/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-数据流中的中位数</title>
    <link href="http://changsk.top/2019/07/04/jianzhioffer-median/"/>
    <id>http://changsk.top/2019/07/04/jianzhioffer-median/</id>
    <published>2019-07-04T13:48:05.000Z</published>
    <updated>2019-07-04T14:18:03.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p><a id="more"></a><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote><p>链接：<a href="https://www.nowcoder.com/questionTerminal/9be0172896bd43948f8a32fb954e1be1来源：牛客网" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/9be0172896bd43948f8a32fb954e1be1来源：牛客网</a></p><p>   1、两个堆中的数据数目差不能超过1，这样可以使中位数只会出现在两个堆的交接处； </p><p>   2、大顶堆的所有数据都小于小顶堆，这样就满足了排序要求。</p></blockquote><p>解析：</p><ol><li><p>用最小堆<strong>minHeap</strong>保存中位数的后半部分<br> 用最大堆<strong>maxHeap</strong>保存中位数的前半部分<br> 后半部分的值都大于前半部分      </p></li><li><p>当前个数为偶数，两堆中数量相同<br>当前个数为奇数，最小堆也就是中位数的后半部分的数量比最大堆个数多1</p></li><li><p>插入num：<br> 当前个数为偶数（应该往中位数后半部分minHeap添加数）：</p></li></ol><ul><li><p>如果num小于前半部分的最大值，应该把num offer 到 maxHeap，然后把maxHeap中的最大值取出来，加入到minHeap</p></li><li><p>否则，把num offer 到minHeap</p><p>当前个数为奇数（应该往中位数前半部分maxHeap添加数）：    </p></li><li><p>如果num大于minHeap中的最小值，先把num offer 到 minHeap，取出minHeap中的最小值加入到maxHeap</p></li><li><p>否则，把num offer 到 maxHeap                </p></li></ul><ol start="4"><li><p>获取中位数：</p><p>如果是奇数，中位数为 <strong>minHeap.peek() * 1.0;</strong></p><p>如果是偶数，中位数为 <strong>(maxHeap.peek() + minHeap.peek()) / 2.0;</strong></p></li></ol><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//优先级队列默认是最小堆,中位数的后半部分</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(); </span><br><span class="line">    <span class="comment">//中位数的前半部分</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="number">6</span>, <span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o2 - o1;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((count &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!maxHeap.isEmpty() &amp;&amp; num &lt; maxHeap.peek())&#123;</span><br><span class="line">                maxHeap.offer(num);</span><br><span class="line">                num = maxHeap.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            minHeap.offer(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(num &gt; minHeap.peek())&#123;</span><br><span class="line">                minHeap.offer(num);</span><br><span class="line">                num = minHeap.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            maxHeap.offer(num);</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((count &amp; <span class="number">1</span>) == <span class="number">1</span>) <span class="keyword">return</span> minHeap.peek() * <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">return</span> (maxHeap.peek() + minHeap.peek()) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="http://changsk.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="http://changsk.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-二叉搜索树的第K个节点</title>
    <link href="http://changsk.top/2019/07/04/jianzhioffer-kth-node/"/>
    <id>http://changsk.top/2019/07/04/jianzhioffer-kth-node/</id>
    <published>2019-07-04T12:29:50.000Z</published>
    <updated>2019-07-04T12:31:04.434Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p><a id="more"></a><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> order = <span class="number">0</span>;</span><br><span class="line">    TreeNode kth = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>) <span class="keyword">return</span> kth;</span><br><span class="line">        kthNodeCore(pRoot, k);</span><br><span class="line">        <span class="keyword">return</span> kth;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">kthNodeCore</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        kthNodeCore(pRoot.left, k);</span><br><span class="line">        order++;</span><br><span class="line">        <span class="keyword">if</span>(order == k) kth = pRoot;</span><br><span class="line">        kthNodeCore(pRoot.right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。&lt;/p&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="http://changsk.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="http://changsk.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="Algorithm" scheme="http://changsk.top/tags/Algorithm/"/>
    
  </entry>
  
</feed>
