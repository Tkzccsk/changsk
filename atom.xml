<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>changsk&#39;s blogs</title>
  
  <subtitle>chang.sk@foxmail.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://changsk.top/"/>
  <updated>2019-06-20T07:58:57.034Z</updated>
  <id>http://changsk.top/</id>
  
  <author>
    <name>changsk</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java_synchronized</title>
    <link href="http://changsk.top/2019/06/20/java-synchronized/"/>
    <id>http://changsk.top/2019/06/20/java-synchronized/</id>
    <published>2019-06-20T05:58:07.000Z</published>
    <updated>2019-06-20T07:58:57.034Z</updated>
    
    <content type="html"><![CDATA[<p><strong>线程安全</strong>是并发编程中的重要关注点，应该注意到的是，造成线程安全问题的主要诱因有两点，一是存在<strong>共享数据</strong>(也称<strong>临界资源</strong>)，二是<strong>存在多条线程共同操作共享数据</strong>。因此为了解决这个问题，我们可能需要这样一个方案，当存在多个线程操作共享数据时，需要<strong>保证同一时刻有且只有一个线程在操作共享数据</strong>，其他线程必须等到该线程处理完数据后再进行，这种方式有个高大上的名称叫<strong>互斥锁</strong>，即能达到互斥访问目的的锁，也就是说当一个共享数据被当前正在访问的线程加上互斥锁后，在同一个时刻，其他线程只能处于<strong>等待的状态</strong>，直到当前线程处理完毕释放该锁。在 Java 中，<strong>关键字 synchronized可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块</strong>(主要是对方法或者代码块中存在共享数据的操作)，同时我们还应该注意到synchronized另外一个重要的作用，<strong>synchronized可保证一个线程的变化(主要是共享数据的变化)被其他线程所看到（保证可见性，完全可以替代Volatile功能）</strong>，这点确实也是很重要的。</p><a id="more"></a><h2 id="synchronized的三种应用方式"><a href="#synchronized的三种应用方式" class="headerlink" title="synchronized的三种应用方式"></a>synchronized的三种应用方式</h2><p>synchronized关键字最主要有以下3种应用方式，下面分别介绍</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁</span><br><span class="line"></span><br><span class="line">修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁</span><br><span class="line"></span><br><span class="line">修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</span><br></pre></td></tr></table></figure><h3 id="synchronized作用于实例方法"><a href="#synchronized作用于实例方法" class="headerlink" title="synchronized作用于实例方法"></a>synchronized作用于实例方法</h3><p>所谓的实例对象锁就是用synchronized修饰实例对象中的实例方法，注意是<strong>实例方法不包括静态方法</strong>，如下</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AccountingSync</span> <span class="title">implements</span> <span class="title">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">//共享资源(临界资源)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * synchronized 修饰实例方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">increase</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000000</span>;j++)&#123;</span><br><span class="line">            increase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws InterruptedException</span> &#123;</span><br><span class="line">        AccountingSync instance=<span class="keyword">new</span> AccountingSync();</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(instance);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.<span class="keyword">join</span>();</span><br><span class="line">        t2.<span class="keyword">join</span>();</span><br><span class="line">        System.<span class="keyword">out</span>.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出结果:</span></span><br><span class="line"><span class="comment">     * 2000000</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，我们开启两个线程操作同一个共享资源即变量i，由于<code>i++;</code>操作并不具备原子性，该操作是<strong>先读取值，然后写回一个新值，相当于原来的值加上1</strong>，分两步完成(应该是三步，读取，加1，写入)，如果第二个线程在第一个线程读取旧值和写回新值期间读取i的域值，那么第二个线程就会与第一个线程一起看到同一个值，并执行相同值的加1操作，这也就造成了线程安全失败，因此对于increase方法必须使用synchronized修饰，以便保证线程安全。此时我们应该注意到synchronized修饰的是实例方法increase，在这样的情况下，当前线程的锁便是实例对象instance，注意Java中的线程同步锁可以是任意对象。从代码执行结果来看确实是正确的，倘若我们没有使用synchronized关键字，其最终输出结果就很可能小于2000000，这便是synchronized关键字的作用。这里我们还需要意识到，当一个线程正在访问一个对象的 synchronized 实例方法，那么其他线程不能访问该对象的其他 synchronized 方法，毕竟一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他synchronized实例方法，但是<strong>其他线程还是可以访问该实例对象的其他非synchronized方法</strong>，当然如果是一个线程 A 需要访问实例对象 obj1 的 synchronized 方法 f1(当前对象锁是obj1)，另一个线程 B 需要访问实例对象 obj2 的 synchronized 方法 f2(当前对象锁是obj2)，这样是允许的，因为两个实例对象锁并不同相同，此时如果两个线程操作数据并非共享的，线程安全是有保障的，遗憾的是如果两个线程操作的是共享数据，那么线程安全就有可能无法保证了，如下代码将演示出该现象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountingSyncBad</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000000</span>;j++)&#123;</span><br><span class="line">            increase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//new新实例</span></span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> AccountingSyncBad());</span><br><span class="line">        <span class="comment">//new新实例</span></span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> AccountingSyncBad());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">//join含义:当前线程A等待thread线程终止之后才能从thread.join()返回</span></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码与前面不同的是我们同时创建了两个新实例AccountingSyncBad，然后启动两个不同的线程对共享变量i进行操作，但很遗憾操作结果是1452317而不是期望结果2000000，因为上述代码犯了严重的错误，虽然我们使用synchronized修饰了increase方法，但却new了两个不同的实例对象，这也就意味着存在着<strong>两个不同的实例对象锁</strong>，因此t1和t2都会进入各自的对象锁，也就是说t1和t2线程使用的是不同的锁，因此线程安全是无法保证的。解决这种困境的的方式是将<strong>synchronized作用于静态的increase方法</strong>，这样的话，对象锁就<strong>当前类对象</strong>，由于无论创建多少个实例对象，但对于的类对象拥有只有一个，所有在这样的情况下对象锁就是唯一的。下面我们看看如何使用将synchronized作用于静态的increase方法。</p><h3 id="synchronized作用于静态方法"><a href="#synchronized作用于静态方法" class="headerlink" title="synchronized作用于静态方法"></a>synchronized作用于静态方法</h3><p>当synchronized作用于静态方法时，<strong>其锁就是当前类的class对象锁</strong>。由于静态成员不专属于任何一个实例对象，是类成员，因此通过class对象锁可以控制静态成员的并发操作。需要注意的是如果一个线程A调用一个实例对象的非static synchronized方法，而线程B需要调用这个实例对象所属类的静态 synchronized方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的class对象，而访问非静态 synchronized 方法占用的锁是当前实例对象锁，看如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountingSyncClass</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 作用于静态方法,锁是当前class对象,也就是</span></span><br><span class="line"><span class="comment">     * AccountingSyncClass类对应的class对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非静态,访问时锁不一样不会发生互斥</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase4Obj</span><span class="params">()</span></span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000000</span>;j++)&#123;</span><br><span class="line">            increase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//new新实例</span></span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> AccountingSyncClass());</span><br><span class="line">        <span class="comment">//new心事了</span></span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> AccountingSyncClass());</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t1.start();t2.start();</span><br><span class="line"></span><br><span class="line">        t1.join();t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于synchronized关键字修饰的是静态increase方法，与修饰实例方法不同的是，其锁对象是当前类的class对象。注意代码中的increase4Obj方法是实例方法，其对象锁是当前实例对象，如果别的线程调用该方法，将不会产生互斥现象，毕竟<strong>锁对象不同</strong>，但我们应该意识到这种情况下可能会发现线程安全问题(操作了共享静态变量i)。</p><h3 id="synchronized同步代码块"><a href="#synchronized同步代码块" class="headerlink" title="synchronized同步代码块"></a>synchronized同步代码块</h3><p>除了使用关键字修饰<strong>实例方法</strong>和<strong>静态方法</strong>外，还可以修饰<strong>同步代码块</strong>，在某些情况下，我们编写的方法体可能比较大，同时存在一些比较耗时的操作，而需要同步的代码又只有一小部分，如果直接对整个方法进行同步操作，可能会得不偿失，此时我们可以使用同步代码块的方式对需要同步的代码进行包裹，这样就无需对整个方法进行同步操作了，同步代码块的使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountingSync</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AccountingSync instance=<span class="keyword">new</span> AccountingSync();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略其他耗时操作....</span></span><br><span class="line">        <span class="comment">//使用同步代码块对变量i进行同步操作,锁对象为instance</span></span><br><span class="line">        <span class="keyword">synchronized</span>(instance)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000000</span>;j++)&#123;</span><br><span class="line">                    i++;</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(instance);</span><br><span class="line">        t1.start();t2.start();</span><br><span class="line">        t1.join();t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码看出，将synchronized作用于一个给定的实例对象instance，即<strong>当前实例对象就是锁对象</strong>，每次当线程进入synchronized包裹的代码块时就会要求当前线程持有instance实例对象锁，如果当前有其他线程正持有该对象锁，那么新到的线程就必须等待，这样也就保证了每次只有一个线程执行i++;操作。当然除了instance作为对象外，我们还可以使用this对象(代表当前实例)或者当前类的class对象作为锁，如下代码：</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//this,当前实例对象锁</span></span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000000</span>;j++)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class对象锁</span></span><br><span class="line"><span class="keyword">synchronized</span>(AccountingSync.<span class="keyword">class</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000000</span>;j++)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解完synchronized的基本含义及其使用方式后，下面我们将进一步深入理解synchronized的底层实现原理。</p><h2 id="synchronized底层语义原理"><a href="#synchronized底层语义原理" class="headerlink" title="synchronized底层语义原理"></a>synchronized底层语义原理</h2><p>Java 虚拟机中的同步(Synchronization)基于进入和退出管程(<strong>Monitor</strong>)对象实现， 无论是显式同步(有明确的 <strong>monitorenter</strong> 和 <strong>monitorexit</strong> 指令,即同步代码块)还是隐式同步都是如此。在 Java 语言中，同步用的最多的地方可能是被 synchronized 修饰的同步方法。同步方法并不是由 monitorenter 和 monitorexit 指令来实现同步的，而是由方法调用指令读取运行时常量池中方法的<code>ACC_SYNCHRONIZED</code>标志来隐式实现的，关于这点，稍后详细分析。下面先来了解一个概念Java对象头，这对深入理解synchronized实现原理非常关键。</p><h3 id="理解Java对象头与Monitor"><a href="#理解Java对象头与Monitor" class="headerlink" title="理解Java对象头与Monitor"></a>理解Java对象头与Monitor</h3><p>在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。如下：</p><p><img src="1.jpg" alt></p><ul><li><p>实例变量：<strong>存放类的属性数据信息，包括父类的属性信息</strong>，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。</p></li><li><p>填充数据：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，<strong>仅仅是为了字节对齐</strong>，这点了解即可。</p></li></ul><p>而对于顶部，则是Java头对象，<strong>它是实现synchronized的锁对象的基础</strong>，这点我们重点分析它，一般而言，<strong>synchronized使用的锁对象是存储在Java对象头</strong>里的，jvm中采用<strong>2个字来存储对象头</strong>(如果对象是数组则会分配3个字，多出来的1个字记录的是数组长度)，其主要结构是由<code>Mark Word</code> 和<code>Class Metadata Address</code> 组成，其结构说明如下表：</p><table><thead><tr><th align="center">虚拟机位数</th><th>头对象结构</th><th>说明</th></tr></thead><tbody><tr><td align="center">32/64bit</td><td>Mark Word</td><td>存储对象的hashCode、锁信息或分代年龄或GC标志等信息</td></tr><tr><td align="center">32/64bit</td><td>Class Metadata Address</td><td>类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类的实例</td></tr><tr><td align="center"><strong>其中Mark Word在默认情况下存储着对象的HashCode、分代年龄、锁标记位等.</strong></td><td></td><td></td></tr></tbody></table><p>以下是32位JVM的Mark Word默认存储结构</p><table><thead><tr><th>锁状态</th><th>25bit</th><th>4bit</th><th>1bit是否是偏向锁</th><th>2bit 锁标志位</th></tr></thead><tbody><tr><td>无锁状态</td><td>对象HashCode</td><td>对象分代年龄</td><td>0</td><td>01</td></tr><tr><td>由于对象头的信息是与对象自身定义的数据没有关系的额外存储成本，因此考虑到JVM的空间效率，Mark Word 被设计成为一个<strong>非固定的数据结构</strong>，以便存储更多有效的数据，它会根据对象本身的状态复用自己的存储空间，如32位JVM下，除了上述列出的Mark Word默认存储结构外，还有如下可能变化的结构：</td><td></td><td></td><td></td><td></td></tr></tbody></table><p><img src="2.jpg" alt></p><p>其中<code>轻量级锁</code>和<code>偏向锁</code>是<code>Java 6</code>对 synchronized 锁进行优化后新增加的，稍后我们会简要分析。这里我们主要分析一下重量级锁也就是通常说synchronized的对象锁，<strong>锁标识位为10</strong>，其中<strong>指针指向的是monitor对象</strong>（也称为管程或监视器锁）的起始地址。<strong>每个对象都存在着一个 monitor 与之关联</strong>，对象与其 monitor 之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。在Java虚拟机(HotSpot)中，<strong>monitor是由ObjectMonitor实现</strong>的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的）</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = NULL;</span><br><span class="line">    _count        = <span class="number">0</span>; <span class="comment">//记录个数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = NULL;</span><br><span class="line">    _owner        = NULL;</span><br><span class="line">    _WaitSet      = NULL; <span class="comment">//处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = NULL ;</span><br><span class="line">    _succ         = NULL ;</span><br><span class="line">    _cxq          = NULL ;</span><br><span class="line">    FreeNext      = NULL ;</span><br><span class="line">    _EntryList    = NULL ; <span class="comment">//处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>ObjectMonitor中有两个队列，<strong>_WaitSet</strong> 和 <strong>_EntryList</strong>，用来保存ObjectWaiter对象列表( 每个等待锁的线程都会被封装成ObjectWaiter对象)，_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用 wait() 方法，将<strong>释放</strong>当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。如下图所示</p><p><img src="3.jpg" alt></p><p>由此看来，<strong>monitor对象存在于每个Java对象的对象头</strong>中(存储的指针的指向)，synchronized锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因，<strong>同时也是notify/notifyAll/wait等方法存在于顶级对象Object中的原因</strong>(关于这点稍后还会进行分析)，ok~，有了上述知识基础后，下面我们将进一步分析synchronized在字节码层面的具体语义实现。</p><h2 id="synchronized代码块底层原理"><a href="#synchronized代码块底层原理" class="headerlink" title="synchronized代码块底层原理"></a>synchronized代码块底层原理</h2><p>现在我们重新定义一个synchronized修饰的同步代码块，在代码块中操作共享变量i，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncCodeBlock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//同步代码库</span></span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">           i++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译上述代码并使用<code>javap</code>反编译后得到字节码如下(这里我们省略一部分没有必要的信息)：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Classfile /Users<span class="meta-keyword">/zejian/</span>Downloads/Java8_Action<span class="meta-keyword">/src/</span>main<span class="meta-keyword">/java/</span>com<span class="meta-keyword">/zejian/</span>concurrencys/SyncCodeBlock.class</span><br><span class="line">  Last modified <span class="number">2017</span><span class="number">-6</span><span class="number">-2</span>; size <span class="number">426</span> bytes</span><br><span class="line">  MD5 checksum c80bc322c87b312de760942820b4fed5</span><br><span class="line">  Compiled from <span class="string">"SyncCodeBlock.java"</span></span><br><span class="line">public class com.zejian.concurrencys.SyncCodeBlock</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line"><span class="symbol">  flags:</span> ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">  <span class="comment">//........省略常量池中数据</span></span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  public com.zejian.concurrencys.SyncCodeBlock();</span><br><span class="line"><span class="symbol">    descriptor:</span> ()V</span><br><span class="line"><span class="symbol">    flags:</span> ACC_PUBLIC</span><br><span class="line"><span class="symbol">    Code:</span></span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial <span class="meta">#1                  <span class="comment">// Method java/lang/Object."&lt;init&gt;":()V</span></span></span><br><span class="line">         <span class="number">4</span>: return</span><br><span class="line"><span class="symbol">      LineNumberTable:</span></span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">  <span class="comment">//===========主要看看syncTask方法实现================</span></span><br><span class="line">  public void syncTask();</span><br><span class="line"><span class="symbol">    descriptor:</span> ()V</span><br><span class="line"><span class="symbol">    flags:</span> ACC_PUBLIC</span><br><span class="line"><span class="symbol">    Code:</span></span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: dup</span><br><span class="line">         <span class="number">2</span>: astore_1</span><br><span class="line">         <span class="number">3</span>: monitorenter  <span class="comment">//注意此处，进入同步方法</span></span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: dup</span><br><span class="line">         <span class="number">6</span>: getfield      <span class="meta">#2             <span class="comment">// Field i:I</span></span></span><br><span class="line">         <span class="number">9</span>: iconst_1</span><br><span class="line">        <span class="number">10</span>: iadd</span><br><span class="line">        <span class="number">11</span>: putfield      <span class="meta">#2            <span class="comment">// Field i:I</span></span></span><br><span class="line">        <span class="number">14</span>: aload_1</span><br><span class="line">        <span class="number">15</span>: monitorexit   <span class="comment">//注意此处，退出同步方法</span></span><br><span class="line">        <span class="number">16</span>: goto          <span class="number">24</span></span><br><span class="line">        <span class="number">19</span>: astore_2</span><br><span class="line">        <span class="number">20</span>: aload_1</span><br><span class="line">        <span class="number">21</span>: monitorexit <span class="comment">//注意此处，退出同步方法</span></span><br><span class="line">        <span class="number">22</span>: aload_2</span><br><span class="line">        <span class="number">23</span>: athrow</span><br><span class="line">        <span class="number">24</span>: return</span><br><span class="line">      Exception table:</span><br><span class="line">      <span class="comment">//省略其他字节码.......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="symbol">SourceFile:</span> <span class="string">"SyncCodeBlock.java"</span></span><br></pre></td></tr></table></figure><p>我们主要关注字节码中的如下代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>: monitorenter  <span class="comment">//进入同步方法</span></span><br><span class="line"><span class="comment">//..........省略其他  </span></span><br><span class="line"><span class="number">15</span>: monitorexit   <span class="comment">//退出同步方法</span></span><br><span class="line"><span class="number">16</span>: <span class="keyword">goto</span>          <span class="number">24</span></span><br><span class="line"><span class="comment">//省略其他.......</span></span><br><span class="line"><span class="number">21</span>: monitorexit <span class="comment">//退出同步方法</span></span><br></pre></td></tr></table></figure><p>从字节码中可知同步语句块的实现使用的是<strong>monitorenter</strong> 和 <strong>monitorexit</strong> 指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置，<strong>当执行monitorenter指令时，当前线程将试图获取 objectref(即对象锁) 所对应的 monitor 的持有权，当 objectref 的 monitor 的进入计数器为 0，那线程可以成功取得 monitor，并将计数器值设置为 1，取锁成功。如果当前线程已经拥有 objectref 的 monitor 的持有权，那它可以重入这个 monitor (关于重入性稍后会分析)，重入时计数器的值也会加 1。倘若其他线程已经拥有 objectref 的 monitor 的所有权，那当前线程将被阻塞，直到正在执行线程执行完毕，即monitorexit指令被执行，执行线程将释放 monitor(锁)并设置计数器值为0 ，其他线程将有机会持有 monitor</strong> 。值得注意的是编译器将会确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都有执行其对应 monitorexit 指令，而无论这个方法是正常结束还是异常结束。<strong>为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行 monitorexit 指令。从字节码中也可以看出多了一个monitorexit指令，它就是异常结束时被执行的释放monitor 的指令。</strong></p><h2 id="synchronized方法底层原理"><a href="#synchronized方法底层原理" class="headerlink" title="synchronized方法底层原理"></a>synchronized方法底层原理</h2><p>方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 <code>ACC_SYNCHRONIZED</code>访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会 检查方法的<code>ACC_SYNCHRONIZED</code>访问标志是否被设置，如果设置了，<strong>执行线程将先持有monitor</strong>（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。在方法执行期间，执行线程持有了monitor，其他任何线程都无法再获得同一个monitor。如果一个同步方法执行期间抛 出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的monitor将在异常抛到同步方法之外时自动释放。下面我们看看字节码层面如何实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">           i++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用javap反编译后的字节码如下：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Classfile /Users<span class="meta-keyword">/zejian/</span>Downloads/Java8_Action<span class="meta-keyword">/src/</span>main<span class="meta-keyword">/java/</span>com<span class="meta-keyword">/zejian/</span>concurrencys/SyncMethod.class</span><br><span class="line">  Last modified <span class="number">2017</span><span class="number">-6</span><span class="number">-2</span>; size <span class="number">308</span> bytes</span><br><span class="line">  MD5 checksum f34075a8c059ea65e4cc2fa610e0cd94</span><br><span class="line">  Compiled from <span class="string">"SyncMethod.java"</span></span><br><span class="line">public class com.zejian.concurrencys.SyncMethod</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line"><span class="symbol">  flags:</span> ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//省略没必要的字节码</span></span><br><span class="line">  <span class="comment">//==================syncTask方法======================</span></span><br><span class="line">  public synchronized void syncTask();</span><br><span class="line"><span class="symbol">    descriptor:</span> ()V</span><br><span class="line">    <span class="comment">//方法标识ACC_PUBLIC代表public修饰，ACC_SYNCHRONIZED指明该方法为同步方法</span></span><br><span class="line"><span class="symbol">    flags:</span> ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line"><span class="symbol">    Code:</span></span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: dup</span><br><span class="line">         <span class="number">2</span>: getfield      <span class="meta">#2                  <span class="comment">// Field i:I</span></span></span><br><span class="line">         <span class="number">5</span>: iconst_1</span><br><span class="line">         <span class="number">6</span>: iadd</span><br><span class="line">         <span class="number">7</span>: putfield      <span class="meta">#2                  <span class="comment">// Field i:I</span></span></span><br><span class="line">        <span class="number">10</span>: return</span><br><span class="line"><span class="symbol">      LineNumberTable:</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="symbol">SourceFile:</span> <span class="string">"SyncMethod.java"</span></span><br></pre></td></tr></table></figure><p>从字节码中可以看出，synchronized修饰的方法并没有<code>monitorenter</code>指令和<code>monitorexit</code>指令，取得代之的确实是<code>ACC_SYNCHRONIZED</code>标识，<strong>该标识指明了该方法是一个同步方法</strong>，JVM通过该ACC_SYNCHRONIZED访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。这便是synchronized锁在同步代码块和同步方法上实现的基本原理。同时我们还必须注意到的是在Java早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的<code>Mutex Lock</code>来实现的，而<strong>操作系统实现线程之间的切换时需要从用户态转换到核心态</strong>，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的synchronized效率低的原因。庆幸的是在<code>Java 6</code>之后Java官方对从JVM层面对synchronized较大优化，所以现在的synchronized锁效率也优化得很不错了，Java 6之后，为了减少获得锁和释放锁所带来的性能消耗，引入了<strong>轻量级锁</strong>和<strong>偏向锁</strong>，接下来我们将简单了解一下Java官方在JVM层面对synchronized锁的优化。</p><h2 id="Java虚拟机对synchronized的优化"><a href="#Java虚拟机对synchronized的优化" class="headerlink" title="Java虚拟机对synchronized的优化"></a>Java虚拟机对synchronized的优化</h2><p>锁的状态总共有四种，<strong>无锁状态</strong>、<strong>偏向锁</strong>、<strong>轻量级锁</strong>和<strong>重量级锁</strong>。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是<strong>锁的升级是单向的</strong>，也就是说只能从低到高升级，不会出现锁的降级，关于重量级锁，前面我们已详细分析过，下面我们将介绍偏向锁和轻量级锁以及JVM的其他优化手段，这里并不打算深入到每个锁的实现和转换过程更多地是阐述Java虚拟机所提供的每个锁的核心优化思想，毕竟涉及到具体过程比较繁琐，如需了解详细过程可以查阅《深入理解Java虚拟机原理》。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p><strong>偏向锁是Java 6之后加入的新锁</strong>，它是一种<strong>针对加锁操作的优化手段</strong>，经过研究发现，在大多数情况下，<strong>锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁</strong>。偏向锁的核心思想是，<strong>如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能</strong>。所以，<strong>对于没有锁竞争的场合，偏向锁有很好的优化效果</strong>，毕竟极有可能连续多次是同一个线程申请相同的锁。<strong>但是对于锁竞争比较激烈的场合，偏向锁就失效了</strong>，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。下面我们接着了解轻量级锁。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会<strong>尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)，此时Mark Word 的结构也变为轻量级锁的结构</strong>。轻量级锁能够提升程序性能的依据是“<strong>对绝大部分的锁，在整个同步周期内都不存在竞争</strong>”，注意这是经验数据。需要了解的是，<strong>轻量级锁所适应的场景是线程交替执行同步块的场合</strong>，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。</p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>轻量级锁失败后，<strong>虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段</strong>。这是基于<strong>在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的</strong>。最后没办法也就只能升级为重量级锁了。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p><strong>消除锁是虚拟机另外一种锁的优化</strong>，这种优化更彻底，<strong>Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间</strong>，如下StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zejian on 2017/6/4.</span></span><br><span class="line"><span class="comment"> * Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创]</span></span><br><span class="line"><span class="comment"> * 消除StringBuffer同步锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> class StringBufferRemoveSync &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">add</span>(<span class="keyword">String</span> str1, <span class="keyword">String</span> str2) &#123;</span><br><span class="line">        <span class="comment">//StringBuffer是线程安全,由于sb只会在append方法中使用,不可能被其他线程引用</span></span><br><span class="line">        <span class="comment">//因此sb属于不可能共享的资源,JVM会自动消除内部的锁</span></span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        sb.<span class="built_in">append</span>(str1).<span class="built_in">append</span>(str2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        StringBufferRemoveSync rmsync = <span class="keyword">new</span> StringBufferRemoveSync();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            rmsync.<span class="built_in">add</span>(<span class="string">"abc"</span>, <span class="string">"123"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关于synchronized-可能需要了解的关键点"><a href="#关于synchronized-可能需要了解的关键点" class="headerlink" title="关于synchronized 可能需要了解的关键点"></a>关于synchronized 可能需要了解的关键点</h2><h3 id="synchronized的可重入性"><a href="#synchronized的可重入性" class="headerlink" title="synchronized的可重入性"></a>synchronized的可重入性</h3><p>从互斥锁的设计上来说，当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁，请求将会成功，在java中<strong>synchronized</strong>是基于原子性的内部锁机制，<strong>是可重入的</strong>，因此在一个线程调用synchronized方法的同时在其方法体内部调用该对象另一个synchronized方法，也就是说一个线程得到一个对象锁后再次请求该对象锁，是允许的，这就是synchronized的可重入性。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountingSync</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AccountingSync instance=<span class="keyword">new</span> AccountingSync();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000000</span>;j++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//this,当前实例对象锁</span></span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                increase();<span class="comment">//synchronized的可重入性</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(instance);</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(instance);</span><br><span class="line">        t1.start();t2.start();</span><br><span class="line">        t1.join();t2.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如代码所演示的，在获取当前实例对象锁后进入synchronized代码块执行同步代码，并在代码块中调用了当前实例对象的另外一个synchronized方法，再次请求当前实例锁时，将被允许，进而执行方法体代码，这就是重入锁最直接的体现，需要特别注意另外一种情况，<strong>当子类继承父类时，子类也是可以通过可重入锁调用父类的同步方法。注意由于synchronized是基于monitor实现的，因此每次重入，monitor中的计数器仍会加1。</strong></p><h2 id="线程中断与synchronized"><a href="#线程中断与synchronized" class="headerlink" title="线程中断与synchronized"></a>线程中断与synchronized</h2><h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><p>正如中断二字所表达的意义，在线程运行(run方法)中间打断它，在Java中，提供了以下3个有关线程中断的方法</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中断线程（实例方法）</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> Thread.<span class="title">interrupt</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断线程是否被中断（实例方法）</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> Thread.<span class="title">isInterrupted</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否被中断并清除当前中断状态（静态方法）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">boolean</span> Thread.<span class="title">interrupted</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>当一个线程处于<strong>被阻塞状态</strong>或者试图执行一个阻塞操作时，使用Thread.interrupt()方式中断该线程，注意此时将会抛出一个<code>InterruptedException</code>的异常，<strong>同时中断状态将会被复位</strong>(由中断状态改为非中断状态)，如下代码将演示该过程：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InterruputSleepThread3</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws InterruptedException</span> &#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="comment">//while在try中，通过异常中断就可以退出run循环</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                        <span class="comment">//当前线程处于阻塞状态，异常必须捕捉处理，无法往外抛出</span></span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.<span class="keyword">out</span>.println(<span class="string">"Interruted When Sleep"</span>);</span><br><span class="line">                    boolean interrupt = <span class="keyword">this</span>.isInterrupted();</span><br><span class="line">                    <span class="comment">//中断状态被复位</span></span><br><span class="line">                    System.<span class="keyword">out</span>.println(<span class="string">"interrupt:"</span>+interrupt);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//中断处于阻塞状态的线程</span></span><br><span class="line">        t1.interrupt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 输出结果:</span></span><br><span class="line"><span class="comment">           Interruted When Sleep</span></span><br><span class="line"><span class="comment">           interrupt:false</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上述代码所示，我们创建一个线程，并在线程中<strong>调用了sleep方法从而使用线程进入阻塞状态</strong>，启动线程后，调用线程实例对象的interrupt方法中断阻塞异常，并抛出InterruptedException异常，此时中断状态也将被复位。这里有些人可能会诧异，为什么不用Thread.sleep(2000);而是用TimeUnit.SECONDS.sleep(2);其实原因很简单，<strong>前者使用时并没有明确的单位说明，而后者非常明确表达秒的单位</strong>，事实上<strong>后者的内部实现最终还是调用了Thread.sleep(2000);</strong>，但为了编写的代码语义更清晰，建议使用<code>TimeUnit.SECONDS.sleep(2);</code>的方式，注意TimeUnit是个枚举类型。ok~，除了阻塞中断的情景，我们还可能会遇到处于运行期且非阻塞的状态的线程，这种情况下，直接调用Thread.interrupt()中断线程是不会得到任响应的，如下代码，将无法中断非阻塞状态下的线程：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InterruputThread</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws InterruptedException</span> &#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                    System.<span class="keyword">out</span>.println(<span class="string">"未被中断"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 输出结果(无限执行):</span></span><br><span class="line"><span class="comment">             未被中断</span></span><br><span class="line"><span class="comment">             未被中断</span></span><br><span class="line"><span class="comment">             未被中断</span></span><br><span class="line"><span class="comment">             ......</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然我们调用了interrupt方法，但线程t1并未被中断，因为处于非阻塞状态的线程需要我们手动进行中断检测并结束程序，改进后代码如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InterruputThread</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws InterruptedException</span> &#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="comment">//判断当前线程是否被中断</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.isInterrupted())&#123;</span><br><span class="line">                        System.<span class="keyword">out</span>.println(<span class="string">"线程中断"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">"已跳出循环,线程中断!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 输出结果:</span></span><br><span class="line"><span class="comment">            线程中断</span></span><br><span class="line"><span class="comment">            已跳出循环,线程中断!</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是的，我们在代码中使用了实例方法isInterrupted判断线程是否已被中断，如果被中断将跳出循环以此结束线程,注意<strong>非阻塞状态调用interrupt()并不会导致中断状态重置</strong>。综合所述，可以简单总结一下中断两种情况，</p><ul><li><p>一种是当线程处于阻塞状态或者试图执行一个阻塞操作时，我们可以使用实例方法interrupt()进行线程中断，执行中断操作后将会抛出interruptException异常(该异常必须捕捉无法向外抛出)并将<strong>中断状态复位</strong></p></li><li><p>另外一种是当线程处于运行状态时，我们也可调用实例方法interrupt()进行线程中断，但同时<strong>必须手动判断中断状态</strong>，并编写中断线程的代码(其实就是结束run方法体的代码)。</p><p>有时我们在编码时可能需要兼顾以上两种情况，那么就可以如下编写：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//判断当前线程是否已中断,注意interrupted方法是静态的,执行后会对中断状态进行复位</span></span><br><span class="line">    <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中断与synchronized"><a href="#中断与synchronized" class="headerlink" title="中断与synchronized"></a>中断与synchronized</h3><p>事实上线程的中断操作对于正在等待获取的锁对象的synchronized方法或者代码块并不起作用，也就是对于synchronized来说，如果一个线程在等待锁，那么结果只有两种，要么它获得这把锁继续执行，要么它就保存等待，即使调用中断线程的方法，也不会生效。演示代码如下</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zejian on 2017/6/2.</span></span><br><span class="line"><span class="comment"> * Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SynchronizedBlocked</span> <span class="title">implements</span> <span class="title">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">f</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Trying to call f()"</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) <span class="comment">// Never releases lock</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>(); <span class="comment">// yield 让步，屈服，投降，让出CPU的意思，使当前线程从执行状态（运行状态）变为可执行态（就绪状态）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在构造器中创建新线程并启动获取对象锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SynchronizedBlocked</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">//该线程已持有当前实例锁</span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                f(); <span class="comment">// Lock acquired by this thread</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">//中断判断</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">"中断线程!!"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws InterruptedException</span> &#123;</span><br><span class="line">        SynchronizedBlocked sync = <span class="keyword">new</span> SynchronizedBlocked();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(sync);</span><br><span class="line">        <span class="comment">//启动后调用f()方法,无法获取当前实例锁处于等待状态</span></span><br><span class="line">        t.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//中断线程,无法生效</span></span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在SynchronizedBlocked构造函数中创建一个新线程并启动获取调用f()获取到当前实例锁，由于SynchronizedBlocked自身也是线程，启动后在其run方法中也调用了f()，但由于对象锁被其他线程占用，导致t线程只能等到锁，此时我们调用了<code>t.interrupt();</code>但并不能中断线程。</p><h2 id="等待唤醒机制与synchronized"><a href="#等待唤醒机制与synchronized" class="headerlink" title="等待唤醒机制与synchronized"></a>等待唤醒机制与synchronized</h2><p>所谓等待唤醒机制本篇主要指的是<code>notify/notifyAll</code>和<code>wait</code>方法，<strong>在使用这3个方法时，必须处于synchronized代码块或者synchronized方法中，否则就会抛出IllegalMonitorStateException异常，这是因为调用这几个方法前必须拿到当前对象的监视器monitor对象，也就是说notify/notifyAll和wait方法依赖于monitor对象</strong>，在前面的分析中，我们知道<strong>monitor 存在于对象头的Mark Word 中</strong>(存储monitor引用指针)，<strong>而synchronized关键字可以获取 monitor</strong> ，这也就是为什么notify/notifyAll和wait方法必须在synchronized代码块或者synchronized方法调用的原因。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">synchronized</span> (obj) &#123;</span><br><span class="line">       <span class="selector-tag">obj</span><span class="selector-class">.wait</span>();</span><br><span class="line">       <span class="selector-tag">obj</span><span class="selector-class">.notify</span>();</span><br><span class="line">       <span class="selector-tag">obj</span><span class="selector-class">.notifyAll</span>();         </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>需要特别理解的一点是，与sleep方法不同的是wait方法调用完成后，线程将被暂停，但<strong>wait方法将会释放当前持有的监视器锁(monitor)，直到有线程调用notify/notifyAll方法后方能继续执行，而sleep方法只让线程休眠并不释放锁</strong>。<strong>同时notify/notifyAll方法调用后，并不会马上释放监视器锁，而是在相应的synchronized(){}/synchronized方法执行结束后才自动释放锁</strong>。</p><p>本篇的主要参考资料：<br>《Java编程思想》<br>《深入理解Java虚拟机》<br>《实战Java高并发程序设计》</p><hr><blockquote><p>作者：zejian_<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/javazejian/article/details/72828483" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/72828483</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;线程安全&lt;/strong&gt;是并发编程中的重要关注点，应该注意到的是，造成线程安全问题的主要诱因有两点，一是存在&lt;strong&gt;共享数据&lt;/strong&gt;(也称&lt;strong&gt;临界资源&lt;/strong&gt;)，二是&lt;strong&gt;存在多条线程共同操作共享数据&lt;/strong&gt;。因此为了解决这个问题，我们可能需要这样一个方案，当存在多个线程操作共享数据时，需要&lt;strong&gt;保证同一时刻有且只有一个线程在操作共享数据&lt;/strong&gt;，其他线程必须等到该线程处理完数据后再进行，这种方式有个高大上的名称叫&lt;strong&gt;互斥锁&lt;/strong&gt;，即能达到互斥访问目的的锁，也就是说当一个共享数据被当前正在访问的线程加上互斥锁后，在同一个时刻，其他线程只能处于&lt;strong&gt;等待的状态&lt;/strong&gt;，直到当前线程处理完毕释放该锁。在 Java 中，&lt;strong&gt;关键字 synchronized可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块&lt;/strong&gt;(主要是对方法或者代码块中存在共享数据的操作)，同时我们还应该注意到synchronized另外一个重要的作用，&lt;strong&gt;synchronized可保证一个线程的变化(主要是共享数据的变化)被其他线程所看到（保证可见性，完全可以替代Volatile功能）&lt;/strong&gt;，这点确实也是很重要的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://changsk.top/tags/java/"/>
    
      <category term="synchronized" scheme="http://changsk.top/tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>java之AQS</title>
    <link href="http://changsk.top/2019/06/20/java-AQS/"/>
    <id>http://changsk.top/2019/06/20/java-AQS/</id>
    <published>2019-06-20T02:04:45.000Z</published>
    <updated>2019-06-20T03:38:08.529Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简单解释一下J.U.C，是JDK中提供的并发工具包,<code>java.util.concurrent</code>。里面提供了很多并发编程中很常用的实用工具类，比如<strong>atomic原子操作</strong>、比如<strong>lock同步锁</strong>、fork/join等。</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>谈到并发，不得不谈ReentrantLock；而谈到ReentrantLock，不得不谈AbstractQueuedSynchronizer（AQS）！</p><a id="more"></a><p><img src="0.jpg" alt><br>类如其名，抽象的队列式的同步器，<strong>AQS定义了一套多线程访问共享资源的同步器框架</strong>，许多同步类实现都依赖于它，如常用的<strong>ReentrantLock</strong>/<strong>Semaphore</strong>/<strong>CountDownLatch</strong>…。<br>　　<br>它维护了一个<code>volatile int state</code>（代表共享资源）和一个<code>FIFO线程等待队列</code>（<strong>多线程争用资源被阻塞时会进入此队列</strong>）。这里volatile是核心关键词，具体volatile的语义，在此不述。state的访问方式有三种:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">getState</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">setState</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">compareAndSetState</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。</p><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时<strong>只需要实现共享资源state的获取与释放方式</strong>即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），<strong>AQS已经在顶层实现</strong>好了。自定义同步器实现时主要实现以下几种方法：</p><p><code>isHeldExclusively()</code>：该线程是否正在独占资源。只有用到condition才需要去实现它。<br><code>tryAcquire(int)</code>：独占方式。尝试获取资源，成功则返回true，失败则返回false。<br><code>tryRelease(int)</code>：独占方式。尝试释放资源，成功则返回true，失败则返回false。<br><code>tryAcquireShared(int)</code>：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。<br><code>tryReleaseShared(int)</code>：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</p><p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是<strong>可重入</strong>的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p><p>再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，<strong>每个子线程执行完后countDown()一次</strong>，<strong>state会CAS减1</strong>。等到所有子线程都执行完后(即state=0)，会<strong>unpark()</strong>主调用线程，然后主调用线程就会从<strong>await()</strong>函数返回，继续后余动作。</p><p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p><h2 id="从Lock作为切入点"><a href="#从Lock作为切入点" class="headerlink" title="从Lock作为切入点"></a>从Lock作为切入点</h2><p>我想以lock作为切入点来讲解AQS，毕竟同步锁是解决线程安全问题的通用手段，也是我们工作中用得比较多的方式。</p><h3 id="Lock-API"><a href="#Lock-API" class="headerlink" title="Lock API"></a>Lock API</h3><p>Lock是一个接口，方法定义如下</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> lock() <span class="comment">// 如果锁可用就获得锁，如果锁不可用就阻塞直到锁释放</span></span><br><span class="line"><span class="keyword">void</span> lockInterruptibly() <span class="comment">// 和 lock()方法相似, 但阻塞的线程可中断，抛出             java.lang.InterruptedException异常</span></span><br><span class="line"><span class="keyword">boolean</span> tryLock() <span class="comment">// 非阻塞获取锁;尝试获取锁，如果成功返回true</span></span><br><span class="line"><span class="keyword">boolean</span> tryLock(<span class="keyword">long</span> timeout, TimeUnit timeUnit) <span class="comment">//带有超时时间的获取锁方法</span></span><br><span class="line"><span class="keyword">void</span> unlock() <span class="comment">// 释放锁</span></span><br></pre></td></tr></table></figure><h3 id="Lock的实现"><a href="#Lock的实现" class="headerlink" title="Lock的实现"></a>Lock的实现</h3><p>实现Lock接口的类有很多，以下为几个常见的锁实现</p><ul><li><strong>ReentrantLock</strong>：表示重入锁，它是<strong>唯一一个实现了Lock接口的类</strong>。重入锁指的是线程在获得锁之后，再次获取该锁不需要阻塞，而是<strong>直接关联一次计数器增加重入次数</strong>。</li><li><strong>ReentrantReadWriteLock</strong>：重入读写锁，它实现了<strong>ReadWriteLock</strong>接口，在这个类中维护了两个锁，一个是<strong>ReadLock</strong>，一个是<strong>WriteLock</strong>，<strong>他们都分别实现了Lock接口</strong>。读写锁是一种适合<strong>读多写少</strong>的场景下解决线程安全问题的工具，基本原则是：<code>读和读不互斥、读和写互斥、写和写互斥</code>。也就是说涉及到影响数据变化的操作都会存在互斥。</li><li><strong>StampedLock</strong>： stampedLock是JDK8引入的新的锁机制，可以简单认为是<strong>读写锁的一个改进版本</strong>，读写锁虽然通过<strong>分离读和写的功能使得读和读之间可以完全并发</strong>，但是读和写是有冲突的，<strong>如果大量的读线程存在，可能会引起写线程的饥饿</strong>。stampedLock是一种<strong>乐观</strong>的读策略，使得乐观锁完全不会阻塞写线程。</li></ul><h3 id="ReentrantLock的简单实用"><a href="#ReentrantLock的简单实用" class="headerlink" title="ReentrantLock的简单实用"></a>ReentrantLock的简单实用</h3><p>如何在实际应用中使用ReentrantLock呢？我们通过一个简单的demo来演示一下</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> Lock <span class="keyword">lock</span>=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">lock</span>.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码主要做一件事，就是通过一个静态的<code>incr()</code>方法对共享变量<code>count</code>做连续递增，在没有加同步锁的情况下多线程访问这个方法一定会存在线程安全问题。所以用到了<code>ReentrantLock</code>来实现同步锁，并且<strong>在finally语句块中释放锁。</strong><br><strong>那么我来引出一个问题，大家思考一下</strong></p><blockquote><p>多个线程通过lock竞争锁时，当竞争失败的锁是如何实现等待以及被唤醒的呢?</p></blockquote><h2 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h2><p>AQS全称为<strong>AbstractQueuedSynchronizer</strong>，它提供了一个<strong>FIFO队列</strong>，可以看成是一个用来实现同步锁以及其他涉及到同步功能的核心组件，常见的有:<strong>ReentrantLock</strong>、<strong>CountDownLatch</strong>等。<br><strong>AQS是一个抽象类</strong>，主要是通过<strong>继承</strong>的方式来使用，它本身没有实现任何的同步接口，仅仅是定义了<strong>同步状态的获取以及释放的方法</strong>来提供自定义的同步组件。<br>可以这么说，<strong>只要搞懂了AQS，那么J.U.C中绝大部分的api都能轻松掌握。</strong></p><h3 id="AQS的两种功能"><a href="#AQS的两种功能" class="headerlink" title="AQS的两种功能"></a>AQS的两种功能</h3><p>从使用层面来说，AQS的功能分为两种：独占和共享</p><ul><li><strong>独占锁</strong>，每次只能有一个线程持有锁，比如前面给大家演示的ReentrantLock就是以独占方式实现的互斥锁</li><li><strong>共享锁</strong>，允许多个线程同时获取锁，并发访问共享资源，比如ReentrantReadWriteLock</li></ul><h3 id="ReentrantLock的类图"><a href="#ReentrantLock的类图" class="headerlink" title="ReentrantLock的类图"></a>ReentrantLock的类图</h3><p>仍然以ReentrantLock为例，来分析AQS在重入锁中的使用。毕竟单纯分析AQS没有太多的含义。先理解这个类图，可以方便我们理解AQS的原理<br><img src="1.jpg" alt="ReentrantLock的类图"></p><h3 id="AQS的内部实现"><a href="#AQS的内部实现" class="headerlink" title="AQS的内部实现"></a>AQS的内部实现</h3><p>AQS的实现依赖内部的<strong>同步队列</strong>,也就是<strong>FIFO的双向队列（不是双端队列，<em>双端队列</em>是指允许两端都可以进行入队和出队操作的<em>队列</em>）</strong>，<strong>如果当前线程竞争锁失败，那么AQS会把当前线程以及等待状态信息构造成一个Node加入到同步队列中，同时再阻塞该线程。当获取锁的线程释放锁以后，会从队列中唤醒一个阻塞的节点(线程)。</strong><br><img src="2.jpg" alt="AQS同步队列"></p><blockquote><p>AQS队列内部维护的是一个FIFO的双向链表，这种结构的特点是每个数据结构都有两个指针，分别指向直接的后继节点和直接前驱节点。所以双向链表可以从任意一个节点开始很方便的访问前驱和后继。每个Node其实是对线程的封装，当线程争抢锁失败后会封装成Node加入到ASQ队列中去</p></blockquote><p>Node类的组成如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">        <span class="keyword">volatile</span> Node prev; <span class="comment">//前驱节点</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next; <span class="comment">//后继节点</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;<span class="comment">//当前线程</span></span><br><span class="line">        Node nextWaiter; <span class="comment">//存储在condition队列中的后继节点</span></span><br><span class="line">        <span class="comment">//是否为共享锁</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">            Node p = prev;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将线程构造成一个Node，添加到等待队列</span></span><br><span class="line">        Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">            <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这个方法会在Condition队列使用，后续单独写一篇文章分析condition</span></span><br><span class="line">        Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">            <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="释放锁以及添加线程对于队列的变化"><a href="#释放锁以及添加线程对于队列的变化" class="headerlink" title="释放锁以及添加线程对于队列的变化"></a>释放锁以及添加线程对于队列的变化</h3><h4 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h4><p>当出现<strong>锁竞争</strong>以及<strong>释放锁</strong>的时候，AQS同步队列中的节点会发生变化，首先看一下添加节点的场景。<br><img src="3.jpg" alt="节点添加到同步队列"><br>这里会涉及到两个变化</p><ul><li>新的线程封装成Node节点追加到同步队列中，设置prev节点以及修改当前节点的前置节点的next节点指向自己</li><li>通过CAS将tail重新指向新的尾部节点</li></ul><h4 id="释放锁移除节点"><a href="#释放锁移除节点" class="headerlink" title="释放锁移除节点"></a>释放锁移除节点</h4><p>head节点表示获取锁成功的节点，当头结点在释放同步状态时，会唤醒后继节点，如果后继节点获得锁成功，会把自己设置为头结点，节点的变化过程如下<br><img src="4.jpg" alt="移除节点的变化"><br>这个过程也是涉及到两个变化</p><ul><li>修改head节点指向下一个获得锁的节点</li><li>新的获得锁的节点，将prev的指针指向null</li></ul><p>这里有一个小的变化，就是设置head节点不需要用CAS，原因是设置head节点是由获得锁的线程来完成的，而同步锁只能由一个线程获得，所以不需要CAS保证，只需要把head节点设置为原首节点的后继节点，并且断开原head节点的next引用即可</p><h2 id="AQS的源码分析"><a href="#AQS的源码分析" class="headerlink" title="AQS的源码分析"></a>AQS的源码分析</h2><p>清楚了AQS的基本架构以后，我们来分析一下AQS的源码，仍然以ReentrantLock为模型。</p><h3 id="ReentrantLock的时序图"><a href="#ReentrantLock的时序图" class="headerlink" title="ReentrantLock的时序图"></a>ReentrantLock的时序图</h3><p>调用ReentrantLock中的lock()方法，源码的调用过程我使用了时序图来展现<br><img src="5.jpg" alt="ReentrantLock中lock方法的时序图"><br>从图上可以看出来，当锁获取失败时，会调用addWaiter()方法将当前线程封装成Node节点加入到AQS队列，基于这个思路，我们来分析AQS的源码实现</p><h3 id="分析源码"><a href="#分析源码" class="headerlink" title="分析源码"></a>分析源码</h3><h4 id="ReentrantLock-lock"><a href="#ReentrantLock-lock" class="headerlink" title="ReentrantLock.lock()"></a>ReentrantLock.lock()</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    sync.<span class="keyword">lock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是获取锁的入口，调用sync这个类里面的方法，sync是什么呢？</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> static <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br></pre></td></tr></table></figure><p><strong>sync是一个静态内部类</strong>，它<strong>继承了AQS这个抽象类</strong>，前面说过<strong>AQS是一个同步工具</strong>，主要<strong>用来实现同步控制</strong>。我们在利用这个工具的时候，会<strong>继承它来实现同步控制功能。</strong><br>通过进一步分析，发现Sync这个类有两个具体的实现，分别是<code>NofairSync(非公平锁)</code>,<code>FailSync(公平锁)</code>.</p><ul><li>公平锁：表示所有线程严格按照<strong>FIFO</strong>来获取锁</li><li>非公平锁： 表示可以存在<strong>抢占锁</strong>的功能，也就是说不管当前队列上是否存在其他线程等待，<strong>新线程都有机会抢占锁</strong></li></ul><p>公平锁和非公平锁的实现上的差异，我会在文章后面做一个解释，接下来的分析仍然以<code>非公平锁</code>作为主要分析逻辑。</p><h4 id="NonfairSync-lock"><a href="#NonfairSync-lock" class="headerlink" title="NonfairSync.lock"></a>NonfairSync.lock</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) <span class="comment">//通过cas操作来修改state状态，表示争抢锁的操作</span></span><br><span class="line">      setExclusiveOwnerThread(Thread.currentThread());<span class="comment">//设置当前获得锁状态的线程</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      acquire(<span class="number">1</span>); <span class="comment">//尝试去获取锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码简单解释一下</p><ul><li>由于这里是非公平锁，所以调用lock方法时，<strong>先去通过cas去抢占锁</strong></li><li>如果抢占锁成功，保存获得锁成功的当前线程</li><li>抢占锁失败，调用acquire来走锁竞争逻辑</li></ul><blockquote><p><strong>compareAndSetState</strong><br>compareAndSetState的代码实现逻辑如下</p></blockquote><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// See below <span class="keyword">for</span> intrinsics setup <span class="keyword">to</span> support this</span><br><span class="line">return unsafe.compareAndSwapInt(this, <span class="keyword">state</span>Offset, expect, update);</span><br></pre></td></tr></table></figure><p>}</p><blockquote><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这段代码其实逻辑很简单，就是通过cas乐观锁的方式来做比较并替换。上面这段代码的意思是，如果当前内存中的<span class="keyword">state</span>的值和预期值expect相等，则替换为update。更新成功返回true，否则返回false.</span><br><span class="line">&gt; 这个操作是原子的，不会出现线程安全问题，这里面涉及到Unsafe这个类的操作，一级涉及到<span class="keyword">state</span>这个属性的意义。</span><br><span class="line">&gt; **<span class="keyword">state</span>**</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li>当state=0时，表示无锁状态</li><li>当state&gt;0时，表示已经有线程获得了锁，也就是state = 1，但是因为ReentrantLock允许重入，所以同一个线程多次获得同步锁的时候，state会递增，比如重入5次，那么state=5。 而在释放锁的时候，同样需要释放5次直到state=0其他线程才有资格获得锁</li></ul><blockquote><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; private volatile int <span class="keyword">state</span>;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>需要注意的是：不同的AQS实现，state所表达的含义是不一样的。<br><strong>Unsafe</strong><br>Unsafe类是在sun.misc包下，不属于Java标准。但是很多Java的基础类库，包括一些被广泛使用的高性能开发库都是基于Unsafe类开发的，比如Netty、Hadoop、Kafka等；Unsafe可认为是Java中留下的后门，提供了一些低层次操作，如直接内存访问、线程调度等</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>这个是一个native方法， 第一个参数为需要改变的对象，第二个为偏移量(即之前求出来的headOffset的值)，第三个参数为期待的值，第四个为更新后的值<br>整个方法的作用是如果当前时刻的值等于预期值var4相等，则更新为新的期望值 var5，如果更新成功，则返回true，否则返回false；</p></blockquote><h4 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h4><p>acquire是AQS中的方法，如果CAS操作未能成功，说明state已经不为0，此时继续acquire(1)操作,这里大家思考一下，acquire方法中的1的参数是用来做什么呢？如果没猜中，往前面回顾一下state这个概念</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的主要逻辑是</p><ul><li>通过tryAcquire尝试获取独占锁，如果成功返回true，失败返回false</li><li>如果tryAcquire失败，则会通过addWaiter方法将当前线程封装成Node添加到AQS队列尾部</li><li>acquireQueued，将Node作为参数，通过自旋去尝试获取锁。</li></ul><blockquote><p>如果大家看过我写的<a href="https://mp.weixin.qq.com/s?__biz=MzI0MzI1Mjg5Nw==&mid=2247483699&idx=1&sn=9e51113bbbb3ae94d6b7273f3ee1b00f&chksm=e96eaafdde1923eb6d3f721c902335c54037b503d5a3d7693e30246efa8356c41ea17bcfacc5&token=1402731013&lang=zh_CN#rd" target="_blank" rel="noopener">Synchronized源码分析</a>的文章，就应该能够明白自旋存在的意义</p></blockquote><h4 id="NonfairSync-tryAcquire"><a href="#NonfairSync-tryAcquire" class="headerlink" title="NonfairSync.tryAcquire"></a>NonfairSync.tryAcquire</h4><p>这个方法的作用是<strong>尝试获取锁</strong>，如果成功返回true，不成功返回false<br>它是重写AQS类中的tryAcquire方法，并且大家仔细看一下AQS中tryAcquire方法的定义，并没有实现，而是抛出异常。按照一般的思维模式，既然是一个不实现的模版方法，那应该定义成abstract，让子类来实现呀？大家想想为什么</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">nonfairTryAcquire</span><span class="params">(acquires)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="nonfairTryAcquire"><a href="#nonfairTryAcquire" class="headerlink" title="nonfairTryAcquire"></a>nonfairTryAcquire</h4><p>tryAcquire(1)在NonfairSync中的实现代码如下</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ffinal <span class="function"><span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得当前执行的线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState(); <span class="comment">//获得state的值</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">//state=0说明当前是无锁状态</span></span><br><span class="line">        <span class="comment">//通过cas操作来替换state的值改为1，大家想想为什么要用cas呢？</span></span><br><span class="line">        <span class="comment">//理由是，在多线程环境中，直接修改state=1会存在线程安全问题，你猜到了吗？</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">             <span class="comment">//保存当前获得锁的线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这段逻辑就很简单了。如果是同一个线程来获得锁，则直接增加重入次数</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires; <span class="comment">//增加重入次数</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取当前线程，判断当前的锁的状态</li><li>如果state=0表示当前是无锁状态，通过cas更新state状态的值</li><li>如果当前线程是属于重入，则增加重入次数</li></ul><h4 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h4><p>当tryAcquire方法获取锁失败以后，则会先调用<strong>addWaiter将当前线程封装成Node，然后添加到AQS队列</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">Node</span> <span class="title">addWaiter</span>(<span class="keyword">Node</span> <span class="title">mode</span>) &#123; //<span class="attr">mode=</span><span class="keyword">Node</span>.<span class="title">EXCLUSIVE</span></span><br><span class="line">        //将当前线程封装成<span class="keyword">Node</span><span class="title">，并且mode</span>为独占锁</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node</span> = new <span class="keyword">Node</span><span class="title">(Thread</span>.currentThread(), mode); </span><br><span class="line">        // Try the fast path of enq; backup to full enq on failure</span><br><span class="line">        // tail是AQS的中表示同步队列队尾的属性，刚开始为null，所以进行enq(<span class="keyword">node</span><span class="title">)方法</span></span><br><span class="line"><span class="title">        Node</span> pred = tail;</span><br><span class="line">        if (pred != null) &#123; //tail不为空的情况，说明队列中存在节点数据</span><br><span class="line">            <span class="keyword">node</span>.<span class="title">prev</span> = pred;  //将当前线程的<span class="keyword">Node</span><span class="title">的prev</span>节点指向tail</span><br><span class="line">            if (compareAndSetTail(pred, <span class="keyword">node</span><span class="title">)) &#123;//通过cas</span>将<span class="keyword">node</span><span class="title">添加到AQS</span>队列</span><br><span class="line">                pred.next = <span class="keyword">node</span><span class="title">;//cas</span>成功，把旧的tail的next指针指向新的tail</span><br><span class="line">                return <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">            &#125;</span></span><br><span class="line"><span class="title">        &#125;</span></span><br><span class="line"><span class="title">        enq</span>(<span class="keyword">node</span><span class="title">); //tail</span>=null，将<span class="keyword">node</span><span class="title">添加到同步队列中</span></span><br><span class="line"><span class="title">        return</span> <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">    &#125;</span></span><br></pre></td></tr></table></figure><ul><li>将当前线程封装成Node</li><li>判断当前链表中的tail节点是否为空，如果不为空，则通过cas操作把当前线程的node添加到AQS队列</li><li>如果为空或者cas失败，调用enq将节点添加到AQS队列</li></ul><h4 id="enq"><a href="#enq" class="headerlink" title="enq"></a>enq</h4><p><strong>enq就是通过自旋操作把当前节点加入到队列中</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">Node</span> <span class="title">enq</span>(final <span class="keyword">Node</span> <span class="title">node</span>) &#123;</span><br><span class="line">        //自旋，不做过多解释，不清楚的关注公众号[架构师修炼宝典]</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            <span class="keyword">Node</span> <span class="title">t</span> = tail; //如果是第一次添加到队列，那么<span class="attr">tail=</span>null</span><br><span class="line">            if (t == null) &#123; // Must initialize</span><br><span class="line">                //CAS的方式创建一个空的<span class="keyword">Node</span><span class="title">作为头结点</span></span><br><span class="line"><span class="title">                if</span> (compareAndSetHead(new <span class="keyword">Node</span><span class="title">()))</span></span><br><span class="line"><span class="title">                   //此时队列中只一个头结点，所以tail</span>也指向它</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">//进行第二次循环时，tail不为null，进入else区域。将当前线程的<span class="keyword">Node</span><span class="title">结点的prev</span>指向tail，然后使用CAS将tail指向<span class="keyword">Node</span><span class="title"></span></span><br><span class="line"><span class="title">                node</span>.prev = t;</span><br><span class="line">                if (compareAndSetTail(t, <span class="keyword">node</span><span class="title">)) &#123;</span></span><br><span class="line"><span class="title">//t</span>此时指向tail,所以可以CAS成功，将tail重新指向<span class="keyword">Node</span><span class="title">。此时t</span>为更新前的tail的值，即指向空的头结点，t.<span class="attr">next=</span><span class="keyword">node</span><span class="title">，就将头结点的后续结点指向Node</span>，返回头结点</span><br><span class="line">                    t.next = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">                    return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>假如有两个线程t1,t2同时进入enq方法，t==null表示队列是首次使用，需要先初始化<br>另外一个线程cas失败，则进入下次循环，通过cas操作将node添加到队尾</p><blockquote><p>到目前为止，通过addwaiter方法构造了一个AQS队列，并且将线程添加到了队列的节点中</p></blockquote><h4 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h4><p>将添加到队列中的Node作为参数传入acquireQueued方法，这里面会做抢占锁的操作</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">// 获取prev节点,若为null即刻抛出NullPointException</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="comment">// 如果前驱为head才有资格进行锁的抢夺</span></span><br><span class="line">                setHead(node); <span class="comment">// 获取锁成功后就不需要再进行同步操作了,获取锁成功的线程作为新的head节点</span></span><br><span class="line"><span class="comment">//凡是head节点,head.thread与head.prev永远为null, 但是head.next不为null</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>; <span class="comment">//获取锁成功</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//如果获取锁失败，则根据节点的waitStatus决定是否需要挂起线程</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())<span class="comment">// 若前面为true,则执行挂起,待下次唤醒的时候检测中断的标志</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed) <span class="comment">// 如果抛出异常则取消锁的获取,进行出队(sync queue)操作</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取当前节点的prev节点</li><li>如果prev节点为head节点，那么它就有资格去争抢锁，调用tryAcquire抢占锁</li><li>抢占锁成功以后，把获得锁的节点设置为head，并且移除原来的初始化head节点</li><li>如果获得锁失败，则根据waitStatus决定是否需要挂起线程</li><li>最后，通过cancelAcquire取消获得锁的操作</li></ul><p>前面的逻辑都很好理解，主要看一下shouldParkAfterFailedAcquire这个方法和parkAndCheckInterrupt的作用</p><h4 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h4><p>从上面的分析可以看出，<strong>只有队列的第二个节点可以有机会争用锁</strong>，如果成功获取锁，则此节点<strong>晋升为头节点</strong>。对于第三个及以后的节点，if (p == head)条件不成立，首先进行shouldParkAfterFailedAcquire(p, node)操作<br>shouldParkAfterFailedAcquire方法是判断一个争用锁的线程是否应该被阻塞。它首先判断一个节点的前置节点的状态是否为Node.SIGNAL，如果是，是说明此节点已经将状态设置-如果锁释放，则应当通知它，所以它可以安全的阻塞了，返回true。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private static boolean shouldParkAfterFailedAcquire(<span class="keyword">Node</span> <span class="title">pred</span>, <span class="keyword">Node</span> <span class="title">node</span>) &#123;</span><br><span class="line">    int ws = pred.waitStatus; //前继节点的状态</span><br><span class="line">    if (ws == <span class="keyword">Node</span>.<span class="title">SIGNAL</span>)//如果是SIGNAL状态，意味着当前线程需要被unpark唤醒</span><br><span class="line">               return <span class="literal">true</span>;</span><br><span class="line">//如果前节点的状态大于<span class="number">0</span>，即为CANCELLED状态时，则会从前节点开始逐步循环找到一个没有被“CANCELLED”节点设置为当前节点的前节点，返回<span class="literal">false</span>。在下次循环执行shouldParkAfterFailedAcquire时，返回<span class="literal">true</span>。这个操作实际是把队列中CANCELLED的节点剔除掉。</span><br><span class="line">    if (ws &gt; <span class="number">0</span>) &#123;// 如果前继节点是“取消”状态，则设置 “当前节点”的 “当前前继节点” 为 “‘原前继节点'的前继节点”。</span><br><span class="line">       </span><br><span class="line">        do &#123;</span><br><span class="line">            <span class="keyword">node</span>.<span class="title">prev</span> = pred = pred.prev;</span><br><span class="line">        &#125; while (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">    &#125; else</span> &#123; // 如果前继节点为“<span class="number">0</span>”或者“共享锁”状态，则设置前继节点为SIGNAL状态。</span><br><span class="line">        /*</span><br><span class="line">         * waitStatus must be <span class="number">0</span> <span class="keyword">or</span> PROPAGATE.  Indicate that we</span><br><span class="line">         * need a signal, but don't park yet.  Caller will need to</span><br><span class="line">         * retry to make sure it cannot acquire before parking.</span><br><span class="line">         */</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, <span class="keyword">Node</span>.<span class="title">SIGNAL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt"></a>parkAndCheckInterrupt</h4><p>如果shouldParkAfterFailedAcquire返回了true，则会执行：<code>parkAndCheckInterrupt()</code>方法，它是通过LockSupport.park(this)将<strong>当前线程挂起到WATING状态</strong>，它需要等待一个<strong>中断</strong>、<strong>unpark</strong>方法来唤醒它，通过这样一种FIFO的机制的等待，来实现了Lock的操作。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="function"><span class="keyword">return</span> Thread.<span class="title">interrupted</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>LockSupport</strong><br>LockSupport类是Java6引入的一个类，提供了基本的线程同步原语。LockSupport实际上是调用了Unsafe类里的函数，归结到Unsafe里，只有两个函数：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread jthread)</span></span>;  </span><br><span class="line">&gt; <span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> isAbsolute, <span class="keyword">long</span> time)</span></span>;  </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>unpark函数为线程提供“许可(permit)”，线程调用park函数则等待“许可”。这个有点像信号量，但是这个“许可”是不能叠加的，“许可”是一次性的。<br>permit相当于0/1的开关，默认是0，调用一次unpark就加1变成了1.调用一次park会消费permit，又会变成0。 如果再调用一次park会阻塞，因为permit已经是0了。直到permit变成1.这时调用unpark会把permit设置为1.每个线程都有一个相关的permit，permit最多只有一个，重复调用unpark不会累积</p></blockquote><h2 id="锁的释放"><a href="#锁的释放" class="headerlink" title="锁的释放"></a>锁的释放</h2><h3 id="ReentrantLock-unlock"><a href="#ReentrantLock-unlock" class="headerlink" title="ReentrantLock.unlock"></a>ReentrantLock.unlock</h3><p>加锁的过程分析完以后，再来分析一下释放锁的过程，调用release方法，这个方法里面做两件事，</p><p>1，释放锁 ；</p><p>2，唤醒park的线程</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease"></a>tryRelease</h3><p>这个动作可以认为就是一个<strong>设置锁状态的操作</strong>，而且是将状态减掉传入的参数值（参数是1），如果结果状态为0，就将<strong>排它锁的Owner设置为null</strong>，以使得其它的线程有机会进行执行。<br>在排它锁中，加锁的时候状态会增加1（当然可以自己修改这个值），在解锁的时候减掉1，同一个锁，在可以重入后，可能会被叠加为2、3、4这些值，只有unlock()的次数与lock()的次数对应才会将Owner线程设置为空，而且也只有这种情况下才会返回true。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases; <span class="comment">// 这里是将锁的数量减1</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<span class="comment">// 如果释放的线程和获取锁的线程不是同一个，抛出非法监视器状态异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; </span><br><span class="line"><span class="comment">// 由于重入的关系，不是每次释放锁c都等于0，</span></span><br><span class="line">    <span class="comment">// 直到最后一次释放锁时，才会把当前线程释放</span></span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor"></a>unparkSuccessor</h3><p>在方法unparkSuccessor(Node)中，就意味着<strong>真正要释放锁</strong>了，它传入的是head节点（<strong>head节点是占用锁的节点</strong>），当前线程被释放之后，需要唤醒下一个节点的线程</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void unparkSuccessor(Node <span class="type">node</span>) &#123;</span><br><span class="line">    int ws = <span class="type">node</span>.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(<span class="type">node</span>, ws, <span class="number">0</span>);</span><br><span class="line">    Node s = <span class="type">node</span>.<span class="keyword">next</span>;</span><br><span class="line">    <span class="keyword">if</span> (s == null || s.waitStatus &gt; <span class="number">0</span>) &#123;//判断后继节点是否为空或者是否是取消状态,</span><br><span class="line">        s = null;</span><br><span class="line">        <span class="keyword">for</span> (Node t =<span class="built_in"> tail</span>; t != null &amp;&amp; t != <span class="type">node</span>; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>) //然后从队列尾部向前遍历找到最前面的一个waitStatus小于<span class="number">0</span>的节点, 至于为什么从尾部开始向前遍历，因为在doAcquireInterruptibly.cancelAcquire方法的处理过程中只设置了<span class="keyword">next</span>的变化，没有设置prev的变化，在最后有这样一行代码：<span class="type">node</span>.<span class="keyword">next</span> = <span class="type">node</span>，如果这时执行了unparkSuccessor方法，并且向后遍历的话，就成了死循环了，所以这时只有prev是稳定的</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">//内部首先会发生的动作是获<span class="built_in">取head</span>节点的<span class="keyword">next</span>节点，如果获取到的节点不为空，则直接通过：“LockSupport.unpark()”方法来释放对应的被挂起的线程，这样一来将会有一个节点唤醒后继续进入循环进一步尝试tryAcquire()方法来获取锁</span><br><span class="line">    <span class="keyword">if</span> (s != null)</span><br><span class="line">        LockSupport.unpark(s.thread); //释放许可</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这篇文章基本将AQS队列的实现过程做了比较清晰的分析，主要是<strong>基于非公平锁的独占锁</strong>实现。在获得同步锁时，<strong>同步器维护一个同步队列</strong>，<strong>获取状态失败的线程都会被加入到队列中并在队列中进行自旋</strong>；<strong>移出队列（或停止自旋）的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用tryRelease(int arg)方法释放同步状态，然后唤醒头节点的后继节点。</strong></p><blockquote><p>参考文章：<br><a href="https://segmentfault.com/a/1190000017372067" target="_blank" rel="noopener">深入分析AQS实现原理</a><br><a href="https://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">Java并发之AQS详解</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简单解释一下J.U.C，是JDK中提供的并发工具包,&lt;code&gt;java.util.concurrent&lt;/code&gt;。里面提供了很多并发编程中很常用的实用工具类，比如&lt;strong&gt;atomic原子操作&lt;/strong&gt;、比如&lt;strong&gt;lock同步锁&lt;/strong&gt;、fork/join等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;谈到并发，不得不谈ReentrantLock；而谈到ReentrantLock，不得不谈AbstractQueuedSynchronizer（AQS）！&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://changsk.top/categories/Java/"/>
    
    
      <category term="java" scheme="http://changsk.top/tags/java/"/>
    
      <category term="AQS" scheme="http://changsk.top/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据类型</title>
    <link href="http://changsk.top/2019/06/20/redis-data-type/"/>
    <id>http://changsk.top/2019/06/20/redis-data-type/</id>
    <published>2019-06-20T01:31:16.000Z</published>
    <updated>2019-06-20T01:54:36.154Z</updated>
    
    <content type="html"><![CDATA[<p>Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</p><hr><h2 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h2><p>string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。</p><p>string 类型是<strong>二进制安全</strong>的。意思是 r<strong>edis 的 string 可以包含任何数据</strong>。比如jpg图片或者序列化的对象。</p><p>string 类型是 Redis 最基本的数据类型，<strong>string 类型的值最大能存储 512MB</strong>。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">redis</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">SET</span> <span class="selector-tag">name</span> "<span class="selector-tag">runoob</span>"</span><br><span class="line"><span class="selector-tag">OK</span></span><br><span class="line"><span class="selector-tag">redis</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">GET</span> <span class="selector-tag">name</span></span><br><span class="line">"<span class="selector-tag">runoob</span>"</span><br></pre></td></tr></table></figure><p>在以上实例中我们使用了 Redis 的 <strong>SET</strong> 和 <strong>GET</strong> 命令。键为 name，对应的值为 <strong>runoob</strong>。</p><p><strong>注意：</strong>一个键最大能存储512MB。</p><hr><h2 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h2><p>Redis hash 是一个键值(key=&gt;value)对集合。</p><p>Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p><strong>DEL runoob</strong> 用于删除前面测试用过的 key，不然会报错：<strong>(error) WRONGTYPE Operation against a key holding the wrong kind of value</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">redis</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">DEL</span> <span class="selector-tag">runoob</span></span><br><span class="line"><span class="selector-tag">redis</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">HMSET</span> <span class="selector-tag">myhash</span> <span class="selector-tag">field1</span> "<span class="selector-tag">Hello</span>" <span class="selector-tag">field2</span> "<span class="selector-tag">World</span>"</span><br><span class="line">"<span class="selector-tag">OK</span>"</span><br><span class="line"><span class="selector-tag">redis</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">HGET</span> <span class="selector-tag">myhash</span> <span class="selector-tag">field1</span></span><br><span class="line">"<span class="selector-tag">Hello</span>"</span><br><span class="line"><span class="selector-tag">redis</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">HGET</span> <span class="selector-tag">myhash</span> <span class="selector-tag">field2</span></span><br><span class="line">"<span class="selector-tag">World</span>"</span><br></pre></td></tr></table></figure><p>实例中我们使用了 Redis <strong>HMSET, HGET</strong> 命令，<strong>HMSET</strong> 设置了两个 <strong>field=&gt;value</strong> 对, HGET 获取对应 <strong>field</strong> 对应的 <strong>value</strong>。</p><p>每个 hash 可以存储 2<sup>32</sup>-1 键值对（40多亿）。</p><hr><h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">redis</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">DEL</span> <span class="selector-tag">runoob</span></span><br><span class="line"><span class="selector-tag">redis</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">lpush</span> <span class="selector-tag">runoob</span> <span class="selector-tag">redis</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 1</span><br><span class="line"><span class="selector-tag">redis</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">lpush</span> <span class="selector-tag">runoob</span> <span class="selector-tag">mongodb</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 2</span><br><span class="line"><span class="selector-tag">redis</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">lpush</span> <span class="selector-tag">runoob</span> <span class="selector-tag">rabitmq</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 3</span><br><span class="line"><span class="selector-tag">redis</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">lrange</span> <span class="selector-tag">runoob</span> 0 10</span><br><span class="line">1) "<span class="selector-tag">rabitmq</span>"</span><br><span class="line">2) "<span class="selector-tag">mongodb</span>"</span><br><span class="line">3) "<span class="selector-tag">redis</span>"</span><br><span class="line"><span class="selector-tag">redis</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt;</span><br></pre></td></tr></table></figure><p>列表最多可存储 2<sup>32</sup> - 1 元素 (4294967295, 每个列表可存储40多亿)。</p><hr><h2 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><p>Redis的Set是string类型的无序集合。</p><p><strong>集合是通过哈希表实现的</strong>，所以添加，删除，查找的复杂度都是O(1)。</p><h3 id="sadd-命令"><a href="#sadd-命令" class="headerlink" title="sadd 命令"></a>sadd 命令</h3><p>添加一个 string 元素到 key 对应的 set 集合中，成功返回1，如果元素已经在集合中返回 0，如果 key 对应的 set 不存在则返回错误。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sadd <span class="built_in">key</span> <span class="built_in">member</span></span><br></pre></td></tr></table></figure><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">redis</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">DEL</span> <span class="selector-tag">runoob</span></span><br><span class="line"><span class="selector-tag">redis</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">sadd</span> <span class="selector-tag">runoob</span> <span class="selector-tag">redis</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 1</span><br><span class="line"><span class="selector-tag">redis</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">sadd</span> <span class="selector-tag">runoob</span> <span class="selector-tag">mongodb</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 1</span><br><span class="line"><span class="selector-tag">redis</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">sadd</span> <span class="selector-tag">runoob</span> <span class="selector-tag">rabitmq</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 1</span><br><span class="line"><span class="selector-tag">redis</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">sadd</span> <span class="selector-tag">runoob</span> <span class="selector-tag">rabitmq</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 0</span><br><span class="line"><span class="selector-tag">redis</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">smembers</span> <span class="selector-tag">runoob</span></span><br><span class="line"></span><br><span class="line">1) "<span class="selector-tag">redis</span>"</span><br><span class="line">2) "<span class="selector-tag">rabitmq</span>"</span><br><span class="line">3) "<span class="selector-tag">mongodb</span>"</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>以上实例中 rabitmq 添加了两次，但根据集合内元素的唯一性，第二次插入的元素将被忽略。</p><p>集合中最大的成员数为 2<sup>32</sup> - 1(4294967295, 每个集合可存储40多亿个成员)。</p><hr><h2 id="zset-sorted-set：有序集合"><a href="#zset-sorted-set：有序集合" class="headerlink" title="zset(sorted set：有序集合)"></a>zset(sorted set：有序集合)</h2><p>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。</p><p>不同的是<strong>每个元素都会关联一个double类型的分数</strong>。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p>zset的成员是唯一的,但<strong>分数(score)却可以重复。</strong></p><h3 id="zadd-命令"><a href="#zadd-命令" class="headerlink" title="zadd 命令"></a>zadd 命令</h3><p>添加元素到集合，元素在集合中存在则更新对应score</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zadd <span class="built_in">key</span> score <span class="built_in">member</span></span><br></pre></td></tr></table></figure><h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">redis</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">DEL</span> <span class="selector-tag">runoob</span></span><br><span class="line"><span class="selector-tag">redis</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">zadd</span> <span class="selector-tag">runoob</span> 0 <span class="selector-tag">redis</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 1</span><br><span class="line"><span class="selector-tag">redis</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">zadd</span> <span class="selector-tag">runoob</span> 0 <span class="selector-tag">mongodb</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 1</span><br><span class="line"><span class="selector-tag">redis</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">zadd</span> <span class="selector-tag">runoob</span> 0 <span class="selector-tag">rabitmq</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 1</span><br><span class="line"><span class="selector-tag">redis</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">zadd</span> <span class="selector-tag">runoob</span> 0 <span class="selector-tag">rabitmq</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 0</span><br><span class="line"><span class="selector-tag">redis</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; &gt; <span class="selector-tag">ZRANGEBYSCORE</span> <span class="selector-tag">runoob</span> 0 1000</span><br><span class="line">1) "<span class="selector-tag">mongodb</span>"</span><br><span class="line">2) "<span class="selector-tag">rabitmq</span>"</span><br><span class="line">3) "<span class="selector-tag">redis</span>"</span><br></pre></td></tr></table></figure><blockquote><p>参考文章：<a href="https://www.runoob.com/redis/redis-data-types.html" target="_blank" rel="noopener">Redis 数据类型</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;String（字符串）&quot;&gt;&lt;a href=&quot;#String（字符串）&quot; class=&quot;he
      
    
    </summary>
    
      <category term="Redis" scheme="http://changsk.top/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://changsk.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>redis持久化</title>
    <link href="http://changsk.top/2019/06/19/redis-persistence/"/>
    <id>http://changsk.top/2019/06/19/redis-persistence/</id>
    <published>2019-06-19T13:51:19.000Z</published>
    <updated>2019-06-19T15:47:10.270Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis持久化概述"><a href="#Redis持久化概述" class="headerlink" title="Redis持久化概述"></a>Redis持久化概述</h1><p>Redis是一种高级key-value数据库。它跟memcached类似，不过数据可以持久化，而且支持的数据类型很丰富。有<strong>字符串</strong>，<strong>链表</strong>，<strong>集合</strong>和<strong>有序集合</strong>和<strong>map</strong>。支持在服务器端计算集合的并，交和补集(difference)等，还支持多种<strong>排序功能</strong>。所以Redis也可以被看成是一个数据结构服务器。</p><p>Redis的所有数据都是保存在内存中，然后不定期的通过<strong>异步方式</strong>保存到磁盘上(这称为“<strong>半持久化模式</strong>”)；也可以把每一次数据变化都写入到一个append only file(aof)里面(这称为“全持久化模式”)。 </p><p>由于Redis的数据都存放在内存中，如果没有配置持久化，redis重启后数据就全丢失了，于是需要开启redis的持久化功能，将数据保存到磁盘上，当redis重启后，可以从磁盘中恢复数据。redis提供两种方式进行持久化，一种是<strong>RDB持久化</strong>（原理是将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化），另外一种是<strong>AOF（append only file）</strong>持久化（原理是将Reids的<strong>操作日志</strong>以追加的方式写入文件）。</p><p>持久化的功能：Redis是<strong>内存数据库</strong>，<strong>数据都是存储在内存</strong>中，为了避免进程退出导致数据的永久丢失，需要定期将Redis中的数据以某种形式(<strong>数据</strong>或<strong>命令</strong>)从内存保存到硬盘；当下次Redis重启时，利用持久化文件实现数据恢复。除此之外，为了进行<strong>灾难备份</strong>，可以将持久化文件拷贝到一个远程位置。</p><p>Redis持久化分为RDB持久化和AOF持久化：<strong>前者将当前数据保存到硬盘，后者则是将每次执行的写命令保存到硬盘</strong>（类似于MySQL的binlog）；由于AOF持久化的实时性更好，即当进程意外退出时丢失的数据更少，因此AOF是目前主流的持久化方式，不过RDB持久化仍然有其用武之地。</p><p>Redis持久化的两种方式：</p><ul><li><p>RDB：在<strong>指定的时间间隔</strong>能对数据进行<strong>快照存储</strong>。</p></li><li><p>AOF：记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据。</p><a id="more"></a></li></ul><h1 id="持久化的配置"><a href="#持久化的配置" class="headerlink" title="持久化的配置"></a>持久化的配置</h1><p>为了使用持久化的功能，我们需要先知道该如何开启持久化的功能。</p><h2 id="RDB的持久化配置"><a href="#RDB的持久化配置" class="headerlink" title="RDB的持久化配置"></a>RDB的持久化配置</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 时间策略</span></span><br><span class="line"><span class="attribute">save</span> <span class="number">900</span> <span class="number">1</span></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件名称</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件保存路径</span></span><br><span class="line">dir /home/work/app/redis/data/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果持久化出错，主进程是否停止写入</span></span><br><span class="line">stop-writes-<span class="literal">on</span>-bgsave-<span class="literal">error</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否压缩</span></span><br><span class="line">rdbcompression <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入时是否检查</span></span><br><span class="line">rdbchecksum <span class="literal">yes</span></span><br></pre></td></tr></table></figure><p>配置其实非常简单，这里说一下持久化的时间策略具体是什么意思。</p><ul><li><code>save 900 1</code> 表示900s内如果有1条是写入命令，就触发产生一次快照，可以理解为就进行一次备份</li><li><code>save 300 10</code> 表示300s内有10条写入，就产生快照</li></ul><p>下面的类似，那么为什么需要配置这么多条规则呢？因为<strong>Redis每个时段的读写请求肯定不是均衡的</strong>，为了平衡性能与数据安全，我们可以自由定制什么情况下触发备份。所以这里就是根据自身Redis写入情况来进行合理配置。</p><p><code>stop-writes-on-bgsave-error yes</code> 这个配置也是非常重要的一项配置，这是当备份进程出错时，主进程就停止接受新的写入操作，是为了<strong>保护持久化的数据一致性问题</strong>。<strong>如果自己的业务有完善的监控系统，可以禁止此项配置，</strong> 否则请开启。</p><p>关于压缩的配置 <code>rdbcompression yes</code> ，建议没有必要开启，毕竟Redis本身就属于<strong>CPU密集型服务器</strong>，再开启压缩会带来更多的CPU消耗，相比硬盘成本，CPU更值钱。</p><p>当然如果你想要禁用RDB配置，也是非常容易的，<strong>只需要在save的最后一行写上：`save “”</strong>`</p><h2 id="AOF的配置"><a href="#AOF的配置" class="headerlink" title="AOF的配置"></a>AOF的配置</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否开启aof</span></span><br><span class="line"><span class="string">appendonly</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件名称</span></span><br><span class="line"><span class="string">appendfilename</span> <span class="string">"appendonly.aof"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步方式</span></span><br><span class="line"><span class="string">appendfsync</span> <span class="string">everysec</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># aof重写期间是否同步</span></span><br><span class="line"><span class="literal">no</span><span class="bullet">-appendfsync-on-rewrite</span> <span class="literal">no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重写触发配置</span></span><br><span class="line"><span class="string">auto-aof-rewrite-percentage</span> <span class="number">100</span></span><br><span class="line"><span class="string">auto-aof-rewrite-min-size</span> <span class="number">64</span><span class="string">mb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载aof时如果有错如何处理</span></span><br><span class="line"><span class="string">aof-load-truncated</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件重写策略</span></span><br><span class="line"><span class="string">aof-rewrite-incremental-fsync</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure><p>还是重点解释一些关键的配置：</p><p><code>appendfsync everysec</code> 它其实有三种模式:</p><ul><li>always：把每个写命令都<strong>立即同步</strong>到aof，很慢，但是很安全</li><li>everysec：每秒同步一次，是折中方案</li><li>no：redis不处理交给OS来处理，非常快，但是也最不安全</li></ul><p>一般情况下都采用 <strong>everysec</strong> 配置，这样可以兼顾速度与安全，<strong>最多损失1s的数据</strong>。</p><p><code>aof-load-truncated yes</code> 如果该配置启用，在加载时发现aof尾部不正确时，会<strong>向客户端写入一个log</strong>，但是会继续执行，如果设置为 <code>no</code> ，发现错误就会停止，必须修复后才能重新加载。</p><h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><p>关于原理部分，我们主要来看RDB与AOF是如何完成持久化的，它们的过程是如何。</p><p>在介绍原理之前先说下Redis内部的定时任务机制，<strong>定时任务执行的频率可以在配置文件中通过 <code>hz 10</code> 来设置</strong>（<strong>这个配置表示1s内执行10次，也就是每100ms触发一次定时任务</strong>）。该值最大能够设置为：<strong>500</strong>，但是不建议超过：<strong>100</strong>，因为值越大说明执行频率越频繁越高，这会带来CPU的更多消耗，从而影响主进程读写性能。</p><p>定时任务使用的是Redis自己实现的 <strong>TimeEvent</strong>，它会定时去调用一些命令完成定时任务，这些任务可能会阻塞主进程导致Redis性能下降。因此我们在配置Redis时，一定要整体考虑一些会触发定时任务的配置，根据实际情况进行调整。</p><h2 id="RDB的原理"><a href="#RDB的原理" class="headerlink" title="RDB的原理"></a>RDB的原理</h2><p>RDB持久化是将当前进程中的数据生成快照保存到硬盘(因此也称作快照持久化)，保存的文件后缀是rdb；当Redis重新启动时，可以读取快照文件恢复数据。</p><p>在Redis中RDB持久化的触发分为两种：自己<strong>手动触发</strong>与Redis<strong>定时触发</strong>。</p><h2 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h2><p><strong>save</strong>命令和<strong>bgsave</strong>命令都可以生成RDB文件。<br>save命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在Redis服务器阻塞期间，服务器不能处理任何命令请求。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">save</span></span><br></pre></td></tr></table></figure><p>而bgsave命令会<strong>创建一个子进程</strong>，由子进程来负责创建RDB文件，父进程(即Redis主进程)则继续处理请求。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">bgsave</span></span><br></pre></td></tr></table></figure><p>bgsave命令执行过程中，只有fork子进程时会阻塞服务器，而对于save命令，整个过程都会阻塞服务器，因此save已基本被废弃，线上环境要杜绝save的使用。</p><h2 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 时间策略</span><br><span class="line">save <span class="number">900</span> <span class="number">1</span></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure><p>其中save 900 1的含义是：当时间到900秒时，如果redis数据发生了至少1次变化，则执行bgsave；save 300 10和save 60 10000同理。当三个save条件满足任意一个时，都会引起bgsave的调用。</p><h3 id="save-m-n的实现原理"><a href="#save-m-n的实现原理" class="headerlink" title="save m n的实现原理"></a>save m n的实现原理</h3><p>Redis的<strong>save m n</strong>，是通过<strong>serverCron</strong>函数、<strong>dirty</strong>计数器、和<strong>lastsave</strong>时间戳来实现的。 </p><p>serverCron是Redis服务器的周期性操作函数，默认每隔100ms执行一次；该函数对服务器的状态进行维护，其中一项工作就是<strong>检查 save m n 配置的条件是否满足，如果满足就执行bgsave</strong>。</p><p>dirty计数器是Redis服务器维持的一个状态，<strong>记录了上一次执行bgsave/save命令后，服务器状态进行了多少次修改(包括增删改)；而当save/bgsave执行完成后，会将dirty重新置为0</strong>。</p><p>例如，如果Redis执行了set mykey helloworld，则dirty值会+1；如果执行了sadd myset v1 v2 v3，则dirty值会+3；注意dirty记录的是服务器进行了多少次修改，而不是客户端执行了多少修改数据的命令。</p><p>astsave时间戳也是Redis服务器维持的一个状态，记录的是上一次成功执行save/bgsave的时间。<br>save m n的原理如下：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每隔<span class="number">100</span>ms，执行serverCron函数；在serverCron函数中，遍历save m <span class="built_in">n</span>配置的保存条件，只要有一个条件满足，就进行bgsave。对于每一个save m <span class="built_in">n</span>条件，只有下面两条同时满足时才算满足： </span><br><span class="line">（<span class="number">1</span>）当前时间-lastsave &gt; m </span><br><span class="line">（<span class="number">2</span>）dirty &gt;= <span class="built_in">n</span></span><br></pre></td></tr></table></figure><h3 id="其他自动触发机制"><a href="#其他自动触发机制" class="headerlink" title="其他自动触发机制"></a>其他自动触发机制</h3><p>除了save m n 以外，还有一些其他情况会触发bgsave： </p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在主从复制场景下，如果从节点执行全量复制操作，则主节点会执行bgsave命令，并将rdb文件发送给从节点 </span><br><span class="line">执行<span class="built_in">shutdown</span>命令时，自动执行rdb持久化</span><br></pre></td></tr></table></figure><p><strong>自动触发的场景主要是有以下几点：</strong></p><ul><li>根据我们的 <code>save m n</code> 配置规则自动触发；</li><li>从节点全量复制时，主节点发送rdb文件给从节点完成复制操作，主节点会触发 <code>bgsave</code>；</li><li>执行 <code>debug reload</code> 时；</li><li>执行 <code>shutdown</code>时，如果没有开启aof，也会触发。<h3 id="bgsave执行流程"><a href="#bgsave执行流程" class="headerlink" title="bgsave执行流程"></a>bgsave执行流程</h3><img src="1.jpg" alt="image1"><br>图片中的5个步骤所进行的操作如下： </li></ul><ol><li>Redis父进程首先判断：当前是否在执行save，或bgsave/bgrewriteaof（后面会详细介绍该命令）的子进程，如果在执行则bgsave命令直接返回。bgsave/bgrewriteaof 的子进程不能同时执行，主要是基于性能方面的考虑：两个并发的子进程同时执行大量的磁盘写操作，可能引起严重的性能问题。 </li><li>父进程执行fork操作创建子进程，这个过程中父进程是阻塞的，Redis不能执行来自客户端的任何命令 </li><li>父进程fork后，bgsave命令返回”Background saving started”信息并不再阻塞父进程，并可以响应其他命令 </li><li>子进程创建RDB文件，根据父进程内存快照生成临时快照文件，完成后对原有文件进行原子替换 </li><li>子进程发送信号给父进程表示完成，父进程更新统计信息</li></ol><p>这里注意的是 <code>fork</code> 操作会阻塞，导致Redis读写性能下降。我们可以控制单个Redis实例的最大内存，来尽可能降低Redis在fork时的事件消耗。以及上面提到的自动触发的频率减少fork次数，或者使用手动触发，根据自己的机制来完成持久化。</p><h3 id="RDB文件"><a href="#RDB文件" class="headerlink" title="RDB文件"></a>RDB文件</h3><p>RDB文件是经过压缩的二进制文件，下面介绍关于RDB文件的一些细节。 </p><p>RDB文件的存储路径既可以在启动前配置，也可以通过命令动态设定。 </p><ul><li>配置：dir配置指定目录，dbfilename指定文件名。默认是Redis根目录下的dump.rdb文件。 </li><li>动态设定：Redis启动后也可以动态修改RDB存储路径，在磁盘损害或空间不足时非常有用；执行命令为config set dir {newdir}和config set dbfilename {newFileName}<br><img src="4.jpg" alt></li></ul><ol><li>REDIS：常量，保存着”REDIS”5个字符。 </li><li>db_version：RDB文件的版本号，注意不是Redis的版本号。 </li><li>SELECTDB 0 pairs：表示一个完整的数据库(0号数据库)，同理SELECTDB 3 pairs表示完整的3号数据库；只有当数据库中有键值对时，RDB文件中才会有该数据库的信息(上图所示的Redis中只有0号和3号数据库有键值对)；如果Redis中所有的数据库都没有键值对，则这一部分直接省略。其中：SELECTDB是一个常量，代表后面跟着的是数据库号码；0和3是数据库号码；pairs则存储了具体的键值对信息，包括key、value值，及其数据类型、内部编码、过期时间、压缩信息等等。 </li><li>EOF：常量，标志RDB文件正文内容结束。 </li><li>check_sum：前面所有内容的校验和；Redis在载入RBD文件时，会计算前面的校验和并与check_sum值比较，判断文件是否损坏。<br>Redis默认采用LZF算法对RDB文件进行压缩。虽然压缩耗时，但是可以大大减小RDB文件的体积，因此压缩默认开启；可以通过命令关闭：<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config <span class="builtin-name">set</span> rdbcompression <span class="literal">no</span></span><br></pre></td></tr></table></figure></li></ol><p>需要注意的是，RDB文件的压缩并不是针对整个文件进行的，而是对数据库中的字符串进行的，且只有在字符串达到一定长度(20字节)时才会进行。</p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>RDB文件的载入工作是在服务器启动时自动执行的，并没有专门的命令。但是由于<strong>AOF的优先级更高</strong>，因此当AOF开启时，Redis会优先载入AOF文件来恢复数据；只有当AOF关闭时，才会在Redis服务器启动时检测RDB文件，并自动载入。<strong>服务器载入RDB文件期间处于阻塞状态</strong>，直到载入完成为止。Redis载入RDB文件时，会对RDB文件进行校验，如果文件损坏，则日志中会打印错误，Redis启动失败。</p><h3 id="RDB优势"><a href="#RDB优势" class="headerlink" title="RDB优势"></a>RDB优势</h3><ol><li><p>一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的。比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。</p></li><li><p>对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。</p></li><li><p>性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。</p></li><li><p>相比于AOF机制，如果数据集很大，RDB的启动效率会更高。</p></li></ol><h3 id="RDB劣势"><a href="#RDB劣势" class="headerlink" title="RDB劣势"></a>RDB劣势</h3><ol><li><p>如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。</p></li><li><p>由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</p></li></ol><h2 id="AOF的原理"><a href="#AOF的原理" class="headerlink" title="AOF的原理"></a>AOF的原理</h2><p>AOF的整个流程大体来看可以分为两步，一步是命令的实时写入（如果是 <code>appendfsync everysec</code> 配置，会有1s损耗），第二步是对aof文件的重写。</p><p>对于增量追加到文件这一步主要的流程是：<strong>命令写入=》追加到aof_buf =》同步到aof磁盘</strong>。那么这里为什么要先写入buf在同步到磁盘呢？如果实时写入磁盘会带来非常高的磁盘IO，影响整体性能。</p><p><strong>aof重写是为了减少aof文件的大小，可以手动或者自动触发</strong>，关于自动触发的规则请看上面配置部分。fork的操作也是发生在重写这一步，也是这里会对主进程产生阻塞。</p><p><strong>手动触发：</strong> <code>bgrewriteaof</code>，<strong>自动触发</strong> 就是根据配置规则来触发，当然自动触发的整体时间还跟Redis的定时任务频率有关系。</p><p>下面来看看重写的一个流程图：<br><img src="2.jpg" alt="image2"></p><p>对于上图有四个关键点补充一下：</p><ol><li>在重写期间，由于主进程依然在响应命令，为了保证最终备份的完整性；因此它依然会写入旧的AOF file中，如果重写失败，能够保证数据不丢失。</li><li>为了把重写期间响应的写入信息也写入到新的文件中，因此也会为子进程保留一个buf，防止新写的file丢失数据。</li><li>重写是直接把当前内存的数据生成对应命令，并不需要读取老的AOF文件进行分析、命令合并。</li><li>AOF文件直接采用的文本协议，主要是兼容性好、追加方便、可读性高可认为修改修复。</li></ol><blockquote><p>不管是RDB还是AOF都是先写入一个临时文件，然后通过 <code>rename</code> 完成文件的替换工作。</p></blockquote><h3 id="AOF优势"><a href="#AOF优势" class="headerlink" title="AOF优势"></a>AOF优势</h3><ol><li><p>该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无需多言，我想大家都能正确的理解它。</p></li><li><p>由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过redis-check-aof工具来帮助我们解决数据一致性的问题。</p></li><li><p>如果日志过大，Redis可以自动启用rewrite机制。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。</p></li><li><p>AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。</p></li></ol><h3 id="AOF劣势"><a href="#AOF劣势" class="headerlink" title="AOF劣势"></a>AOF劣势</h3><ul><li><p>Redis会不断地将被执行的命令记录到AOF文件里面，所以随着Redis不断运行，AOF文件的体积也会不断增长。在极端情况下，体积不断增大的AOF文件甚至可能会用完硬盘的所有可用空间。对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</p></li><li><p>Redis在重启之后需要通过重新执行AOF文件记录的所有写命令来还原数据集，所以如果AOF文件的体积非常大，那么还原操作执行的时间就可能会非常长。</p></li><li><p>根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。<br><strong>解决办法</strong>：</p></li></ul><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>为了解决AOF文件体积不断增大的问题，用户可以向Redis发送BGREWRITEAOF命令，这个命令会通过移除AOF文件中的冗余命令来重写（<span class="built_in">rewrite</span>）AOF文件，使AOF文件的体积变得尽可能地小。BGREWRITEAOF的工作原理和BGSAVE创建快照的工作原理非常相似：Redis会创建一个子进程，然后由子进程负责对AOF文件进行重写。因为AOF文件重写也需要用到子进程，所以快照持久化因为创建子进程而导致的性能问题和内存占用问题，在AOF持久化中也同样存在。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>跟快照持久化可以通过设置save选项来自动执行BGSAVE一样，AOF持久化也可以通过设置<span class="built_in">auto</span>-aof-<span class="built_in">rewrite</span>-percentage选项和<span class="built_in">auto</span>-aof-<span class="built_in">rewrite</span>-min-size选项来自动执行BGREWRITEAOF。举个例子，假设用户对Redis设置了配置选项<span class="built_in">auto</span>-aof-<span class="built_in">rewrite</span>-percentage <span class="number">100</span>和<span class="built_in">auto</span>-aof-<span class="built_in">rewrite</span>-min-size <span class="number">64</span>mb，并且启动了AOF持久化，那么当AOF文件的体积大于<span class="number">64</span>MB，并且AOF文件的体积比上一次重写之后的体积大了至少一倍（<span class="number">100</span>%）的时候，Redis将执行BGREWRITEAOF命令。如果AOF重写执行得过于频繁的话，用户可以考虑将<span class="built_in">auto</span>-aof-<span class="built_in">rewrite</span>-percentage选项的值设置为<span class="number">100</span>以上，这种做法可以让Redis在AOF文件的体积变得更大之后才执行重写操作，不过也会让Redis在启动时还原数据集所需的时间变得更长。</span><br></pre></td></tr></table></figure><h1 id="从持久化中恢复数据"><a href="#从持久化中恢复数据" class="headerlink" title="从持久化中恢复数据"></a>从持久化中恢复数据</h1><p>数据的备份、持久化做完了，我们如何从这些持久化文件中恢复数据呢？如果一台服务器上有既有RDB文件，又有AOF文件，该加载谁呢？</p><p>其实想要从这些文件中恢复数据，只需要重新启动Redis即可。我们还是通过图来了解这个流程：<br><img src="3.jpg" alt="image2"></p><p>启动时会先检查<strong>AOF</strong>文件是否存在，如果不存在就尝试加载RDB。那么为什么会优先加载AOF呢？因为<strong>AOF保存的数据更完整，通过上面的分析我们知道AOF基本上最多损失1s的数据。</strong></p><h1 id="性能与实践"><a href="#性能与实践" class="headerlink" title="性能与实践"></a>性能与实践</h1><p>通过上面的分析，我们都知道RDB的快照、AOF的重写都需要fork，这是一个重量级操作，<strong>会对Redis造成阻塞</strong>。因此为了不影响Redis主进程响应，我们需要尽可能降低阻塞。</p><ol><li>降低fork的频率，比如可以手动来触发RDB生成快照与AOF重写；</li><li>控制Redis最大使用内存，防止fork耗时过长；</li><li>使用更牛逼的硬件；</li><li>合理配置Linux的内存分配策略，避免因为物理内存不足导致fork失败。</li></ol><p>在线上我们到底该怎么做？我提供一些自己的实践经验。</p><ol><li>如果Redis中的数据并不是特别敏感或者可以通过其它方式重写生成数据，可以关闭持久化，如果丢失数据可以通过其它途径补回；</li><li>自己制定策略定期检查Redis的情况，然后可以手动触发备份、重写数据；</li><li>单机如果部署多个实例，要防止多个机器同时运行持久化、重写操作，防止出现内存、CPU、IO资源竞争，让持久化变为串行；</li><li>可以加入主从机器，利用一台从机器进行备份处理，其它机器正常响应客户端的命令；</li><li>RDB持久化与AOF持久化可以同时存在，配合使用。</li></ol><blockquote><p>参考文章：<br><a href="https://segmentfault.com/a/1190000015983518" target="_blank" rel="noopener">一起看懂Redis两种持久化方式的原理</a><br><a href="https://segmentfault.com/a/1190000013113862" target="_blank" rel="noopener">Redis重写/压缩AOF文件</a><br><a href="https://www.cnblogs.com/chenliangcl/p/7240350.html" target="_blank" rel="noopener">redis持久化的几种方式</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis持久化概述&quot;&gt;&lt;a href=&quot;#Redis持久化概述&quot; class=&quot;headerlink&quot; title=&quot;Redis持久化概述&quot;&gt;&lt;/a&gt;Redis持久化概述&lt;/h1&gt;&lt;p&gt;Redis是一种高级key-value数据库。它跟memcached类似，不过数据可以持久化，而且支持的数据类型很丰富。有&lt;strong&gt;字符串&lt;/strong&gt;，&lt;strong&gt;链表&lt;/strong&gt;，&lt;strong&gt;集合&lt;/strong&gt;和&lt;strong&gt;有序集合&lt;/strong&gt;和&lt;strong&gt;map&lt;/strong&gt;。支持在服务器端计算集合的并，交和补集(difference)等，还支持多种&lt;strong&gt;排序功能&lt;/strong&gt;。所以Redis也可以被看成是一个数据结构服务器。&lt;/p&gt;
&lt;p&gt;Redis的所有数据都是保存在内存中，然后不定期的通过&lt;strong&gt;异步方式&lt;/strong&gt;保存到磁盘上(这称为“&lt;strong&gt;半持久化模式&lt;/strong&gt;”)；也可以把每一次数据变化都写入到一个append only file(aof)里面(这称为“全持久化模式”)。 &lt;/p&gt;
&lt;p&gt;由于Redis的数据都存放在内存中，如果没有配置持久化，redis重启后数据就全丢失了，于是需要开启redis的持久化功能，将数据保存到磁盘上，当redis重启后，可以从磁盘中恢复数据。redis提供两种方式进行持久化，一种是&lt;strong&gt;RDB持久化&lt;/strong&gt;（原理是将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化），另外一种是&lt;strong&gt;AOF（append only file）&lt;/strong&gt;持久化（原理是将Reids的&lt;strong&gt;操作日志&lt;/strong&gt;以追加的方式写入文件）。&lt;/p&gt;
&lt;p&gt;持久化的功能：Redis是&lt;strong&gt;内存数据库&lt;/strong&gt;，&lt;strong&gt;数据都是存储在内存&lt;/strong&gt;中，为了避免进程退出导致数据的永久丢失，需要定期将Redis中的数据以某种形式(&lt;strong&gt;数据&lt;/strong&gt;或&lt;strong&gt;命令&lt;/strong&gt;)从内存保存到硬盘；当下次Redis重启时，利用持久化文件实现数据恢复。除此之外，为了进行&lt;strong&gt;灾难备份&lt;/strong&gt;，可以将持久化文件拷贝到一个远程位置。&lt;/p&gt;
&lt;p&gt;Redis持久化分为RDB持久化和AOF持久化：&lt;strong&gt;前者将当前数据保存到硬盘，后者则是将每次执行的写命令保存到硬盘&lt;/strong&gt;（类似于MySQL的binlog）；由于AOF持久化的实时性更好，即当进程意外退出时丢失的数据更少，因此AOF是目前主流的持久化方式，不过RDB持久化仍然有其用武之地。&lt;/p&gt;
&lt;p&gt;Redis持久化的两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;RDB：在&lt;strong&gt;指定的时间间隔&lt;/strong&gt;能对数据进行&lt;strong&gt;快照存储&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;AOF：记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://changsk.top/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://changsk.top/tags/Redis/"/>
    
      <category term="持久化" scheme="http://changsk.top/tags/%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>消失的U盘内存</title>
    <link href="http://changsk.top/2019/06/19/udisk-capacity-small/"/>
    <id>http://changsk.top/2019/06/19/udisk-capacity-small/</id>
    <published>2019-06-19T12:57:42.000Z</published>
    <updated>2019-06-19T13:40:17.049Z</updated>
    
    <content type="html"><![CDATA[<p>今天为了给<code>mac book pro</code>安装双系统<code>ubuntu 16.04</code>，用U盘制作安装启动盘。安装的过程还算顺利，唯一让人难受的地方进入安装界面之后 <code>mbp</code>的触摸板不能用，只能用有线的鼠标和键盘。安装好了之后发现32G容量的U盘只有2M多了。应该是制作安装启动盘的时候，把很大一部分内存隐藏了起来，所以导致U盘可见容量减小。</p><a id="more"></a><p>下面记录了找回U盘容量的过程：</p><ol><li>右键<code>我的电脑</code> -&gt; <code>管理</code> -&gt; <code>磁盘管理</code>，发现U盘内存属于未分配的状态。</li></ol><p><img src="1.jpg" alt></p><ol start="2"><li>在黑色未分配区域点击右键选择<code>新建简单卷</code></li></ol><p><img src="2.jpg" alt></p><ol start="3"><li>接下来一路 <code>next</code><br><img src="3.jpg" alt><br><img src="4.jpg" alt><br><img src="5.jpg" alt><br><img src="6.jpg" alt></li><li>然后就发现消失的U盘内存回来了。<br><img src="7.jpg" alt></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天为了给&lt;code&gt;mac book pro&lt;/code&gt;安装双系统&lt;code&gt;ubuntu 16.04&lt;/code&gt;，用U盘制作安装启动盘。安装的过程还算顺利，唯一让人难受的地方进入安装界面之后 &lt;code&gt;mbp&lt;/code&gt;的触摸板不能用，只能用有线的鼠标和键盘。安装好了之后发现32G容量的U盘只有2M多了。应该是制作安装启动盘的时候，把很大一部分内存隐藏了起来，所以导致U盘可见容量减小。&lt;/p&gt;
    
    </summary>
    
      <category term="others" scheme="http://changsk.top/categories/others/"/>
    
    
      <category term="U盘" scheme="http://changsk.top/tags/U%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>mysql分片、分区、分表、分库</title>
    <link href="http://changsk.top/2019/06/19/mysql-partition/"/>
    <id>http://changsk.top/2019/06/19/mysql-partition/</id>
    <published>2019-06-19T07:41:49.000Z</published>
    <updated>2019-06-19T12:30:45.401Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Scale-Out（横向扩展）-Scale-Up（纵向扩展）"><a href="#一、Scale-Out（横向扩展）-Scale-Up（纵向扩展）" class="headerlink" title="一、Scale Out（横向扩展）/Scale Up（纵向扩展）"></a>一、Scale Out（横向扩展）/Scale Up（纵向扩展）</h2><p>Mysql的扩展方案包括<strong>Scale Out</strong>和<strong>Scale Up</strong>两种。</p><a id="more"></a><h3 id="Scale-Out（横向扩展）"><a href="#Scale-Out（横向扩展）" class="headerlink" title="Scale Out（横向扩展）"></a>Scale Out（横向扩展）</h3><p><strong>Scale Out（横向扩展）：</strong>是指Application可以在<strong>水平方向</strong>上扩展。一般对数据中心的应用而言，Scale out指的是当<strong>添加更多的机器</strong>时，应用仍然可以很好的利用这些机器的资源来提升自己的效率从而达到很好的扩展性。</p><h3 id="Scale-Up（纵向扩展）"><a href="#Scale-Up（纵向扩展）" class="headerlink" title="Scale Up（纵向扩展）"></a>Scale Up（纵向扩展）</h3><p><strong>Scale Up（纵向扩展）：</strong>是指Application可以在<strong>垂直方向</strong>上扩展。一般对单台机器而言，Scale Up指的是当某个计算节点（机器）<strong>添加更多的CPU Cores</strong>，<strong>存储设备</strong>，使用<strong>更大的内存</strong>时，应用可以很充分的利用这些资源来提升自己的效率从而达到很好的扩展性。</p><h2 id="二、Sharding（属于横向扩展）"><a href="#二、Sharding（属于横向扩展）" class="headerlink" title="二、Sharding（属于横向扩展）"></a>二、Sharding（属于横向扩展）</h2><p>Sharding 是把数据库横向扩展（Scale Out）到多个物理节点上的一种有效的方式，其主要目的是为<strong>突破单节点数据库服务器的 I/O 能力限制</strong>，解决数据库扩展性问题。<strong>Shard这个词的意思是“碎片”</strong>。如果将一个数据库当作一块大玻璃，将这块玻璃打碎，那么每一小块都称为数据库的碎片（Database Shard）。将整个数据库打碎的过程就叫做sharding，可以翻译为分片。</p><p>形式上，<strong>Sharding可以简单定义为将大数据库分布到多个物理节点上的一个分区方案</strong>。每一个分区包含数据库的某一部分，称为一个shard，分区方式可以是任意的，并不局限于传统的<strong>水平分区</strong>和<strong>垂直分区</strong>。一个shard可以包含多个表的内容甚至可以包含多个数据库实例中的内容。每个shard被放置在一个数据库服务器上。一个数据库服务器可以处理一个或多个shard的数据。系统中需要有服务器进行查询路由转发，负责将查询转发到包含该查询所访问数据的shard或shards节点上去执行。</p><h3 id="Sharding-策略"><a href="#Sharding-策略" class="headerlink" title="Sharding 策略"></a>Sharding 策略</h3><ul><li><p>哈希取模：hash(key) % N；</p></li><li><p>范围：可以是 ID 范围也可以是时间范围；</p></li><li><p>映射表：使用单独的一个数据库来存储映射关系。</p></li></ul><p><strong>MySql的Sharding策略包括垂直切分和水平切分两种</strong>。</p><h3 id="垂直-纵向-拆分"><a href="#垂直-纵向-拆分" class="headerlink" title="垂直(纵向)拆分"></a>垂直(纵向)拆分</h3><p><strong>垂直(纵向)拆分：</strong>是指<strong>按功能模块拆分</strong>，以解决表与表之间的io竞争。即将表按照<strong>功能模块</strong>、<strong>关系密切程度</strong>划分出来，<strong>部署到不同的库上</strong>。例如，我们会建立定义数据库workDB、商品数据库payDB、用户数据库userDB、日志数据库logDB等，分别用于存储项目数据定义表、商品定义表、用户数据表、日志数据表等。</p><p>如userid,name,addr一个表，为了防止表过大，分成2个表。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">userid,</span>name</span><br><span class="line"></span><br><span class="line"><span class="built_in">userid,</span>addr</span><br></pre></td></tr></table></figure><p>表结构设计垂直切分。常见的一些场景包括:</p><ol><li><p><strong>大字段的垂直切分</strong>。单独将大字段建在另外的表中，提高基础表的访问性能，原则上在性能关键的应用中应当避免数据库的大字段</p></li><li><p><strong>按照使用用途垂直切分</strong>。例如企业物料属性，可以按照基本属性、销售属性、采购属性、生产制造属性、财务会计属性等用途垂直切分.</p></li><li><p><strong>按照访问频率垂直切分</strong>。例如电子商务、Web 2.0系统中，如果用户属性设置非常多，可以将基本、使用频繁的属性和不常用的属性垂直切分开</p></li></ol><h3 id="水平-横向-拆分"><a href="#水平-横向-拆分" class="headerlink" title="水平(横向)拆分"></a>水平(横向)拆分</h3><p> <strong>水平(横向)拆分：</strong>将<strong>同一个表的数据进行分块保存到不同的数据库</strong>中，来解决单表中数据量增长出现的压力。这些数据库中的表<strong>结构完全相同</strong>。当一个表中的数据量过大时，我们可以把该表的数据按照某种规则，例如<strong>userID散列</strong>、按<strong>性别</strong>、按<strong>省</strong>，进行划分，然后存储到<strong>多个结构相同的表</strong>，和<strong>不同的库</strong>上。例如，我们的userDB中的用户数据表中，每一个表的数据量都很大，就可以把userDB切分为结构相同的多个userDB：part0DB、part1DB等，再将userDB上的用户数据表userTable，切分为很多userTable：userTable0、userTable1等，然后将这些表按照一定的规则存储到多个userDB上。</p><p>表结构设计水平切分。常见的一些场景包括:</p><ol><li>比如在线电子商务网站，订单表数据量过大，按照年度、月度水平切分。</li><li>Web 2.0网站注册用户、在线活跃用户过多，按照用户ID范围等方式，将相关用户以及该用户紧密关联的表做水平切分。</li><li>例如论坛的置顶帖子，因为涉及到分页问题，每页都需要显示置顶贴，这种情况可以把置顶贴水平切分开来，避免取置顶帖子时从所有帖子的表中读取</li></ol><h2 id="三、分表和分区"><a href="#三、分表和分区" class="headerlink" title="三、分表和分区"></a>三、分表和分区</h2><p><strong>分表从表面意思说就是把一张表分成多个小表</strong>，把一张表按一定的规则分解成N个具有独立存储空间的实体表。系统读写时需要根据定义好的规则得到对应的字表明，然后操作它。</p><p><strong>分区则是把一张表的数据分成N多个区</strong>块，这些区块可以在同一个磁盘上，也可以在不同的磁盘上，在逻辑上看最终只是一张表，但底层是由<strong>N个物理区块组成的，</strong>分区实现比较简单，数据库mysql、oracle等很容易就可支持。分区对业务透明，分区只不过把存放数据的文件分成了许多小块，根据一定的规则把数据文件(MYD)和索引文件（MYI）进行了分割，分区后的表呢，还是一张表。</p><p>分表和分区的区别：</p><ol><li><p>实现方式上<br><strong>mysql的分表是真正的分表，一张表分成很多表后，每一个小表都是完整的一张表</strong>，都对应<strong>三个文件</strong>（MyISAM引擎：一个.MYD<strong>数据文件</strong>，.MYI<strong>索引文件</strong>，.frm<strong>表结构文件</strong>）。</p></li><li><p>数据处理上<br>分表后数据都是存放在分表里，<strong>总表只是一个外壳</strong>，存取数据发生在一个一个的分表里面。分区则不存在分表的概念，分区只不过把存放数据的文件分成了许多小块，分区后的表还是一张表，数据处理还是由自己来完成。</p></li><li><p>提高性能上 </p></li></ol><p>（1）分表后，单表的并发能力提高了，磁盘I/O性能也提高了。并发能力为什么提高了呢，因为查询一次所花的时间变短了，如果出现高并发的话，总表可以根据不同的查询，将并发压力分到不同的小表里面。磁盘I/O性能高了，本来一个非常大的.MYD文件现在也分摊到各个小表的.MYD中去了。</p><p>   （2）mysql提出了分区的概念，我觉得就想突破磁盘I/O瓶颈，想提高磁盘的读写能力，来增加mysql性能。</p><p>   在这一点上，分区和分表的测重点不同，分表重点是存取数据时，如何提高mysql并发能力上；而分区呢，如何突破磁盘的读写能力，从而达到提高mysql性能的目的。</p><ol start="4"><li>实现的难易度上<br>分表的方法有很多，用merge来分表，是最简单的一种方式。这种方式和分区难易度差不多，并且对程序代码来说可以做到透明的。如果是用其他分表方式就比分区麻烦了。 分区实现是比较简单的，建立分区表，跟建平常的表没什么区别，并且对代码端来说是透明的。 </li></ol><p>分区的适用场景:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>一张表的查询速度已经慢到影响使用的时候。</span><br><span class="line"><span class="bullet">2. </span>表中的数据是分段的</span><br><span class="line"><span class="bullet">3. </span>对数据的操作往往只涉及一部分数据，而不是所有的数据</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sales (  </span><br><span class="line">        <span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT,  </span><br><span class="line">        amount <span class="keyword">DOUBLE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">        order_day DATETIME <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">        PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>, order_day)  </span><br><span class="line">    ) <span class="keyword">ENGINE</span>=<span class="keyword">Innodb</span>   </span><br><span class="line">    <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(<span class="keyword">YEAR</span>(order_day)) (  </span><br><span class="line">        <span class="keyword">PARTITION</span> p_2010 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2010</span>),  </span><br><span class="line">        <span class="keyword">PARTITION</span> p_2011 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2011</span>),  </span><br><span class="line">        <span class="keyword">PARTITION</span> p_2012 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2012</span>),  </span><br><span class="line">    <span class="keyword">PARTITION</span> p_catchall <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> MAXVALUE);</span><br></pre></td></tr></table></figure><p>分表的适用场景</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>一张表的查询速度已经慢到影响使用的时候。</span><br><span class="line"><span class="bullet">2. </span>当频繁插入或者联合查询时，速度变慢。</span><br></pre></td></tr></table></figure><p>分表的实现需要业务结合实现和迁移，较为复杂。</p><h3 id="如何选择？"><a href="#如何选择？" class="headerlink" title="如何选择？"></a>如何选择？</h3><p>应该使用哪一种方式来实施数据库分库分表，这要看数据库中<strong>数据量的瓶颈</strong>所在，并综合项目的业务类型进行考虑。</p><ol><li><p>如果数据库是因为<strong>表太多而造成海量数据</strong>，并且项目的各项业务逻辑划分清晰、低耦合，那么规则简单明了、容易实施的垂直切分必是首选。</p></li><li><p>而如果数据库中的表并不多，但<strong>单表的数据量很</strong>大、或<strong>数据热度很高</strong>，这种情况之下就应该选择水平切分，水平切分比垂直切分要复杂一些，它将原本逻辑上属于一体的数据进行了物理分割，除了在分割时要对分割的粒度做好评估，考虑数据平均和负载平均，后期也将对项目人员及应用程序产生额外的数据管理负担。</p></li></ol><p>在现实项目中，往往是这两种情况兼而有之，这就需要做出权衡，甚至既需要垂直切分，又需要水平切分。</p><h2 id="四、分表和分库"><a href="#四、分表和分库" class="headerlink" title="四、分表和分库"></a>四、分表和分库</h2><p><strong>分表能够解决单表数据量过大带来的查询效率下降的问题</strong>，但是，却无法给数据库的并发处理能力带来质的提升。面对高并发的读写访问，当数据库master服务器无法承载写操作压力时，不管如何扩展slave服务器，此时都没有意义了。因此，我们必须换一种思路，对数据库进行拆分，从而提高数据库写入能力，这就是所谓的分库。</p><p>分表和分区都是基于同一个数据库里的数据分离技巧，对数据库性能有一定提升，但是随着业务数据量的增加，原来所有的数据都是在一个数据库上的，网络IO及文件IO都集中在一个数据库上的，因此CPU、内存、文件IO、网络IO都可能会成为系统瓶颈。当业务系统的数据容量接近或超过单台服务器的容量、QPS/TPS接近或超过单个数据库实例的处理极限等此时，往往是采用垂直和水平结合的数据拆分方法，把数据服务和数据存储分布到多台数据库服务器上。</p><p>与分表策略相似，分库可以采用通过一个关键字取模的方式，来对数据访问进行路由，如下图所示：</p><p><img src="1.jpg" alt="图片.png"></p><h2 id="五、分库分表存在的问题"><a href="#五、分库分表存在的问题" class="headerlink" title="五、分库分表存在的问题"></a>五、分库分表存在的问题</h2><h3 id="事务问题"><a href="#事务问题" class="headerlink" title="事务问题"></a>事务问题</h3><p>在执行分库分表之后，由于数据存储到了不同的库上，<strong>数据库事务管理出现了困难</strong>。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价；如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。</p><h3 id="跨库跨表的join问题"><a href="#跨库跨表的join问题" class="headerlink" title="跨库跨表的join问题"></a>跨库跨表的join问题</h3><p>在执行了分库分表之后，难以避免会将原本逻辑关联性很强的数据划分到不同的表、不同的库上，这时，表的关联操作将受到限制，我们无法join位于不同分库的表，也无法join分表粒度不同的表，结果原本一次查询能够完成的业务，可能需要多次查询才能完成。</p><h3 id="额外的数据管理负担和数据运算压力。"><a href="#额外的数据管理负担和数据运算压力。" class="headerlink" title="额外的数据管理负担和数据运算压力。"></a>额外的数据管理负担和数据运算压力。</h3><p>额外的数据管理负担，最显而易见的就是数据的定位问题和数据的增删改查的重复执行问题，这些都可以通过应用程序解决，但必然引起额外的逻辑运算，例如，对于一个记录用户成绩的用户数据表userTable，业务要求查出成绩最好的100位，在进行分表之前，只需一个order by语句就可以搞定，但是在进行分表之后，将需要n个order by语句，分别查出每一个分表的前100名用户数据，然后再对这些数据进行合并计算，才能得出结果。</p><h2 id="六、分片（Sharding）和分区（Partition）"><a href="#六、分片（Sharding）和分区（Partition）" class="headerlink" title="六、分片（Sharding）和分区（Partition）"></a>六、分片（Sharding）和分区（Partition）</h2><p>sharding和partition的区别：<br><img src="2.jpg" alt="图片.png"></p><blockquote><p>参考文章：<br><a href="https://blog.51cto.com/net881004/2109383" target="_blank" rel="noopener">mysql分片、分区、分表、分库</a><br><a href="https://cloud.tencent.com/developer/news/243312" target="_blank" rel="noopener">Mysql分表和分区的区别、分库和分表区别</a><br><a href="http://youzhixueyuan.com/the-principle-of-separating-tables-reading-and-writing-and-using-scenarios.html" target="_blank" rel="noopener">阿里P8架构师谈：数据库分库分表、读写分离的原理实现，使用场景</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、Scale-Out（横向扩展）-Scale-Up（纵向扩展）&quot;&gt;&lt;a href=&quot;#一、Scale-Out（横向扩展）-Scale-Up（纵向扩展）&quot; class=&quot;headerlink&quot; title=&quot;一、Scale Out（横向扩展）/Scale Up（纵向扩展）&quot;&gt;&lt;/a&gt;一、Scale Out（横向扩展）/Scale Up（纵向扩展）&lt;/h2&gt;&lt;p&gt;Mysql的扩展方案包括&lt;strong&gt;Scale Out&lt;/strong&gt;和&lt;strong&gt;Scale Up&lt;/strong&gt;两种。&lt;/p&gt;
    
    </summary>
    
      <category term="Mysql" scheme="http://changsk.top/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="http://changsk.top/tags/Mysql/"/>
    
      <category term="分片" scheme="http://changsk.top/tags/%E5%88%86%E7%89%87/"/>
    
      <category term="分区" scheme="http://changsk.top/tags/%E5%88%86%E5%8C%BA/"/>
    
      <category term="分表" scheme="http://changsk.top/tags/%E5%88%86%E8%A1%A8/"/>
    
      <category term="分库" scheme="http://changsk.top/tags/%E5%88%86%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>桥梁模式bridge</title>
    <link href="http://changsk.top/2019/06/19/bridge/"/>
    <id>http://changsk.top/2019/06/19/bridge/</id>
    <published>2019-06-19T06:54:11.000Z</published>
    <updated>2019-06-19T07:44:32.520Z</updated>
    
    <content type="html"><![CDATA[<h2 id="桥梁模式的定义"><a href="#桥梁模式的定义" class="headerlink" title="桥梁模式的定义"></a>桥梁模式的定义</h2><p>定义: <strong>将抽象和实现解耦, 使得两者可以独立的变化</strong></p><p>通俗的说, 就是一个类调用另一个类中的方法, 需要一个桥梁, 通过<strong>聚合</strong>的关系调用</p><p>其类图如下:</p><a id="more"></a><p><img src="1.jpg" alt="img"></p><p>其中角色说明如下:</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Abstraction 抽象化角色</span>: 它的主要职责是定义出该角色的行为, 同时保存一个对实现化角色的引用, 一般是抽象类</span><br><span class="line"></span><br><span class="line"><span class="attribute">Implementor 实现化角色</span>: 接口或抽象类, 定义角色必须的行为和属性</span><br><span class="line"></span><br><span class="line"><span class="attribute">RefinedAbstraction 修正抽象化角色</span>: 它引用实现化角色对抽象化角色进行修正</span><br><span class="line"></span><br><span class="line"><span class="attribute">ConcreteImplementor 具体实现化角色</span>: 它实现接口或抽象类定义的方法和属性</span><br></pre></td></tr></table></figure><h2 id="桥梁模式实现"><a href="#桥梁模式实现" class="headerlink" title="桥梁模式实现"></a>桥梁模式实现</h2><p>抽象角色的部分实现是由实现角色完成的</p><p>实现化角色代码:</p><p><img src="2.jpg" alt="img"></p><p>具体实现化角色代码:</p><p><img src="3.jpg" alt="img"></p><p>抽象化角色代码:</p><p><img src="4.jpg" alt="img"></p><p>具体抽象化角色代码:</p><p><img src="5.jpg" alt="img"></p><p>场景类代码:</p><p><img src="6.jpg" alt="img"></p><h2 id="桥梁模式优点"><a href="#桥梁模式优点" class="headerlink" title="桥梁模式优点"></a>桥梁模式优点</h2><p>桥梁模式是一个很简单的模式, 它只是使用了类间的<strong>聚合关系</strong>、<strong>继承</strong>、<strong>覆写</strong>等常用功能, 但是它却提供了一个非常清晰、稳定的架构。</p><p>桥梁模式的优点:</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">抽象和实现分离. 这是桥梁模式的主要特点, 它完全是为了解决继承的缺点而提出的设计模式. 在该模式下,实现可以不受抽象的约束,不用再绑定在一个固定的抽象层次上,具有优秀的扩充能力.</span><br><span class="line"></span><br><span class="line">实现细节对客户透明. 客户不用关心细节的实现, 它已经由抽象层通过聚合关系完成了封装</span><br></pre></td></tr></table></figure><h2 id="桥梁模式的使用场景"><a href="#桥梁模式的使用场景" class="headerlink" title="桥梁模式的使用场景:"></a>桥梁模式的使用场景:</h2><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">不希望或不适用使用继承的场景. 例如继承层次过滤、无法更细化设计颗粒等场景</span><br><span class="line"></span><br><span class="line">接口或抽象类不稳定的场景.</span><br><span class="line"></span><br><span class="line">重用性要求较高的场景. 设计的颗粒度越细,则被重用的可能性就越大, 而采用继承则受父类的限制, 不可能出现太细的颗粒度</span><br></pre></td></tr></table></figure><p>使用桥梁模式主要考虑如何拆分抽象和实现,并不是一设计继承就要考虑使用该模式. 桥梁模式的意图还是对变化的封装, 尽量把可能变化的因素封装到最细、最小的逻辑单元中,避免风险扩散.因此在进行系统设计时,<strong>发现类的继承有N层时,可以考虑使用桥梁模式</strong>.</p><p><strong>桥梁模式在Java应用中的一个非常典型的例子就是JDBC驱动器</strong>。JDBC为所有的关系型数据库提供一个通用的界面。一个应用系统动态地选择一个合适的驱动器，然后通过驱动器向数据库引擎发出指令。这个过程就是将抽象角色的行为委派给实现角色的过程。</p><p>抽象角色可以针对任何数据库引擎发出查询指令，因为抽象角色并不直接与数据库引擎打交道，JDBC驱动器负责这个底层的工作。由于JDBC驱动器的存在，应用系统可以不依赖于数据库引擎的细节而独立地演化；同时数据库引擎也可以独立于应用系统的细节而独立的演化。两个独立的等级结构如下图所示，左边是JDBC API的等级结构，右边是JDBC驱动器的等级结构。应用程序是建立在JDBC API的基础之上的。</p><p><img src="7.jpg" alt="img"></p><p>应用系统作为一个等级结构，与JDBC驱动器这个等级结构是相对独立的，它们之间没有静态的强关联。应用系统通过委派与JDBC驱动器相互作用，这是一个桥梁模式的例子。</p><p><strong>JDBC的这种架构，把抽象部分和具体部分分离开来，从而使得抽象部分和具体部分都可以独立地扩展。</strong>对于应用程序而言，只要选用不同的驱动，就可以让程序操作不同的数据库，而无需更改应用程序，从而实现在不同的数据库上移植；对于驱动程序而言，为数据库实现不同的驱动程序，并不会影响应用程序。</p><blockquote><p>以上文章来自：<a href="http://mini.eastday.com/mobile/180816152400347.html#" target="_blank" rel="noopener">23种设计模式之桥梁模式</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;桥梁模式的定义&quot;&gt;&lt;a href=&quot;#桥梁模式的定义&quot; class=&quot;headerlink&quot; title=&quot;桥梁模式的定义&quot;&gt;&lt;/a&gt;桥梁模式的定义&lt;/h2&gt;&lt;p&gt;定义: &lt;strong&gt;将抽象和实现解耦, 使得两者可以独立的变化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通俗的说, 就是一个类调用另一个类中的方法, 需要一个桥梁, 通过&lt;strong&gt;聚合&lt;/strong&gt;的关系调用&lt;/p&gt;
&lt;p&gt;其类图如下:&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://changsk.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="桥接模式" scheme="http://changsk.top/tags/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>mysql之explain详解</title>
    <link href="http://changsk.top/2019/06/18/mysql-explain/"/>
    <id>http://changsk.top/2019/06/18/mysql-explain/</id>
    <published>2019-06-18T13:11:51.000Z</published>
    <updated>2019-06-19T03:31:50.136Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://segmentfault.com/a/1190000008131735" target="_blank" rel="noopener">MySQL 性能优化神器 Explain 使用分析</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MySQL 提供了一个 <strong>EXPLAIN</strong> 命令, 它可以对 <code>SELECT</code> 语句进行分析, 并输出 <code>SELECT</code> 执行的详细信息, 以供开发人员针对性优化.<br>EXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了, 例如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">from</span> user_info <span class="keyword">WHERE</span> <span class="keyword">id</span> &lt; <span class="number">300</span>;</span><br></pre></td></tr></table></figure><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>为了接下来方便演示 EXPLAIN 的使用, 首先我们需要建立两个测试用的表, 并添加相应的数据:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user_info`</span> (</span><br><span class="line">  <span class="string">`id`</span>   <span class="built_in">BIGINT</span>(<span class="number">20</span>)  <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">  <span class="string">`age`</span>  <span class="built_in">INT</span>(<span class="number">11</span>)              <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`name_index`</span> (<span class="string">`name`</span>)</span><br><span class="line">)</span><br><span class="line">  <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info (<span class="keyword">name</span>, age) <span class="keyword">VALUES</span> (<span class="string">'xys'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info (<span class="keyword">name</span>, age) <span class="keyword">VALUES</span> (<span class="string">'a'</span>, <span class="number">21</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info (<span class="keyword">name</span>, age) <span class="keyword">VALUES</span> (<span class="string">'b'</span>, <span class="number">23</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info (<span class="keyword">name</span>, age) <span class="keyword">VALUES</span> (<span class="string">'c'</span>, <span class="number">50</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info (<span class="keyword">name</span>, age) <span class="keyword">VALUES</span> (<span class="string">'d'</span>, <span class="number">15</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info (<span class="keyword">name</span>, age) <span class="keyword">VALUES</span> (<span class="string">'e'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info (<span class="keyword">name</span>, age) <span class="keyword">VALUES</span> (<span class="string">'f'</span>, <span class="number">21</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info (<span class="keyword">name</span>, age) <span class="keyword">VALUES</span> (<span class="string">'g'</span>, <span class="number">23</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info (<span class="keyword">name</span>, age) <span class="keyword">VALUES</span> (<span class="string">'h'</span>, <span class="number">50</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info (<span class="keyword">name</span>, age) <span class="keyword">VALUES</span> (<span class="string">'i'</span>, <span class="number">15</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`order_info`</span> (</span><br><span class="line">  <span class="string">`id`</span>           <span class="built_in">BIGINT</span>(<span class="number">20</span>)  <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`user_id`</span>      <span class="built_in">BIGINT</span>(<span class="number">20</span>)           <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`product_name`</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">  <span class="string">`productor`</span>    <span class="built_in">VARCHAR</span>(<span class="number">30</span>)          <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`user_product_detail_index`</span> (<span class="string">`user_id`</span>, <span class="string">`product_name`</span>, <span class="string">`productor`</span>)</span><br><span class="line">)</span><br><span class="line">  <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_info (user_id, product_name, productor) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'p1'</span>, <span class="string">'WHH'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_info (user_id, product_name, productor) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'p2'</span>, <span class="string">'WL'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_info (user_id, product_name, productor) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'p1'</span>, <span class="string">'DX'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_info (user_id, product_name, productor) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">'p1'</span>, <span class="string">'WHH'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_info (user_id, product_name, productor) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">'p5'</span>, <span class="string">'WL'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_info (user_id, product_name, productor) <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">'p3'</span>, <span class="string">'MA'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_info (user_id, product_name, productor) <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">'p1'</span>, <span class="string">'WHH'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_info (user_id, product_name, productor) <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="string">'p1'</span>, <span class="string">'WHH'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_info (user_id, product_name, productor) <span class="keyword">VALUES</span> (<span class="number">9</span>, <span class="string">'p8'</span>, <span class="string">'TE'</span>);</span><br></pre></td></tr></table></figure><h2 id="EXPLAIN-输出格式"><a href="#EXPLAIN-输出格式" class="headerlink" title="EXPLAIN 输出格式"></a>EXPLAIN 输出格式</h2><p>EXPLAIN 命令的输出内容大致如下:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * <span class="keyword">from</span> user_info where id = 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: <span class="literal">NULL</span></span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: <span class="literal">NULL</span></span><br><span class="line">1 row <span class="keyword">in</span> set, 1 <span class="builtin-name">warning</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p>各列的含义如下:</p><ul><li>id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</li><li>select_type: SELECT 查询的类型.</li><li>table: 查询的是哪个表</li><li>partitions: 匹配的分区</li><li>type: join 类型</li><li>possible_keys: 此次查询中可能选用的索引</li><li>key: 此次查询中确切使用到的索引.</li><li>ref: 哪个字段或常数与 key 一起被使用</li><li>rows: 显示此查询一共扫描了多少行. 这个是一个估计值.</li><li>filtered: 表示此查询条件所过滤的数据的百分比</li><li>extra: 额外的信息</li></ul><p>接下来我们来重点看一下比较重要的几个字段.</p><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p><code>select_type</code> 表示了查询的类型, 它的常用取值有:</p><ul><li><strong>SIMPLE</strong>, 表示此查询<strong>不包含 UNION 查询或子查询</strong></li><li>PRIMARY, 表示此查询是最外层的查询</li><li>UNION, 表示此查询是 UNION 的第二或随后的查询</li><li>DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询</li><li>UNION RESULT, UNION 的结果</li><li>SUBQUERY, 子查询中的第一个 SELECT</li><li>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</li></ul><p>最常见的查询类别应该是 <code>SIMPLE</code> 了, 比如当我们的查询<strong>没有子查询, 也没有 UNION 查询</strong>时, 那么通常就是 <code>SIMPLE</code> 类型, 例如:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * <span class="keyword">from</span> user_info where id = 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: <span class="literal">NULL</span></span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: <span class="literal">NULL</span></span><br><span class="line">1 row <span class="keyword">in</span> set, 1 <span class="builtin-name">warning</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p>如果我们使用了 UNION 查询, 那么 EXPLAIN 输出 的结果类似如下:</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN (SELECT * FROM user_info  WHERE id IN (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">    -&gt; UNION</span><br><span class="line">    -&gt; (SELECT * FROM user_info WHERE id IN (<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span><br><span class="line">| <span class="type">id</span> | <span class="type">select_type</span>  | <span class="type">table</span>      | <span class="type">partitions</span> | <span class="type">type</span>  | <span class="type">possible_keys</span> | <span class="type">key</span>     | <span class="type">key_len</span> | <span class="type">ref</span>  | <span class="type">rows</span> | <span class="type">filtered</span> | <span class="type">Extra</span>           |<span class="type"></span></span><br><span class="line"><span class="type">+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="type">|  1</span> | <span class="type">PRIMARY</span>      | <span class="type">user_info</span>  | <span class="type">NULL</span>       | <span class="type">range</span> | <span class="type">PRIMARY</span>       | <span class="type">PRIMARY</span> | <span class="type">8</span>       | <span class="type">NULL</span> |    <span class="type">3</span> |   <span class="type">100</span><span class="number">.00</span> | <span class="type">Using</span> <span class="keyword">where</span>     |<span class="type"></span></span><br><span class="line"><span class="type">|  2</span> | <span class="type">UNION</span>        | <span class="type">user_info</span>  | <span class="type">NULL</span>       | <span class="type">range</span> | <span class="type">PRIMARY</span>       | <span class="type">PRIMARY</span> | <span class="type">8</span>       | <span class="type">NULL</span> |    <span class="type">3</span> |   <span class="type">100</span><span class="number">.00</span> | <span class="type">Using</span> <span class="keyword">where</span>     |<span class="type"></span></span><br><span class="line"><span class="type">| NULL</span> | <span class="type">UNION</span> RESULT | <span class="type">&lt;union1</span>,<span class="number">2</span>&gt; | <span class="type">NULL</span>       | <span class="type">ALL</span>   | <span class="type">NULL</span>          | <span class="type">NULL</span>    | <span class="type">NULL</span>    | <span class="type">NULL</span> | <span class="type">NULL</span> |     <span class="type">NULL</span> | <span class="type">Using</span> temporary |<span class="type"></span></span><br><span class="line"><span class="type">+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="type">3</span> rows <span class="built_in">in</span> <span class="built_in">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>表示查询涉及的表或衍生表</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p><code>type</code> 字段比较重要, 它提供了<strong>判断查询是否高效的重要依据依据</strong>. 通过 <code>type</code> 字段, 我们判断此次查询是 <code>全表扫描</code> 还是 <code>索引扫描</code> 等.</p><h4 id="type-常用类型"><a href="#type-常用类型" class="headerlink" title="type 常用类型"></a>type 常用类型</h4><p>type 常用的取值有:</p><ul><li><code>system</code>: 表中只有一条数据. 这个类型是特殊的 <code>const</code> 类型.</li><li><code>const</code>: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.<br>例如下面的这个查询, 它使用了主键索引, 因此 <code>type</code> 就是 <code>const</code> 类型的.</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * <span class="keyword">from</span> user_info where id = 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: <span class="literal">NULL</span></span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: <span class="literal">NULL</span></span><br><span class="line">1 row <span class="keyword">in</span> set, 1 <span class="builtin-name">warning</span> (0.00 sec)</span><br></pre></td></tr></table></figure><ul><li><code>eq_ref</code>: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 <code>=</code>, 查询效率较高. 例如:</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mysql&gt;</span> <span class="string">EXPLAIN</span> <span class="string">SELECT</span> <span class="string">*</span> <span class="string">FROM</span> <span class="string">user_info,</span> <span class="string">order_info</span> <span class="string">WHERE</span> <span class="string">user_info.id</span> <span class="string">=</span> <span class="string">order_info.user_id\G</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">1.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">           id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  select_type:</span> <span class="string">SIMPLE</span></span><br><span class="line"><span class="attr">        table:</span> <span class="string">order_info</span></span><br><span class="line"><span class="attr">   partitions:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         type:</span> <span class="string">index</span></span><br><span class="line"><span class="attr">possible_keys:</span> <span class="string">user_product_detail_index</span></span><br><span class="line"><span class="attr">          key:</span> <span class="string">user_product_detail_index</span></span><br><span class="line"><span class="attr">      key_len:</span> <span class="number">314</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         rows:</span> <span class="number">9</span></span><br><span class="line"><span class="attr">     filtered:</span> <span class="number">100.00</span></span><br><span class="line"><span class="attr">        Extra:</span> <span class="string">Using</span> <span class="string">where;</span> <span class="string">Using</span> <span class="string">index</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">2.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">           id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  select_type:</span> <span class="string">SIMPLE</span></span><br><span class="line"><span class="attr">        table:</span> <span class="string">user_info</span></span><br><span class="line"><span class="attr">   partitions:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         type:</span> <span class="string">eq_ref</span></span><br><span class="line"><span class="attr">possible_keys:</span> <span class="string">PRIMARY</span></span><br><span class="line"><span class="attr">          key:</span> <span class="string">PRIMARY</span></span><br><span class="line"><span class="attr">      key_len:</span> <span class="number">8</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="string">test.order_info.user_id</span></span><br><span class="line"><span class="attr">         rows:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">     filtered:</span> <span class="number">100.00</span></span><br><span class="line"><span class="attr">        Extra:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="number">2</span> <span class="string">rows</span> <span class="string">in</span> <span class="string">set,</span> <span class="number">1</span> <span class="string">warning</span> <span class="string">(0.00</span> <span class="string">sec)</span></span><br></pre></td></tr></table></figure><ul><li><code>ref</code>: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 <code>最左前缀</code> 规则索引的查询.<br>例如下面这个例子中, 就使用到了 <code>ref</code> 类型的查询:</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mysql&gt;</span> <span class="string">EXPLAIN</span> <span class="string">SELECT</span> <span class="string">*</span> <span class="string">FROM</span> <span class="string">user_info,</span> <span class="string">order_info</span> <span class="string">WHERE</span> <span class="string">user_info.id</span> <span class="string">=</span> <span class="string">order_info.user_id</span> <span class="string">AND</span> <span class="string">order_info.user_id</span> <span class="string">=</span> <span class="number">5</span><span class="string">\G</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">1.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">           id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  select_type:</span> <span class="string">SIMPLE</span></span><br><span class="line"><span class="attr">        table:</span> <span class="string">user_info</span></span><br><span class="line"><span class="attr">   partitions:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         type:</span> <span class="string">const</span></span><br><span class="line"><span class="attr">possible_keys:</span> <span class="string">PRIMARY</span></span><br><span class="line"><span class="attr">          key:</span> <span class="string">PRIMARY</span></span><br><span class="line"><span class="attr">      key_len:</span> <span class="number">8</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="string">const</span></span><br><span class="line"><span class="attr">         rows:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">     filtered:</span> <span class="number">100.00</span></span><br><span class="line"><span class="attr">        Extra:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">2.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">           id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  select_type:</span> <span class="string">SIMPLE</span></span><br><span class="line"><span class="attr">        table:</span> <span class="string">order_info</span></span><br><span class="line"><span class="attr">   partitions:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         type:</span> <span class="string">ref</span></span><br><span class="line"><span class="attr">possible_keys:</span> <span class="string">user_product_detail_index</span></span><br><span class="line"><span class="attr">          key:</span> <span class="string">user_product_detail_index</span></span><br><span class="line"><span class="attr">      key_len:</span> <span class="number">9</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="string">const</span></span><br><span class="line"><span class="attr">         rows:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">     filtered:</span> <span class="number">100.00</span></span><br><span class="line"><span class="attr">        Extra:</span> <span class="string">Using</span> <span class="string">index</span></span><br><span class="line"><span class="number">2</span> <span class="string">rows</span> <span class="string">in</span> <span class="string">set,</span> <span class="number">1</span> <span class="string">warning</span> <span class="string">(0.01</span> <span class="string">sec)</span></span><br></pre></td></tr></table></figure><ul><li><code>range</code>: 表示使用<strong>索引范围查询</strong>, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.<br>当 <code>type</code> 是 <code>range</code> 时, 那么 EXPLAIN 输出的 <code>ref</code> 字段为 NULL, 并且 <code>key_len</code> 字段是<strong>此次查询中使用到的索引的最长的那个.</strong></li></ul><p>例如下面的例子就是一个范围查询:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT *</span><br><span class="line">    -&gt;         <span class="keyword">FROM</span> user_info</span><br><span class="line">    -&gt;         WHERE id BETWEEN 2 <span class="keyword">AND</span> 8 \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: <span class="literal">NULL</span></span><br><span class="line">         type: range</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: <span class="literal">NULL</span></span><br><span class="line">         rows: 7</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row <span class="keyword">in</span> set, 1 <span class="builtin-name">warning</span> (0.00 sec)</span><br></pre></td></tr></table></figure><ul><li><code>index</code>: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.<br><code>index</code> 类型通常出现在: <strong>所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据</strong>. 当是这种情况时, Extra 字段 会显示 <code>Using index</code>.</li></ul><p>例如:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mysql&gt;</span> <span class="string">EXPLAIN</span> <span class="string">SELECT</span> <span class="string">name</span> <span class="string">FROM</span>  <span class="string">user_info</span> <span class="string">\G</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">1.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">           id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  select_type:</span> <span class="string">SIMPLE</span></span><br><span class="line"><span class="attr">        table:</span> <span class="string">user_info</span></span><br><span class="line"><span class="attr">   partitions:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         type:</span> <span class="string">index</span></span><br><span class="line"><span class="attr">possible_keys:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">          key:</span> <span class="string">name_index</span></span><br><span class="line"><span class="attr">      key_len:</span> <span class="number">152</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         rows:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">     filtered:</span> <span class="number">100.00</span></span><br><span class="line"><span class="attr">        Extra:</span> <span class="string">Using</span> <span class="string">index</span></span><br><span class="line"><span class="number">1</span> <span class="string">row</span> <span class="string">in</span> <span class="string">set,</span> <span class="number">1</span> <span class="string">warning</span> <span class="string">(0.00</span> <span class="string">sec)</span></span><br></pre></td></tr></table></figure><p>上面的例子中, 我们查询的 name 字段恰好是一个索引, 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据. 因此这样的情况下, type 的值是 <code>index</code>, 并且 Extra 的值是 <code>Using index</code>.</p><ul><li>ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.<br>下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mysql&gt;</span> <span class="string">EXPLAIN</span> <span class="string">SELECT</span> <span class="string">age</span> <span class="string">FROM</span>  <span class="string">user_info</span> <span class="string">WHERE</span> <span class="string">age</span> <span class="string">=</span> <span class="number">20</span> <span class="string">\G</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">1.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">           id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  select_type:</span> <span class="string">SIMPLE</span></span><br><span class="line"><span class="attr">        table:</span> <span class="string">user_info</span></span><br><span class="line"><span class="attr">   partitions:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         type:</span> <span class="string">ALL</span></span><br><span class="line"><span class="attr">possible_keys:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">          key:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">      key_len:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         rows:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">     filtered:</span> <span class="number">10.00</span></span><br><span class="line"><span class="attr">        Extra:</span> <span class="string">Using</span> <span class="string">where</span></span><br><span class="line"><span class="number">1</span> <span class="string">row</span> <span class="string">in</span> <span class="string">set,</span> <span class="number">1</span> <span class="string">warning</span> <span class="string">(0.00</span> <span class="string">sec)</span></span><br></pre></td></tr></table></figure><h4 id="type-类型的性能比较"><a href="#type-类型的性能比较" class="headerlink" title="type 类型的性能比较"></a>type 类型的性能比较</h4><p>通常来说, 不同的 type 类型的性能关系如下:<br><code>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</code><br><code>ALL</code> 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.<br>而 <code>index</code> 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.<br>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.</p><h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p><code>possible_keys</code> 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 <code>possible_keys</code> 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 <code>key</code> 字段决定.</p><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>此字段是 MySQL 在当前查询时所真正使用到的索引.</p><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>表示<strong>查询优化器使用了索引的字节数</strong>. <strong>这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.</strong><br>key_len 的计算规则如下:</p><ul><li>字符串<ul><li>char(n): n 字节长度</li><li>varchar(n): 如果是 utf8 编码, 则是 3 <em>n + 2字节; 如果是 utf8mb4 编码, 则是 4</em> n + 2 字节.</li></ul></li><li>数值类型:<ul><li>TINYINT: 1字节</li><li>SMALLINT: 2字节</li><li>MEDIUMINT: 3字节</li><li>INT: 4字节</li><li>BIGINT: 8字节</li></ul></li><li>时间类型<ul><li>DATE: 3字节</li><li>TIMESTAMP: 4字节</li><li>DATETIME: 8字节</li></ul></li><li>字段属性: <strong>NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性</strong>.</li></ul><p>我们来举两个简单的栗子:</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> order_info <span class="keyword">WHERE</span> user_id &lt; <span class="number">3</span> <span class="keyword">AND</span> product_name = <span class="string">'p1'</span> <span class="keyword">AND</span> productor = <span class="string">'WHH'</span> \G</span><br><span class="line">*************************** <span class="number">1.</span> row ***************************</span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: order_info</span><br><span class="line">   partitions: <span class="literal">NULL</span></span><br><span class="line">         <span class="built_in">type</span>: range</span><br><span class="line">possible_keys: user_product_detail_index</span><br><span class="line">          <span class="keyword">key</span>: user_product_detail_index</span><br><span class="line">      key_len: <span class="number">9</span></span><br><span class="line">          ref: <span class="literal">NULL</span></span><br><span class="line">         rows: <span class="number">5</span></span><br><span class="line">     filtered: <span class="number">11.11</span></span><br><span class="line">        Extra: <span class="keyword">Using</span> <span class="keyword">where</span>; Using <span class="keyword">index</span></span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>上面的例子是从表 order_info 中查询指定的内容, 而我们从此表的建表语句中可以知道, 表 <code>order_info</code> 有一个联合索引:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)</span><br></pre></td></tr></table></figure><p>不过此查询语句 <code>WHERE user_id &lt; 3 AND product_name = &#39;p1&#39; AND productor = &#39;WHH&#39;</code> 中, 因为先进行 user_id 的范围查询, 而根据 <code>最左前缀匹配</code> 原则, <strong>当遇到范围查询时, 就停止索引的匹配</strong>, 因此实际上我们使用到的索引的字段只有 <code>user_id</code>, 因此在 <code>EXPLAIN</code> 中, 显示的 key_len 为 9. 因为 user_id 字段是 BIGINT, 占用 8 字节, 而 NULL 属性占用一个字节, 因此总共是 9 个字节. 若我们将user_id 字段改为 <code>BIGINT(20) NOT NULL DEFAULT &#39;0&#39;</code>, 则 key_length 应该是8.</p><p>上面因为 <code>最左前缀匹配</code> 原则, 我们的查询仅仅使用到了联合索引的 <code>user_id</code> 字段, 因此效率不算高.</p><p>接下来我们来看一下下一个例子:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mysql&gt;</span> <span class="string">EXPLAIN</span> <span class="string">SELECT</span> <span class="string">*</span> <span class="string">FROM</span> <span class="string">order_info</span> <span class="string">WHERE</span> <span class="string">user_id</span> <span class="string">=</span> <span class="number">1</span> <span class="string">AND</span> <span class="string">product_name</span> <span class="string">=</span> <span class="string">'p1'</span> <span class="string">\G;</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">1.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">           id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  select_type:</span> <span class="string">SIMPLE</span></span><br><span class="line"><span class="attr">        table:</span> <span class="string">order_info</span></span><br><span class="line"><span class="attr">   partitions:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         type:</span> <span class="string">ref</span></span><br><span class="line"><span class="attr">possible_keys:</span> <span class="string">user_product_detail_index</span></span><br><span class="line"><span class="attr">          key:</span> <span class="string">user_product_detail_index</span></span><br><span class="line"><span class="attr">      key_len:</span> <span class="number">161</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="string">const,const</span></span><br><span class="line"><span class="attr">         rows:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">     filtered:</span> <span class="number">100.00</span></span><br><span class="line"><span class="attr">        Extra:</span> <span class="string">Using</span> <span class="string">index</span></span><br><span class="line"><span class="number">1</span> <span class="string">row</span> <span class="string">in</span> <span class="string">set,</span> <span class="number">1</span> <span class="string">warning</span> <span class="string">(0.00</span> <span class="string">sec)</span></span><br></pre></td></tr></table></figure><p>这次的查询中, 我们没有使用到范围查询, key_len 的值为 161. 为什么呢? 因为我们的查询条件 <code>WHERE user_id = 1 AND product_name = &#39;p1&#39;</code> 中, 仅仅使用到了联合索引中的前两个字段, 因此 <code>keyLen(user_id) + keyLen(product_name) = 9 + 50 * 3 + 2 = 161</code></p><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.<br>这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.</p><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>EXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</p><ul><li>Using filesort<br>当 Extra 中有 <code>Using filesort</code> 时, 表示 MySQL 需<strong>额外的排序操作</strong>, 不能通过索引顺序达到排序效果. 一般有 <code>Using filesort</code>, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.</li></ul><p>例如下面的例子:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mysql&gt;</span> <span class="string">EXPLAIN</span> <span class="string">SELECT</span> <span class="string">*</span> <span class="string">FROM</span> <span class="string">order_info</span> <span class="string">ORDER</span> <span class="string">BY</span> <span class="string">product_name</span> <span class="string">\G</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">1.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">           id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  select_type:</span> <span class="string">SIMPLE</span></span><br><span class="line"><span class="attr">        table:</span> <span class="string">order_info</span></span><br><span class="line"><span class="attr">   partitions:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         type:</span> <span class="string">index</span></span><br><span class="line"><span class="attr">possible_keys:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">          key:</span> <span class="string">user_product_detail_index</span></span><br><span class="line"><span class="attr">      key_len:</span> <span class="number">253</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         rows:</span> <span class="number">9</span></span><br><span class="line"><span class="attr">     filtered:</span> <span class="number">100.00</span></span><br><span class="line"><span class="attr">        Extra:</span> <span class="string">Using</span> <span class="string">index;</span> <span class="string">Using</span> <span class="string">filesort</span></span><br><span class="line"><span class="number">1</span> <span class="string">row</span> <span class="string">in</span> <span class="string">set,</span> <span class="number">1</span> <span class="string">warning</span> <span class="string">(0.00</span> <span class="string">sec)</span></span><br></pre></td></tr></table></figure><p>我们的索引是</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)</span><br></pre></td></tr></table></figure><p>但是上面的查询中根据 <code>product_name</code> 来排序, 因此不能使用索引进行优化, 进而会产生 <code>Using filesort</code>.如果我们将排序依据改为 <code>ORDER BY user_id, product_name</code>, 那么就不会出现 <code>Using filesort</code> 了. 例如:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mysql&gt;</span> <span class="string">EXPLAIN</span> <span class="string">SELECT</span> <span class="string">*</span> <span class="string">FROM</span> <span class="string">order_info</span> <span class="string">ORDER</span> <span class="string">BY</span> <span class="string">user_id,</span> <span class="string">product_name</span> <span class="string">\G</span></span><br><span class="line"><span class="string">***************************</span> <span class="number">1.</span> <span class="string">row</span> <span class="string">***************************</span></span><br><span class="line"><span class="attr">           id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  select_type:</span> <span class="string">SIMPLE</span></span><br><span class="line"><span class="attr">        table:</span> <span class="string">order_info</span></span><br><span class="line"><span class="attr">   partitions:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         type:</span> <span class="string">index</span></span><br><span class="line"><span class="attr">possible_keys:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">          key:</span> <span class="string">user_product_detail_index</span></span><br><span class="line"><span class="attr">      key_len:</span> <span class="number">253</span></span><br><span class="line"><span class="attr">          ref:</span> <span class="literal">NULL</span></span><br><span class="line"><span class="attr">         rows:</span> <span class="number">9</span></span><br><span class="line"><span class="attr">     filtered:</span> <span class="number">100.00</span></span><br><span class="line"><span class="attr">        Extra:</span> <span class="string">Using</span> <span class="string">index</span></span><br><span class="line"><span class="number">1</span> <span class="string">row</span> <span class="string">in</span> <span class="string">set,</span> <span class="number">1</span> <span class="string">warning</span> <span class="string">(0.00</span> <span class="string">sec)</span></span><br></pre></td></tr></table></figure><ul><li>Using index<br>“覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</li><li>Using temporary<br>查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文：&lt;a href=&quot;https://segmentfault.com/a/1190000008131735&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MySQL 性能优化神器 Explain 使用分析&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="Mysql" scheme="http://changsk.top/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="http://changsk.top/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>java动态代理</title>
    <link href="http://changsk.top/2019/06/18/java-dynamic-proxy/"/>
    <id>http://changsk.top/2019/06/18/java-dynamic-proxy/</id>
    <published>2019-06-18T08:30:57.000Z</published>
    <updated>2019-06-18T09:41:27.961Z</updated>
    
    <content type="html"><![CDATA[<p>以下文章来自：<a href="https://www.cnblogs.com/gonjan-blog/p/6685611.html" target="_blank" rel="noopener">java动态代理实现与原理详细分析</a></p><p>关于Java中的动态代理，我们首先需要了解的是一种常用的设计模式–<strong>代理模式</strong>，而对于代理，根据<strong>创建代理类的时间点</strong>，又可以分为静态代理和动态代理。</p><a id="more"></a><h2 id="一、代理模式"><a href="#一、代理模式" class="headerlink" title="一、代理模式"></a>一、代理模式</h2><p>   代理模式是常用的java设计模式，他的特征是<strong>代理类与委托类有同样的接口</strong>，代理类主要负责为委托类<strong>预处理消息</strong>、<strong>过滤消息</strong>、把<strong>消息转发给委托类</strong>，以及<strong>事后处理消息</strong>等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。简单的说就是，我们在访问实际对象时，是通过代理对象来访问的，<strong>代理模式就是在访问实际对象时引入一定程度的间接性</strong>，因为这种间接性，可以附加多种用途。在后面我会解释这种间接性带来的好处。代理模式结构图（图片来自《大话设计模式》）：</p><p><img src="1.jpg" alt="img">                                                          </p><h2 id="二、静态代理"><a href="#二、静态代理" class="headerlink" title="二、静态代理"></a>二、静态代理</h2><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>静态代理：由程序员创建或特定工具自动<strong>生成源代码</strong>，也就是<strong>在编译时就已经将接口，被代理类，代理类等确定下来</strong>。<strong>在程序运行之前，代理类的.class文件就已经生成。</strong></p><h3 id="静态代理简单实现"><a href="#静态代理简单实现" class="headerlink" title="静态代理简单实现"></a>静态代理简单实现</h3><p> 根据上面代理模式的类图，来写一个简单的静态代理的例子。我这儿举一个比较粗糙的例子，假如一个班的同学要向老师交班费，但是都是通过班长把自己的钱转交给老师。这里，班长就是代理学生上交班费，</p><p>班长就是学生的代理。</p><p>​    首先，我们创建一个Person接口。这个接口就是学生（被代理类），和班长（代理类）的公共接口，他们都有上交班费的行为。这样，学生上交班费就可以让班长来代理执行。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建Person接口</span></span><br><span class="line"><span class="comment"> * @author Gonjan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Person</span> &#123;</span><br><span class="line">    <span class="comment">//上交班费</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">giveMoney</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student类实现Person接口。Student可以具体实施上交班费的动作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(name + <span class="string">"上交班费50元"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StudentsProxy类，这个类也实现了Person接口，但是还另外持有一个学生类对象，由于实现了Peson接口，同时持有一个学生对象，那么他可以代理学生类对象执行上交班费（执行giveMoney()方法）行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学生代理类，也实现了Person接口，保存一个学生实体，这样既可以代理学生产生行为</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Gonjan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentsProxy</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//被代理的学生</span></span><br><span class="line">    Student stu;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentsProxy</span><span class="params">(Person stu)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只代理学生对象</span></span><br><span class="line">        <span class="keyword">if</span>(stu.getClass() == Student.class) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stu = (Student)stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//代理上交班费，调用被代理学生的上交班费行为</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stu.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面测试一下，看如何使用代理模式：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="comment">//被代理的学生张三，他的班费上交有代理对象monitor（班长）完成</span></span><br><span class="line">        Person zhangsan = <span class="keyword">new</span> <span class="type">Student</span>(<span class="string">"张三"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//生成代理对象，并将张三传给代理对象</span></span><br><span class="line">        Person monitor = <span class="keyword">new</span> <span class="type">StudentsProxy</span>(zhangsan);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//班长代理上交班费</span></span><br><span class="line">        monitor.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="2.jpg" alt="img"></p><p>这里并没有直接通过张三（被代理对象）来执行上交班费的行为，而是通过班长（代理对象）来代理执行了。这就是代理模式。</p><p>代理模式最主要的就是有一个<strong>公共接口</strong>（Person），一个<strong>具体的类</strong>（Student），一个<strong>代理类</strong>（StudentsProxy）,<strong>代理类持有具体类的实例，代为执行具体类实例方法</strong>。上面说到，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。这里的间接性就是指<strong>不直接调用实际对象的方法，那么我们在代理过程中就可以加上一些其他用途。就这个例子来说，加入班长在帮张三上交班费之前想要先反映一下张三最近学习有很大进步，通过代理模式很轻松就能办到：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentsProxy</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//被代理的学生</span></span><br><span class="line">    Student stu;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentsProxy</span><span class="params">(Person stu)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只代理学生对象</span></span><br><span class="line">        <span class="keyword">if</span>(stu.getClass() == Student.class) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stu = (Student)stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//代理上交班费，调用被代理学生的上交班费行为</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"张三最近学习有进步！"</span>);</span><br><span class="line">        stu.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="3.jpg" alt="img"></p><p>可以看到，只需要在代理类中帮张三上交班费之前，执行其他操作就可以了。这种操作，也是使用代理模式的一个很大的优点。最直白的就是在Spring中的<strong>面向切面编程（AOP）</strong>，我们能在一个切点之前执行一些操作，在一个切点之后执行一些操作，这个切点就是一个个方法。这些方法所在类肯定就是被代理了，在代理过程中切入了一些其他操作。</p><h2 id="三、动态代理"><a href="#三、动态代理" class="headerlink" title="三、动态代理"></a><strong>三、动态代理</strong></h2><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p><strong>代理类在程序运行时创建的代理方式被成为动态代理</strong>。 我们上面静态代理的例子中，代理类(studentProxy)是自己定义好的，在程序运行之前就已经编译完成。然而动态代理，代理类并不是在Java代码中定义的，而是在<strong>运行时根据我们在Java代码中的“指示”动态生成的</strong>。相比于静态代理， <strong>动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法</strong>。 比如说，想要在每个代理的方法前都加上一个处理方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//调用被代理方法前加入处理方法</span></span><br><span class="line">       beforeMethod();</span><br><span class="line">       stu.giveMoney();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里只有一个giveMoney方法，就写一次beforeMethod方法，但是如果出了giveMonney还有很多其他的方法，那就需要写很多次beforeMethod方法，麻烦。那看看下面动态代理如何实现。</p><h3 id="动态代理简单实现"><a href="#动态代理简单实现" class="headerlink" title="动态代理简单实现"></a>动态代理简单实现</h3><p>在java的java.lang.reflect包下提供了一个<strong>Proxy类</strong>和一个<strong>InvocationHandler接口</strong>，通过这个类和这个接口可以生成JDK动态代理类和动态代理对象。</p><p>创建一个动态代理对象步骤，具体代码见后面：</p><ul><li>创建一个<strong>InvocationHandler</strong>对象</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个与代理对象相关联的InvocationHandler</span></span><br><span class="line"> InvocationHandler stuHandler = <span class="keyword">new</span> <span class="type">MyInvocationHandler</span>&lt;Person&gt;(stu);</span><br></pre></td></tr></table></figure><ul><li>使用<strong>Proxy</strong>类的<strong>getProxyClass</strong>静态方法生成一个动态代理类stuProxyClass </li></ul><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Class</span>&lt;?&gt; stuProxyClass = Proxy.getProxyClass(Person.<span class="keyword">class</span>.getClassLoader(), <span class="keyword">new</span> <span class="keyword">Class</span>&lt;?&gt;[] &#123;Person.<span class="keyword">class</span>&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><ul><li>获得stuProxyClass 中一个<strong>带InvocationHandler参数的构造器constructor</strong></li></ul><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">Constructor</span>&lt;?&gt; <span class="title">constructor</span> = <span class="title">PersonProxy</span>.<span class="title">getConstructor</span><span class="params">(InvocationHandler.<span class="keyword">class</span>)</span>;</span></span><br></pre></td></tr></table></figure><ul><li>通过构造器constructor来创建一个动态实例<strong>stuProxy</strong></li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Person stuProxy</span> = (Person) cons.newInstance(stuHandler);</span><br></pre></td></tr></table></figure><p>就此，一个动态代理对象就创建完毕，当然，上面四个步骤可以通过Proxy类的newProxyInstances方法来简化：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//创建一个与代理对象相关联的InvocationHandler</span></span><br><span class="line">  InvocationHandler stuHandler = <span class="keyword">new</span> <span class="type">MyInvocationHandler</span>&lt;Person&gt;(stu);</span><br><span class="line"><span class="comment">//创建一个代理对象stuProxy，代理对象的每个执行方法都会替换执行Invocation中的invoke方法</span></span><br><span class="line">  Person stuProxy= (Person) Proxy.<span class="keyword">new</span><span class="type">ProxyInstance</span>(Person.class.getClassLoader(), <span class="keyword">new</span> <span class="type">Class</span>&lt;?&gt;[]&#123;Person.class&#125;, stuHandler);</span><br></pre></td></tr></table></figure><p>到这里肯定都会很疑惑，这动态代理到底是如何执行的，是如何通过代理对象来执行被代理对象的方法的，先不急，我们先看看一个简单的完整的动态代理的例子。还是上面静态代理的例子，班长需要帮学生代交班费。首先是定义一个Person接口:</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建Person接口</span></span><br><span class="line"><span class="comment"> * @author Gonjan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Person</span> &#123;</span><br><span class="line">    <span class="comment">//上交班费</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">giveMoney</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建需要被代理的实际类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//假设数钱花了一秒时间</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">       System.out.println(name + <span class="string">"上交班费50元"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再定义一个检测方法执行时间的工具类，在任何方法执行前先调用start方法，执行后调用finsh方法，就可以计算出该方法的运行时间，这也是一个最简单的方法执行时间检测工具。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MonitorUtil</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        tl.<span class="keyword">set</span>(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//结束时打印耗时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">finish</span>(<span class="params">String methodName</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> finishTime = System.currentTimeMillis();</span><br><span class="line">        System.<span class="keyword">out</span>.println(methodName + <span class="string">"方法耗时"</span> + (finishTime - tl.<span class="keyword">get</span>()) + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建StuInvocationHandler类，实现InvocationHandler接口，这个类中持有一个被代理对象的实例target。InvocationHandler中有一个invoke方法，所有执行代理对象的方法都会被替换成执行invoke方法。</p><p>再再invoke方法中执行被代理对象target的相应方法。当然，在代理过程中，我们在真正执行被代理对象的方法前加入自己其他处理。这也是Spring中的AOP实现的主要原理，这里还涉及到一个很重要的关于java反射方面的基础知识。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StuInvocationHandler</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">   <span class="comment">//invocationHandler持有的被代理对象</span></span><br><span class="line">    T <span class="keyword">target</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StuInvocationHandler</span><span class="params">(T <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.<span class="keyword">target</span> = <span class="keyword">target</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * proxy:代表动态代理对象</span></span><br><span class="line"><span class="comment">     * method：代表正在执行的方法</span></span><br><span class="line"><span class="comment">     * args：代表调用目标方法时传入的实参</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"代理执行"</span> +method.getName() + <span class="string">"方法"</span>);</span><br><span class="line">     */   </span><br><span class="line">        <span class="comment">//代理过程中插入监测方法,计算该方法耗时</span></span><br><span class="line">        MonitorUtil.start();</span><br><span class="line">        Object result = method.invoke(<span class="keyword">target</span>, args);</span><br><span class="line">        MonitorUtil.finish(method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做完上面的工作后，我们就可以具体来创建动态代理对象了，上面简单介绍了如何创建动态代理对象，我们使用简化的方式创建动态代理对象：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个实例对象，这个对象是被代理的对象</span></span><br><span class="line">        Person zhangsan = <span class="keyword">new</span> <span class="type">Student</span>(<span class="string">"张三"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个与代理对象相关联的InvocationHandler</span></span><br><span class="line">        InvocationHandler stuHandler = <span class="keyword">new</span> <span class="type">StuInvocationHandler</span>&lt;Person&gt;(zhangsan);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个代理对象stuProxy来代理zhangsan，代理对象的每个执行方法都会替换执行Invocation中的invoke方法</span></span><br><span class="line">        Person stuProxy = (Person) Proxy.<span class="keyword">new</span><span class="type">ProxyInstance</span>(Person.class.getClassLoader(), <span class="keyword">new</span> <span class="type">Class</span>&lt;?&gt;[]&#123;Person.class&#125;, stuHandler)；</span><br><span class="line"></span><br><span class="line">       <span class="comment">//代理执行上交班费的方法</span></span><br><span class="line">        stuProxy.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们执行这个ProxyTest类，先想一下，我们创建了一个需要被代理的学生张三，将zhangsan对象传给了stuHandler中，我们在创建代理对象stuProxy时，将stuHandler作为参数了的，上面也有说到所有执行代理对象的方法都会被替换成执行invoke方法，也就是说，最后执行的是StuInvocationHandler中的invoke方法。所以在看到下面的运行结果也就理所当然了。</p><p>运行结果：</p><p><img src="4.jpg" alt="img"></p><p>上面说到，<strong>动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。</strong>是因为所有被代理执行的方法，都是<strong>通过在InvocationHandler中的invoke方法调用的</strong>，所以我们只要在invoke方法中统一处理，就可以对所有被代理的方法进行相同的操作了。例如，这里的方法计时，所有的被代理对象执行的方法都会被计时，然而我只做了很少的代码量。</p><p>动态代理的过程，代理对象和被代理对象的关系不像静态代理那样一目了然，清晰明了。因为动态代理的过程中，我们并没有实际看到代理类，也没有很清晰地的看到代理类的具体样子，而且动态代理中被代理对象和代理对象是通过<strong>InvocationHandler</strong>来完成的代理过程的，其中具体是怎样操作的，为什么<strong>代理对象执行的方法都会通过InvocationHandler中的invoke方法来执行</strong>。带着这些问题，我们就需要对java动态代理的源码进行简要的分析，弄清楚其中缘由。</p><h2 id="四、动态代理原理分析"><a href="#四、动态代理原理分析" class="headerlink" title="四、动态代理原理分析"></a><strong>四、动态代理原理分析</strong></h2><p>​    <strong>1、Java动态代理创建出来的动态代理类</strong></p><p>上面我们利用Proxy类的<strong>newProxyInstance</strong>方法创建了一个动态代理对象，查看该方法的源码，发现它只是封装了创建动态代理类的步骤(红色标准部分)：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object newProxyInstance(ClassLoader loader,</span><br><span class="line">                                      <span class="keyword">Class</span>&lt;?&gt;[] interfaces,</span><br><span class="line">                                      InvocationHandler h)</span><br><span class="line">    <span class="keyword">throws</span> IllegalArgumentException</span><br><span class="line">&#123;</span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">Class</span>&lt;?&gt;[] intfs = interfaces.clone(); <span class="comment">//红色部分</span></span><br><span class="line">    <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Look up or generate the designated proxy class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">Class</span>&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);<span class="comment">//红色部分</span></span><br><span class="line">        <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;<span class="keyword">Void</span>&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">Void</span> run() &#123;</span><br><span class="line">                    cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;); <span class="comment">//红色部分</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        Throwable t = e.getCause();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，我们最应该关注的是<code>Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</code>这句，这里产生了代理类，后面代码中的构造器也是通过这里产生的类来获得，可以看出，这个类的产生就是整个动态代理的关键，由于是动态生成的类文件，我这里不具体进入分析如何产生的这个类文件，只需要知道这个类文件时<strong>缓存在java虚拟机</strong>中的，我们可以通过下面的方法将其打印到文件里面，一睹真容：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] classFile = ProxyGenerator.generateProxyClass(<span class="string">"$Proxy0"</span>, Student.class.getInterfaces());</span><br><span class="line"><span class="keyword">String</span> path = <span class="string">"G:/javacode/javase/Test/bin/proxy/StuProxy.class"</span>;</span><br><span class="line"><span class="built_in">try</span>(FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(path)) &#123;</span><br><span class="line">    fos.<span class="built_in">write</span>(classFile);</span><br><span class="line">    fos.<span class="built_in">flush</span>();</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"代理类class文件写入成功"</span>);</span><br><span class="line">&#125; <span class="built_in">catch</span> (Exception e) &#123;</span><br><span class="line">   System.out.<span class="built_in">println</span>(<span class="string">"写文件错误"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对这个class文件进行反编译，我们看看jdk为我们生成了什么样的内容：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"><span class="keyword">import</span> proxy.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> $Proxy0 <span class="keyword">extends</span> Proxy <span class="keyword">implements</span> Person</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *注意这里是生成代理类的构造方法，方法参数为InvocationHandler类型，看到这，是不是就有点明白</span></span><br><span class="line"><span class="comment">  *为何代理对象调用方法都是执行InvocationHandler中的invoke方法，而InvocationHandler又持有一个</span></span><br><span class="line"><span class="comment">  *被代理对象的实例，不禁会想难道是....？ 没错，就是你想的那样。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *super(paramInvocationHandler)，是调用父类Proxy的构造方法。</span></span><br><span class="line"><span class="comment">  *父类持有：protected InvocationHandler h;</span></span><br><span class="line"><span class="comment">  *Proxy构造方法：</span></span><br><span class="line"><span class="comment">  *    protected Proxy(InvocationHandler h) &#123;</span></span><br><span class="line"><span class="comment">  *         Objects.requireNonNull(h);</span></span><br><span class="line"><span class="comment">  *         this.h = h;</span></span><br><span class="line"><span class="comment">  *     &#125;</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> $Proxy0(InvocationHandler paramInvocationHandler)</span><br><span class="line">    <span class="keyword">throws</span> </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">super</span>(paramInvocationHandler);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//这个静态块本来是在最后的，我把它拿到前面来，方便描述</span></span><br><span class="line">   <span class="keyword">static</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//看看这儿静态块儿里面有什么，是不是找到了giveMoney方法。请记住giveMoney通过反射得到的名字m3，其他的先不管</span></span><br><span class="line">      m1 = <span class="keyword">Class</span>.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, <span class="keyword">new</span> <span class="keyword">Class</span>[] &#123; <span class="keyword">Class</span>.forName(<span class="string">"java.lang.Object"</span>) &#125;);</span><br><span class="line">      m2 = <span class="keyword">Class</span>.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>, <span class="keyword">new</span> <span class="keyword">Class</span>[<span class="number">0</span>]);</span><br><span class="line">      m3 = <span class="keyword">Class</span>.forName(<span class="string">"proxy.Person"</span>).getMethod(<span class="string">"giveMoney"</span>, <span class="keyword">new</span> <span class="keyword">Class</span>[<span class="number">0</span>]);</span><br><span class="line">      m0 = <span class="keyword">Class</span>.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>, <span class="keyword">new</span> <span class="keyword">Class</span>[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NoSuchMethodException localNoSuchMethodException)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(localNoSuchMethodException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException localClassNotFoundException)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(localClassNotFoundException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  *这里调用代理对象的giveMoney方法，直接就调用了InvocationHandler中的invoke方法，并把m3传了进去。</span></span><br><span class="line"><span class="comment">  *this.h.invoke(this, m3, null);这里简单，明了。</span></span><br><span class="line"><span class="comment">  *来，再想想，代理对象持有一个InvocationHandler对象，InvocationHandler对象持有一个被代理的对象，</span></span><br><span class="line"><span class="comment">  *再联系到InvacationHandler中的invoke方法。嗯，就是这样。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> giveMoney()</span><br><span class="line">    <span class="keyword">throws</span> </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> localError;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//注意，这里为了节省篇幅，省去了toString，hashCode、equals方法的内容。原理和giveMoney方法一毛一样。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk为我们的生成了一个叫<strong>$Proxy0</strong>（这个名字后面的0是编号，有多个代理类会一次递增）的代理类，这个类文件是放在内存中的，我们在创建代理对象时，就是通过反射获得这个类的构造方法，然后创建的代理实例。通过对这个生成的代理类源码的查看，我们很容易能看出，动态代理实现的具体过程。</p><p>我们可以把<strong>InvocationHandler看做一个中介类，中介类持有一个被代理对象，在invoke方法中调用了被代理对象的相应方法。通过聚合方式持有被代理对象的引用，把外部对invoke的调用最终都转为对被代理对象的调用。</strong></p><p>代理类调用自己方法时，通过自身持有的中介类对象来调用中介类对象的invoke方法，从而达到代理执行被代理对象的方法。也就是说，动态代理通过中介类实现了具体的代理功能。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a><strong>五、总结</strong></h2><p>生成的代理类：$Proxy0 extends Proxy implements Person，我们看到代理类继承了Proxy类，所以也就决定了<strong>java动态代理只能对接口进行代理，Java的继承机制注定了这些动态代理类们无法实现对class的动态代理</strong>。上面的动态代理的例子，其实就是AOP的一个简单实现了，在目标对象的方法执行之前和执行之后进行了处理，对方法耗时统计。Spring的AOP实现其实也是用了Proxy和InvocationHandler这两个东西的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下文章来自：&lt;a href=&quot;https://www.cnblogs.com/gonjan-blog/p/6685611.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;java动态代理实现与原理详细分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于Java中的动态代理，我们首先需要了解的是一种常用的设计模式–&lt;strong&gt;代理模式&lt;/strong&gt;，而对于代理，根据&lt;strong&gt;创建代理类的时间点&lt;/strong&gt;，又可以分为静态代理和动态代理。&lt;/p&gt;
    
    </summary>
    
      <category term="动态代理" scheme="http://changsk.top/categories/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
    
      <category term="java" scheme="http://changsk.top/tags/java/"/>
    
      <category term="动态代理" scheme="http://changsk.top/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>mysql主从复制和读写分离</title>
    <link href="http://changsk.top/2019/06/18/mysql-master-slave-replication/"/>
    <id>http://changsk.top/2019/06/18/mysql-master-slave-replication/</id>
    <published>2019-06-18T03:11:11.000Z</published>
    <updated>2019-06-18T08:33:01.603Z</updated>
    
    <content type="html"><![CDATA[<p>以下文章参考自：：<a href="https://segmentfault.com/a/1190000008942618" target="_blank" rel="noopener">MySql 主从复制及配置实现</a></p><blockquote><p>Mysql 主从复制的原理和kafka的partition的replication机制很类似，原理互通，大概是因为这种做法确实可以保证分布式系统的可靠性。</p></blockquote><h3 id="一、什么是Mysql主从复制"><a href="#一、什么是Mysql主从复制" class="headerlink" title="一、什么是Mysql主从复制"></a>一、什么是Mysql主从复制</h3><p><strong>MySQL主从复制是其最重要的功能之一</strong>。主从复制是指一台服务器充当主数据库服务器，另一台或多台服务器充当从数据库服务器，<strong>主服务器中的数据自动复制到从服务器之中</strong>。对于多级复制，数据库服务器即可充当主机，也可充当从机。<strong>MySQL主从复制的基础是主服务器对数据库修改记录二进制日志(bin log)</strong>，从服务器通过主服务器的二进制日志自动执行更新。</p><a id="more"></a><h3 id="二、Mysq主从复制的类型"><a href="#二、Mysq主从复制的类型" class="headerlink" title="二、Mysq主从复制的类型"></a>二、Mysq主从复制的类型</h3><h4 id="基于语句的复制："><a href="#基于语句的复制：" class="headerlink" title="基于语句的复制："></a>基于语句的复制：</h4><p>主服务器上面执行的语句在从服务器上面再执行一遍，在MySQL-3.23版本以后支持。</p><p>存在的问题：时间上可能不完全同步造成偏差，执行语句的用户也可能不是同一个用户。</p><h4 id="基于行的复制："><a href="#基于行的复制：" class="headerlink" title="基于行的复制："></a>基于行的复制：</h4><p>把主服务器上面改变后的内容直接复制过去，而不关心到底改变该内容是由哪条语句引发的，在MySQL-5.0版本以后引入。</p><p>存在的问题：比如一个工资表中有一万个用户，我们把每个用户的工资+1000，那么基于行的复制则要复制一万行的内容，由此造成的开销比较大，而基于语句的复制仅仅一条语句就可以了。</p><h4 id="混合类型的复制："><a href="#混合类型的复制：" class="headerlink" title="混合类型的复制："></a>混合类型的复制：</h4><p><strong>MySQL默认使用基于语句的复制</strong>，当基于语句的复制会引发问题的时候就会使用基于行的复制，<strong>MySQL会自动进行选择。</strong></p><p>在MySQL主从复制架构中，<strong>读操作可以在所有的服务器上面进行</strong>，而<strong>写操作只能在主服务器上面进行</strong>。主从复制架构虽然给读操作提供了扩展，可如果写操作也比较多的话（多台从服务器还要从主服务器上面同步数据），单主模型的复制中<strong>主服务器势必会成为性能瓶颈。</strong></p><h3 id="三、主从复制的作用"><a href="#三、主从复制的作用" class="headerlink" title="三、主从复制的作用"></a>三、主从复制的作用</h3><p>1、主数据库出现问题，可以切换到从数据库。<br>2、可以进行数据库层面的读写分离。读写分离就是在主服务器上修改，数据会同步到从服务器，从服务器只能提供读取数据，不能写入，实现备份的同时也实现了数据库性能的优化，以及提升了服务器安全。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）基于程序代码内部实现</span><br><span class="line"></span><br><span class="line">在代码中根据select 、insert进行路由分类，这类方法也是目前生产环境下应用最广泛的。优点是性能较好，因为程序在代码中实现，不需要增加额外的硬件开支，缺点是需要开发人员来实现，运维人员无从下手。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）基于中间代理层实现</span><br><span class="line"></span><br><span class="line">代理一般介于应用服务器和数据库服务器之间，代理数据库服务器接收到应用服务器的请求后根据判断后转发到，后端数据库，有以下代表性的程序。</span><br><span class="line"></span><br><span class="line">（<span class="number">1</span>）MySQL_proxy。MySQL_proxy是MySQL的一个开源项目，通过其自带的lua脚本进行sql判断。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）Atlas。是由 Qihoo <span class="number">360</span>, Web平台部基础架构团队开发维护的一个基于MySQL协议的数据中间层项目。它是在MySQL-proxy <span class="number">0.8</span><span class="number">.2</span>版本的基础上，对其进行了优化，增加了一些新的功能特性。<span class="number">360</span>内部使用Atlas运行的MySQL业务，每天承载的读写请求数达几十亿条。支持事物以及存储过程。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）Amoeba。由阿里巴巴集团在职员工陈思儒使用java语言进行开发，阿里巴巴集团将其用户生产环境下，但是它并不支持事物以及存储过程。</span><br><span class="line"></span><br><span class="line">不是所有的应用都能够在基于程序代码中实现读写分离，像一些大型的java应用，如果在程序代码中实现读写分离对代码的改动就较大，所以，像这种应用一般会考虑使用代理层来实现。</span><br></pre></td></tr></table></figure><p>3、可以在从数据库上进行日常备份</p><h3 id="四、Mysql主从复制的工作原理"><a href="#四、Mysql主从复制的工作原理" class="headerlink" title="四、Mysql主从复制的工作原理"></a>四、Mysql主从复制的工作原理</h3><p>如下图所示：</p><p>[<img src="1.jpg" alt="MySQL主从复制原理及配置实现"></p><p><strong>主服务器上面的任何修改都会保存在二进制日志Binary log里面</strong>，从服务器上面启动一个<strong>I/O thread</strong>（实际上就是一个主服务器的客户端进程），连接到主服务器上面请求<strong>读取二进制日志</strong>，然后把读取到的二进制日志写到本地的一个<strong>Realy log</strong>（中继日志）里面。从服务器上面开启一个<strong>SQL thread</strong>定时检查Realy log，如果发现有更改立即把更改的内容在本机上面<strong>执行一遍</strong>。</p><p>如果<strong>一主多从</strong>的话，这时主库<strong>既要负责写又要负责为几个从库提供二进制日志</strong>。此时可以稍做调整，将二进制日志只给某一从，这一从再开启二进制日志并将自己的二进制日志再发给其它从。或者是干脆这个从不记录只负责将二进制日志转发给其它从，这样架构起来性能可能要好得多，而且数据之间的延时应该也稍微要好一些。工作原理图如下：</p><p>[<img src="2.jpg" alt="MySQL主从复制原理及配置实现"></p><p>实际上在老版本的MySQL主从复制中Slave端并不是两个进程完成的，而是由一个进程完成。但是后来发现这样做存在较大的风险和性能问题，主要如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先，一个进程会使复制bin-log日志和解析日志并在自身执行的过程成为一个串行的过程，性能受到了一定的限制，异步复制的延迟也会比较长。</span><br><span class="line"></span><br><span class="line">另外，<span class="literal">Slave</span>端从<span class="literal">Master</span>端获取bin-log过来之后，需要接着解析日志内容，然后在自身执行。在这个过程中，<span class="literal">Master</span>端可能又产生了大量变化并新增了大量的日志。如果在这个阶段<span class="literal">Master</span>端的存储出现了无法修复的错误，那么在这个阶段所产生的所有变更都将永远无法找回。如果在<span class="literal">Slave</span>端的压力比较大的时候，这个过程的时间可能会比较长。</span><br></pre></td></tr></table></figure><p>为了提高复制的性能并解决存在的风险，后面版本的MySQL将<strong>Slave端的复制动作交由两个进程来完成</strong>。提出这个改进方案的人是Yahoo!的一位工程师“Jeremy Zawodny”。这样既<strong>解决了性能问题</strong>，又<strong>缩短了异步的延时时间</strong>，同时也减少了可能存在的数据丢失量。</p><p>当然，即使是换成了现在这样两个线程处理以后，同样也还是存在slave数据延时以及数据丢失的可能性的，毕竟这个复制是异步的。只要数据的更改不是在一个事务中，这些问题都是会存在的。如果要完全避免这些问题，就只能用MySQL的cluster来解决了。不过MySQL的cluster是内存数据库的解决方案，需要将所有数据都load到内存中，这样就对内存的要求就非常大了，对于一般的应用来说可实施性不是太大。</p><p>还有一点要提的是MySQL的复制过滤(Replication Filters)，复制过滤可以让你只复制服务器中的一部分数据。有两种复制过滤：在Master上过滤二进制日志中的事件；在Slave上过滤中继日志中的事件。如下：</p><p>[<img src="3.jpg" alt="MySQL主从复制原理及配置实现"></p><p>配置Master的my.cnf文件(关键性的配置)/etc/my.cnf</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">log-bin</span>=mysql-bin</span><br><span class="line"></span><br><span class="line"><span class="attr">server-id</span>   = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">binlog-do-db</span>=icinga</span><br><span class="line"></span><br><span class="line"><span class="attr">binlog-do-db</span>=DB2     //如果备份多个数据库，重复设置这个选项即可</span><br><span class="line"></span><br><span class="line"><span class="attr">binlog-do-db</span>=DB3   //需要同步的数据库，如果没有本行，即表示同步所有的数据库</span><br><span class="line"></span><br><span class="line"><span class="attr">binlog-ignore-db</span>=mysql  //被忽略的数据库</span><br></pre></td></tr></table></figure><p>配置Slave的my.cnf文件(关键性的配置)/etc/my.cnf</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">log-bin</span>=mysql-bin</span><br><span class="line"></span><br><span class="line"><span class="attr">server-id</span>=<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="attr">master-host</span>=<span class="number">10.1</span>.<span class="number">68.110</span></span><br><span class="line"></span><br><span class="line"><span class="attr">master-user</span>=backup</span><br><span class="line"></span><br><span class="line"><span class="attr">master-password</span>=<span class="number">1234</span>qwer</span><br><span class="line"></span><br><span class="line"><span class="attr">master-port</span>=<span class="number">3306</span></span><br><span class="line"></span><br><span class="line"><span class="attr">replicate-do-db</span>=icinga</span><br><span class="line"></span><br><span class="line"><span class="attr">replicate-do-db</span>=DB2</span><br><span class="line"></span><br><span class="line"><span class="attr">replicate-do-db</span>=DB3   //需要同步的数据库，如果没有本行，即表示同步所有的数据库</span><br><span class="line"></span><br><span class="line"><span class="attr">replicate-ignore-db</span>=mysql   //被忽略的数据库</span><br></pre></td></tr></table></figure><p>网友说replicate-do-db的使用中可能会出些问题（<a href="http://blog.knowsky.com/196961.htm" target="_blank" rel="noopener">http://blog.knowsky.com/19696…</a>），自己没有亲自去测试。猜想binlog-do-db参数用于主服务器中，通过过滤Binary Log来过滤掉配置文件中不允许复制的数据库，也就是不向Binary Log中写入不允许复制数据的操作日志；而replicate-do-db用于从服务器中，通过过滤Relay Log来过滤掉不允许复制的数据库或表，也就是执行Relay Log中的动作时不执行那些不被允许的修改动作。这样的话，多个从数据库服务器的情况：有的从服务器既从主服务器中复制数据，又做为主服务器向另外的从服务器复制数据，那它的配置文件中应该可以同时存在binlog-do-db、replicate-do-db这两个参数才对。一切都是自己的预测，关于binlog-do-db、replicate-do-db的具体使用方法还得在实际开发中一点点摸索才可以。</p><p>网上有说，复制时忽略某些数据库或者表的操作最好不要在主服务器上面进行，因为主服务器忽略之后就不会再往二进制文件中写了，但是在从服务器上面虽然忽略了某些数据库但是主服务器上面的这些操作信息依然会被复制到从服务器上面的relay log里面，只是不会在从服务器上面执行而已。我想这个意思应该是建议在从服务器中设置replicate-do-db，而不要在主服务器上设置binlog-do-db。</p><p>另外，不管是黑名单（binlog-ignore-db、replicate-ignore-db）还是白名单（binlog-do-db、replicate-do-db）只写一个就行了，如果同时使用那么只有白名单生效。</p><h3 id="五、Mysql主从复制的过程"><a href="#五、Mysql主从复制的过程" class="headerlink" title="五、Mysql主从复制的过程"></a>五、Mysql主从复制的过程</h3><p><strong>MySQL主从复制的两种情况：同步复制和异步复制，实际复制架构中大部分为异步复制。</strong></p><p>复制的基本过程如下：</p><ol><li>Slave上面的IO进程连接上Master，并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容。</li><li>Master接收到来自Slave的IO进程的请求后，负责复制的IO进程会根据请求信息读取日志指定位置之后的日志信息，返回给Slave的IO进程。返回信息中除了日志所包含的信息之外，还<strong>包括本次返回的信息已经到Master端的bin-log文件的名称以及bin-log的位置。</strong></li><li>Slave的IO进程接收到信息后，将接收到的日志内容依次添加到Slave端的<strong>relay-log</strong>文件的最末端，并将读取到的Master端的 bin-log的文件名和位置记录到<strong>master-info</strong>文件中，<strong>以便在下一次读取的时候能够清楚的告诉Master“我需要从某个bin-log的哪个位置开始往后的日志内容，请发给我”。</strong></li><li><strong>Slave的Sql进程检测到relay-log中新增加了内容后</strong>，会马上解析relay-log的内容成为在Master端真实执行时候的那些可执行的内容，并在自身执行。</li></ol><h3 id="六、Mysql主从复制的具体配置"><a href="#六、Mysql主从复制的具体配置" class="headerlink" title="六、Mysql主从复制的具体配置"></a>六、Mysql主从复制的具体配置</h3><p>复制通常用来创建主节点的副本，通过添加冗余节点来保证高可用性，当然复制也可以用于其他用途，例如在从节点上进行数据读、分析等等。在横向扩展的业务中，复制很容易实施，主要表现在在利用主节点进行写操作，多个从节点进行读操作，<strong>MySQL复制的异步性是指：事物首先在主节点上提交，然后复制给从节点并在从节点上应用，这样意味着在同一个时间点主从上的数据可能不一致。异步复制的好处在于它比同步复制要快，如果对数据的一致性要求很高，还是采用同步复制较好。</strong></p><p>最简单的复制模式就是一主一从的复制模式了，这样一个简单的架构只需要三个步骤即可完成：</p><p>（1）建立一个主节点，开启binlog，设置服务器id；</p><p>（2）建立一个从节点，设置服务器id；</p><p>（3）将从节点连接到主节点上。</p><p>下面我们开始操作，以MySQL 5.5为例，操作系统Ubuntu12.10，Master 10.1.6.159 Slave 10.1.6.191。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="builtin-name">get</span> install mysql-server</span><br></pre></td></tr></table></figure><h5 id="Master机器"><a href="#Master机器" class="headerlink" title="Master机器"></a>Master机器</h5><p>Master上面开启binlog日志，并且设置一个唯一的服务器id，在局域网内这个id必须唯一。二进制的binlog日志记录master上的所有数据库改变，这个日志会被复制到从节点上，并且在从节点上回放。修改my.cnf文件，在mysqld模块下修改如下内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">server-id</span>   = <span class="number">1</span></span><br><span class="line"><span class="attr">log_bin</span>     = /var/log/mysql/mysql-bin.log</span><br></pre></td></tr></table></figure><p>log_bin设置二进制日志所产生文件的基本名称，二进制日志由一系列文件组成，log_bin的值是可选项，如果没有为log_bin设置值，则默认值是：主机名-bin。如果随便修改主机名，则binlog日志的名称也会被改变的。server-id是用来唯一标识一个服务器的，每个服务器的server-id都不一样。这样slave连接到master后，会请求master将所有的binlog传递给它，然后将这些binlog在slave上回放。为了防止权限混乱，一般都是建立一个单独用于复制的账户。</p><p>binlog是复制过程的关键，它记录了数据库的所有改变，通常即将执行完毕的语句会在binlog日志的末尾写入一条记录，binlog只记录改变数据库的语句，对于不改变数据库的语句则不进行记录。这种情况叫做基于语句的复制，前面提到过还有一种情况是基于行的复制，两种模式各有各的优缺点。</p><h5 id="Slave机器"><a href="#Slave机器" class="headerlink" title="Slave机器"></a>Slave机器</h5><p>slave机器和master一样，需要一个唯一的server-id。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">server-id</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>连接Slave到Master</p><p>在Master和Slave都配置好后，只需要把slave只想master即可</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">change</span> <span class="keyword">master</span> <span class="keyword">to</span> master_host=<span class="string">'10.1.6.159'</span>,master_port=<span class="number">3306</span>,master_user=<span class="string">'rep'</span>,</span><br><span class="line">master_password=<span class="string">'123456'</span>;</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>;</span><br></pre></td></tr></table></figure><p>接下来在master上做一些针对改变数据库的操作，来观察slave的变化情况。在修改完my.cnf配置重启数据库后，就开始记录binlog了。可以在/var/log/mysql目录下看到一个mysql-bin.000001文件，而且还有一个mysql-bin.index文件，这个mysql-bin.index文件是什么？这个文件保存了所有的binlog文件列表，但是我们在配置文件中并没有设置改值，这个可以通过log_bin_index进行设置，如果没有设置改值，则默认值和log_bin一样。在master上执行show binlog events命令，可以看到第一个binlog文件的内容。</p><p>注意：上面的sql语句是从头开始复制第一个binlog，如果想从某个位置开始复制binlog，就需要在change master to时指定要开始的binlog文件名和语句在文件中的起点位置，参数如下：master_log_file和master_log_pos。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show binlog events\G</span><br><span class="line"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">** 1. row **</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span></span><br><span class="line">   Log_name: mysql-bin.000001</span><br><span class="line"><span class="code">        Pos: 4</span></span><br><span class="line"> Event<span class="emphasis">_type: Format_</span>desc</span><br><span class="line">  Server_id: 1</span><br><span class="line">End<span class="emphasis">_log_</span>pos: 107</span><br><span class="line"><span class="code">       Info: Server ver: 5.5.28-0ubuntu0.12.10.2-log, Binlog ver: 4</span></span><br><span class="line"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">** 2. row **</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span></span><br><span class="line">   Log_name: mysql-bin.000001</span><br><span class="line"><span class="code">        Pos: 107</span></span><br><span class="line"> Event_type: Query</span><br><span class="line">  Server_id: 1</span><br><span class="line">End<span class="emphasis">_log_</span>pos: 181</span><br><span class="line"><span class="code">       Info: create user rep</span></span><br><span class="line"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">** 3. row **</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span></span><br><span class="line">   Log_name: mysql-bin.000001</span><br><span class="line"><span class="code">        Pos: 181</span></span><br><span class="line"> Event_type: Query</span><br><span class="line">  Server_id: 1</span><br><span class="line">End<span class="emphasis">_log_</span>pos: 316</span><br><span class="line"><span class="code">       Info: grant replication slave on *.* to rep identified by '123456'</span></span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><ul><li>Log_name 是二进制日志文件的名称，一个事件不能横跨两个文件</li><li>Pos 这是该事件在文件中的开始位置</li><li>Event_type 事件的类型，事件类型是给slave传递信息的基本方法，每个新的binlog都已Format_desc类型开始，以Rotate类型结束</li><li>Server_id 创建该事件的服务器id</li><li>End_log_pos 该事件的结束位置，也是下一个事件的开始位置，因此事件范围为Pos~End_log_pos-1</li><li>Info 事件信息的可读文本，不同的事件有不同的信息</li></ul><p><strong>示例</strong></p><p>在master的test库中创建一个rep表，并插入一条记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> rep(<span class="keyword">name</span> <span class="keyword">var</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rep <span class="keyword">values</span> (<span class="string">"guol"</span>);</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">logs</span>;</span><br></pre></td></tr></table></figure><p>flush logs命令强制轮转日志，生成一个新的二进制日志，可以通过show binlog events in ‘xxx’来查看该二进制日志。可以通过show master status查看当前正在写入的binlog文件。这样就会在slave上执行相应的改变操作。</p><p>上面就是最简单的主从复制模式，不过有时候随着时间的推进，binlog会变得非常庞大，如果新增加一台slave，从头开始复制master的binlog文件是非常耗时的，所以我们可以从一个指定的位置开始复制binlog日志，可以通过其他方法把以前的binlog文件进行快速复制，例如copy物理文件。在change master to中有两个参数可以实现该功能，master_log_file和master_log_pos，通过这两个参数指定binlog文件及其位置。我们可以从master上复制也可以从slave上复制，假如我们是从master上复制，具体操作过程如下：</p><p>（1）为了防止在操作过程中数据更新，导致数据不一致，所以需要先刷新数据并锁定数据库：flush tables with read lock。</p><p>（2）检查当前的binlog文件及其位置：show master status。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show master status\G</span><br><span class="line"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">** 1. row **</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span></span><br><span class="line">File: mysql-bin.000003</span><br><span class="line">Position: 107</span><br><span class="line">Binlog<span class="emphasis">_Do_</span>DB:</span><br><span class="line">Binlog<span class="emphasis">_Ignore_</span>DB:</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>（3）通过mysqldump命令创建数据库的逻辑备分：mysqldump –all-databases -hlocalhost -p &gt;back.sql。</p><p>（4）有了master的逻辑备份后，对数据库进行解锁：unlock tables。</p><p>（5）把back.sql复制到新的slave上，执行：mysql -hlocalhost -p 把master的逻辑备份插入slave的数据库中。</p><p>（6）现在可以把新的slave连接到master上了，只需要在change master to中多设置两个参数master_log_file=’mysql-bin.000003’和master_log_pos=’107’即可，然后启动slave：start slave，这样slave就可以接着107的位置进行复制了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">change</span> <span class="keyword">master</span> <span class="keyword">to</span> master_host=<span class="string">'10.1.6.159'</span>,master_port=<span class="number">3306</span>,master_user=<span class="string">'rep'</span>,</span><br><span class="line">master_password=<span class="string">'123456'</span>,master_log_file=<span class="string">'mysql-bin.000003'</span>,master_log_pos=<span class="string">'107'</span>;</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>;</span><br></pre></td></tr></table></figure><p>有时候master并不能让你锁住表进行复制，因为可能跑一些不间断的服务，如果这时master已经有了一个slave，我们则可以通过这个slave进行再次扩展一个新的slave。原理同在master上进行复制差不多，关键在于找到binlog的位置，你在复制的同时可能该slave也在和master进行同步，操作如下：</p><p>（1）为了防止数据变动，还是需要停止slave的同步：stop slave。</p><p>（2）然后刷新表，并用mysqldump逻辑备份数据库。</p><p>（3）使用show slave status查看slave的相关信息，记录下两个字段的值Relay_Master_Log_File和Exec_Master_Log_Pos，这个用来确定从后面哪里开始复制。</p><p>（4）对slave解锁，把备份的逻辑数据库导入新的slave的数据库中，然后设置change master to，这一步和复制master一样。</p><h3 id="七、深入了解Mysql主从配置"><a href="#七、深入了解Mysql主从配置" class="headerlink" title="七、深入了解Mysql主从配置"></a>七、深入了解Mysql主从配置</h3><h4 id="一主多从"><a href="#一主多从" class="headerlink" title="一主多从"></a>一主多从</h4><p>由一个master和一个slave组成复制系统是最简单的情况。<strong>Slave之间并不相互通信，只能与master进行通信</strong>。在实际应用场景中，MySQL复制90%以上都是一个Master复制到一个或者多个Slave的架构模式，主要用于读压力比较大的应用的数据库端廉价扩展解决方案。</p><p>[<img src="4.jpg" alt="MySQL主从复制原理及配置实现"></p><p>在上图中，是我们开始时提到的一主多从的情况，这时<strong>主库既要负责写又要负责为几个从库提供二进制日志</strong>。这种情况将二进制日志只给某一从，这一从再开启二进制日志并将自己的二进制日志再发给其它从，或者是干脆这个从不记录只负责将二进制日志转发给其它从，这样架构起来性能可能要好得多，而且数据之间的延时应该也稍微要好一些。</p><h4 id="主主复制"><a href="#主主复制" class="headerlink" title="主主复制"></a>主主复制</h4><p>[<img src="5.jpg" alt="MySQL主从复制原理及配置实现"></p><p>上图中，Master-Master复制的两台服务器，<strong>既是master，又是另一台服务器的slave</strong>。这样，<strong>任何一方所做的变更，都会通过复制应用到另外一方的数据库中</strong>。在这种复制架构中，各自上运行的不是同一db，比如左边的是db1,右边的是db2，db1的从在右边反之db2的从在左边，两者<strong>互为主从</strong>，再辅助一些监控的服务还可以实现一定程度上的高可以用。</p><h4 id="主动—被动模式的Master-Master-Master-Master-in-Active-Passive-Mode"><a href="#主动—被动模式的Master-Master-Master-Master-in-Active-Passive-Mode" class="headerlink" title="主动—被动模式的Master-Master(Master-Master in Active-Passive Mode)"></a>主动—被动模式的Master-Master(Master-Master in Active-Passive Mode)</h4><p>[<img src="6.jpg" alt="MySQL主从复制原理及配置实现"></p><p>上图中，这是由master-master结构变化而来的，它避免了M-M的缺点，实际上，这是一种具有容错和高可用性的系统。它的不同点在于<strong>其中只有一个节点在提供读写服务，另外一个节点时刻准备着</strong>，当主节点一旦故障马上接替服务。比如通过corosync+pacemaker+drbd+MySQL就可以提供这样一组高可用服务，主备模式下再跟着slave服务器，也可以实现<strong>读写分离</strong>。</p><h4 id="带从服务器的Master-Master结构-Master-Master-with-Slaves"><a href="#带从服务器的Master-Master结构-Master-Master-with-Slaves" class="headerlink" title="带从服务器的Master-Master结构(Master-Master with Slaves)"></a>带从服务器的Master-Master结构(Master-Master with Slaves)</h4><p>[<img src="7.jpg" alt="MySQL主从复制原理及配置实现"></p><p>这种结构的优点就是提供了冗余。在地理上分布的复制结构，它不存在单一节点故障问题，而且还可以将读密集型的请求放到slave上。</p><ol><li><h4 id="MySQL-5-5支持半同步复制"><a href="#MySQL-5-5支持半同步复制" class="headerlink" title="MySQL-5.5支持半同步复制"></a>MySQL-5.5支持半同步复制</h4></li></ol><p>早前的MySQL复制只能是基于异步来实现，从MySQL-5.5开始，支持<strong>半自动复制</strong>。在以前的异步（<strong>asynchronous</strong>）复制中，主库在执行完一些事务后，是不会管备库的进度的。如果备库处于落后，而更不幸的是主库此时又出现Crash（例如宕机），这时备库中的数据就是不完整的。简而言之，在主库发生故障的时候，我们无法使用备库来继续提供数据一致的服务了。<strong>Semisynchronous Replication(半同步复制)则一定程度上保证提交的事务已经传给了至少一个备库。Semi synchronous中，仅仅保证事务的已经传递到备库上，但是并不确保已经在备库上执行完成了。</strong></p><p>此外，还有一种情况会导致主备数据不一致。在某个session中，<strong>主库上提交一个事务后，会等待事务传递给至少一个备库</strong>，如果在这个等待过程中主库Crash，那么也可能备库和主库不一致，这是很致命的。<strong>如果主备网络故障或者备库挂了，主库在事务提交后等待10秒（rpl_semi_sync_master_timeout的默认值）后，就会继续。这时，主库就会变回原来的异步状态。</strong></p><p>MySQL在加载并开启Semi-sync插件后，<strong>每一个事务需等待备库接收日志后才返回给客户端</strong>。如果做的是小事务，两台主机的延迟又较小，则Semi-sync可以实现在性能很小损失的情况下的零数据丢失。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下文章参考自：：&lt;a href=&quot;https://segmentfault.com/a/1190000008942618&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MySql 主从复制及配置实现&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Mysql 主从复制的原理和kafka的partition的replication机制很类似，原理互通，大概是因为这种做法确实可以保证分布式系统的可靠性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、什么是Mysql主从复制&quot;&gt;&lt;a href=&quot;#一、什么是Mysql主从复制&quot; class=&quot;headerlink&quot; title=&quot;一、什么是Mysql主从复制&quot;&gt;&lt;/a&gt;一、什么是Mysql主从复制&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;MySQL主从复制是其最重要的功能之一&lt;/strong&gt;。主从复制是指一台服务器充当主数据库服务器，另一台或多台服务器充当从数据库服务器，&lt;strong&gt;主服务器中的数据自动复制到从服务器之中&lt;/strong&gt;。对于多级复制，数据库服务器即可充当主机，也可充当从机。&lt;strong&gt;MySQL主从复制的基础是主服务器对数据库修改记录二进制日志(bin log)&lt;/strong&gt;，从服务器通过主服务器的二进制日志自动执行更新。&lt;/p&gt;
    
    </summary>
    
      <category term="Mysql" scheme="http://changsk.top/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="http://changsk.top/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>java中clone常见的三种方式</title>
    <link href="http://changsk.top/2019/06/18/java-clone-threeMethod/"/>
    <id>http://changsk.top/2019/06/18/java-clone-threeMethod/</id>
    <published>2019-06-18T02:36:17.000Z</published>
    <updated>2019-06-18T02:56:16.460Z</updated>
    
    <content type="html"><![CDATA[<p>在 JAVA 中克隆一个对象常见的有三种形式 :</p><ol><li><p>通过自己写一个克隆方法，里面 new 一个同样的对象来进行 get、set 依次赋值实现<strong>深度克隆</strong>（很繁琐且易出错）； </p></li><li><p>通过实现 <strong>Cloneable</strong> 接口并重写 Object 类的 <strong>clone</strong>() 方法（分为深浅两种方式）； </p></li><li><p>通过实现 <strong>Serializable</strong> 接口并用对象的序列化和反序列化来实现真正的深度克隆；</p><a id="more"></a></li></ol><p>下面介绍第二、第三种方法。</p><h2 id="Cloneable-接口实现克隆"><a href="#Cloneable-接口实现克隆" class="headerlink" title="Cloneable 接口实现克隆"></a>Cloneable 接口实现克隆</h2><h3 id="Cloneable-接口实现浅克隆"><a href="#Cloneable-接口实现浅克隆" class="headerlink" title="Cloneable 接口实现浅克隆"></a>Cloneable 接口实现浅克隆</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"ilt"</span>;</span><br><span class="line">    <span class="keyword">private</span> Hand hand = <span class="keyword">new</span> Hand();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hand <span class="title">getHand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        People p1 = <span class="keyword">new</span> People();</span><br><span class="line">        People p2 = (People) p1.clone();</span><br><span class="line">        System.out.println(<span class="string">"第一个对象的hash值:"</span>+p1.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"第二个对象的hash值:"</span>+p2.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"分割线-----------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"p1中的hand对象的hash值:"</span>+p1.getHand().hashCode());</span><br><span class="line">        System.out.println(<span class="string">"p2中的hand对象的hash值:"</span>+p2.getHand().hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hand</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码输出的结果如下，根据hash值相等能确定两个对象是否相等的原则，发现p1和p2不等，但p1中的hand对象与p2中的hand对象是相等的。<strong>Cloneable 接口实现克隆是先在内存中开辟一块和原始对象一样的空间，然后原样拷贝原始对象中的内容，对基本数据类型就是值复制，而对非基本类型变量保存的仅仅是对象的引用，所以会导致 clone 后的非基本类型变量和原始对象中相应的变量指向的是同一个对象。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一个对象的<span class="built_in">hash</span>值:1408448235</span><br><span class="line">第二个对象的<span class="built_in">hash</span>值:77244764</span><br><span class="line">分割线-----------</span><br><span class="line">p1中的hand对象的<span class="built_in">hash</span>值:1172625760</span><br><span class="line">p2中的hand对象的<span class="built_in">hash</span>值:1172625760</span><br></pre></td></tr></table></figure><h3 id="Cloneable-接口实现深克隆"><a href="#Cloneable-接口实现深克隆" class="headerlink" title="Cloneable 接口实现深克隆"></a>Cloneable 接口实现深克隆</h3><p>在浅度克隆的基础上对于要克隆对象中的非基本数据类型的属性对应的类也实现克隆，这样对于非基本数据类型的属性复制的不是一份引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"ilt"</span>;</span><br><span class="line">    <span class="keyword">private</span> Hand hand = <span class="keyword">new</span> Hand();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hand <span class="title">getHand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHand</span><span class="params">(Hand hand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hand = hand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        People p2 = (People) <span class="keyword">super</span>.clone();</span><br><span class="line">        p2.setHand((Hand) hand.clone());</span><br><span class="line">        <span class="keyword">return</span> p2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        People p1 = <span class="keyword">new</span> People();</span><br><span class="line">        People p2 = (People) p1.clone();</span><br><span class="line">        System.out.println(<span class="string">"第一个对象的hash值:"</span> + p1.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"第二个对象的hash值:"</span> + p2.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"分割线-----------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"p1中的hand对象的hash值:"</span> + p1.getHand().hashCode());</span><br><span class="line">        System.out.println(<span class="string">"p2中的hand对象的hash值:"</span> + p2.getHand().hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hand</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下，证明已经进行深克隆</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一个对象的<span class="built_in">hash</span>值:1172625760</span><br><span class="line">第二个对象的<span class="built_in">hash</span>值:863719801</span><br><span class="line">分割线-----------</span><br><span class="line">p1中的hand对象的<span class="built_in">hash</span>值:1696725334</span><br><span class="line">p2中的hand对象的<span class="built_in">hash</span>值:427340025</span><br></pre></td></tr></table></figure><h2 id="序列化与反序列化实现深克隆"><a href="#序列化与反序列化实现深克隆" class="headerlink" title="序列化与反序列化实现深克隆"></a>序列化与反序列化实现深克隆</h2><p><strong>对象序列化操作可以将对象的状态转换成字节流传输或者存储再生，我们可以借用这一特点实现对象的深度克隆，特别是当我们的对象嵌套非常复杂且想实现深度克隆时如果使用序列化方式会大大减少代码量</strong>。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> TestClone <span class="keyword">implements</span> Serializable&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1</span>L;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">"ilt"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        TestClone t1 = <span class="keyword">new</span> TestClone();</span><br><span class="line">        <span class="keyword">byte</span>[] b = ObjectUtil.objectToBytes(t1);<span class="comment">//序列化</span></span><br><span class="line">        TestClone t2 = (TestClone) ObjectUtil.bytesToObject(b);<span class="comment">//反序列化</span></span><br><span class="line">        System.out.<span class="keyword">println</span>(<span class="string">"t1对象的name："</span>+t1.name);</span><br><span class="line">        System.out.<span class="keyword">println</span>(<span class="string">"t2对象的name："</span>+t2.name);</span><br><span class="line">        System.out.<span class="keyword">println</span>(<span class="string">"分割线-------------"</span>);</span><br><span class="line">        System.out.<span class="keyword">println</span>(<span class="string">"t1对象的hash值为："</span>+t1.hashCode());</span><br><span class="line">        System.out.<span class="keyword">println</span>(<span class="string">"t2对象的hash值为："</span>+t2.hashCode());</span><br><span class="line">        System.out.<span class="keyword">println</span>(<span class="string">"分割线-------------"</span>);</span><br><span class="line">        System.out.<span class="keyword">println</span>(<span class="string">"t1中的obj对象的hash值为："</span>+t1.obj.hashCode());</span><br><span class="line">        System.out.<span class="keyword">println</span>(<span class="string">"t2中的obj对象的hash值为："</span>+t2.obj.hashCode());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> Bean <span class="keyword">implements</span> Serializable&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1</span>L;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下，证明对象的属性被深克隆下来了</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">t1</span>对象的name：ilt</span><br><span class="line"><span class="built_in">t2</span>对象的name：ilt</span><br><span class="line">分割线-------------</span><br><span class="line"><span class="built_in">t1</span>对象的hash值为：<span class="number">1847546936</span></span><br><span class="line"><span class="built_in">t2</span>对象的hash值为：<span class="number">812610706</span></span><br><span class="line">分割线-------------</span><br><span class="line"><span class="built_in">t1</span>中的obj对象的hash值为：<span class="number">1164730192</span></span><br><span class="line"><span class="built_in">t2</span>中的obj对象的hash值为：<span class="number">1699624469</span></span><br></pre></td></tr></table></figure><blockquote><p>作者：youngerTree<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/syilt/article/details/78482927" target="_blank" rel="noopener">https://blog.csdn.net/syilt/article/details/78482927</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 JAVA 中克隆一个对象常见的有三种形式 :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;通过自己写一个克隆方法，里面 new 一个同样的对象来进行 get、set 依次赋值实现&lt;strong&gt;深度克隆&lt;/strong&gt;（很繁琐且易出错）； &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过实现 &lt;strong&gt;Cloneable&lt;/strong&gt; 接口并重写 Object 类的 &lt;strong&gt;clone&lt;/strong&gt;() 方法（分为深浅两种方式）； &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过实现 &lt;strong&gt;Serializable&lt;/strong&gt; 接口并用对象的序列化和反序列化来实现真正的深度克隆；&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://changsk.top/categories/Java/"/>
    
    
      <category term="java" scheme="http://changsk.top/tags/java/"/>
    
      <category term="clone" scheme="http://changsk.top/tags/clone/"/>
    
  </entry>
  
  <entry>
    <title>java中volatile关键字的作用</title>
    <link href="http://changsk.top/2019/06/18/java-volatile/"/>
    <id>http://changsk.top/2019/06/18/java-volatile/</id>
    <published>2019-06-18T01:38:32.000Z</published>
    <updated>2019-06-18T02:24:03.430Z</updated>
    
    <content type="html"><![CDATA[<p>以下文章来源于：<a href="https://www.cnblogs.com/baizhanshi/p/6422926.html" target="_blank" rel="noopener">Java并发：volatile内存可见性和指令重排</a></p><h2 id="volatile两大作用"><a href="#volatile两大作用" class="headerlink" title="volatile两大作用"></a>volatile两大作用</h2><p><strong>1、保证内存可见性</strong></p><p><strong>2、防止指令重排</strong></p><p>此外需注意volatile<strong>并不保证操作的原子性。</strong></p><a id="more"></a><h2 id="（一）内存可见性"><a href="#（一）内存可见性" class="headerlink" title="（一）内存可见性"></a>（一）内存可见性</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h3><p><strong>JVM内存模型：主内存和线程独立的工作内存</strong></p><p>Java内存模型规定，对于多个线程共享的变量，存储在主内存当中，每个线程都有自己独立的工作内存（比如CPU的寄存器），线程只能访问自己的工作内存，不可以访问其它线程的工作内存。</p><p>工作内存中保存了主内存共享变量的<strong>副本</strong>，线程要操作这些共享变量，只能通过操作工作内存中的副本来实现，操作完毕之后再同步回到主内存当中。</p><p>如何保证多个线程操作主内存的数据完整性是一个难题，Java内存模型也规定了工作内存与主内存之间交互的协议，定义了8种原子操作：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) <span class="string">lock:</span>将主内存中的变量锁定，为一个线程所独占</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>) <span class="string">unclock:</span>将lock加的锁定解除，此时其它的线程可以有机会访问此变量</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>) <span class="string">read:</span>将主内存中的变量值读到工作内存当中</span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>) <span class="string">load:</span>将read读取的值保存到工作内存中的变量副本中。</span><br><span class="line"></span><br><span class="line">(<span class="number">5</span>) <span class="string">use:</span>将值传递给线程的代码执行引擎</span><br><span class="line"></span><br><span class="line">(<span class="number">6</span>) <span class="string">assign:</span>将执行引擎处理返回的值重新赋值给变量副本</span><br><span class="line"></span><br><span class="line">(<span class="number">7</span>) <span class="string">store:</span>将变量副本的值存储到主内存中。</span><br><span class="line"></span><br><span class="line">(<span class="number">8</span>) <span class="string">write:</span>将store存储的值写入到主内存的共享变量当中。</span><br></pre></td></tr></table></figure><p><strong>通过上面Java内存模型的概述，我们会注意到这么一个问题，每个线程在获取锁之后会在自己的工作内存来操作共享变量，操作完成之后将工作内存中的副本回写到主内存，并且在其它线程从主内存将变量同步回自己的工作内存之前，共享变量的改变对其是不可见的。</strong>即其他线程的本地内存中的变量已经是过时的，并不是更新后的值。</p><h3 id="2-内存可见性带来的问题"><a href="#2-内存可见性带来的问题" class="headerlink" title="2 内存可见性带来的问题"></a>2 内存可见性带来的问题</h3><p>很多时候我们需要一个线程对共享变量的改动，其它线程也需要立即得知这个改动该怎么办呢？下面举两个例子说明内存可见性的重要性：</p><h4 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h4><p>有一个全局的状态变量open:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`boolean` `open=``<span class="literal">true</span>``<span class="comment">;`</span></span><br></pre></td></tr></table></figure><p>这个变量用来描述对一个资源的打开关闭状态，true表示打开，false表示关闭，假设有一个线程A,在执行一些操作后将open修改为false:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//线程A</span><br><span class="line">resource.close()<span class="comment">;</span></span><br><span class="line"><span class="attribute">open</span> = false<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>线程B随时关注open的状态，当open为true的时候通过访问资源来进行一些操作:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程B</span></span><br><span class="line"><span class="built_in">while</span>(<span class="built_in">open</span>) &#123;</span><br><span class="line">doSomethingWithResource(resource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当A把资源关闭的时候，open变量对线程B是不可见的，如果此时open变量的改动尚未同步到线程B的工作内存中,那么线程B就会用一个已经关闭了的资源去做一些操作，因此产生错误。</p><h4 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h4><p>下面是一个通过布尔标志判断线程是否结束的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CancelThreadTest</span> </span>&#123;</span><br><span class="line">         <span class="function">publicstatic <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">                   PrimeGeneratorgen = <span class="keyword">new</span> PrimeGenerator();</span><br><span class="line">                   newThread(gen).start();</span><br><span class="line">                   <span class="keyword">try</span></span><br><span class="line">                   &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                   &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                            gen.cancel();</span><br><span class="line">                   &#125;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeGenerator</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">         privateboolean cancelled;      </span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function">publicvoid <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   <span class="keyword">while</span>(!cancelled)</span><br><span class="line">                   &#123;</span><br><span class="line">                            System.out.println(<span class="string">"Running..."</span>);</span><br><span class="line">                            <span class="comment">//doingsomething here...</span></span><br><span class="line">                   &#125;                </span><br><span class="line">         &#125;       </span><br><span class="line">         <span class="function">publicvoid <span class="title">cancel</span><span class="params">()</span></span>&#123;cancelled = <span class="keyword">true</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主线程中设置PrimeGenerator线程的是否取消标识，PrimeGenerator线程检测到这个标识后就会结束线程，由于主线程修改cancelled变量的内存可见性，主线程修改cancelled标识后并不马上同步回主内存，所以PrimeGenerator线程结束的时间难以把控（最终是一定会同步回主内存，让PrimeGenerator线程结束）。</p><p>如果PrimeGenerator线程执行一些比较关键的操作，主线程希望能够及时终止它，这时将cenceled用volatile关键字修饰就是必要的。</p><p><strong>特别注意：上面演示这个并不是正确的取消线程的方法，因为一旦PrimeGenerator线程中包含BolckingQueue.put()等阻塞方法，那么将可能永远不会去检查cancelled标识，导致线程永远不会退出。正确的方法参见另外一篇关于如何正确终止线程的方法。</strong></p><h3 id="3-提供内存可见性"><a href="#3-提供内存可见性" class="headerlink" title="3 提供内存可见性"></a>3 提供内存可见性</h3><p>volatile保证可见性的原理是在<strong>每次访问变量时都会进行一次刷新</strong>，因此每次访问都是主内存中最新的版本。所以volatile关键字的作用之一就是<strong>保证变量修改的实时可见性</strong>。</p><p><strong>针对上面的例子1：</strong></p><p>要求一个线程对open的改变，其他的线程能够立即可见，Java为此提供了volatile关键字，在声明open变量的时候加入volatile关键字就可以保证open的内存可见性，即open的改变对所有的线程都是立即可见的。</p><p><strong>针对上面的例子2：</strong></p><p>将cancelled标志设置的volatile保证主线程针对cancelled标识的修改能够让PrimeGenerator线程立马看到。</p><p>备注：也可以通过提供synchronized同步的open变量的Get/Set方法解决此内存可见性问题，因为要Get变量open，必须等Set方完全释放锁之后。后面将介绍到两者的区别。</p><h2 id="（二）指令重排"><a href="#（二）指令重排" class="headerlink" title="（二）指令重排"></a>（二）指令重排</h2><h3 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1 概念"></a>1 概念</h3><p>指令重排序是JVM为了<strong>优化指令</strong>，<strong>提高程序运行效率</strong>，在<strong>不影响单线程程序执行结果的前提</strong>下，尽可能地提高并行度。编译器、处理器也遵循这样一个目标。注意是单线程。多线程的情况下指令重排序就会给程序员带来问题。</p><p>不同的指令间可能存在数据依赖。比如下面计算圆的面积的语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> r = <span class="number">2.3</span>d;<span class="comment">//(1)</span></span><br><span class="line"><span class="keyword">double</span> pi =<span class="number">3.1415926</span>; <span class="comment">//(2)</span></span><br><span class="line"><span class="keyword">double</span> area = pi* r * r; <span class="comment">//(3)</span></span><br></pre></td></tr></table></figure><p>area的计算依赖于r与pi两个变量的赋值指令。而r与pi无依赖关系。</p><p>as-if-serial语义是指：不管如何重排序（编译器与处理器为了提高并行度），（单线程）程序的结果不能被改变。这是编译器、Runtime、处理器必须遵守的语义。</p><p>虽然，（1） – happensbefore -&gt; （2）,（2） – happens before -&gt; （3），但是计算顺序(1)(2)(3)与(2)(1)(3) 对于r、pi、area变量的结果并无区别。编译器、Runtime在优化时可以根据情况重排序（1）与（2），而丝毫不影响程序的结果。</p><p>指令重排序包括编译器重排序和运行时重排序。</p><h3 id="2-指令重排带来的问题"><a href="#2-指令重排带来的问题" class="headerlink" title="2 指令重排带来的问题"></a>2 指令重排带来的问题</h3><p>如果一个操作不是原子的，就会给JVM留下重排的机会。下面看几个例子：</p><h4 id="例子1：A线程指令重排导致B线程出错"><a href="#例子1：A线程指令重排导致B线程出错" class="headerlink" title="例子1：A线程指令重排导致B线程出错"></a>例子1：A线程指令重排导致B线程出错</h4><p>对于在同一个线程内，这样的改变是不会对逻辑产生影响的，但是在多线程的情况下指令重排序会带来问题。看下面这个情景:</p><p><strong>在线程A中:</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">context</span> = loadContext()<span class="comment">;</span></span><br><span class="line"><span class="attr">inited</span> = <span class="literal">true</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>在线程B中:</strong></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!inited )&#123; <span class="comment">//根据线程A中对inited变量的修改决定是否使用context变量</span></span><br><span class="line">   <span class="built_in">sleep</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">doSomethingwithconfig</span>(context);</span><br></pre></td></tr></table></figure><p><strong>假设线程A中发生了指令重排序:</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inited</span> = <span class="literal">true</span><span class="comment">;</span></span><br><span class="line"><span class="attr">context</span> = loadContext()<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>那么B中很可能就会拿到一个尚未初始化或尚未初始化完成的context,从而引发程序错误。</p><h4 id="例子2：指令重排导致单例模式失效"><a href="#例子2：指令重排导致单例模式失效" class="headerlink" title="例子2：指令重排导致单例模式失效"></a>例子2：指令重排导致单例模式失效</h4><p>我们都知道一个经典的懒加载方式的双重判断单例模式：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="literal">null</span>;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">        synchronzied(Singleton.class) &#123;</span><br><span class="line">           <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">               &lt;strong&gt;instance = <span class="keyword">new</span> Singleton();  <span class="comment">//非原子操作</span></span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看似简单的一段赋值语句：instance= new Singleton()，但是很不幸它并不是一个原子操作，其实际上可以抽象为下面几条JVM指令：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory =allocate();    //1：分配对象的内存空间 </span><br><span class="line">ctorInstance(memory);  //2：初始化对象 </span><br><span class="line">instance =memory;     //3：设置instance指向刚分配的内存地址</span><br></pre></td></tr></table></figure><p>上面操作2依赖于操作1，但是操作3并不依赖于操作2，所以JVM是可以针对它们进行指令的优化重排序的，经过重排序后如下：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory =allocate();    //1：分配对象的内存空间 </span><br><span class="line">instance =memory;     //3：instance指向刚分配的内存地址，此时对象还未初始化</span><br><span class="line">ctorInstance(memory);  //2：初始化对象</span><br></pre></td></tr></table></figure><p>可以看到指令重排之后，instance指向分配好的内存放在了前面，而这段内存的初始化被排在了后面。</p><p>在线程A执行这段赋值语句，在初始化分配对象之前就已经将其赋值给instance引用，恰好另一个线程进入方法判断instance引用不为null，然后就将其返回使用，导致出错。</p><h3 id="3-防止指令重排"><a href="#3-防止指令重排" class="headerlink" title="3 防止指令重排"></a>3 防止指令重排</h3><p>除了前面内存可见性中讲到的volatile关键字可以保证变量修改的可见性之外，还有另一个重要的作用：<strong>在JDK1.5之后，可以使用volatile变量禁止指令重排序。</strong>  </p><p><strong>解决方案：</strong>例子1中的inited和例子2中的instance以关键字volatile修饰之后，就会阻止JVM对其相关代码进行指令重排，这样就能够按照既定的顺序指执行。</p><p>volatile关键字通过提供“<strong>内存屏障</strong>”的方式来防止指令被重排序，为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p><h2 id="（三）总结"><a href="#（三）总结" class="headerlink" title="（三）总结"></a>（三）总结</h2><h3 id="volatile是轻量级同步机制"><a href="#volatile是轻量级同步机制" class="headerlink" title="volatile是轻量级同步机制"></a>volatile是轻量级同步机制</h3><p>相对于synchronized块的代码锁，volatile应该是提供了一个轻量级的针对共享变量的锁，当我们在多个线程间使用共享变量进行通信的时候需要考虑将共享变量用volatile来修饰。</p><p>volatile是一种稍弱的同步机制，在访问volatile变量时不会执行加锁操作，也就不会执行线程阻塞，因此volatilei变量是一种比synchronized关键字更轻量级的同步机制。</p><h3 id="volatile使用建议"><a href="#volatile使用建议" class="headerlink" title="volatile使用建议"></a>volatile使用建议</h3><p>使用建议：在两个或者更多的线程需要访问的成员变量上使用volatile。当要访问的变量已在synchronized代码块中，或者为常量时，没必要使用volatile。</p><p>由于使用volatile屏蔽掉了JVM中必要的代码优化，所以在效率上比较低，因此一定在必要时才使用此关键字。</p><h3 id="volatile和synchronized区别"><a href="#volatile和synchronized区别" class="headerlink" title="volatile和synchronized区别"></a>volatile和synchronized区别</h3><p><strong>1、volatile不会进行加锁操作：</strong></p><p>volatile变量是一种稍弱的同步机制，在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比synchronized关键字更轻量级的同步机制。</p><p><strong>2、volatile变量作用类似于同步变量读写操作：</strong></p><p>从内存可见性的角度看，写入volatile变量相当于退出同步代码块，而读取volatile变量相当于进入同步代码块。</p><p><strong>3、volatile不如synchronized安全：</strong></p><p>在代码中如果过度依赖volatile变量来控制状态的可见性，通常会比使用锁的代码更脆弱，也更难以理解。仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它。一般来说，用同步机制会更安全些。</p><p>4、<strong>volatile无法同时保证内存可见性和原子性：</strong></p><p>加锁机制（即同步机制）既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性，原因是<strong>声明为volatile的简单变量如果当前值与该变量以前的值相关，那么volatile关键字不起作用</strong>，也就是说<strong>如下的表达式都不是原子操作：“count++”、“count = count+1”。</strong></p><p><strong>当且仅当满足以下所有条件时，才应该使用volatile变量：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、该变量没有包含在具有其他变量的不变式中。</span><br></pre></td></tr></table></figure><p>总结：在需要同步的时候，第一选择应该是synchronized关键字，这是最安全的方式，尝试其他任何方式都是有风险的。尤其在、jdK1.5之后，对synchronized同步机制做了很多优化，如：<strong>自适应的自旋锁、锁粗化、锁消除、轻量级锁</strong>等，使得它的性能明显有了很大的提升。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下文章来源于：&lt;a href=&quot;https://www.cnblogs.com/baizhanshi/p/6422926.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java并发：volatile内存可见性和指令重排&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;volatile两大作用&quot;&gt;&lt;a href=&quot;#volatile两大作用&quot; class=&quot;headerlink&quot; title=&quot;volatile两大作用&quot;&gt;&lt;/a&gt;volatile两大作用&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1、保证内存可见性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、防止指令重排&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此外需注意volatile&lt;strong&gt;并不保证操作的原子性。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://changsk.top/categories/Java/"/>
    
    
      <category term="java" scheme="http://changsk.top/tags/java/"/>
    
      <category term="volatile" scheme="http://changsk.top/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>java设计模式</title>
    <link href="http://changsk.top/2019/06/17/java-design-pattern/"/>
    <id>http://changsk.top/2019/06/17/java-design-pattern/</id>
    <published>2019-06-17T13:10:13.000Z</published>
    <updated>2019-06-20T01:36:19.383Z</updated>
    
    <content type="html"><![CDATA[<p>以下文章来自于：<a href="https://juejin.im/post/5bc96afff265da0aa94a4493" target="_blank" rel="noopener">Java 设计模式</a></p><p>一直想写一篇介绍设计模式的文章，让读者可以很快看完，而且<strong>一看就懂</strong>，<strong>看懂就会用</strong>，同时不会将各个模式搞混。自认为本文还是写得不错的???，花了不少心思来写这文章和做图，力求让读者真的能看着简单同时有所收获。</p><a id="more"></a><p>设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结，其中最出名的当属 </p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Gang of Four</span><br><span class="line"> (</span><br><span class="line">    GoF</span><br><span class="line"> )</span><br></pre></td></tr></table></figure><p> 的分类了，他们将设计模式分类为 23 种经典的模式，根据用途我们又可以分为三大类，分别为<strong>创建型模式</strong>、<strong>结构型模式</strong>和<strong>行为型模式</strong>。是的，我不善于扯这些有的没的，还是少点废话吧<del>~</del></p><p><img src="1.jpg" alt></p><p>有一些重要的设计原则在开篇和大家分享下，这些原则将贯通全文：</p><ol><li><strong>面向接口编程</strong>，而不是面向实现。这个很重要，也是优雅的、可扩展的代码的第一步，这就不需要多说了吧。</li><li><strong>职责单一原则</strong>。每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来。</li><li><strong>对修改关闭，对扩展开放</strong>。对修改关闭是说，我们辛辛苦苦加班写出来的代码，该实现的功能和该修复的 bug 都完成了，别人可不能说改就改；对扩展开放就比较好理解了，也就是说在我们写好的代码基础上，很容易实现扩展。</li></ol><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p><strong>创建型模式的作用就是创建对象</strong>，说到创建一个对象，最熟悉的就是 new 一个对象，然后 set 相关属性。但是，在很多场景下，我们需要<strong>给客户端提供更加友好的创建对象的方式</strong>，尤其是那种我们定义了类，但是需要提供给其他开发者用的时候。</p><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>和名字一样简单，非常简单，直接上代码吧：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FoodFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Food <span class="title">makeFood</span>(<span class="params">String name</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.<span class="keyword">equals</span>(<span class="string">"noodle"</span>)) &#123;</span><br><span class="line">            Food noodle = <span class="keyword">new</span> LanZhouNoodle();</span><br><span class="line">            noodle.addSpicy(<span class="string">"more"</span>);</span><br><span class="line">            <span class="keyword">return</span> noodle;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.<span class="keyword">equals</span>(<span class="string">"chicken"</span>)) &#123;</span><br><span class="line">            Food chicken = <span class="keyword">new</span> HuangMenChicken();</span><br><span class="line">            chicken.addCondiment(<span class="string">"potato"</span>);</span><br><span class="line">            <span class="keyword">return</span> chicken;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>其中，LanZhouNoodle 和 HuangMenChicken 都继承自 Food。</p><p>简单地说，简单工厂模式通常就是这样，一个工厂类 XxxFactory，里面有一个静态方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象。</p><blockquote><p>我们强调<strong>职责单一</strong>原则，一个类只提供一种功能，FoodFactory 的功能就是只要负责生产各种 Food。</p></blockquote><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>简单工厂模式很简单，如果它能满足我们的需要，我觉得就不要折腾了。之所以需要引入工厂模式，是<strong>因为我们往往需要使用两个或两个以上的工厂。</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FoodFactory</span> </span>&#123;</span><br><span class="line">    Food makeFood(<span class="keyword">String</span> name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChineseFoodFactory</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">FoodFactory</span></span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> Food makeFood(<span class="keyword">String</span> name) &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"A"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ChineseFoodA</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">"B"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ChineseFoodB</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmericanFoodFactory</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">FoodFactory</span></span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> Food makeFood(<span class="keyword">String</span> name) &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"A"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">AmericanFoodA</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">"B"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">AmericanFoodB</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>其中，ChineseFoodA、ChineseFoodB、AmericanFoodA、AmericanFoodB 都派生自 Food。</p><p>客户端调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">APP</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先选择一个具体的工厂</span></span><br><span class="line">        FoodFactory factory = <span class="keyword">new</span> ChineseFoodFactory();</span><br><span class="line">        <span class="comment">// 由第一步的工厂产生具体的对象，不同的工厂造出不一样的对象</span></span><br><span class="line">        Food food = factory.makeFood(<span class="string">"A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>虽然都是调用 makeFood(“A”) 制作 A 类食物，但是，不同的工厂生产出来的完全不一样。</p><p>第一步，我们需要<strong>选取合适的工厂</strong>，然后第二步基本上和简单工厂一样。</p><p><strong>核心在于，我们需要在第一步选好我们需要的工厂</strong>。比如，我们有 LogFactory 接口，实现类有 FileLogFactory 和 KafkaLogFactory，分别对应将日志写入文件和写入 Kafka 中，显然，我们客户端第一步就需要决定到底要实例化 FileLogFactory 还是 KafkaLogFactory，这将决定之后的所有的操作。</p><p>虽然简单，不过我也把所有的构件都画到一张图上，这样读者看着比较清晰：</p><p><img src="2.jpg" alt="factory-1"></p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>当涉及到<strong>产品族</strong>的时候，就需要引入抽象工厂模式了。</p><p>一个经典的例子是造一台电脑。我们先不引入抽象工厂模式，看看怎么实现。</p><p>因为电脑是由许多的构件组成的，我们将 CPU 和主板进行抽象，然后 CPU 由 CPUFactory 生产，主板由 MainBoardFactory 生产，然后，我们再将 CPU 和主板搭配起来组合在一起，如下图：</p><p><img src="3.jpg" alt="factory-1"></p><p>这个时候的客户端调用是这样的：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到 Intel 的 CPU</span></span><br><span class="line">CPUFactory intelCPUFactory = <span class="keyword">new</span> <span class="type">IntelCPUFactory</span>();</span><br><span class="line">CPU cpu = intelCPUFactory.makeCPU();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到 AMD 的主板</span></span><br><span class="line">MainBoardFactory mainBoardFactory = <span class="keyword">new</span> <span class="type">AmdMainBoardFactory</span>();</span><br><span class="line">MainBoard mainBoard = mainBoardFactory.make();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组装 CPU 和主板</span></span><br><span class="line">Computer computer = <span class="keyword">new</span> <span class="type">Computer</span>(cpu, mainBoard);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>单独看 CPU 工厂和主板工厂，它们分别是前面我们说的<strong>工厂模式</strong>。这种方式也容易扩展，因为要给电脑加硬盘的话，只需要加一个 HardDiskFactory 和相应的实现即可，不需要修改现有的工厂。</p><p>但是，这种方式有一个问题，那就是如果 <strong>Intel 家产的 CPU 和 AMD 产的主板不能兼容使用</strong>，那么这代码就容易出错，因为客户端并不知道它们不兼容，也就会错误地出现随意组合。</p><p>下面就是我们要说的<strong>产品族</strong>的概念，它代表了组成某个产品的一系列附件的集合：</p><p><img src="4.jpg" alt="abstract-factory-2"></p><p>当涉及到这种产品族的问题的时候，就需要抽象工厂模式来支持了。我们不再定义 CPU 工厂、主板工厂、硬盘工厂、显示屏工厂等等，我们直接定义电脑工厂，每个电脑工厂负责生产所有的设备，这样能保证肯定不存在兼容问题。</p><p><img src="5.jpg" alt="abstract-factory-3"></p><p>这个时候，对于客户端来说，不再需要单独挑选 CPU厂商、主板厂商、硬盘厂商等，直接选择一家品牌工厂，品牌工厂会负责生产所有的东西，而且能保证肯定是兼容可用的。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">    <span class="comment">// 第一步就要选定一个“大厂”</span></span><br><span class="line">    ComputerFactory cf = <span class="keyword">new</span> <span class="type">AmdFactory</span>();</span><br><span class="line">    <span class="comment">// 从这个大厂造 CPU</span></span><br><span class="line">    CPU cpu = cf.makeCPU();</span><br><span class="line">    <span class="comment">// 从这个大厂造主板</span></span><br><span class="line">    MainBoard board = cf.makeMainBoard();</span><br><span class="line">      <span class="comment">// 从这个大厂造硬盘</span></span><br><span class="line">      HardDisk hardDisk = cf.makeHardDisk();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将同一个厂子出来的 CPU、主板、硬盘组装在一起</span></span><br><span class="line">    Computer result = <span class="keyword">new</span> <span class="type">Computer</span>(cpu, board, hardDisk);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>当然，抽象工厂的问题也是显而易见的，比如我们要加个显示器，就需要修改所有的工厂，给所有的工厂都加上制造显示器的方法。这有点违反了<strong>对修改关闭，对扩展开放</strong>这个设计原则。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式用得最多，错得最多。</p><p>饿汉模式最简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line">    <span class="comment">// 首先，将 new Singleton() 堵死</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="comment">// 创建私有静态实例，意味着这个类第一次使用的时候就会进行创建</span></span><br><span class="line">    <span class="comment">// 这个代码还可以放在静态代码块中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 瞎写一个静态方法。这里想说的是，如果我们只是要调用 Singleton.getDate(...)，</span></span><br><span class="line">    <span class="comment">// 本来是不想要生成 Singleton 实例的，不过没办法，已经生成了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">getDate</span><span class="params">(String mode)</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> Date();&#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>很多人都能说出饿汉模式的缺点(浪费内存空间)，可是我觉得生产过程中，很少碰到这种情况：你定义了一个单例的类，不需要其实例，可是你却把一个或几个你会用到的静态方法塞到这个类中。</p></blockquote><p>饱汉模式最容易出错：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    // 首先，也是先堵死<span class="built_in"> new </span>Singleton() 这条路</span><br><span class="line">   <span class="keyword"> private</span> Singleton() &#123;&#125;</span><br><span class="line">    // 和饿汉模式相比，这边不需要先实例化出来，注意这里的 volatile，它是必须的</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> volatile Singleton<span class="built_in"> instance </span>= null;</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> Singleton getInstance() &#123;</span><br><span class="line">       <span class="built_in"> if </span>(instance == null) &#123;</span><br><span class="line">            // 加锁</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                // 这一次判断也是必须的，不然会有并发问题</span><br><span class="line">               <span class="built_in"> if </span>(instance == null) &#123;</span><br><span class="line">                   <span class="built_in"> instance </span>=<span class="built_in"> new </span>Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="built_in"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>volatile 关键字可以保证 instance 的内存可见性和防止指令重排序，使得 instance 在多线程环境下依然可以正确的被初始化。详情请移步这里：<a href="http://changsk.top/2019/06/18/java-volatile/">java中volatile关键字的作用</a>。</p><blockquote><p>双重检查，指的是两次检查 instance 是否为 null。</p><p>volatile 在这里是需要的，希望能引起读者的关注。</p><p>很多人不知道怎么写，直接就在 getInstance() 方法签名上加上 synchronized，这就不多说了，性能太差。</p></blockquote><p>嵌套类最经典，以后大家就用它吧：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton3 &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> private</span> Singleton3() &#123;&#125;</span><br><span class="line">    // 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性</span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> class Holder &#123;</span><br><span class="line">       <span class="keyword"> private</span><span class="keyword"> static</span> Singleton3<span class="built_in"> instance </span>=<span class="built_in"> new </span>Singleton3();</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> Singleton3 getInstance() &#123;</span><br><span class="line">       <span class="built_in"> return </span>Holder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>注意，很多人都会把这个<strong>嵌套类</strong>说成是<strong>静态内部类</strong>，严格地说，内部类和嵌套类是不一样的，它们能访问的外部类权限也是不一样的。</p></blockquote><p>最后，一定有人跳出来说用枚举实现单例，是的没错，枚举类<strong>很特殊，它在类加载的时候会初始化里面的所有的实例，而且 JVM 保证了它们不会再被实例化，所以它天生就是单例的</strong>。不说了，读者自己看着办吧，不建议使用。</p><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>经常碰见的 <strong>XxxBuilder</strong> 的类，通常都是建造者模式的产物。建造者模式其实有很多的变种，但是对于客户端来说，我们的使用通常都是一个模式的：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Food food = new FoodBuilder<span class="params">()</span><span class="string">.a</span><span class="params">()</span><span class="string">.b</span><span class="params">()</span><span class="string">.c</span><span class="params">()</span><span class="string">.build</span><span class="params">()</span>;</span><br><span class="line">Food food = Food.builder<span class="params">()</span><span class="string">.a</span><span class="params">()</span><span class="string">.b</span><span class="params">()</span><span class="string">.c</span><span class="params">()</span><span class="string">.build</span><span class="params">()</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>套路就是先 new 一个 Builder，然后可以链式地调用一堆方法，最后再调用一次 build() 方法，我们需要的对象就有了。</strong></p><p>来一个中规中矩的建造者模式：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下面是“一堆”的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> password;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> nickName;</span><br><span class="line">    <span class="keyword">private</span> int age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法私有化，不然客户端就会直接调用构造方法了</span></span><br><span class="line">    <span class="keyword">private</span> User(<span class="keyword">String</span> name, <span class="keyword">String</span> password, <span class="keyword">String</span> nickName, int age) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">        <span class="built_in">this</span>.nickName = nickName;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 静态方法，用于生成一个 Builder，这个不一定要有，不过写这个方法是一个很好的习惯，</span></span><br><span class="line">    <span class="comment">// 有些代码要求别人写 new User.UserBuilder().a()...build() 看上去就没那么好</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserBuilder builder() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">UserBuilder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBuilder</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 下面是和 User 一模一样的一堆属性</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">String</span>  name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">String</span> password;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">String</span> nickName;</span><br><span class="line">        <span class="keyword">private</span> int age;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> UserBuilder() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 链式调用设置各个属性值，返回 this，即 UserBuilder</span></span><br><span class="line">        <span class="keyword">public</span> UserBuilder name(<span class="keyword">String</span> name) &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> UserBuilder password(<span class="keyword">String</span> password) &#123;</span><br><span class="line">            <span class="built_in">this</span>.password = password;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> UserBuilder nickName(<span class="keyword">String</span> nickName) &#123;</span><br><span class="line">            <span class="built_in">this</span>.nickName = nickName;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> UserBuilder age(int age) &#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// build() 方法负责将 UserBuilder 中设置好的属性“复制”到 User 中。</span></span><br><span class="line">        <span class="comment">// 当然，可以在 “复制” 之前做点检验</span></span><br><span class="line">        <span class="keyword">public</span> User build() &#123;</span><br><span class="line">            <span class="keyword">if</span> (name == <span class="literal">null</span> || password == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">"用户名和密码必填"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (age &lt;= <span class="number">0</span> || age &gt;= <span class="number">150</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">"年龄不合法"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 还可以做赋予”默认值“的功能</span></span><br><span class="line">              <span class="keyword">if</span> (nickName == <span class="literal">null</span>) &#123;</span><br><span class="line">                nickName = name;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">User</span>(name, password, nickName, age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>核心是：先把所有的属性都设置给 Builder，然后 build() 方法的时候，将这些属性<strong>复制</strong>给实际产生的对象。</p><p>看看客户端的调用：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class APP &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       <span class="built_in"> User </span>d = User.builder()</span><br><span class="line">                .name(<span class="string">"foo"</span>)</span><br><span class="line">                .password(<span class="string">"pAss12345"</span>)</span><br><span class="line">                .age(25)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>说实话，建造者模式的<strong>链式</strong>写法很吸引人，但是，多写了很多“无用”的 builder 的代码，感觉这个模式没什么用。不过，<strong>当属性很多，而且有些必填，有些选填的时候，这个模式会使代码清晰很多</strong>。我们可以在 <strong>Builder 的构造方法</strong>中强制让调用者提供必填字段，还有，在 build() 方法中校验各个参数比在 User 的构造方法中校验，代码要优雅一些。</p><blockquote><p>题外话，强烈建议读者使用 lombok，用了 lombok 以后，上面的一大堆代码会变成如下这样:</p></blockquote><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Builder</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span>  name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> password;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> nickName;</span><br><span class="line">    <span class="keyword">private</span> int age;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>怎么样，省下来的时间是不是又可以干点别的了。</p></blockquote><p>当然，如果你只是想要链式写法，不想要建造者模式，有个很简单的办法，User 的 getter 方法不变，所有的 setter 方法都让其 <strong>return this</strong> 就可以了，然后就可以像下面这样调用：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User<span class="built_in"> user </span>= new User().setName(<span class="string">""</span>).setPassword(<span class="string">""</span>).setAge(20);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>这是我要说的创建型模式的最后一个设计模式了。</p><p>原型模式很简单：有一个原型<strong>实例</strong>，基于这个原型实例产生新的实例，也就是“<strong>克隆</strong>”了。</p><p>Object 类中有一个 clone() 方法，它用于生成一个新的对象，当然，如果我们要调用这个方法，java 要求我们的类必须先<strong>实现 Cloneable 接口</strong>，此接口没有定义任何方法，但是不这么做的话，在 clone() 的时候，会抛出 CloneNotSupportedException 异常。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> <span class="function">Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>java 的克隆是浅克隆，碰到对象引用的时候，克隆出来的对象和原对象中的引用将指向同一个对象。通常实现深克隆的方法是将对象进行序列化，然后再进行反序列化。</p></blockquote><p>原型模式了解到这里我觉得就够了，各种变着法子说这种代码或那种代码是原型模式，没什么意义。</p><h3 id="创建型模式总结"><a href="#创建型模式总结" class="headerlink" title="创建型模式总结"></a>创建型模式总结</h3><p>创建型模式总体上比较简单，它们的作用就是为了<strong>产生实例对象</strong>，算是各种工作的第一步了，因为我们写的是<strong>面向对象</strong>的代码，所以我们第一步当然是需要创建一个对象了。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">简单工厂模式最简单；</span><br><span class="line">工厂模式在简单工厂模式的基础上增加了选择工厂的维度，需要第一步选择合适的工厂；</span><br><span class="line">抽象工厂模式有产品族的概念，如果各个产品是存在兼容性问题的，就要用抽象工厂模式<span class="comment">;</span></span><br><span class="line">单例模式就不说了，为了保证全局使用的是同一对象，一方面是安全性考虑，一方面是为了节省资源；</span><br><span class="line">建造者模式专门对付属性很多的那种类，为了让代码更优美；</span><br><span class="line">原型模式用得最少，了解和 Object 类中的 <span class="keyword">clone() </span>方法相关的知识即可。</span><br></pre></td></tr></table></figure><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>前面创建型模式介绍了<strong>创建对象的一些设计模式</strong>，这节介绍的结构型模式旨在<strong>通过改变代码结构来达到解耦的目的，使得我们的代码容易维护和扩展</strong>。</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>第一个要介绍的<strong>代理模式是最常使用的模式之一</strong>了，<strong>用一个代理来隐藏具体实现类的实现细节</strong>，通常还用于在<strong>真实的实现的前后添加一部分逻辑</strong>。</p><p>既然说是<strong>代理</strong>，那就要对客户端隐藏真实实现，由代理来负责客户端的所有请求。当然，代理只是个代理，它不会完成实际的业务逻辑，而是一层皮而已，但是对于客户端来说，它必须表现得就是客户端需要的真实实现。</p><blockquote><p>理解<strong>代理</strong>这个词，这个模式其实就简单了。</p></blockquote><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">FoodService</span> &#123;</span><br><span class="line">    <span class="function">Food <span class="title">makeChicken</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function">Food <span class="title">makeNoodle</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FoodServiceImpl</span> <span class="title">implements</span> <span class="title">FoodService</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">makeChicken</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        Food f = <span class="keyword">new</span> Chicken()</span><br><span class="line">        f.setChicken(<span class="string">"1kg"</span>);</span><br><span class="line">        f.setSpicy(<span class="string">"1g"</span>);</span><br><span class="line">        f.setSalt(<span class="string">"3g"</span>);</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">makeNoodle</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        Food f = <span class="keyword">new</span> Noodle();</span><br><span class="line">        f.setNoodle(<span class="string">"500g"</span>);</span><br><span class="line">        f.setSalt(<span class="string">"5g"</span>);</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理要表现得“就像是”真实实现类，所以需要实现 FoodService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FoodServiceProxy</span> <span class="title">implements</span> <span class="title">FoodService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部一定要有一个真实的实现类，当然也可以通过构造方法注入</span></span><br><span class="line">    <span class="keyword">private</span> FoodService foodService = <span class="keyword">new</span> FoodServiceImpl();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">makeChicken</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"我们马上要开始制作鸡肉了"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果我们定义这句为核心代码的话，那么，核心代码是真实实现类做的，</span></span><br><span class="line">        <span class="comment">// 代理只是在核心代码前后做些“无足轻重”的事情</span></span><br><span class="line">        Food food = foodService.makeChicken();</span><br><span class="line"></span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"鸡肉制作完成啦，加点胡椒粉"</span>); <span class="comment">// 增强</span></span><br><span class="line">         food.addCondiment(<span class="string">"pepper"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> food;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">makeNoodle</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"准备制作拉面~"</span>);</span><br><span class="line">        Food food = foodService.makeNoodle();</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"制作完成啦"</span>)</span><br><span class="line">        <span class="keyword">return</span> food;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>客户端调用，注意，我们要用代理来实例化接口：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里用代理类来实例化</span></span><br><span class="line">FoodService foodService = <span class="keyword">new</span> <span class="type">FoodServiceProxy</span>();</span><br><span class="line">foodService.makeChicken();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="6.jpg" alt="proxy"></p><p>我们发现没有，代理模式说白了就是做 <strong>“方法包装”</strong> 或做 <strong>“方法增强”</strong>。在面向切面编程中，算了还是不要吹捧这个名词了，在 <strong>AOP</strong> 中，其实就是<strong>动态代理</strong>的过程。比如 Spring 中，我们自己不定义代理类，但是 Spring 会帮我们动态来定义代理，然后把我们定义在 <strong>@Before</strong>、<strong>@After</strong>、<strong>@Around</strong> 中的代码逻辑动态添加到代理中。</p><p>说到动态代理，又可以展开说 …… Spring 中实现动态代理有两种，一种是如果我们的类定义了接口，如 UserService 接口和 UserServiceImpl 实现，那么采用 <strong>JDK 的动态代理</strong>，感兴趣的读者可以去看看 java.lang.reflect.Proxy 类的源码；另一种是我们自己没有定义接口的，Spring 会采用 <strong>CGLIB</strong> 进行动态代理，它是一个 jar 包，性能还不错。</p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>说完代理模式，说适配器模式，是因为它们很相似，这里可以做个比较。</p><p>适配器模式做的就是，有一个接口需要实现，但是我们现成的对象都不满足，需要加一层适配器来进行适配。</p><p>适配器模式总体来说分三种：<strong>默认适配器模式</strong>、<strong>对象适配器模式</strong>、<strong>类适配器模式</strong>。先不急着分清楚这几个，先看看例子再说。</p><h4 id="默认适配器模式"><a href="#默认适配器模式" class="headerlink" title="默认适配器模式"></a>默认适配器模式</h4><p>首先，我们先看看最简单的适配器模式<strong>默认适配器模式(Default Adapter)</strong>是怎么样的。</p><p>我们用 Appache commons-io 包中的 FileAlterationListener 做例子，此接口定义了很多的方法，用于对文件或文件夹进行监控，一旦发生了对应的操作，就会触发相应的方法。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> FileAlterationListener &#123;</span><br><span class="line">    <span class="keyword">void</span> onStart(<span class="keyword">final</span> FileAlterationObserver observer);</span><br><span class="line">    <span class="keyword">void</span> onDirectoryCreate(<span class="keyword">final</span> <span class="keyword">File</span> directory);</span><br><span class="line">    <span class="keyword">void</span> onDirectoryChange(<span class="keyword">final</span> <span class="keyword">File</span> directory);</span><br><span class="line">    <span class="keyword">void</span> onDirectoryDelete(<span class="keyword">final</span> <span class="keyword">File</span> directory);</span><br><span class="line">    <span class="keyword">void</span> onFileCreate(<span class="keyword">final</span> <span class="keyword">File</span> <span class="keyword">file</span>);</span><br><span class="line">    <span class="keyword">void</span> onFileChange(<span class="keyword">final</span> <span class="keyword">File</span> <span class="keyword">file</span>);</span><br><span class="line">    <span class="keyword">void</span> onFileDelete(<span class="keyword">final</span> <span class="keyword">File</span> <span class="keyword">file</span>);</span><br><span class="line">    <span class="keyword">void</span> onStop(<span class="keyword">final</span> FileAlterationObserver observer);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>此接口的一大问题是<strong>抽象方法太多</strong>了，如果我们要用这个接口，意味着我们要实现每一个抽象方法，如果我们只是想要监控文件夹中的<strong>文件创建</strong>和<strong>文件删除</strong>事件，可是我们还是不得不实现所有的方法，很明显，这不是我们想要的。</p><p>所以，我们需要下面的一个<strong>适配器</strong>，它用于实现上面的接口，但是<strong>所有的方法都是空方法</strong>，这样，我们就可以转而定义自己的类来继承下面这个类即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileAlterationListenerAdaptor</span> <span class="keyword">implements</span> <span class="title">FileAlterationListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDirectoryCreate</span><span class="params">(<span class="keyword">final</span> File directory)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDirectoryChange</span><span class="params">(<span class="keyword">final</span> File directory)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDirectoryDelete</span><span class="params">(<span class="keyword">final</span> File directory)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFileCreate</span><span class="params">(<span class="keyword">final</span> File file)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFileChange</span><span class="params">(<span class="keyword">final</span> File file)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFileDelete</span><span class="params">(<span class="keyword">final</span> File file)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>比如我们可以定义以下类，我们仅仅需要实现我们想实现的方法就可以了：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FileMonitor</span> <span class="keyword">extends</span> <span class="title">FileAlterationListenerAdaptor</span> </span>&#123;</span><br><span class="line">    public void onFileCreate(<span class="keyword">final</span> <span class="type">File</span> file) &#123;</span><br><span class="line">        <span class="comment">// 文件创建</span></span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onFileDelete(<span class="keyword">final</span> <span class="type">File</span> file) &#123;</span><br><span class="line">        <span class="comment">// 文件删除</span></span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>当然，上面说的只是适配器模式的其中一种，也是最简单的一种，无需多言。下面，再介绍<strong>“正统的”</strong>适配器模式。</p><h4 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h4><p>来看一个《Head First 设计模式》中的一个例子，我稍微修改了一下，看看怎么将鸡适配成鸭，这样鸡也能当鸭来用。因为，现在鸭这个接口，我们没有合适的实现类可以用，所以需要适配器。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Duck</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span>(<span class="params"></span>)</span>; <span class="comment">// 鸭的呱呱叫</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span>(<span class="params"></span>)</span>; <span class="comment">// 飞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Cock</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gobble</span>(<span class="params"></span>)</span>; <span class="comment">// 鸡的咕咕叫</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span>(<span class="params"></span>)</span>; <span class="comment">// 飞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WildCock</span> <span class="title">implements</span> <span class="title">Cock</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gobble</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"咕咕叫"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"鸡也会飞哦"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>鸭接口有 fly() 和 quare() 两个方法，鸡 Cock 如果要冒充鸭，fly() 方法是现成的，但是鸡不会鸭的呱呱叫，没有 quack() 方法。这个时候就需要适配了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 毫无疑问，首先，这个适配器肯定需要 implements Duck，这样才能当做鸭来用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CockAdapter</span> <span class="keyword">implements</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Cock cock;</span><br><span class="line">    <span class="comment">// 构造方法中需要一个鸡的实例，此类就是将这只鸡适配成鸭来用</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">CockAdapter</span><span class="params">(Cock cock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cock = cock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现鸭的呱呱叫方法</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 内部其实是一只鸡的咕咕叫</span></span><br><span class="line">        cock.gobble();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cock.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>客户端调用很简单了：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">    <span class="comment">// 有一只野鸡</span></span><br><span class="line">      Cock wildCock = <span class="keyword">new</span> <span class="type">WildCock</span>();</span><br><span class="line">      <span class="comment">// 成功将野鸡适配成鸭</span></span><br><span class="line">      Duck duck = <span class="keyword">new</span> <span class="type">CockAdapter</span>(wildCock);</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>到这里，大家也就知道了适配器模式是怎么回事了。无非是我们需要一只鸭，但是我们只有一只鸡，这个时候就需要定义一个适配器，由这个适配器来充当鸭，但是适配器里面的方法还是由鸡来实现的。</p><p>我们用一个图来简单说明下：</p><p><img src="7.jpg" alt="adapter-1"></p><p>上图应该还是很容易理解的，我就不做更多的解释了。下面，我们看看类适配模式怎么样的。</p><h4 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h4><p>废话少说，直接上图：</p><p><img src="8.jpg" alt="adapter-1"></p><p>看到这个图，大家应该很容易理解的吧，通过继承的方法，适配器自动获得了所需要的大部分方法。这个时候，客户端使用更加简单，直接 <code>Target t = new SomeAdapter();</code> 就可以了。</p><h4 id="适配器模式总结"><a href="#适配器模式总结" class="headerlink" title="适配器模式总结"></a>适配器模式总结</h4><ol><li><p>类适配和对象适配的异同</p><blockquote><p>一个采用继承，一个采用组合；</p><p>类适配属于静态实现，对象适配属于组合的动态实现，对象适配需要多实例化一个对象。</p><p>总体来说，对象适配用得比较多。</p></blockquote></li><li><p>适配器模式和代理模式的异同</p><p>比较这两种模式，其实是比较对象适配器模式和代理模式，在代码结构上，它们很相似，都<strong>需要一个具体的实现类的实例</strong>。但是它们的目的不一样，<strong>代理模式做的是增强原方法的活</strong>；<strong>适配器做的是适配的活</strong>，为的是提供“把鸡包装成鸭，然后当做鸭来使用”，而鸡和鸭它们之间原本没有继承关系。</p><p><img src="9.jpg" alt="adapter-5"></p></li></ol><h3 id="桥梁模式"><a href="#桥梁模式" class="headerlink" title="桥梁模式"></a>桥梁模式</h3><p>理解桥梁模式，其实就是理解<strong>代码抽象</strong>和<strong>解耦</strong>。</p><p>我们首先需要一个<strong>桥梁</strong>，它是一个<strong>接口</strong>，定义提供的接口方法。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>DrawAPI &#123;</span><br><span class="line">   public void draw(int radius, int x, int y);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>然后是一系列实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedPen</span> <span class="keyword">implements</span> <span class="title">DrawAPI</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"用红色笔画图，radius:"</span> + radius + <span class="string">", x:"</span> + x + <span class="string">", y:"</span> + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreenPen</span> <span class="keyword">implements</span> <span class="title">DrawAPI</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"用绿色笔画图，radius:"</span> + radius + <span class="string">", x:"</span> + x + <span class="string">", y:"</span> + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BluePen</span> <span class="keyword">implements</span> <span class="title">DrawAPI</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"用蓝色笔画图，radius:"</span> + radius + <span class="string">", x:"</span> + x + <span class="string">", y:"</span> + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>定义一个抽象类，此类的实现类都需要使用 DrawAPI：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Shape</span> &#123;</span><br><span class="line">   <span class="keyword">protected</span> DrawAPI drawAPI;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="title">Shape</span>(<span class="params">DrawAPI drawAPI</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.drawAPI = drawAPI;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span>(<span class="params"></span>)</span>;    </span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>定义抽象类的子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 圆形</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> radius;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">int</span> radius, DrawAPI drawAPI)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(drawAPI);</span><br><span class="line">      <span class="keyword">this</span>.radius = radius;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      drawAPI.draw(radius, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 长方形</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, DrawAPI drawAPI)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(drawAPI);</span><br><span class="line">          <span class="keyword">this</span>.x = x;</span><br><span class="line">          <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      drawAPI.draw(<span class="number">0</span>, x, y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>最后，我们来看客户端演示：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">    Shape greenCircle = <span class="keyword">new</span> <span class="type">Circle</span>(<span class="number">10</span>, <span class="keyword">new</span> <span class="type">GreenPen</span>());</span><br><span class="line">      Shape redRectangle = <span class="keyword">new</span> <span class="type">Rectangle</span>(<span class="number">4</span>, <span class="number">8</span>, <span class="keyword">new</span> <span class="type">RedPen</span>());</span><br><span class="line"></span><br><span class="line">      greenCircle.draw();</span><br><span class="line">      redRectangle.draw();</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可能大家看上面一步步还不是特别清晰，我把所有的东西整合到一张图上：</p><p><img src="10.jpg" alt="bridge-1"></p><p>这回大家应该就知道抽象在哪里，怎么解耦了吧。桥梁模式的优点也是显而易见的，就是<strong>非常容易进行扩展</strong>。</p><blockquote><p>本节引用了<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.tutorialspoint.com%2Fdesign_pattern%2Fbridge_pattern.htm" target="_blank" rel="noopener">这里</a>的例子，并对其进行了修改。</p></blockquote><h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p>要把装饰模式说清楚明白，不是件容易的事情。也许读者知道 Java IO 中的几个类是典型的装饰模式的应用，但是读者不一定清楚其中的关系，也许看完就忘了，希望看完这节后，读者可以对其有更深的感悟。</p><p>首先，我们先看一个简单的图，看这个图的时候，了解下层次结构就可以了：</p><p><img src="11.jpg" alt="decorator-1"></p><p>我们来说说装饰模式的出发点，从图中可以看到，接口 <code>Component</code> 其实已经有了 <code>ConcreteComponentA</code> 和 <code>ConcreteComponentB</code> 两个实现类了，但是，如果我们要<strong>增强</strong>这两个实现类的话，我们就可以采用装饰模式，用具体的装饰器来<strong>装饰</strong>实现类，以达到增强的目的。</p><blockquote><p>从名字来简单解释下装饰器。既然说是装饰，那么往往就是<strong>添加小功能</strong>这种，而且，我们要满足可以添加多个小功能。最简单的，代理模式就可以实现功能的增强，但是代理不容易实现多个功能的增强，当然你可以说用代理包装代理的方式，但是那样的话代码就复杂了。</p></blockquote><p>首先明白一些简单的概念，从图中我们看到，所有的具体装饰者们 ConcreteDecorator都可以作为 Component 来使用，因为它们都实现了 Component 中的所有接口。它们和 Component 实现类 ConcreteComponent的区别是，它们只是装饰者，起装饰作用，也就是即使它们看上去牛逼轰轰，但是它们都只是在具体的实现中加了层皮来装饰而已。</p><blockquote><p>注意这段话中混杂在各个名词中的 Component 和 Decorator，别搞混了。</p></blockquote><p>下面来看看一个例子，先把装饰模式弄清楚，然后再介绍下 java io 中的装饰模式的应用。</p><p>最近大街上流行起来了“快乐柠檬”，我们把快乐柠檬的饮料分为三类：红茶、绿茶、咖啡，在这三大类的基础上，又增加了许多的口味，什么金桔柠檬红茶、金桔柠檬珍珠绿茶、芒果红茶、芒果绿茶、芒果珍珠红茶、烤珍珠红茶、烤珍珠芒果绿茶、椰香胚芽咖啡、焦糖可可咖啡等等，每家店都有很长的菜单，但是仔细看下，其实原料也没几样，但是可以搭配出很多组合，如果顾客需要，很多没出现在菜单中的饮料他们也是可以做的。</p><p>在这个例子中，红茶、绿茶、咖啡是最基础的饮料，其他的像金桔柠檬、芒果、珍珠、椰果、焦糖等都属于装饰用的。当然，在开发中，我们确实可以像门店一样，开发这些类：LemonBlackTea、LemonGreenTea、MangoBlackTea、MangoLemonGreenTea……但是，很快我们就发现，这样子干肯定是不行的，这会导致我们需要组合出所有的可能，而且如果客人需要在红茶中加双份柠檬怎么办？三份柠檬怎么办？万一有个变态要四份柠檬，所以这种做法是给自己找加班的。</p><p>不说废话了，上代码。</p><p>首先，定义饮料抽象基类：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Beverage</span> &#123;</span><br><span class="line">      <span class="comment">// 返回描述</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDescription</span>(<span class="params"></span>)</span>;</span><br><span class="line">      <span class="comment">// 返回价格</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">cost</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>然后是三个基础饮料实现类，红茶、绿茶和咖啡：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">BlackTea</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">      public <span class="type">String</span> getDescription() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"红茶"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      public double cost() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">GreenTea</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">    public <span class="type">String</span> getDescription() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"绿茶"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      public double cost() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...<span class="comment">// 咖啡省略</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>定义调料，也就是装饰者的基类，此类必须继承自 Beverage：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调料</span></span><br><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Condiment</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>然后我们来定义柠檬、芒果等具体的调料，它们属于装饰者，毫无疑问，这些调料肯定都需要继承 Condiment 类：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Lemon</span> <span class="keyword">extends</span> <span class="title">Condiment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Beverage</span> bevarage;</span><br><span class="line">      <span class="comment">// 这里很关键，需要传入具体的饮料，如需要传入没有被装饰的红茶或绿茶，</span></span><br><span class="line">      <span class="comment">// 当然也可以传入已经装饰好的芒果绿茶，这样可以做芒果柠檬绿茶</span></span><br><span class="line">      public <span class="type">Lemon</span>(<span class="type">Beverage</span> bevarage) &#123;</span><br><span class="line">        <span class="keyword">this</span>.bevarage = bevarage;</span><br><span class="line">    &#125;</span><br><span class="line">      public <span class="type">String</span> getDescription() &#123;</span><br><span class="line">        <span class="comment">// 装饰</span></span><br><span class="line">        <span class="keyword">return</span> bevarage.getDescription() + <span class="string">", 加柠檬"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      public double cost() &#123;</span><br><span class="line">          <span class="comment">// 装饰</span></span><br><span class="line">        <span class="keyword">return</span> beverage.cost() + <span class="number">2</span>; <span class="comment">// 加柠檬需要 2 元</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Mango</span> <span class="keyword">extends</span> <span class="title">Condiment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Beverage</span> bevarage;</span><br><span class="line">      public <span class="type">Mango</span>(<span class="type">Beverage</span> bevarage) &#123;</span><br><span class="line">        <span class="keyword">this</span>.bevarage = bevarage;</span><br><span class="line">    &#125;</span><br><span class="line">      public <span class="type">String</span> getDescription() &#123;</span><br><span class="line">        <span class="keyword">return</span> bevarage.getDescription() + <span class="string">", 加芒果"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      public double cost() &#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.cost() + <span class="number">3</span>; <span class="comment">// 加芒果需要 3 元</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...<span class="comment">// 给每一种调料都加一个类</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>看客户端调用：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">      <span class="comment">// 首先，我们需要一个基础饮料，红茶、绿茶或咖啡</span></span><br><span class="line">    Beverage beverage = <span class="keyword">new</span> <span class="type">GreenTea</span>();</span><br><span class="line">      <span class="comment">// 开始装饰</span></span><br><span class="line">      beverage = <span class="keyword">new</span> <span class="type">Lemon</span>(beverage); <span class="comment">// 先加一份柠檬</span></span><br><span class="line">      beverage = <span class="keyword">new</span> <span class="type">Mongo</span>(beverage); <span class="comment">// 再加一份芒果</span></span><br><span class="line"></span><br><span class="line">      System.out.println(beverage.getDescription() + <span class="string">" 价格：￥"</span> + beverage.cost());</span><br><span class="line">      <span class="comment">//"绿茶, 加柠檬, 加芒果 价格：￥16"</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果我们需要芒果珍珠双份柠檬红茶：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Beverage beverage = <span class="keyword">new</span> <span class="type">Mongo</span>(<span class="keyword">new</span> <span class="type">Pearl</span>(<span class="keyword">new</span> <span class="type">Lemon</span>(<span class="keyword">new</span> <span class="type">Lemon</span>(<span class="keyword">new</span> <span class="type">BlackTea</span>()))));</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>是不是很变态？</p><p>看看下图可能会清晰一些：</p><p><img src="12.jpg" alt="decorator-2"></p><p>到这里，大家应该已经清楚装饰模式了吧。</p><p>下面，我们再来说说 java IO 中的装饰模式。看下图 InputStream 派生出来的部分类：</p><p><img src="13.jpg" alt="decorator-3"></p><p>我们知道 <strong>InputStream</strong> 代表了输入流，具体的输入来源可以是文件（<strong>FileInputStream</strong>）、管道（<strong>PipedInputStream</strong>）、数组（<strong>ByteArrayInputStream</strong>）等，这些就像前面奶茶的例子中的红茶、绿茶，属于基础输入流。</p><p>FilterInputStream 承接了装饰模式的关键节点，其实现类是一系列装饰器，比如 BufferedInputStream 代表用缓冲来装饰，也就使得输入流<strong>具有了缓冲的功能</strong>，LineNumberInputStream 代表用行号来装饰，在操作的时候就可以取得行号了，DataInputStream 的装饰，使得我们可以从输入流转换为 java 中的基本类型值。</p><p>当然，在 java IO 中，如果我们使用装饰器的话，就不太适合面向接口编程了，如：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStream inputStream = <span class="keyword">new</span> <span class="type">LineNumberInputStream</span>(<span class="keyword">new</span> <span class="type">BufferedInputStream</span>(<span class="keyword">new</span> <span class="type">FileInputStream</span>(<span class="string">""</span>)));</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这样的结果是，InputStream 还是不具有读取行号的功能，因为读取行号的方法定义在 LineNumberInputStream 类中。</p><p>我们应该像下面这样使用：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LineNumberInputStream is = <span class="keyword">new</span> <span class="type">LineNumberInputStream</span>(</span><br><span class="line">                              <span class="keyword">new</span> <span class="type">BufferedInputStream</span>(</span><br><span class="line">                                  <span class="keyword">new</span> <span class="type">FileInputStream</span>(<span class="string">""</span>)));</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>所以说嘛，要找到纯的严格符合设计模式的代码还是比较难的。</p></blockquote><h3 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h3><p>门面模式（也叫外观模式，<strong>Facade Pattern</strong>）在许多源码中有使用，比如 <strong>slf4j 就可以理解为是门面模式的应用</strong>。这是一个简单的设计模式，我们直接上代码再说吧。</p><p>首先，我们定义一个接口：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Shape &#123;</span><br><span class="line">   void draw();</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>定义几个实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Circle::draw()"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Rectangle::draw()"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>客户端调用：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">    <span class="comment">// 画一个圆形</span></span><br><span class="line">      Shape <span class="built_in">circle</span> = <span class="keyword">new</span> Circle();</span><br><span class="line">      <span class="built_in">circle</span>.draw();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 画一个长方形</span></span><br><span class="line">      Shape rectangle = <span class="keyword">new</span> Rectangle();</span><br><span class="line">      rectangle.draw();</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>以上是我们常写的代码，我们需要画圆就要先实例化圆，画长方形就需要先实例化一个长方形，然后再调用相应的 draw() 方法。</p><p>下面，我们看看怎么用门面模式来让客户端调用更加友好一些。</p><p>我们先定义一个门面：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeMaker</span> &#123;</span></span><br><span class="line">   <span class="keyword">private</span> Shape circle;</span><br><span class="line">   <span class="keyword">private</span> Shape rectangle;</span><br><span class="line">   <span class="keyword">private</span> Shape square;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ShapeMaker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      circle = <span class="keyword">new</span> Circle();</span><br><span class="line">      rectangle = <span class="keyword">new</span> Rectangle();</span><br><span class="line">      square = <span class="keyword">new</span> Square();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 下面定义一堆方法，具体应该调用什么方法，由这个门面来决定</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">()</span></span>&#123;</span><br><span class="line">      circle.draw();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRectangle</span><span class="params">()</span></span>&#123;</span><br><span class="line">      rectangle.draw();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSquare</span><span class="params">()</span></span>&#123;</span><br><span class="line">      square.draw();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>看看现在客户端怎么调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ShapeMaker shapeMaker = <span class="keyword">new</span> ShapeMaker();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 客户端调用现在更加清晰了</span></span><br><span class="line">  shapeMaker.drawCircle();</span><br><span class="line">  shapeMaker.drawRectangle();</span><br><span class="line">  shapeMaker.drawSquare();        </span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>门面模式的优点显而易见，<strong>客户端不再需要关注实例化时应该使用哪个实现类</strong>，直接调用门面提供的方法就可以了，因为门面类提供的方法的方法名对于客户端来说已经很友好了。</p><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p><strong>组合模式用于表示具有层次结构的数据</strong>，使得我们对单个对象和组合对象的访问具有一致性。</p><p>直接看一个例子吧，每个员工都有姓名、部门、薪水这些属性，同时还有下属员工集合（虽然可能集合为空），而下属员工和自己的结构是一样的，也有姓名、部门这些属性，同时也有他们的下属员工集合。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Employee</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String dept;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> salary;</span><br><span class="line">   <span class="keyword">private</span> List&lt;Employee&gt; subordinates; <span class="comment">// 下属</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Employee</span>(<span class="params">String name,String dept, <span class="keyword">int</span> sal</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.dept = dept;</span><br><span class="line">      <span class="keyword">this</span>.salary = sal;</span><br><span class="line">      subordinates = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span>(<span class="params">Employee e</span>)</span> &#123;</span><br><span class="line">      subordinates.<span class="keyword">add</span>(e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span>(<span class="params">Employee e</span>)</span> &#123;</span><br><span class="line">      subordinates.<span class="keyword">remove</span>(e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getSubordinates</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> subordinates;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="string">"Employee :[ Name : "</span> + name + <span class="string">", dept : "</span> + dept + <span class="string">", salary :"</span> + salary+<span class="string">" ]"</span>);</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>通常，这种类需要定义 add(node)、remove(node)、getChildren() 这些方法。</p><p>这说的其实就是组合模式，这种简单的模式我就不做过多介绍了，相信各位读者也不喜欢看我写废话。</p><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>英文是 Flyweight Pattern，不知道是谁最先翻译的这个词，感觉这翻译真的不好理解，我们试着强行关联起来吧。<strong>Flyweight 是轻量级的意思</strong>，<strong>享元分开来说就是共享元器件，也就是复用已经生成的对象</strong>，这种做法当然也就是轻量级的了。</p><p><strong>复用对象最简单的方式是，用一个 HashMap 来存放每次新生成的对象。每次需要一个对象的时候，先到 HashMap 中看看有没有，如果没有，再生成新的对象，然后将这个对象放入 HashMap 中。</strong></p><p>这种简单的代码我就不演示了。</p><h3 id="结构型模式总结"><a href="#结构型模式总结" class="headerlink" title="结构型模式总结"></a>结构型模式总结</h3><p>前面，我们说了<strong>代理模式</strong>、<strong>适配器模式</strong>、<strong>桥梁模式</strong>、<strong>装饰模式</strong>、<strong>门面模式</strong>、<strong>组合模式</strong>和<strong>享元模式</strong>。读者是否可以分别把这几个模式说清楚了呢？在说到这些模式的时候，心中是否有一个清晰的图或处理流程在脑海里呢？</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">代理模式是做方法增强的<span class="comment">;</span></span><br><span class="line">适配器模式是把鸡包装成鸭这种用来适配接口的<span class="comment">;</span></span><br><span class="line">桥梁模式做到了很好的解耦<span class="comment">;</span></span><br><span class="line">装饰模式从名字上就看得出来，适合于装饰类或者说是增强类的场景；</span><br><span class="line">门面模式的优点是客户端不需要关心实例化过程，只要调用需要的方法即可；</span><br><span class="line">组合模式用于描述具有层次结构的数据；</span><br><span class="line">享元模式是为了在特定的场景中缓存已经创建的对象，用于提高性能。</span><br></pre></td></tr></table></figure><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><p><strong>行为型模式关注的是各个类之间的相互作用，将职责划分清楚，使得我们的代码更加地清晰。</strong></p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p><strong>策略模式太常用了</strong>，所以把它放到最前面进行介绍。它比较简单，我就不废话，直接用代码说事吧。</p><p>下面设计的场景是，我们需要画一个图形，可选的策略就是用红色笔来画，还是绿色笔来画，或者蓝色笔来画。</p><p>首先，先定义一个策略接口：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Strategy &#123;</span><br><span class="line">   public void draw(int radius, int x, int y);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>然后我们定义具体的几个策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedPen</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"用红色笔画图，radius:"</span> + radius + <span class="string">", x:"</span> + x + <span class="string">", y:"</span> + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreenPen</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"用绿色笔画图，radius:"</span> + radius + <span class="string">", x:"</span> + x + <span class="string">", y:"</span> + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BluePen</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"用蓝色笔画图，radius:"</span> + radius + <span class="string">", x:"</span> + x + <span class="string">", y:"</span> + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>使用策略的类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> &#123;</span></span><br><span class="line">   <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeDraw</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> strategy.draw(radius, x, y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>客户端演示：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">    Context context = <span class="keyword">new</span> <span class="type">Context</span>(<span class="keyword">new</span> <span class="type">BluePen</span>()); <span class="comment">// 使用绿色笔来画</span></span><br><span class="line">      context.executeDraw(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>放到一张图上，让大家看得清晰些：</p><p><img src="14.jpg" alt="strategy-1"></p><p>这个时候，大家有没有联想到结构型模式中的桥梁模式，它们其实非常相似，我把桥梁模式的图拿过来大家对比下：</p><p><img src="15.jpg" alt="bridge-1"></p><p>要我说的话，它们非常相似，桥梁模式在左侧加了一层抽象而已。桥梁模式的耦合更低，结构更复杂一些。</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式对于我们来说，真是再简单不过了。无外乎两个操作，<strong>观察者订阅自己关心的主题</strong>和<strong>主题有数据变化后通知观察者们。</strong></p><p>首先，需要定义主题，<strong>每个主题需要持有观察者列表的引用</strong>，用于在数据变更的时候通知各个观察者：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Subject &#123;</span><br><span class="line"></span><br><span class="line">   private List<span class="variable">&lt;Observer&gt;</span> observers = new ArrayList<span class="variable">&lt;Observer&gt;</span>();</span><br><span class="line">   private int <span class="keyword">state</span>;</span><br><span class="line"></span><br><span class="line">   public int getState() &#123;</span><br><span class="line">      return <span class="keyword">state</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void <span class="built_in">set</span>State(int <span class="keyword">state</span>) &#123;</span><br><span class="line">      this.<span class="keyword">state</span> = <span class="keyword">state</span>;</span><br><span class="line">      // 数据已变更，通知观察者们</span><br><span class="line">      notifyAllObservers();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void attach(Observer observer)&#123;</span><br><span class="line">      observers.add(observer);        </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 通知观察者们</span><br><span class="line">   public void notifyAllObservers()&#123;</span><br><span class="line">      <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">         observer.update();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;     </span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>定义观察者接口：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Observer</span> &#123;</span><br><span class="line">   <span class="keyword">protected</span> Subject subject;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">update</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>其实如果只有一个观察者类的话，接口都不用定义了，不过，通常场景下，既然用到了观察者模式，我们就是希望一个事件出来了，会有多个不同的类需要处理相应的信息。比如，<strong>订单修改成功事件，我们希望发短信的类得到通知、发邮件的类得到通知、处理物流信息的类得到通知等。</strong></p><p>我们来定义具体的几个观察者类：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">BinaryObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 在构造方法中进行订阅主题</span></span><br><span class="line">    public <span class="type">BinaryObserver</span>(<span class="type">Subject</span> subject) &#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="comment">// 通常在构造方法中将 this 发布出去的操作一定要小心</span></span><br><span class="line">        <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 该方法由主题类在数据变更的时候进行调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void update() &#123;</span><br><span class="line">        <span class="type">String</span> result = <span class="type">Integer</span>.toBinaryString(subject.getState());</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"订阅的数据发生变化，新的数据处理为二进制值为："</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">HexaObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    public <span class="type">HexaObserver</span>(<span class="type">Subject</span> subject) &#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void update() &#123;</span><br><span class="line">          <span class="type">String</span> result = <span class="type">Integer</span>.toHexString(subject.getState()).toUpperCase();</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"订阅的数据发生变化，新的数据处理为十六进制值为："</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>客户端使用也非常简单：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">    <span class="comment">// 先定义一个主题</span></span><br><span class="line">      Subject subject1 = <span class="keyword">new</span> <span class="type">Subject</span>();</span><br><span class="line">      <span class="comment">// 定义观察者</span></span><br><span class="line">      <span class="keyword">new</span> <span class="type">BinaryObserver</span>(subject1);</span><br><span class="line">      <span class="keyword">new</span> <span class="type">HexaObserver</span>(subject1);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 模拟数据变更，这个时候，观察者们的 update 方法将会被调用</span></span><br><span class="line">      subject.setState(<span class="number">11</span>);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">订阅的数据发生变化，新的数据处理为二进制值为：<span class="number">1011</span></span><br><span class="line">订阅的数据发生变化，新的数据处理为十六进制值为：<span class="keyword">B</span></span><br><span class="line"><span class="keyword">复制代码</span></span><br></pre></td></tr></table></figure><p>当然，jdk 也提供了相似的支持，具体的大家可以参考 java.util.Observable 和 java.util.Observer 这两个类。</p><p>实际生产过程中，观察者模式往往用消息中间件来实现，如果要实现单机观察者模式，笔者建议读者使用 Guava 中的 EventBus，它有同步实现也有异步实现，本文主要介绍设计模式，就不展开说了。</p><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>责任链通常需要先<strong>建立一个单向链表</strong>，然后调用方只需要调用头部节点就可以了，后面会自动流转下去。比如流程审批就是一个很好的例子，只要终端用户提交申请，根据申请的内容信息，自动建立一条责任链，然后就可以开始流转了。</p><p>有这么一个场景，用户参加一个活动可以领取奖品，但是活动需要进行很多的规则校验然后才能放行，比如首先需要校验用户是否是新用户、今日参与人数是否有限额、全场参与人数是否有限额等等。设定的规则都通过后，才能让用户领走奖品。</p><blockquote><p>如果产品给你这个需求的话，我想大部分人一开始肯定想的就是，用一个 List 来存放所有的规则，然后 foreach 执行一下每个规则就好了。不过，读者也先别急，看看责任链模式和我们说的这个有什么不一样？</p></blockquote><p>首先，我们要定义流程上节点的基类：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">RuleHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="keyword">protected</span> RuleHandler successor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">apply</span>(<span class="params">Context context</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuccessor</span>(<span class="params">RuleHandler successor</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RuleHandler <span class="title">getSuccessor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>接下来，我们需要定义具体的每个节点了。</p><p>校验用户是否是新用户：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">NewUserRuleHandler</span> <span class="keyword">extends</span> <span class="title">RuleHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    public void apply(<span class="type">Context</span> context) &#123;</span><br><span class="line">        <span class="keyword">if</span> (context.isNewUser()) &#123;</span><br><span class="line">              <span class="comment">// 如果有后继节点的话，传递下去</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getSuccessor() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.getSuccessor().apply(context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">"该活动仅限新用户参与"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>校验用户所在地区是否可以参与：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">LocationRuleHandler</span> <span class="keyword">extends</span> <span class="title">RuleHandler</span> </span>&#123;</span><br><span class="line">    public void apply(<span class="type">Context</span> context) &#123;</span><br><span class="line">        boolean allowed = activityService.isSupportedLocation(context.getLocation);</span><br><span class="line">          <span class="keyword">if</span> (allowed) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getSuccessor() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.getSuccessor().apply(context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">"非常抱歉，您所在的地区无法参与本次活动"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>校验奖品是否已领完：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">LimitRuleHandler</span> <span class="keyword">extends</span> <span class="title">RuleHandler</span> </span>&#123;</span><br><span class="line">    public void apply(<span class="type">Context</span> context) &#123;</span><br><span class="line">          int remainedTimes = activityService.queryRemainedTimes(context); <span class="comment">// 查询剩余奖品</span></span><br><span class="line">        <span class="keyword">if</span> (remainedTimes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getSuccessor() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.getSuccessor().apply(userInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">"您来得太晚了，奖品被领完了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">    RuleHandler <span class="keyword">new</span><span class="type">UserHandler</span> = <span class="keyword">new</span> <span class="type">NewUserRuleHandler</span>();</span><br><span class="line">      RuleHandler locationHandler = <span class="keyword">new</span> <span class="type">LocationRuleHandler</span>();</span><br><span class="line">      RuleHandler limitHandler = <span class="keyword">new</span> <span class="type">LimitRuleHandler</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 假设本次活动仅校验地区和奖品数量，不校验新老用户</span></span><br><span class="line">      locationHandler.setSuccessor(limitHandler);</span><br><span class="line">      locationHandler.apply(context);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>代码其实很简单，就是先定义好一个链表，然后在通过任意一节点后，如果此节点有后继节点，那么传递下去。</p><p>至于它和我们前面说的用一个 List 存放需要执行的规则的做法有什么异同，留给读者自己琢磨吧。</p><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>在含有继承结构的代码中，模板方法模式是非常常用的，这也是在<strong>开源代码</strong>中大量被使用的。</p><p>通常会有一个抽象类：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">AbstractTemplate</span> &#123;</span><br><span class="line">    <span class="comment">// 这就是模板方法</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">templateMethod</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        apply(); <span class="comment">// 这个是重点</span></span><br><span class="line">        end(); <span class="comment">// 可以作为钩子方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"init 抽象层已经实现，子类也可以选择覆写"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 留给子类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">apply</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">end</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>模板方法中调用了 3 个方法，其中 apply() 是抽象方法，子类必须实现它，其实模板方法中有几个抽象方法完全是自由的，我们也可以将三个方法都设置为抽象方法，让子类来实现。也就是说，<strong>模板方法只负责定义第一步应该要做什么，第二步应该做什么，第三步应该做什么，至于怎么做，由子类来实现。</strong></p><p>我们写一个实现类：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ConcreteTemplate</span> <span class="keyword">extends</span> <span class="title">AbstractTemplate</span> </span>&#123;</span><br><span class="line">    public void apply() &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"子类实现抽象方法 apply"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">      public void end() &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"我们可以把 method3 当做钩子方法来使用，需要的时候覆写就可以了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>客户端调用演示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AbstractTemplate t = <span class="keyword">new</span> ConcreteTemplate();</span><br><span class="line">      <span class="comment">// 调用模板方法</span></span><br><span class="line">      t.templateMethod();</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>代码其实很简单，基本上看到就懂了，关键是要学会用到自己的代码中。</p><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>废话我就不说了，我们说一个简单的例子。商品库存中心有个最基本的需求是减库存和补库存，我们看看怎么用状态模式来写。</p><p>核心在于，我们的关注点不再是 Context 是该进行哪种操作，而是关注在这个 Context 会有哪些操作。</p><p>定义状态接口：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>State &#123;</span><br><span class="line">   public void doAction(Context context);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>定义减库存的状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeductState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"商品卖出，准备减库存"</span>);</span><br><span class="line">      context.setState(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//... 执行减库存的具体操作</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Deduct State"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>定义补库存状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RevertState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"给此商品补库存"</span>);</span><br><span class="line">          context.setState(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//... 执行加库存的具体操作</span></span><br><span class="line">    &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Revert State"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>前面用到了 context.setState(this)，我们来看看怎么定义 Context 类：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Context &#123;</span><br><span class="line">    private State <span class="keyword">state</span>;</span><br><span class="line">      private String name;</span><br><span class="line">      public Context(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      public void <span class="built_in">set</span>State(State <span class="keyword">state</span>) &#123;</span><br><span class="line">        this.<span class="keyword">state</span> = <span class="keyword">state</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      public void getState() &#123;</span><br><span class="line">        return this.<span class="keyword">state</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>我们来看下客户端调用，大家就一清二楚了：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">    <span class="comment">// 我们需要操作的是 iPhone X</span></span><br><span class="line">    Context context = <span class="keyword">new</span> <span class="type">Context</span>(<span class="string">"iPhone X"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看看怎么进行补库存操作</span></span><br><span class="line">      State revertState = <span class="keyword">new</span> <span class="type">RevertState</span>();</span><br><span class="line">      revertState.doAction(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同样的，减库存操作也非常简单</span></span><br><span class="line">      State deductState = <span class="keyword">new</span> <span class="type">DeductState</span>();</span><br><span class="line">      deductState.doAction(context);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果需要我们可以获取当前的状态</span></span><br><span class="line">    <span class="comment">// context.getState().toString();</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>读者可能会发现，在上面这个例子中，如果我们不关心当前 context 处于什么状态，那么 Context 就可以不用维护 state 属性了，那样代码会简单很多。</p><p>不过，商品库存这个例子毕竟只是个例，我们还有很多实例是需要知道当前 context 处于什么状态的。</p><h3 id="行为型模式总结"><a href="#行为型模式总结" class="headerlink" title="行为型模式总结"></a>行为型模式总结</h3><p>行为型模式部分介绍了<strong>策略模式</strong>、<strong>观察者模式</strong>、<strong>责任链模式</strong>、<strong>模板方法模式</strong>和<strong>状态模式</strong>，其实，经典的行为型模式还包括<strong>备忘录模式</strong>、<strong>命令模式</strong>等，但是它们的使用场景比较有限，而且本文篇幅也挺大了，我就不进行介绍了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学习设计模式的目的是为了让我们的代码更加的<strong>优雅</strong>、<strong>易维护</strong>、<strong>易扩展</strong>。</p><blockquote><p>作者：JavaDoop</p><p>链接：<a href="https://juejin.im/post/5bc96afff265da0aa94a4493" target="_blank" rel="noopener">https://juejin.im/post/5bc96afff265da0aa94a4493</a></p><p>来源：掘金</p><p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下文章来自于：&lt;a href=&quot;https://juejin.im/post/5bc96afff265da0aa94a4493&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java 设计模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一直想写一篇介绍设计模式的文章，让读者可以很快看完，而且&lt;strong&gt;一看就懂&lt;/strong&gt;，&lt;strong&gt;看懂就会用&lt;/strong&gt;，同时不会将各个模式搞混。自认为本文还是写得不错的???，花了不少心思来写这文章和做图，力求让读者真的能看着简单同时有所收获。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://changsk.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://changsk.top/tags/java/"/>
    
      <category term="设计模式" scheme="http://changsk.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>什么是restful？</title>
    <link href="http://changsk.top/2019/06/17/what-is-resuful/"/>
    <id>http://changsk.top/2019/06/17/what-is-resuful/</id>
    <published>2019-06-17T09:25:34.000Z</published>
    <updated>2019-06-17T13:08:52.427Z</updated>
    
    <content type="html"><![CDATA[<p>以下文章来源于：<a href="https://zhuanlan.zhihu.com/p/30396391" target="_blank" rel="noopener">如何给老婆解释什么是RESTful</a></p><p>老婆经常喜欢翻看我订阅的技术杂志，她总能从她的视角提出很多有趣的问题。</p><p>一个悠闲的周日下午，她午觉醒来，又习惯性的抓起这个月的杂志，饶有兴趣地看了起来。</p><p>果不其然，看着看着，她又对我发难了，“Restful是什么呀，老公？是restaurant的形容词吗，突然就觉得好饿了啊……”</p><a id="more"></a><p>作为一个合格的程序员，我一直把能够将一项技术讲给老婆听，并且能给她讲懂，作为我已经掌握了这项技术的标准。</p><p>如果我直接回答说，“REST就是<strong>Representational State Transfer</strong>的缩写呀，翻译为中文就是‘表述性状态转移’”，那她今晚肯定得罚我跪键盘。我必须找个合适的机会，把Restful的<strong>来龙去脉</strong>给她形象的描述一遍。</p><p>“走，咱们去楼下咖啡厅吃个下午茶吧”，我对老婆说。</p><p>“一个芝士蛋糕，一杯拿铁，两条吸管，谢谢”，我对前台的服务员说，然后我们找了个角落坐了下来。</p><h2 id="Level-0-面向前台"><a href="#Level-0-面向前台" class="headerlink" title="Level 0 - 面向前台"></a>Level 0 - 面向前台</h2><p>“刚才我们向前台点了一杯拿铁，这个过程可以用这段文字来描述”，说着，我在纸上写下了这段JSON，虽然她不知道什么叫JSON，但理解这段文字对于英语专业8级的她，实在再简单不过。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;addOrder&quot;: &#123;</span><br><span class="line">        &quot;orderName&quot;: &quot;latte&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“我们通过这段文字，告诉前台，新增一笔订单，订单是一杯拿铁咖啡”，接着，前台给我们返回这么一串回复：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;orderId&quot;: &quot;123456&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“订单ID？还是订单编号？”</p><p>“恩恩，就是订单编号”</p><p>“那我们就等着前台喊‘订单123456的客户可以取餐了’，然后就可以开吃了！”</p><p>“哈哈，你真聪明，不过，在这之前，假设我们有一张会员卡，我们想查询一下这张会员卡的余额，这时候，要向前台发起另一个询问”，我继续在纸上写着：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;queryBalance&quot;: &#123;</span><br><span class="line">        &quot;cardId&quot;: &quot;886333&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“查询卡号为886333的卡的余额？”</p><p>“真棒！接着，查询的结果返回来了”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;balance&quot;: &quot;0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“切，没钱……”</p><p>“哈哈，没钱，现在我们要跟前台说，这杯咖啡不要了”，我在纸上写到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;deleteOrder&quot;: &#123;</span><br><span class="line">        &quot;orderId&quot;: &quot;123456&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“哼，这就把订单取消啦？”</p><h2 id="Level-1-面向资源"><a href="#Level-1-面向资源" class="headerlink" title="Level 1 - 面向资源"></a>Level 1 - 面向资源</h2><p>“现在这家咖啡店越做越大，来喝咖啡的人越来越多，单靠前台显然是不行的，店主决定进行分工，每个<strong>资源</strong>都有专人负责，我们可以直接<strong>面向资源</strong>操作。”</p><p>“面向资源？”</p><p>“是的，比如还是下单，请求的内容不变，但是我们多了一条消息”，我在纸上画出这次的模型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/orders</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;addOrder&quot;: &#123;</span><br><span class="line">        &quot;orderName&quot;: &quot;latte&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“多了一个斜杠和orders？这是什么意思？”</p><p>“这个表示我们这个<strong>请求是发给哪个资源的</strong>，订单是一种资源，我们可以理解为是咖啡厅专门管理订单的人，他可以帮我们处理所有有关订单的操作，包括新增订单、修改订单、取消订单等操作”</p><p>“Soga…”</p><p>“接着还是会返回订单的编号给我们”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;orderId&quot;: &quot;123456&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“下面，我们还是要查询会员卡余额，这次请求的资源变成了cards”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/cards</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;queryBalance&quot;: &#123;</span><br><span class="line">        &quot;cardId&quot;: &quot;886333&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“接下来是取消订单”</p><p>“这个我会”，说着，她抢走我手上的笔，在纸上写了起来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/orders</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;deleteOrder&quot;: &#123;</span><br><span class="line">        &quot;orderId&quot;: &quot;123456&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Level-2-打上标签"><a href="#Level-2-打上标签" class="headerlink" title="Level 2 - 打上标签"></a>Level 2 - 打上标签</h2><p>“接下来，店主还想继续优化他的咖啡厅的服务流程，他发现负责处理订单的员工，每次都要去订单内容里面看是新增订单还是删除订单，还是其他的什么操作，十分不方便，于是规定，所有新增资源的请求，都在请求上面写上大大的‘POST’，表示这是一笔新增资源的请求”</p><p><strong>“其他种类的请求，比如查询类的，用‘GET’表示</strong>，<strong>删除类的，用‘DELETE’表示”</strong></p><p>“还有修改类的，修改分为两种，第一种，如果这个修改，<strong>无论发送多少次，最后一次修改后的资源，总是和第一次修改后的一样</strong>，比如将拿铁改为猫屎，那么用‘PUT’表示；第二种，如果这个修改，<strong>每次修改都会让这个资源和前一次的不一样</strong>，比如是加一杯咖啡，那么这种请求用‘PATCH’或者‘POST’表示”，一口气讲了这么多，发现她有点似懂非懂。</p><p>“来，我们再来重复上面那个过程，来一杯拿铁”，我边说边画着：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /orders</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;orderName&quot;: &quot;latte&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“请求的内容简洁多啦，不用告诉店员是addOrder，看到POST就知道是新增”，她听的很认真，理解的也很透彻。</p><p>“恩恩，返回的内容还是一样”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;orderId&quot;: &quot;123456&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“接着是查询会员卡余额，这次也简化了很多”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /cards</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;cardId&quot;: &quot;886333&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“这个请求我们还可以进一步优化为这样”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /cards/886333</span><br></pre></td></tr></table></figure><p>“Soga，直接把要查询的卡号写在后面了”</p><p>“没错，接着，取消订单”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /orders/123456</span><br></pre></td></tr></table></figure><h2 id="Level-3-完美服务"><a href="#Level-3-完美服务" class="headerlink" title="Level 3 - 完美服务"></a>Level 3 - 完美服务</h2><p>“忽然有一天，有个顾客抱怨说，他买了咖啡后，不知道要怎么取消订单，咖啡厅一个店员回了一句，你不会看我们的宣传单吗，上面不写着：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /orders/&#123;orderId&#125;</span><br></pre></td></tr></table></figure><p>顾客反问道，谁会去看那个啊，店员不服，又说到，你瞎了啊你……据说后面两人吵着吵着还打了起来…”</p><p>“噗，真是悲剧…”</p><p>“有了这次教训，店长决定，顾客下了单之后，不仅给他们返回订单的编号，还给顾客返回所有可以对这个订单做的操作，比如告诉用户如何删除订单。现在，我们还是发出请求，请求内容和上一次一样”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /orders</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;orderName&quot;: &quot;latte&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“但是这次返回时多了些内容”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;orderId&quot;: &quot;123456&quot;,</span><br><span class="line">    &quot;link&quot;: &#123;</span><br><span class="line">        &quot;rel&quot;: &quot;cancel&quot;,</span><br><span class="line">        &quot;url&quot;: &quot;/order/123456&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“这次返回时多了一项link信息，里面包含了一个rel属性和url属性，rel是relationship的意思，这里的关系是cancel，url则告诉你如何执行这个cancel操作，接着你就可以这样子来取消订单啦”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /orders/123456</span><br></pre></td></tr></table></figure><p>“哈哈，这服务真是贴心，以后再也不用担心店员和顾客打起来了”</p><p>“订单123456的客户可以取餐了”，伴随着咖啡厅的广播，我们吃起了下午茶，一杯拿铁，两支吸管……</p><h2 id="对程序员的话"><a href="#对程序员的话" class="headerlink" title="对程序员的话"></a>对程序员的话</h2><p>用了大白话，给老婆讲明白了RESTful的来龙去脉，当然，我还是有些话想说的，只是怕老婆听完一脸懵逼，没给她说：</p><p>1、</p><p>上面讲的Level0~Level3，来自<em>Leonard Richardson</em>提出的<strong>Richardson Maturity Model</strong>：</p><p><img src="1.jpg" alt="img"></p><p>Level0和Level1最大的区别，就是Level1拥有了Restful的第一个特征——<strong>面向资源</strong>，这对构建可伸缩、分布式的架构是至关重要的。同时，如果把Level0的数据格式换成Xml，那么其实就是<strong>SOAP</strong>，SOAP的特点是<strong>关注行为和处理</strong>，和面向资源的RESTful有很大的不同。</p><p>Level0和Level1，其实都很挫，他们都<strong>只是把HTTP当做一个传输的通道</strong>，没有把HTTP当做一种<strong>传输协议</strong>。</p><p>Level2，真正将HTTP作为了一种传输协议，最直观的一点就是Level2使用了<strong>HTTP动词</strong>，<strong>GET/PUT/POST/DELETE/PATCH</strong>….,这些都是HTTP的规范，规范的作用自然是重大的，用户看到一个POST请求，就知道它不是<strong>幂等</strong>的，使用时要小心，看到PUT，就知道他是幂等的，调用多几次都不会造成问题，当然，这些的前提都是API的设计者和开发者也遵循这一套规范，确保自己提供的PUT接口是幂等的。</p><p>Level3，关于这一层，有一个古怪的名词，叫<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/HATEOAS" target="_blank" rel="noopener">HATEOAS</a>（Hypertext As The Engine Of Application State），中文翻译为“将超媒体格式作为应用状态的引擎”，核心思想就是<strong>每个资源都有它的状态，不同状态下，可对它进行的操作不一样</strong>。理解了这一层，再来看看REST的全称，Representational State Transfer，中文翻译为“表述性状态转移”，是不是好理解多了？</p><p>Level3的Restful API，给使用者带来了很大的便利，使用者<strong>只需要知道如何获取资源的入口</strong>，<strong>之后的每个URI都可以通过请求获得，无法获得就说明无法执行那个请求</strong>。</p><p>现在绝大多数的RESTful接口都做到了Level2的层次，做到Level3的比较少。当然，<strong>这个模型并不是一种规范，只是用来理解Restful的工具</strong>。所以，做到了Level2，也就是<strong>面向资源</strong>和<strong>使用Http动词</strong>，就已经很Restful了。<strong>Restful本身也不是一种规范</strong>，我比较倾向于用“<strong>风格</strong>“来形容它。如果你想深入了解Level3，可以阅读《Rest in Practice》第五章。</p><p>2、</p><p>我跟老婆讲的时候，用的数据格式是JSON，但是要强调一点，Restful对数据格式没有限制，就算你用的是XML或者其他格式，只要符合上面提到的几个特征，也算Restful。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下文章来源于：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30396391&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;如何给老婆解释什么是RESTful&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;老婆经常喜欢翻看我订阅的技术杂志，她总能从她的视角提出很多有趣的问题。&lt;/p&gt;
&lt;p&gt;一个悠闲的周日下午，她午觉醒来，又习惯性的抓起这个月的杂志，饶有兴趣地看了起来。&lt;/p&gt;
&lt;p&gt;果不其然，看着看着，她又对我发难了，“Restful是什么呀，老公？是restaurant的形容词吗，突然就觉得好饿了啊……”&lt;/p&gt;
    
    </summary>
    
      <category term="Restful" scheme="http://changsk.top/categories/Restful/"/>
    
    
      <category term="restful" scheme="http://changsk.top/tags/restful/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出理解基于 Kafka 和 ZooKeeper 的分布式消息队列</title>
    <link href="http://changsk.top/2019/06/17/kafka-zookeeper/"/>
    <id>http://changsk.top/2019/06/17/kafka-zookeeper/</id>
    <published>2019-06-17T03:46:08.000Z</published>
    <updated>2019-06-17T13:06:35.284Z</updated>
    
    <content type="html"><![CDATA[<p>消息队列中间件是分布式系统中重要的组件，主要解决<strong>应用耦合</strong>(使消息的生产者和消费者解耦)，<strong>异步消息</strong>（消息的生产和消费是异步的），<strong>流量削峰</strong>等问题。实现<strong>高性能，高可用，可伸缩和最终一致性架构</strong>，是大型分布式系统不可缺少的中间件。</p><a id="more"></a><p><strong>本场 Chat 主要内容：</strong></p><ul><li>Kafka 的架构解读；</li><li>Kafka 为什么要将 Topic 进行分区；</li><li>Kafka 高可靠性实现基础解读；</li><li>Kafka 复制原理和同步方式；</li><li>Leader 选举机制，及如何确保新选举出的 Leader 是优选；</li><li>同步副本 ISR；</li><li>Kafka 数据可靠性和持久性保证；</li><li>深入解读 HW 机制；</li><li>Kafka 架构中 ZooKeeper 以怎样的形式存在；</li><li>全程解析：Producer -&gt; kafka -&gt; consumer。</li></ul><p><strong>相关内容链接：</strong></p><ol><li><a href="https://gitbook.cn/gitchat/column/5b7d127b84322801444db274" target="_blank" rel="noopener">《分布式中间件实践之路》</a></li><li><a href="https://gitbook.cn/gitchat/column/5ad56a79af8f2f35290f6535" target="_blank" rel="noopener">《Python 快速入门实战教程》</a></li><li><a href="https://gitbook.cn/gitchat/activity/5ba904caf934bf2b6d5596da" target="_blank" rel="noopener">《分布式锁的最佳实践之：基于 Etcd 的分布式锁》</a></li><li><a href="https://gitbook.cn/gitchat/activity/5b3d91c56edf9d4ff8ee21c4" target="_blank" rel="noopener">《基于 Redis 的分布式锁实现及踩坑案例》</a></li><li><a href="https://gitbook.cn/gitchat/activity/5b0586f9c2716f0a6df46a99" target="_blank" rel="noopener">《一个高可靠性商用 Redis 集群方案介绍》</a></li></ol><hr><h3 id="1-Kafka-总体架构"><a href="#1-Kafka-总体架构" class="headerlink" title="1. Kafka 总体架构"></a>1. Kafka 总体架构</h3><p>基于 Kafka-ZooKeeper 的分布式消息队列系统总体架构如下：</p><p><img src="1.jpg" alt="enter image description here"></p><p>如上图所示，一个典型的 Kafka 体系架构包括若干 <strong>Producer（消息生产者）</strong>，若干 <strong>broker（作为 Kafka 节点的服务器</strong>），若干 <strong>Consumer（Group）</strong>，以及一个 <strong>ZooKeeper 集群</strong>。<strong>Kafka通过 ZooKeeper 管理集群配置、选举 Leader 以及在 consumer group 发生变化时进行 Rebalance（即消费者负载均衡，在下一课介绍）。Producer 使用 push（推）模式将消息发布到 broker，Consumer 使用 pull（拉）模式从 broker 订阅并消费消息。</strong></p><p>上图仅描摹了一个总体架构，并没有对作为 Kafka 节点的 broker 进行深入刻画，事实上，它的内部细节相当复杂，如下图所示，Kafka 节点涉及 <strong>Topic</strong>、<strong>Partition</strong> 两个重要概念。</p><p><img src="2.jpg" alt="enter image description here"></p><p>在 Kafka 架构中，有几个术语：</p><ul><li><strong>Producer</strong>：生产者，即消息发送者，push 消息到 Kafka 集群中的 broker（就是 server）中；</li><li><strong>Broker</strong>：Kafka 集群由多个 Kafka 实例（server） 组成，每个实例构成一个 broker，说白了就是服务器；</li><li><strong>Topic</strong>：producer 向 kafka 集群 push 的消息会被归于某一类别，即Topic，这本质上只是一个<strong>逻辑概念</strong>，面向的对象是 producer 和 consumer，producer 只需要关注将消息 push 到哪一个 Topic 中，而 consumer 只需要关心自己订阅了哪个 Topic；</li><li><strong>Partition</strong>：<strong>每一个 Topic 又被分为多个 Partitions</strong>，<strong>即物理分区</strong>；出于负载均衡的考虑，<strong>同一个 Topic 的 Partitions 分别存储于 Kafka 集群的多个 broker 上</strong>；而为了提高可靠性，<strong>这些 Partitions 可以由 Kafka 机制中的 replicas 来设置备份的数量</strong>；如上面的框架图所示，每个 partition 都存在两个备份；</li><li><strong>Consumer</strong>：消费者，从 Kafka 集群的 broker 中 pull 消息、消费消息；</li><li><strong>Consumer group</strong>：high-level consumer API 中，<strong>每个 consumer 都属于一个 consumer-group</strong>，<strong>每条消息只能被 consumer-group 中的一个 Consumer 消费</strong>，<strong>但可以被多个 consumer-group 消费</strong>；</li><li><strong>replicas</strong>：<strong>partition 的副本</strong>，保障 partition 的<strong>高可用</strong>；</li><li><strong>leader</strong>：<strong>replicas 中的一个角色， producer 和 consumer 只跟 leader 交互；</strong></li><li><strong>follower</strong>：replicas 中的一个角色，<strong>从 leader 中复制数据，作为副本，一旦 leader 挂掉，会从它的 followers 中选举出一个新的 leader 继续提供服务</strong>；</li><li><strong>controller</strong>：Kafka 集群中的其中一个服务器，用来进行 leader election 以及 各种 failover(故障转移)；</li><li><strong>ZooKeeper</strong>：Kafka 通过 ZooKeeper 来存储集群的 meta 信息等，文中将详述。</li></ul><h4 id="1-1-Topic-amp-Partition"><a href="#1-1-Topic-amp-Partition" class="headerlink" title="1.1 Topic &amp; Partition"></a>1.1 Topic &amp; Partition</h4><p><strong>一个 topic 可以认为是一类消息</strong>，<strong>每个 topic 将被分成多个 partition</strong>，<strong>每个 partition 在存储层面是 append log 文件</strong>。任何发布到此 partition 的消息都会被追加到log文件的尾部，每条消息在文件中的位置称为 offset（偏移量），<strong>offset 为一个 long 型的数字，它唯一标记一条消息</strong>。 Kafka 机制中，producer push 来的消息是追加（append）到 partition 中的，这是一种<strong>顺序写磁盘</strong>的机制，效率远高于随机写内存，如下示意图：</p><p><img src="3.jpg" alt="enter image description here"></p><h4 id="1-2-Kafka-为什么要将-Topic-进行分区？"><a href="#1-2-Kafka-为什么要将-Topic-进行分区？" class="headerlink" title="1.2 Kafka 为什么要将 Topic 进行分区？"></a>1.2 Kafka 为什么要将 Topic 进行分区？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">简而言之：负载均衡 + 水平扩展。</span><br></pre></td></tr></table></figure><p>前已述及，<strong>Topic 只是逻辑概念</strong>，面向的是 producer 和 consumer；而 <strong>Partition 则是物理概念</strong>。可以想象，如果 Topic 不进行分区，而将 Topic 内的消息存储于一个 broker，那么关于该 Topic 的所有读写请求都将由这一个 broker 处理，<strong>吞吐量很容易陷入瓶颈</strong>，这显然是不符合高吞吐量应用场景的。有了 Partition 概念以后，假设一个 Topic 被分为 10 个 Partitions，Kafka 会根据一定的算法将 10 个 Partition 尽可能均匀的分布到不同的 broker（服务器）上，当 producer 发布消息时，producer 客户端可以采用 <code>random</code>、<code>key-hash</code> 及 <code>轮询</code> 等算法选定目标 partition，若不指定，Kafka 也将根据一定算法将其置于某一分区上。<strong>Partiton 机制可以极大的提高吞吐量，并且使得系统具备良好的水平扩展能力。</strong></p><p>在创建 topic 时可以在 <code>$KAFKA_HOME/config/server.properties</code> 中指定这个 partition 的数量（如下所示），当然可以在 topic 创建之后去修改 partition 的数量。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The default number of log partitions per topic. More partitions allow greater</span></span><br><span class="line"><span class="comment"># parallelism for consumption, but this will also result in more files across</span></span><br><span class="line"><span class="comment"># the brokers.</span></span><br><span class="line"><span class="attr">num.partitions</span>=<span class="number">3</span></span><br></pre></td></tr></table></figure><p>在发送一条消息时，可以<strong>指定这个消息的 key</strong>，producer 根据这个 key 和 partition 机制来判断这个消息发送到哪个partition。partition 机制可以通过指定 producer 的 partition.class 这一参数来指定（即支持自定义），该 class 必须实现 kafka.producer.Partitioner 接口。</p><p>有关 topic 与 partition 的更多细节，可以参考下面的“Kafka 文件存储机制”这一节。</p><h3 id="2-Kafka-高可靠性实现基础解读"><a href="#2-Kafka-高可靠性实现基础解读" class="headerlink" title="2. Kafka 高可靠性实现基础解读"></a>2. Kafka 高可靠性实现基础解读</h3><p>谈及可靠性，最常规、最有效的策略就是 “<strong>副本（replication）机制</strong>” ，Kafka 实现高可靠性同样采用了该策略。通过调节副本相关参数，可使 Kafka 在性能和可靠性之间取得平衡。本节先从 Kafka 文件存储机制入手，从最底层了解 Kafka 的存储细节，进而对消息的存储有个微观的认知。之后通过介绍 Kafka 的<strong>复制原理</strong>和<strong>同步方式</strong>来阐述宏观层面的概念。最后介绍 <strong>ISR</strong>，<strong>HW</strong> 和 <strong>leader</strong> 选举。</p><h4 id="2-1-Kafka-文件存储机制"><a href="#2-1-Kafka-文件存储机制" class="headerlink" title="2.1 Kafka 文件存储机制"></a>2.1 Kafka 文件存储机制</h4><p>Kafka 中消息是以 topic 进行分类的，生产者通过 topic 向 Kafka broker 发送消息，消费者通过 topic 读取数据。然而 <strong>topic 在物理层面又能以 partition 为分组</strong>，一个 topic 可以分成若干个 partition。事实上，partition 并不是最终的存储粒度，<strong>partition 还可以细分为 segment</strong>，<strong>一个 partition 物理上由多个 segment 组成</strong>，那么这些 segment 又是什么呢？</p><p>为了便于说明问题，假设这里只有一个 Kafka 集群，且这个集群只有一个 Kafka broker，即只有一台物理机。在这个 Kafka broker 中配置 <code>log.dirs=/tmp/kafka-logs</code>，以此来设置 Kafka 消息文件存储目录；与此同时，通过命令创建一个 topic：mytopic_test，partition 的数量配置为 4（创建 topic 的命令请见上一课）。之后，可以在 <code>/tmp/kafka-logs</code> 目录中可以看到生成了 4 个目录：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-x<span class="number"> 2 </span>root root<span class="number"> 4096 </span>Apr<span class="number"> 15 </span>13:21 mytopic_test-0</span><br><span class="line">drwxr-xr-x<span class="number"> 2 </span>root root<span class="number"> 4096 </span>Apr<span class="number"> 15 </span>13:21 mytopic_test-1</span><br><span class="line">drwxr-xr-x<span class="number"> 2 </span>root root<span class="number"> 4096 </span>Apr<span class="number"> 15 </span>13:21 mytopic_test-2</span><br><span class="line">drwxr-xr-x<span class="number"> 2 </span>root root<span class="number"> 4096 </span>Apr<span class="number"> 15 </span>13:21 mytopic_test-3</span><br></pre></td></tr></table></figure><p>在 Kafka 文件存储中，同一个 topic 下有多个不同的 partition，每个 partiton 为一个目录，partition 的名称规则为：topic 名称 + 有序序号，第一个序号从 0 开始计，最大的序号为 partition 数量减 1，<strong>partition 是实际物理上的概念，而 topic 是逻辑上的概念。</strong></p><p><strong>问题 1：为什么不能以 partition 作为存储单位？</strong></p><p>上面提到 partition 还可以细分为 segment，这个 segment 又是什么？如果就以 partition 为最小存储单位，可以想象，当 Kafka producer 不断发送消息，必然会引起 <strong>partition 文件的无限扩张</strong>，将对消息文件的维护以及已消费的消息的清理带来严重的影响，因此，需以 segment 为单位将 partition 进一步细分。<strong>每个 partition（目录）相当于一个巨型文件被平均分配到多个大小相等的 segment（段）数据文件中</strong>（每个 segment 文件中消息数量不一定相等）这种特性也方便 old segment 的删除，即方便已被消费的消息的清理，提高磁盘的利用率。每个 partition 只需要支持顺序读写就行，segment 的文件生命周期由服务端配置参数（log.segment.bytes，log.roll.{ms,hours} 等若干参数）决定。</p><p><strong>问题 2：segment 的工作原理是怎样的？</strong></p><p>segment 文件由两部分组成，分别为 “<strong>.index</strong>” 文件和 “<strong>.log</strong>” 文件，分别表示为 <strong>segment 索引文件和数据文件。</strong>这两个文件的命令规则为：partition 全局的第一个 segment 从 0 开始，后续每个 segment 文件名为上一个 segment 文件最后一条消息的 offset 值，数值大小为 64 位，20 位数字字符长度，没有数字用 0 填充，如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000000000000000</span>.index</span><br><span class="line"><span class="number">00000000000000000000</span>.log</span><br><span class="line"><span class="number">00000000000000170410</span>.index</span><br><span class="line"><span class="number">00000000000000170410</span>.log</span><br><span class="line"><span class="number">00000000000000239430</span>.index</span><br><span class="line"><span class="number">00000000000000239430</span>.log</span><br></pre></td></tr></table></figure><p>以上面的 segment 文件为例，展示出 segment：00000000000000170410 的 “.index” 文件和 “.log” 文件的对应的关系，如下图：</p><p><img src="4.jpg" alt="enter image description here"></p><p>如上图，<strong>“.index” 索引文件存储大量的元数据</strong>，<strong>“.log” 数据文件存储大量的消息</strong>，<strong>索引文件中的元数据指向对应数据文件中 message 的物理偏移地址</strong>。其中以 “.index” 索引文件中的元数据 [3, 348] 为例，在 “.log” 数据文件表示第 3 个消息，即在全局 partition 中表示 170410+3=170413 个消息，该消息的物理偏移地址为 348。</p><p><strong>问题 3：如何从 partition 中通过 offset 查找 message 呢？</strong></p><p>以上图为例，读取 offset=170418 的消息，首先查找 segment 文件，其中 00000000000000000000.index 为最开始的文件，第二个文件为 00000000000000170410.index（起始偏移为 170410+1=170411），而第三个文件为 00000000000000239430.index（起始偏移为 239430+1=239431），所以这个 offset=170418 就落到了第二个文件之中。其它后续文件可以依次类推，以其偏移量命名并排列这些文件，然后根据<strong>二分查找</strong>法就可以快速定位到具体文件位置。其次根据 00000000000000170410.index 文件中的 [8,1325] 定位到 00000000000000170410.log 文件中的 1325 的位置进行读取。</p><p>要是读取 offset=170418 的消息，从 00000000000000170410.log 文件中的 1325 的位置进行读取，那么，如何确定何时读完本条消息呢？（否则就读到下一条消息的内容了）</p><p>这个问题由<strong>消息的物理结构</strong>解决，<strong>消息都具有固定的物理结构</strong>，包括：offset（8 Bytes）、消息体的大小（4 Bytes）、crc32（4 Bytes）、magic（1 Byte）、attributes（1 Byte）、key length（4 Bytes）、key（K Bytes）、payload（N Bytes）等等字段，可以确定一条消息的大小，即读取到哪里截止。</p><h4 id="2-2-复制原理和同步方式"><a href="#2-2-复制原理和同步方式" class="headerlink" title="2.2 复制原理和同步方式"></a>2.2 复制原理和同步方式</h4><p>Kafka 中 topic 的每个 partition 有一个预写式的日志文件，虽然 partition 可以继续细分为若干个 segment 文件，但是对于上层应用来说，仍然可以将 partition 看成最小的存储单元（一个有多个 segment 文件拼接的 “巨型” 文件），每个 partition 都由一些列有序的、不可变的消息组成，这些消息被连续的追加到 partition 中。</p><p><img src="5.jpg" alt="enter image description here"></p><p>上图中有两个新名词：HW 和 LEO。这里先介绍下 <strong>LEO，LogEndOffset 的缩写</strong>，表示每个 partition 的 log 最后一条 Message 的位置。<strong>HW 是 HighWatermark 的缩写</strong>，是指 consumer 能够看到的此 partition 的位置，这个涉及到多副本的概念，这里先提及一下，下文再详述。</p><p>言归正传，为了提高消息的可靠性，<strong>Kafka 每个 topic 的 partition 有 N 个副本（replicas）</strong>，其中 N（大于等于 1）是 topic 的复制因子（replica fator）的个数。<strong>Kafka 通过多副本机制实现故障自动转移</strong>，当 Kafka 集群中出现 broker 失效时，副本机制可保证服务可用。对于任何一个 partition，<strong>它的 N 个 replicas 中，其中一个 replica 为 leader，其他都为 follower，leader 负责处理 partition 的所有读写请求，follower 则负责被动地去复制 leader 上的数据</strong>。如下图所示，Kafka 集群中有 4 个 broker，某 topic 有 3 个 partition，且复制因子即副本个数也为 3：</p><p><img src="6.jpg" alt="enter image description here"></p><p>如果 leader 所在的 broker 发生故障或宕机，对应 partition 将因无 leader 而不能处理客户端请求，这时副本的作用就体现出来了：一个新 leader 将从 follower 中被选举出来并继续处理客户端的请求。</p><p><strong>如何确保新选举出的 leader 是优选呢？</strong></p><p>一个 partition 有多个副本（replicas），为了提高可靠性，<strong>这些副本分散在不同的 broker 上</strong>，由于带宽、读写性能、网络延迟等因素，同一时刻，这些<strong>副本的状态通常是不一致的</strong>：即 <strong>followers 与 leader 的状态不一致</strong>。那么，如何保证新选举出的 leader 是优选呢？ Kafka 机制中，leader 将负责维护和跟踪一个 <strong>ISR（In-Sync Replicas</strong>）列表，即<strong>同步副本队列</strong>，这个<strong>列表里面的副本与 leader 保持同步，状态一致</strong>。如果新的 leader 从 ISR 列表中的副本中选出，那么就可以保证新 leader 为优选。当然，这不是唯一的策略，下文将继续解读。</p><h4 id="2-3-同步副本-ISR"><a href="#2-3-同步副本-ISR" class="headerlink" title="2.3 同步副本 ISR"></a>2.3 同步副本 ISR</h4><p>上一节中讲到了<strong>同步副本队列 ISR（In-Sync Replicas）</strong>。虽然副本极大的增强了可用性，但是副本数量对 Kafka 的吞吐率有一定影响。<strong>默认情况下 Kafka 的 replica 数量为 1，即每个 partition 都只有唯一的 leader，无 follower，没有容灾能力</strong>。为了确保消息的可靠性，生产环境中，通常将其值（由 broker 的参数 offsets.topic.replication.factor 指定）大小设置为大于 1，比如 3。 <strong>所有的副本（replicas）统称为 Assigned Replicas，即 AR</strong>。<strong>ISR 是 AR 中的一个子集</strong>，<strong>由 leader 维护 ISR 列表</strong>，follower 从 leader 同步数据有一些延迟（由参数 replica.lag.time.max.ms <strong>设置超时阈值</strong>），<strong>超过阈值的 follower 将被剔除出 ISR， 存入 OSR（Outof-Sync Replicas）</strong>列表，新加入的 follower 也会先存放在 OSR 中。<strong>AR=ISR+OSR。</strong></p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注：ISR中包括：<span class="built_in">leader</span> + 与<span class="built_in">leader</span>保持同步的followers。</span><br></pre></td></tr></table></figure><p>上面一节还涉及到一个概念，即 HW。<strong>HW 俗称高水位</strong>，HighWatermark 的缩写，<strong>取一个 partition 对应的 ISR 中最小的 LEO 作为 HW</strong>，<strong>consumer 最多只能消费到 HW 所在的位置</strong>。另外每个 replica 都有 HW，leader 和 follower 各自负责更新自己的 HW 的状态。<strong>对于 leader 新写入的消息，consumer 不能立刻消费，leader 会等待该消息被所有 ISR 中的 replicas 同步后更新 HW，此时消息才能被 consumer 消费。这样就保证了如果 leader 所在的 broker 失效，该消息仍然可以从新选举的 leader 中获取。对于来自内部 broker 的读取请求，没有 HW 的限制。</strong></p><p>下图详细的说明了当 producer 生产消息至 broker 后，ISR 以及 HW 和 LEO 的流转过程：</p><p><img src="7.jpg" alt="enter image description here"></p><p>由此可见，Kafka 的复制机制<strong>既不是完全的同步复制</strong>，<strong>也不是单纯的异步复制</strong>。事实上，<strong>同步复制要求所有能工作的 follower 都复制完，这条消息才会被 commit</strong>，这种复制方式受限于复制最慢的 follower，会极大的影响吞吐率。而<strong>异步复制方式下，follower 异步的从 leader 复制数据，数据只要被 leader 写入 log 就被认为已经 commit</strong>，这种情况下如果 follower 都还没有复制完，落后于 leader 时，突然 leader 宕机，则会丢失数据，降低可靠性。而 Kafka 使用 <strong>ISR</strong> 的策略则在可靠性和吞吐率方面取得了较好的平衡。</p><p>Kafka 的 ISR 的管理最终都会反馈到 ZooKeeper 节点上，具体位置为：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/brokers/topics/[topic]/partitions/[partition]/<span class="keyword">state</span></span><br></pre></td></tr></table></figure><p>目前，有两个地方会对这个 ZooKeeper 的节点进行维护。</p><ol><li>Controller 来维护：<strong>Kafka 集群中的其中一个 Broker 会被选举为 Controller</strong>，<strong>主要负责 Partition 管理和副本状态管理</strong>，也会执行类似于重分配 partition 之类的管理任务。在符合某些特定条件下，Controller 下的 LeaderSelector 会选举新的 leader，ISR 和新的 <code>leader_epoch</code> 及 <code>controller_epoch</code> 写入 ZooKeeper 的相关节点中。同时发起 LeaderAndIsrRequest 通知所有的 replicas。</li><li>leader 来维护：leader 有单独的线程定期检测 ISR 中 follower 是否脱离 ISR，如果发现 ISR 变化，则会将新的 ISR 的信息返回到 ZooKeeper 的相关节点中。</li></ol><h4 id="2-4-数据可靠性和持久性保证"><a href="#2-4-数据可靠性和持久性保证" class="headerlink" title="2.4 数据可靠性和持久性保证"></a>2.4 数据可靠性和持久性保证</h4><p>当 producer 向 leader 发送数据时，可以通过 request.required.acks 参数来设置数据<strong>可靠性的级别</strong>：</p><p><strong>1. request.required.acks = 1</strong></p><p>这是<strong>默认情况</strong>，即：<strong>producer 发送数据到 leader，leader 写本地日志成功，返回客户端成功；此时 ISR 中的其它副本还没有来得及拉取该消息，如果此时 leader 宕机了，那么此次发送的消息就会丢失。</strong></p><p><strong>2. request.required.acks = 0</strong></p><p><strong>producer 不停向leader发送数据，而不需要 leader 反馈成功消息，这种情况下数据传输效率最高，但是数据可靠性确是最低的。可能在发送过程中丢失数据，可能在 leader 宕机时丢失数据。</strong></p><p><strong>3. request.required.acks = -1（all）</strong></p><p><strong>producer 发送数据给 leader，leader 收到数据后要等到 ISR 列表中的所有副本都同步数据完成后（强一致性），才向生产者返回成功消息，如果一直收不到成功消息，则认为发送数据失败会自动重发数据。这是可靠性最高的方案，当然，性能也会受到一定影响。</strong></p><p>*<em>注意：参数 min.insync.replicas *</em></p><p>如果要提高数据的可靠性，在设置 request.required.acks=-1 的同时，还需参数 min.insync.replicas 配合，如此才能发挥最大的功效。min.insync.replicas 这个参数用于设定 ISR 中的最小副本数，默认值为1，当且仅当 request.required.acks 参数设置为-1时，此参数才生效。当 ISR 中的副本数少于 min.insync.replicas 配置的数量时，客户端会返回异常：<code>org.apache.kafka.common.errors.NotEnoughReplicasExceptoin: Messages are rejected since there are fewer in-sync replicas than required</code>。不难理解，如果 min.insync.replicas 设置为 2，当 ISR 中实际副本数为 1 时（只有leader），将无法保证可靠性，此时拒绝客户端的写请求以防止消息丢失。</p><h4 id="2-5-深入解读-HW-机制"><a href="#2-5-深入解读-HW-机制" class="headerlink" title="2.5 深入解读 HW 机制"></a>2.5 深入解读 HW 机制</h4><p>考虑这样一种场景：acks=-1，部分 ISR 副本完成同步，此时leader挂掉，如下图所示：follower1 同步了消息 4、5，follower2 同步了消息 4，与此同时 follower2 被选举为 leader，那么此时 follower1 中的多出的消息 5 该做如何处理呢？</p><p><img src="8.jpg" alt="enter image description here"></p><p>这里就需要 HW 的协同配合了。如前所述，一个 partition 中的 ISR 列表中，<strong>leader 的 HW 是所有 ISR 列表里副本中最小的那个的 LEO</strong>。类似于木桶原理，水位取决于最低那块短板。</p><p><img src="9.jpg" alt="enter image description here"></p><p>如上图，某个 topic 的某 partition 有三个副本，分别为 A、B、C。A 作为 leader 肯定是 LEO 最高，B 紧随其后，C 机器由于配置比较低，网络比较差，故而同步最慢。这个时候 A 机器宕机，这时候如果 B 成为 leader，假如没有 HW，在 A 重新恢复之后会做同步（makeFollower) 操作，在宕机时 log 文件之后直接做追加操作，而假如 B 的 LEO 已经达到了 A 的 LEO，会产生数据不一致的情况，所以使用 HW 来避免这种情况。 A 在做同步操作的时候，先将 log 文件截断到之前自己的 HW 的位置，即 3，之后再从 B 中拉取消息进行同步。</p><p><strong>如果失败的 follower 恢复过来，它首先将自己的 log 文件截断到上次 checkpointed 时刻的 HW 的位置，之后再从 leader 中同步消息。leader 挂掉会重新选举，新的 leader 会发送 “指令” 让其余的 follower 截断至自身的 HW 的位置然后再拉取新的消息。</strong></p><p>当 ISR 中的个副本的 LEO 不一致时，如果此时 leader 挂掉，选举新的 leader 时并不是按照 LEO 的高低进行选举，而是按照 ISR 中的<strong>顺序选举</strong>。</p><h4 id="2-6-Leader-选举"><a href="#2-6-Leader-选举" class="headerlink" title="2.6 Leader 选举"></a>2.6 Leader 选举</h4><p>为了保证可靠性，对于任意一条消息，<strong>只有它被 ISR 中的所有 follower 都从 leader 复制过去才会被认为已提交</strong>，并返回信息给 producer。如此，可以避免因部分数据被写进 leader，而尚未被任何 follower 复制就宕机的情况下而造成数据丢失。对于 producer 而言，它可以选择是否等待消息 commit，这可以通过参数 <strong>request.required.acks</strong> 来设置。这种机制可以确保：只要 ISR 中有一个或者以上的 follower，一条被 commit 的消息就不会丢失。</p><p><strong>问题 1：如何在保证可靠性的前提下避免吞吐量下降？</strong></p><p>有一个很重要的问题是当 leader 宕机了，怎样在 follower 中选举出新的 leader，因为 follower 可能落后很多或者直接 crash 了，所以必须确保选择 “最新” 的 follower 作为新的 leader。一个基本的原则就是，如果 leader 挂掉，新的 leader 必须拥有原来的 leader 已经 commit 的所有消息，这不就是 ISR 中副本的特征吗？</p><p>但是，存在一个问题，ISR 列表维持多大的规模合适呢？换言之，<strong>leader 在一个消息被 commit 前需要等待多少个 follower 确认呢</strong>？等待 follower 的数量越多，与 leader 保持同步的 follower 就越多，可靠性就越高，但这也会造成吞吐率的下降。</p><p><strong>少数服从多数的选举原则</strong></p><p>一种常用的选举 leader 的策略是 “<strong>少数服从多数</strong>” ，不过，Kafka 并不是采用这种方式。这种模式下，如果有 2f+1 个副本，那么在 commit 之前必须保证有 f+1 个 replica 复制完消息，同时为了保证能正确选举出新的 leader，失败的副本数不能超过 f 个。这种方式有个很大的优势，系统的延迟取决于最快的几台机器，也就是说比如副本数为 3，那么延迟就取决于最快的那个 follower 而不是最慢的那个。</p><p>“少数服从多数” 的策略也有一些劣势，为了保证 leader 选举的正常进行，它所能容忍的失败的 follower 数比较少，如果要容忍 1 个 follower 挂掉，那么至少要 3 个以上的副本，如果要容忍 2 个 follower 挂掉，必须要有 5 个以上的副本。也就是说，<strong>在生产环境下为了保证较高的容错率，必须要有大量的副本，而大量的副本又会在大数据量下导致性能的急剧下降</strong>。这种算法更多用在 ZooKeeper 这种共享集群配置的系统中，而很少在需要大量数据的系统中使用。</p><p><strong>Kafka 选举 leader 的策略是怎样的？</strong></p><p>实际上，leader 选举的算法非常多，比如 ZooKeeper 的 Zab、Raft 以及 Viewstamped Replication。而 Kafka 所使用的 leader 选举算法更像是微软的 PacificA 算法。</p><p><strong>Kafka 在 ZooKeeper 中为每一个 partition 动态的维护了一个 ISR，这个 ISR 里的所有 replica 都与 leader 保持同步，只有 ISR 里的成员才能有被选为 leader 的可能</strong>（通过参数配置：<code>unclean.leader.election.enable=false</code>）。在这种模式下，<strong>对于 f+1 个副本，一个 Kafka topic 能在保证不丢失已经 commit 消息的前提下容忍 f 个副本的失败</strong>，在大多数使用场景下，这种模式是十分有利的。事实上，<strong>对于任意一条消息，只有它被 ISR 中的所有 follower 都从 leader 复制过去才会被认为已提交，并返回信息给 producer，从而保证可靠性</strong>。但与 “少数服从多数” 策略不同的是，<strong>Kafka ISR 列表中副本的数量不需要超过副本总数的一半，即不需要满足 “多数派” 原则，通常，ISR 列表副本数大于等于 2 即可，如此，便在可靠性和吞吐量方面取得平衡。</strong></p><p><strong>极端情况下的 leader 选举策略</strong></p><p>前已述及，当 ISR 中至少有一个 follower 时（<strong>ISR 包括 leader</strong>），Kafka 可以确保已经 commit 的消息不丢失，但如果某一个 partition 的所有 replica 都挂了，自然就无法保证数据不丢失了。这种情况下如何进行 leader 选举呢？通常有两种方案：</p><ol><li>等待 ISR 中任意一个 replica 恢复过来，并且选它作为 leader；</li><li><strong>选择第一个恢复过来的 replica（并不一定是在 ISR 中）作为leader。</strong>（默认）</li></ol><p>如何选择呢？这就需要在<strong>可用性和一致性</strong>当中作出抉择。如果一定要等待 ISR 中的 replica 恢复过来，不可用的时间就可能会相对较长。而且如果 ISR 中所有的 replica 都无法恢复了，或者数据丢失了，这个 partition 将永远不可用。</p><p>选择第一个恢复过来的 replica 作为 leader，如果这个 replica 不是 ISR 中的 replica，那么，它可能并不具备所有已经 commit 的消息，从而造成消息丢失。默认情况下，Kafka 采用第二种策略，即 <code>unclean.leader.election.enable=true</code>，也可以将此参数设置为 false 来启用第一种策略。</p><p><code>unclean.leader.election.enable</code> 这个参数对于 leader 的选举、系统的可用性以及数据的可靠性都有至关重要的影响。生产环境中应慎重权衡。</p><h3 id="3-Kafka-架构中-ZooKeeper-以怎样的形式存在？"><a href="#3-Kafka-架构中-ZooKeeper-以怎样的形式存在？" class="headerlink" title="3. Kafka 架构中 ZooKeeper 以怎样的形式存在？"></a>3. Kafka 架构中 ZooKeeper 以怎样的形式存在？</h3><p>ZooKeeper 是一个分布式的、开放源码的<strong>分布式应用程序协调服务</strong>，是 Google 的 Chubby 一个开源的实现。分布式应用程序可以基于它实现统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等工作。在基于 Kafka 的分布式消息队列中，ZooKeeper 的作用有：<strong>broker 注册</strong>、<strong>topic 注册</strong>、<strong>producer 和 consumer 负载均衡、维护 partition 与 consumer 的关系、记录消息消费的进度以及 consumer 注册等。</strong></p><h4 id="3-1-broker-在-ZooKeeper-中的注册"><a href="#3-1-broker-在-ZooKeeper-中的注册" class="headerlink" title="3.1 broker 在 ZooKeeper 中的注册"></a>3.1 broker 在 ZooKeeper 中的注册</h4><ul><li>为了记录 broker 的注册信息，在 ZooKeeper 上，<strong>专门创建了属于 Kafka 的一个节点</strong>，其路径为 /brokers；</li><li>Kafka 的每个 broker 启动时，都会到 ZooKeeper 中进行注册，告诉 ZooKeeper 其 broker.id，在整个集群中，broker.id 应该全局唯一，并在 ZooKeeper 上创建其属于自己的节点，其节点路径为 <code>/brokers/ids/{broker.id}</code>；</li><li>创建完节点后，Kafka 会将该 broker 的 broker.name 及端口号记录到该节点；</li><li>另外，该 <strong>broker 节点属性为临时节点</strong>，<strong>当 broker 会话失效时，ZooKeeper 会删除该节点，这样，我们就可以很方便的监控到broker 节点的变化，及时调整负载均衡等。</strong></li></ul><h4 id="3-2-Topic-在-ZooKeeper-中的注册"><a href="#3-2-Topic-在-ZooKeeper-中的注册" class="headerlink" title="3.2 Topic 在 ZooKeeper 中的注册"></a>3.2 Topic 在 ZooKeeper 中的注册</h4><p>在 Kafka 中，所有 <strong>topic 与 broker 的对应关系都由 ZooKeeper 进行维护</strong>，在 ZooKeeper 中，建立专门的节点来记录这些信息，其节点路径为 <code>/brokers/topics/{topic_name}</code>。 前面说过，为了保障数据的可靠性，<strong>每个 Topic 的 Partitions 实际上是存在备份的</strong>，并且<strong>备份的数量由 Kafka 机制中的 replicas 来控制</strong>。那么问题来了：如下图所示，假设某个 TopicA 被分为 2 个 Partitions，并且存在两个备份，由于这 2 个 Partitions（1-2）被分布在不同的 broker 上，同一个 partiton 与其备份不能（也不应该）存储于同一个 broker 上。以 Partition1 为例，假设它被存储于 broker2，其对应的备份分别存储于 broker1 和 broker4，有了备份，可靠性得到保障，但数据一致性却是个问题。</p><p><img src="10.jpg" alt="enter image description here"></p><p>为了保障数据的一致性，ZooKeeper 机制得以引入。<strong>基于 ZooKeeper，Kafka 为每一个 partition 找一个节点作为 leader，其余备份作为 follower</strong>；接续上图的例子，就 TopicA 的 partition1 而言，如果位于 broker2（Kafka 节点）上的 partition1 为 leader，那么位于 broker1 和 broker4 上面的 partition1 就充当 follower，则有下图：</p><p><img src="11.jpg" alt="enter image description here"></p><p>基于上图的架构，当 producer push 的消息写入 partition（分区) 时，作为 leader 的 broker（Kafka 节点） 会将消息写入自己的分区，同时还会将此消息复制到各个 follower，实现同步。如果，某个follower 挂掉，leader 会再找一个替代并同步消息；如果 leader 挂了，follower 们会选举出一个新的 leader 替代，继续业务，<strong>这些都是由 ZooKeeper 完成的。</strong></p><h4 id="3-3-consumer-在-ZooKeeper-中的注册"><a href="#3-3-consumer-在-ZooKeeper-中的注册" class="headerlink" title="3.3 consumer 在 ZooKeeper 中的注册"></a>3.3 consumer 在 ZooKeeper 中的注册</h4><p><strong>注册新的消费者分组</strong></p><p><strong>当新的消费者组注册到 ZooKeeper 中时，ZooKeeper 会创建专用的节点来保存相关信息</strong>，其节点路径为 <code>ls/consumers/{group_id}</code>，其节点下有三个子节点，分别为 <code>[ids, owners, offsets]</code>。</p><ul><li>ids 节点：记录该消费组中当前正在消费的消费者；</li><li>owners 节点：记录该消费组消费的 topic 信息；</li><li>offsets 节点：<strong>记录每个 topic 的每个分区的 offset</strong>。</li></ul><p><strong>注册新的消费者</strong></p><p>当新的消费者注册到 Kafka 中时，会在 <code>/consumers/{group_id}/ids</code> 节点下创建临时子节点，并记录相关信息。</p><p><strong>监听消费者分组中消费者的变化</strong></p><p>每个消费者都要关注其所属消费者组中消费者数目的变化，即监听 <code>/consumers/{group_id}/ids</code> 下子节点的变化。<strong>一旦发现消费者新增或减少，就会触发消费者的负载均衡。</strong></p><h4 id="3-4-Producers-负载均衡"><a href="#3-4-Producers-负载均衡" class="headerlink" title="3.4 Producers 负载均衡"></a>3.4 Producers 负载均衡</h4><p>对于同一个 topic 的不同 partition，<strong>Kafka会尽力将这些 partition 分布到不同的 broker 服务器上，这种均衡策略实际上是基于 ZooKeeper 实现的</strong>。<strong>在一个 broker 启动时，会首先完成 broker 的注册过程，并注册一些诸如 “有哪些可订阅的 topic” 之类的元数据信息。producers 启动后也要到 ZooKeeper 下注册，创建一个临时节点来监听 broker 服务器列表的变化。由于在 ZooKeeper 下 broker 创建的也是临时节点，当 brokers 发生变化时，producers 可以得到相关的通知，从改变自己的 broker list。其它的诸如 topic 的变化以及broker 和 topic 的关系变化，也是通过 ZooKeeper 的这种 Watcher 监听实现的。</strong></p><p>在生产中，必须指定 topic；但是对于 partition，有两种指定方式：</p><ul><li>明确指定 partition(0-N)，则数据被发送到指定 partition；</li><li>设置为 <code>RD_KAFKA_PARTITION_UA</code>，则 Kafka 会回调 partitioner 进行均衡选取，partitioner 方法需要自己实现。可以轮询或者传入 key 进行 hash。未实现则采用默认的随机方法 <code>rd_kafka_msg_partitioner_random</code> 随机选择。</li></ul><h4 id="3-5-Consumer-负载均衡"><a href="#3-5-Consumer-负载均衡" class="headerlink" title="3.5 Consumer 负载均衡"></a>3.5 Consumer 负载均衡</h4><p><strong>Kafka 保证同一 consumer group 中只有一个 consumer 可消费某条消息</strong>，实际上，Kafka 保证的是稳定状态下<strong>每一个 consumer 实例只会消费某一个或多个特定的数据</strong>，<strong>而某个 partition 的数据只会被某一个特定的 consumer 实例所消费</strong>。这样设计的劣势是无法让同一个 consumer group 里的 consumer 均匀消费数据，优势是每个 consumer 不用都跟大量的 broker 通信，减少通信开销，同时也降低了分配难度，实现也更简单。另外，因为<strong>同一个 partition 里的数据是有序的</strong>，这种设计可以保证每个 partition 里的数据也是有序被消费。</p><p><strong>consumer 数量不等于 partition 数量</strong></p><p>如果某 consumer group 中 consumer 数量少于 partition 数量，则至少有一个 consumer 会消费多个 partition 的数据；如果 consumer 的数量与 partition 数量相同，则正好一个 consumer 消费一个 partition 的数据，而如果 consumer 的数量多于 partition 的数量时，会有部分 consumer 无法消费该 topic 下任何一条消息。</p><p><strong>借助 ZooKeeper 实现负载均衡</strong></p><p>关于负载均衡，对于某些低级别的 API，consumer 消费时必须指定 topic 和 partition，这显然不是一种友好的均衡策略。基于高级别的 API，<strong>consumer 消费时只需制定 topic，借助 ZooKeeper 可以根据 partition 的数量和 consumer 的数量做到均衡的动态配置。</strong></p><p><strong>consumers 在启动时会到 ZooKeeper 下以自己的 conusmer-id 创建临时节点</strong> <code>/consumer/[group-id]/ids/[conusmer-id]</code>，并对 <code>/consumer/[group-id]/ids</code> <strong>注册监听事件</strong>，当消费者发生变化时，同一 group 的其余消费者会得到通知。当然，<strong>消费者还要监听 broker 列表的变化</strong>。librdkafka 通常会将 partition 进行排序后，根据消费者列表，进行轮流的分配。</p><h4 id="3-6-记录消费进度-Offset"><a href="#3-6-记录消费进度-Offset" class="headerlink" title="3.6 记录消费进度 Offset"></a>3.6 记录消费进度 Offset</h4><p>在 consumer 对指定消息 partition 的消息进行消费的过程中，需要定时地将 <strong>partition 消息的消费进度 Offset 记录到 ZooKeeper</strong>上，以便在<strong>该 consumer 进行重启或者其它 consumer 重新接管该消息分区的消息消费权后，能够从之前的进度开始继续进行消息消费</strong>。<strong>Offset 在 ZooKeeper 中由一个专门节点进行记录</strong>，其节点路径为：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#节点内容就是Offset的值。</span><br><span class="line">/consumers/<span class="string">[group_id]</span>/offsets/<span class="string">[topic]</span>/<span class="string">[broker_id-partition_id]</span></span><br></pre></td></tr></table></figure><p>PS：<strong>Kafka 已推荐将 consumer 的 Offset 信息保存在 Kafka 内部的 topic 中</strong>，即：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__consumer_offsets(<span class="name">/brokers/topics/__consumer_offsets</span>)</span><br></pre></td></tr></table></figure><p>并且默认提供了 <code>kafka_consumer_groups.sh</code> 脚本<strong>供用户查看consumer 信息</strong>（命令：<code>sh kafka-consumer-groups.sh –bootstrap-server * –describe –group *</code>）。在当前版本中，offset 存储方式要么存储在本地文件中，要么存储在 broker 端，具体的存储方式取决 <code>offset.store.method</code> 的配置，默认是存储在 broker 端。</p><h4 id="3-7-记录-Partition-与-Consumer-的关系"><a href="#3-7-记录-Partition-与-Consumer-的关系" class="headerlink" title="3.7 记录 Partition 与 Consumer 的关系"></a>3.7 记录 Partition 与 Consumer 的关系</h4><p>consumer group 下有多个 consumer（消费者），对于每个消费者组（consumer group），Kafka都会为其分配一个全局唯一的 group ID，group 内部的所有消费者共享该 ID。<strong>订阅的 topic 下的每个分区只能分配给某个 group 下的一个consumer</strong>（<strong>当然该分区还可以被分配给其它 group</strong>）。同时，Kafka 为每个消费者分配一个 consumer ID，通常采用 <code>hostname:UUID</code> 形式表示。</p><p>在Kafka中，规定了<strong>每个 partition 只能被同组的一个消费者进行消费</strong>，因此，<strong>需要在 ZooKeeper 上记录下 partition 与 consumer 之间的关系</strong>，<strong>每个 consumer 一旦确定了对一个 partition 的消费权力，需要将其 consumer ID 写入到 ZooKeeper 对应消息分区的临时节点</strong>上，例如：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/consumers/<span class="string">[group_id]</span>/owners/<span class="string">[topic]</span>/<span class="string">[broker_id-partition_id]</span></span><br></pre></td></tr></table></figure><p>其中，[<code>broker_id-partition_id</code>] 就是一个消息分区的标识，节点内容就是该消息分区 消费者的 consumer ID。</p><h3 id="4-全程解析（Producer-kafka-consumer）"><a href="#4-全程解析（Producer-kafka-consumer）" class="headerlink" title="4. 全程解析（Producer-kafka-consumer）"></a>4. 全程解析（Producer-kafka-consumer）</h3><h4 id="4-1-producer-发布消息"><a href="#4-1-producer-发布消息" class="headerlink" title="4.1 producer 发布消息"></a>4.1 producer 发布消息</h4><p><strong>producer 采用 push 模式将消息发布到 broker</strong>，<strong>每条消息都被 append 到 patition</strong> 中，属于顺序写磁盘（顺序写磁盘效率比随机写内存要高，保障 kafka 吞吐率）。producer 发送消息到 broker 时，<strong>会根据分区算法选择将其存储到哪一个 partition。</strong></p><p><strong>其路由机制为：</strong></p><ol><li>指定了 patition，则直接使用；</li><li>未指定 patition 但指定 key，通过对 key 进行 hash 选出一个 patition；</li><li>patition 和 key 都未指定，使用轮询选出一个 patition。</li></ol><p><strong>写入流程：</strong></p><ol><li>producer 先从 ZooKeeper 的 “/brokers/…/state” <strong>节点找到该 partition 的leader；</strong></li><li>producer 将消息发送给该 leader；</li><li>leader 将消息写入本地 log；</li><li>followers 从 leader <strong>pull</strong> 消息，写入本地 log 后 leader 发送 <strong>ACK</strong>；</li><li>leader 收到所有 ISR 中的 replica 的 ACK 后，增加 <strong>HW</strong>（high watermark，最后 commit 的 offset） 并向 producer 发送 <strong>ACK</strong>；</li></ol><h4 id="4-2-Broker-存储消息"><a href="#4-2-Broker-存储消息" class="headerlink" title="4.2 Broker 存储消息"></a>4.2 Broker 存储消息</h4><p><strong>物理上把 topic 分成一个或多个 patition</strong>，<strong>每个 patition 物理上对应一个文件夹</strong>（该文件夹存储该 patition 的所有<strong>消息和索引文件</strong>）</p><h4 id="4-3-Consumer-消费消息"><a href="#4-3-Consumer-消费消息" class="headerlink" title="4.3 Consumer 消费消息"></a>4.3 Consumer 消费消息</h4><p>high-level consumer API 提供了 consumer group 的语义，<strong>一个消息只能被 group 内的一个 consumer 所消费，且 consumer 消费消息时不关注 offset，最后一个 offset 由 ZooKeeper 保存</strong>（下次消费时，该group 中的consumer将从offset记录的位置开始消费）。</p><p><strong>注意：</strong></p><ol><li>如果消费线程大于 patition 数量，则有些线程将收不到消息；</li><li>如果 patition 数量大于消费线程数，则有些线程多收到多个 patition 的消息；</li><li>如果一个线程消费多个 patition，则无法保证你收到的消息的顺序，而<strong>一个 patition 内的消息是有序的</strong>。</li></ol><p><strong>consumer 采用 pull 模式从 broker 中读取数据。</strong></p><p><strong>push 模式很难适应消费速率不同的消费者</strong>，因为消息发送速率是由 broker 决定的。它的目标是尽可能以最快速度传递消息，但是这样很容易造成 consumer 来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而 pull 模式则可以根据 consumer 的消费能力以适当的速率消费消息。</p><p>对于 Kafka 而言，pull 模式更合适，它可简化 broker 的设计，consumer 可自主控制消费消息的速率，同时 consumer 可以自己控制消费方式——即可批量消费也可逐条消费，同时还能选择不同的提交方式从而实现不同的传输语义。</p><blockquote><p>上述文章参考自：<a href="https://gitbook.cn/books/5ae1e77197c22f130e67ec4e/index.html" target="_blank" rel="noopener">深入浅出理解基于 Kafka 和 ZooKeeper 的分布式消息队列</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;消息队列中间件是分布式系统中重要的组件，主要解决&lt;strong&gt;应用耦合&lt;/strong&gt;(使消息的生产者和消费者解耦)，&lt;strong&gt;异步消息&lt;/strong&gt;（消息的生产和消费是异步的），&lt;strong&gt;流量削峰&lt;/strong&gt;等问题。实现&lt;strong&gt;高性能，高可用，可伸缩和最终一致性架构&lt;/strong&gt;，是大型分布式系统不可缺少的中间件。&lt;/p&gt;
    
    </summary>
    
      <category term="MQ" scheme="http://changsk.top/categories/MQ/"/>
    
    
      <category term="kafka" scheme="http://changsk.top/tags/kafka/"/>
    
      <category term="zookeeper" scheme="http://changsk.top/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>java中sleep和wait的区别</title>
    <link href="http://changsk.top/2019/06/17/java-sleep-wait/"/>
    <id>http://changsk.top/2019/06/17/java-sleep-wait/</id>
    <published>2019-06-17T02:28:50.000Z</published>
    <updated>2019-06-17T09:45:30.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sleep-amp-wait"><a href="#sleep-amp-wait" class="headerlink" title="sleep()  &amp; wait()"></a>sleep()  &amp; wait()</h2><a id="more"></a><table><thead><tr><th>sleep()方法</th><th>wait()方法</th></tr></thead><tbody><tr><td>sleep()使当前线程进入停滞状态（<strong>阻塞</strong>当前线程，即会发生<strong>上下文的切换</strong>，会有很大的开销），让出CUP的使用，目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会</td><td>wait()方法是Object类里的方法；当一个线程执行到wait()方法时，它就进入到一个和该对象相关的等待池中，<strong>同时失去（释放）了对象的机锁</strong>（暂时失去机锁，wait(long timeout)超时时间到后还需要返还对象锁）；其他线程可以访问</td></tr><tr><td>sleep()是Thread类的static(静态)的方法；因此它不能改变对象的锁，所以当在一个synchronized块中调用sleep()方法是，线程虽然休眠了，但是<strong>对象的机锁并没有被释放</strong>，其他线程无法获取对象锁（即使睡着也持有对象锁）</td><td>wait()使用notify或者notifyAlll或者指定睡眠时间来唤醒当前等待池中的线程</td></tr><tr><td>在sleep()休眠时间期满后，该线程不一定会立即执行，这是因为其它线程可能正在运行而且没有被调度为放弃执行，除非此线程具有更高的优先级</td><td>wait()必须放在synchronized block中，否则会在program runtime时抛出”java.lang.IllegalMonitorStateException“异常</td></tr><tr><td>## 区别</td><td></td></tr><tr><td><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sleep</span>（）和<span class="built_in">wait</span>()这两个函数被调用之后线程都应该放弃执行权，不同的是<span class="built_in">sleep</span>（）不释放锁而<span class="built_in">wait</span>（）的话是释放锁。直白的意思是一个线程调用<span class="built_in">Sleep</span>（）之后进入了阻塞状态，它的意思就是当<span class="built_in">sleep</span>()状态超时，线程重新转入可运行(runnable)状态。而<span class="built_in">Wait</span>（）在释放执行权之后也把锁释放了,通过<span class="built_in">notify</span>()或者<span class="built_in">notifyAll</span>()或者指定睡眠时间来唤醒后，它要运行的话还是要和其他的线程去竞争锁，之后才可以获得执行权。</span><br></pre></td></tr></table></figure></td><td></td></tr></tbody></table><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">所以<span class="selector-tag">sleep</span>()和<span class="selector-tag">wait</span>()方法的最大区别是： </span><br><span class="line">　<span class="selector-tag">sleep</span>()睡眠时，保持对象锁，仍然占有该锁； </span><br><span class="line">　而<span class="selector-tag">wait</span>()睡眠时，释放对象锁。 </span><br><span class="line">　但是<span class="selector-tag">wait</span>()和<span class="selector-tag">sleep</span>()都可以通过<span class="selector-tag">interrupt</span>()方法打断线程的暂停状态，从而使线程立刻抛出<span class="selector-tag">InterruptedException</span>（但不建议使用该方法）。</span><br></pre></td></tr></table></figure><h2 id="Java中sleep方法的几个注意点"><a href="#Java中sleep方法的几个注意点" class="headerlink" title="Java中sleep方法的几个注意点"></a>Java中sleep方法的几个注意点</h2><ul><li>Thread.sleep()方法用来暂停线程的执行，将CPU放给线程调度器。</li><li>Thread.sleep()方法是一个静态方法，它暂停的是当前执行的线程。</li><li>Java有两种sleep方法，一个只有一个毫秒参数，另一个有毫秒和纳秒两个参数。</li><li>与wait方法不同，sleep方法不会释放锁。</li><li>如果其他的线程中断了一个休眠的线程，sleep方法会抛出Interrupted Exception。</li><li>休眠的线程在唤醒之后不保证能获取到CPU，它会先进入就绪态，与其他线程竞争CPU。</li><li>有一个易错的地方，当调用t.sleep()的时候，会暂停线程t。这是不对的，因为Thread.sleep是一个静态方法，它会使当前线程而不是线程t进入休眠状态。</li><li>wait方法必须正在同步环境下使用，比如synchronized方法或者同步代码块。如果你不在同步条件下使用，会抛出IllegalMonitorStateException异常。另外，sleep方法不需要再同步条件下调用，你可以任意正常的使用。</li><li>wait方法用于和定义于Object类的，而sleep方法操作于当前线程，定义在java.lang.Thread类里面。</li></ul><p>参考自：</p><blockquote><p><a href="https://blog.csdn.net/jiankunking/article/details/79824353" target="_blank" rel="noopener">Java sleep和wait的区别</a></p></blockquote><blockquote><p><a href="https://www.jianshu.com/p/c655e0a944ae" target="_blank" rel="noopener">在阻塞式io中，如果一个线程在等待io操作，那么cpu还会分配时间片给该线程吗？</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;sleep-amp-wait&quot;&gt;&lt;a href=&quot;#sleep-amp-wait&quot; class=&quot;headerlink&quot; title=&quot;sleep()  &amp;amp; wait()&quot;&gt;&lt;/a&gt;sleep()  &amp;amp; wait()&lt;/h2&gt;
    
    </summary>
    
      <category term="Java" scheme="http://changsk.top/categories/Java/"/>
    
    
      <category term="java" scheme="http://changsk.top/tags/java/"/>
    
      <category term="sleep" scheme="http://changsk.top/tags/sleep/"/>
    
      <category term="wait" scheme="http://changsk.top/tags/wait/"/>
    
  </entry>
  
  <entry>
    <title>Reactor线程模型</title>
    <link href="http://changsk.top/2019/06/17/Reactor-thread-model/"/>
    <id>http://changsk.top/2019/06/17/Reactor-thread-model/</id>
    <published>2019-06-17T01:33:22.000Z</published>
    <updated>2019-06-17T02:14:47.267Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Reactor是什么"><a href="#Reactor是什么" class="headerlink" title="Reactor是什么?"></a>Reactor是什么?</h4><blockquote><p>The reactor design_pattern is an <strong>event_handling</strong> pattern for handling service requests delivered concurrently to a service handler by <strong>one or more inputs</strong>. The service handler then <strong>demultiplexes</strong> the incoming requests and <strong>dispatches</strong> them synchronously to the associated request handlers.</p><p>from wiki</p></blockquote><a id="more"></a><p>通过wiki中的定义我们可以发现Reactor的重点</p><blockquote><ol><li>事件驱动</li><li>可以处理一个或多个输入源</li><li>通过多路复用将请求的事件分发给对应的处理器处理</li></ol></blockquote><p>根据大神Doug Lea 在 《Scalable IO in Java 》中的介绍，Reacotr模型主要分为三个角色</p><blockquote><ol><li><strong>Reactor</strong>：把IO事件分配给对应的handler处理</li><li><strong>Acceptor</strong>：处理客户端连接事件</li><li><strong>Handler</strong>：处理非阻塞的任务</li></ol></blockquote><h4 id="为什么使用Reactor？"><a href="#为什么使用Reactor？" class="headerlink" title="为什么使用Reactor？"></a>为什么使用Reactor？</h4><p><img src="1.jpg" alt></p><p><strong>传统阻塞IO模型的不足</strong></p><blockquote><ol><li>每个连接都需要独立线程处理，当并发数大时，创建线程数多，占用资源</li><li>采用阻塞IO模型，连接建立后，若当前线程没有数据可读，线程会阻塞（<strong>阻塞会有切换进程或线程上下文的开销</strong>）在读操作上，造成资源浪费</li></ol></blockquote><p>针对传统阻塞IO模型的两个问题，可以采用如下的方案</p><blockquote><ol><li>基于池化思想，避免为每个连接创建线程，连接完成后将业务处理交给<strong>线程池</strong>处理</li><li>基于IO复用模型，<strong>多个连接共用同一个阻塞对象</strong>，不用等待所有的连接。遍历到有新数据可以处理时，操作系统会通知程序，线程跳出阻塞状态，进行业务逻辑处理</li></ol></blockquote><p><strong>Reactor线程模型的思想就是基于IO复用和线程池（线程复用）的结合</strong></p><h4 id="Reactor线程模型分类"><a href="#Reactor线程模型分类" class="headerlink" title="Reactor线程模型分类"></a>Reactor线程模型分类</h4><p>根据Reactor的数量和处理资源的线程数量的不同，分为三类：</p><blockquote><ol><li>单Reactor单线程模型</li><li>单Reactor多线程模型</li><li>多Reactor多线程模型</li></ol></blockquote><p><strong>单Reactor单线程模型</strong></p><p>这种模型在<strong>Reactor中处理事件，并分发事件</strong>，如果是连接事件交给acceptor处理，如果是读写事件和业务处理就交给handler处理，但始终只有一个线程执行所有的事情</p><p><img src="2.jpg" alt></p><p>该线程模型的不足</p><blockquote><ol><li>仅用一个线程处理请求，对于多核资源机器来说是有点浪费的</li><li><strong>当处理读写任务的线程负载过高后，处理速度下降，事件会堆积，严重的会超时，可能导致客户端重新发送请求，性能越来越差</strong></li><li>单线程也会有可靠性的问题</li></ol></blockquote><p>针对上面的种种不足，就有了下面的线程模型</p><p><strong>单Reactor多线程模型</strong></p><p>这种模型和第一种模型到的主要区别是把业务处理从之前的单一线程脱离出来，换成线程池处理，也就是<strong>Reactor线程只处理连接事件和读写事件，业务处理交给线程池处理，充分利用多核机器的资源、提高性能并且增加可靠性</strong></p><p><img src="3.jpg" alt></p><p>该线程模型的不足</p><blockquote><p>Reactor线程承担所有的事件，例如监听和响应，高并发场景下单线程存在性能问题</p></blockquote><p><strong>多Reactor多线程模型</strong></p><p>这种模型下和第二种模型相比是把<strong>Reactor线程拆分了mainReactor和subReactor</strong>两个部分，mainReactor只处理连接事件，读写事件交给subReactor来处理。业务逻辑还是由线程池来处理</p><p><img src="4.jpg" alt></p><p>mainRactor只处理连接事件，用一个线程来处理就好。处理读写事件的subReactor个数一般和CPU数量相等，一个subReactor对应一个线程，业务逻辑由线程池处理</p><p>这种模型使各个模块职责单一，降低耦合度，性能和稳定性都有提高</p><p>这种模型在许多项目中广泛应用，比如<strong>Netty的主从线程模型</strong>等</p><h4 id="Reactor三种模式形象比喻"><a href="#Reactor三种模式形象比喻" class="headerlink" title="Reactor三种模式形象比喻"></a>Reactor三种模式形象比喻</h4><p>餐厅一般有接待员和服务员，接待员负责在门口接待顾客，服务员负责全程服务顾客</p><p>Reactor的三种线程模型可以用接待员和服务员类比</p><blockquote><ol><li>单Reactor单线程模型：接待员和服务员是同一个人，一直为顾客服务。客流量较少适合</li><li>单Reactor多线程模型：一个接待员，多个服务员。客流量大，一个人忙不过来，由专门的接待员在门口接待顾客，然后安排好桌子后，由一个服务员一直服务，一般每个服务员负责一片中的几张桌子</li><li>多Reactor多线程模型：多个接待员，多个服务员。这种就是客流量太大了，一个接待员忙不过来了</li></ol></blockquote><p><strong>参考资料</strong></p><ol><li><p>《Scalable IO in Java》 -Doug Lea  【关注公众号，回复“Doug Lea” 获取该pdf】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文章来源微信公众号：每天晒白牙</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Reactor是什么&quot;&gt;&lt;a href=&quot;#Reactor是什么&quot; class=&quot;headerlink&quot; title=&quot;Reactor是什么?&quot;&gt;&lt;/a&gt;Reactor是什么?&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;The reactor design_pattern is an &lt;strong&gt;event_handling&lt;/strong&gt; pattern for handling service requests delivered concurrently to a service handler by &lt;strong&gt;one or more inputs&lt;/strong&gt;. The service handler then &lt;strong&gt;demultiplexes&lt;/strong&gt; the incoming requests and &lt;strong&gt;dispatches&lt;/strong&gt; them synchronously to the associated request handlers.&lt;/p&gt;
&lt;p&gt;from wiki&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="IO模型" scheme="http://changsk.top/categories/IO%E6%A8%A1%E5%9E%8B/"/>
    
    
      <category term="Reactor" scheme="http://changsk.top/tags/Reactor/"/>
    
      <category term="IO模型" scheme="http://changsk.top/tags/IO%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>linux grep命令详解</title>
    <link href="http://changsk.top/2019/06/16/linux-grep/"/>
    <id>http://changsk.top/2019/06/16/linux-grep/</id>
    <published>2019-06-16T15:33:18.000Z</published>
    <updated>2019-06-17T09:43:40.387Z</updated>
    
    <content type="html"><![CDATA[<p>一篇讲解<a href="http://www.zsythink.net/archives/1733" target="_blank" rel="noopener">grep</a>很好的文章，以便日后查阅。</p><a id="more"></a><p><img src="1.jpg" alt></p><p>文章来源：<a href="http://www.zsythink.net/archives/1733" target="_blank" rel="noopener">grep命令详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一篇讲解&lt;a href=&quot;http://www.zsythink.net/archives/1733&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;grep&lt;/a&gt;很好的文章，以便日后查阅。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://changsk.top/categories/Linux/"/>
    
    
      <category term="Linux命令" scheme="http://changsk.top/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>java中永久代的垃圾回收</title>
    <link href="http://changsk.top/2019/06/16/java-perm-GC/"/>
    <id>http://changsk.top/2019/06/16/java-perm-GC/</id>
    <published>2019-06-16T14:22:27.000Z</published>
    <updated>2019-06-16T15:32:44.927Z</updated>
    
    <content type="html"><![CDATA[<p>今天面试被问到<strong>jvm中永久代会发生垃圾回收吗？</strong></p><a id="more"></a><p>首先，关于永久代的内容可以看这个：[jvm中方法区和永久代的关系]</p><blockquote><p>垃圾回收不会出现在永久代，但是如果永久代满了会触发完全垃圾回收（<strong>Full GC</strong>）。</p></blockquote><p>Hotspot的永久代是在方法区，主要存储的是类加载信息，静态变量以及常量，方法（字节码）等等，可以进行<strong>常量池回收</strong>和<strong>类型卸载</strong>。</p><ul><li>如果这个常量在其它任何对象都没被引用，则可以被回收。</li><li>而类型卸载有点复杂，有以下三点要求：</li></ul><ol><li>该类型的所有实例都已经被回收  </li><li>该类型的ClassLoader已经被回收  </li><li>该类型的java.lang.Class没有在任何地方被引用，该类型不能在任何地方以反射的方式实例化一个对象。在java8中，已经取消了永久代，但是引入了一个元数据区的navite内存区。 </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天面试被问到&lt;strong&gt;jvm中永久代会发生垃圾回收吗？&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://changsk.top/categories/Java/"/>
    
    
      <category term="java" scheme="http://changsk.top/tags/java/"/>
    
      <category term="永久代" scheme="http://changsk.top/tags/%E6%B0%B8%E4%B9%85%E4%BB%A3/"/>
    
      <category term="metaspace" scheme="http://changsk.top/tags/metaspace/"/>
    
  </entry>
  
  <entry>
    <title>markdown语法</title>
    <link href="http://changsk.top/2019/06/16/markdown-syntax/"/>
    <id>http://changsk.top/2019/06/16/markdown-syntax/</id>
    <published>2019-06-16T12:53:05.000Z</published>
    <updated>2019-06-20T01:50:51.503Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习一下Markdown的语法，以便更好地组织文章结构。<br>在此记录，以便日后的查阅。</p><a id="more"></a><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><blockquote><h4 id="Markdown是什么？"><a href="#Markdown是什么？" class="headerlink" title="Markdown是什么？"></a>Markdown<em>是什么</em>？</h4><h4 id="谁创造了它？"><a href="#谁创造了它？" class="headerlink" title="谁创造了它？"></a><em>谁</em>创造了它？</h4><h4 id="为什么要使用它？"><a href="#为什么要使用它？" class="headerlink" title="为什么要使用它？"></a><em>为什么</em>要使用它？</h4><h4 id="怎么使用？"><a href="#怎么使用？" class="headerlink" title="怎么使用？"></a><em>怎么</em>使用？</h4><h4 id="谁在用？"><a href="#谁在用？" class="headerlink" title="谁在用？"></a><em>谁</em>在用？</h4><h4 id="尝试一下"><a href="#尝试一下" class="headerlink" title="尝试一下"></a>尝试一下</h4></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-Markdown是什么？"><a href="#1-Markdown是什么？" class="headerlink" title="1. Markdown是什么？"></a>1. Markdown<em>是什么</em>？</h3><p><strong>Markdown</strong>是一种轻量级<strong>标记语言</strong>，它以纯文本形式(<em>易读、易写、易更改</em>)编写文档，并最终以HTML格式发布。<br><strong>Markdown</strong>也可以理解为将以MARKDOWN语法编写的语言转换成HTML内容的工具。</p><h3 id="2-谁创造了它？"><a href="#2-谁创造了它？" class="headerlink" title="2. 谁创造了它？"></a>2. <em>谁</em>创造了它？</h3><p>它由<a href="http://www.aaronsw.com/" target="_blank" rel="noopener"><strong>Aaron Swartz</strong></a>和<strong>John Gruber</strong>共同设计，<strong>Aaron Swartz</strong>就是那位于去年（<em>2013年1月11日</em>）自杀,有着<strong>开挂</strong>一般人生经历的程序员。维基百科对他的<a href="http://zh.wikipedia.org/wiki/亚伦·斯沃茨" target="_blank" rel="noopener">介绍</a>是：<strong>软件工程师、作家、政治组织者、互联网活动家、维基百科人</strong>。</p><p>他有着足以让你跪拜的人生经历：</p><ul><li><strong>14岁</strong>参与RSS 1.0规格标准的制订。</li><li><strong>2004</strong>年入读<strong>斯坦福</strong>，之后退学。</li><li><strong>2005</strong>年创建<a href="http://infogami.org/" target="_blank" rel="noopener">Infogami</a>，之后与<a href="http://www.reddit.com/" target="_blank" rel="noopener">Reddit</a>合并成为其合伙人。</li><li><strong>2010</strong>年创立求进会（Demand Progress），积极参与禁止网络盗版法案（SOPA）活动，最终该提案被撤回。</li><li><strong>2011</strong>年7月19日，因被控从MIT和JSTOR下载480万篇学术论文并以免费形式上传于网络被捕。</li><li><strong>2013</strong>年1月自杀身亡。</li></ul><p>天才都有早逝的归途。</p><h3 id="3-为什么要使用它？"><a href="#3-为什么要使用它？" class="headerlink" title="3. 为什么要使用它？"></a>3. <em>为什么</em>要使用它？</h3><ul><li>它是易读（看起来舒服）、易写（语法简单）、易更改<strong>纯文本</strong>。处处体现着<strong>极简主义</strong>的影子。</li><li>兼容HTML，可以转换为HTML格式发布。</li><li>跨平台使用。</li><li>越来越多的网站支持Markdown。</li><li>更方便清晰地组织你的电子邮件。（Markdown-here, Airmail）</li><li>摆脱Word（我不是认真的）。</li></ul><h3 id="4-怎么使用？"><a href="#4-怎么使用？" class="headerlink" title="4. 怎么使用？"></a>4. <em>怎么</em>使用？</h3><p>如果不算<strong>扩展</strong>，Markdown的语法绝对<strong>简单</strong>到让你爱不释手。</p><p>Markdown语法主要分为如下几大部分： <strong>标题</strong>，<strong>段落</strong>，<strong>区块引用</strong>，<strong>代码区块</strong>，<strong>强调</strong>，<strong>列表</strong>，<strong>分割线</strong>，<strong>链接</strong>，<strong>图片</strong>，<strong>反斜杠 \</strong>，<strong>符号’`’</strong>。</p><h4 id="4-1-标题"><a href="#4-1-标题" class="headerlink" title="4.1 标题"></a>4.1 标题</h4><p>两种形式：<br>1）使用<code>=</code>和<code>-</code>标记一级和二级标题。</p><blockquote><p>一级标题<br><code>=========</code><br>二级标题<br><code>---------</code></p></blockquote><p>效果：</p><blockquote><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2></blockquote><p>2）使用<code>#</code>，可表示1-6级标题。</p><blockquote><h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6></blockquote><p>效果：</p><blockquote><h1 id="一级标题-2"><a href="#一级标题-2" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-2"><a href="#二级标题-2" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题-1"><a href="#三级标题-1" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题-1"><a href="#四级标题-1" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题-1"><a href="#五级标题-1" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题-1"><a href="#六级标题-1" class="headerlink" title="六级标题"></a>六级标题</h6></blockquote><h4 id="4-2-段落"><a href="#4-2-段落" class="headerlink" title="4.2 段落"></a>4.2 段落</h4><p>段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用<strong>两个以上</strong>空格加上回车（引用中换行省略回车）。</p><h4 id="4-3-区块引用"><a href="#4-3-区块引用" class="headerlink" title="4.3 区块引用"></a>4.3 区块引用</h4><p>在段落的每行或者只在第一行使用符号<code>&gt;</code>,还可使用多个嵌套引用，如：</p><blockquote><p>&gt; 区块引用<br>&gt;&gt; 嵌套引用</p></blockquote><p>效果：</p><blockquote><p>区块引用</p><blockquote><p>嵌套引用</p></blockquote></blockquote><h4 id="4-4-代码区块"><a href="#4-4-代码区块" class="headerlink" title="4.4 代码区块"></a>4.4 代码区块</h4><p>代码区块的建立是在每行加上4个空格或者一个制表符（如同写代码一样）。如<br>普通段落：</p><p>void main()<br>{printf(“Hello, Markdown.”);<br>}</p><p>代码区块：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, Markdown."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>:需要和普通段落之间存在空行。</p><h4 id="4-5-强调"><a href="#4-5-强调" class="headerlink" title="4.5 强调"></a>4.5 强调</h4><p>在强调内容两侧分别加上<code>*</code>或者<code>_</code>，如：</p><blockquote><p><em>斜体</em>，<em>斜体</em><br><strong>粗体</strong>，<strong>粗体</strong></p></blockquote><p>效果：</p><blockquote><p><em>斜体</em>，<em>斜体</em><br><strong>粗体</strong>，<strong>粗体</strong></p></blockquote><h4 id="4-6-列表"><a href="#4-6-列表" class="headerlink" title="4.6 列表"></a>4.6 列表</h4><p>使用<code>·</code>、<code>+</code>、或<code>-</code>标记无序列表，如：</p><blockquote><p>-（+<em>） 第一项 -（+</em>） 第二项 - （+*）第三项</p></blockquote><p><strong>注意</strong>：标记有一个_空格<em>或</em>制表符_。若不在引用区块中，必须和前方段落之间存在空行。</p><p>效果：</p><blockquote><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><p>有序列表的标记方式是将上述的符号换成数字,并辅以<code>.</code>，如：</p><blockquote><p>1 . 第一项<br>2 . 第二项<br>3 . 第三项</p></blockquote><p>效果：</p><blockquote><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol></blockquote><h4 id="4-7-分割线"><a href="#4-7-分割线" class="headerlink" title="4.7 分割线"></a>4.7 分割线</h4><p>分割线最常使用就是三个或以上<code>*</code>，还可以使用<code>-</code>和<code>_</code>。</p><h4 id="4-8-链接"><a href="#4-8-链接" class="headerlink" title="4.8 链接"></a>4.8 链接</h4><p>链接可以由两种形式生成：<strong>行内式</strong>和<strong>参考式</strong>。<strong>行内式</strong>：</p><blockquote><p><a href="https:://github.com/younghz/Markdown" title="Markdown" target="_blank" rel="noopener">younghz的Markdown库</a>。</p></blockquote><p>效果：</p><blockquote><p><a href="https://github.com/younghz/://github.com/younghz/Markdown" target="_blank" rel="noopener">younghz的Markdown库</a>。</p></blockquote><p><strong>参考式</strong>：</p><blockquote><p><a href="https:://github.com/younghz/Markdown" title="Markdown" target="_blank" rel="noopener">younghz的Markdown库1</a><br><a href="https:://github.com/younghz/Markdown" title="Markdown" target="_blank" rel="noopener">younghz的Markdown库2</a></p></blockquote><p>效果：</p><blockquote><p><a href="https://github.com/younghz/://github.com/younghz/Markdown" target="_blank" rel="noopener">younghz的Markdown库1</a><br><a href="https://github.com/younghz/://github.com/younghz/Markdown" target="_blank" rel="noopener">younghz的Markdown库2</a></p></blockquote><p><strong>注意</strong>：上述的<code>[1]:https:://github.com/younghz/Markdown &quot;Markdown&quot;</code>不出现在区块中。</p><h4 id="4-9-图片"><a href="#4-9-图片" class="headerlink" title="4.9 图片"></a>4.9 图片</h4><p>添加图片的形式和链接相似，只需在链接的基础上前方加一个<code>！</code>。</p><h4 id="4-10-反斜杠"><a href="#4-10-反斜杠" class="headerlink" title="4.10 反斜杠\"></a>4.10 反斜杠<code>\</code></h4><p>相当于<strong>反转义</strong>作用。使符号成为普通符号。</p><h4 id="4-11-符号’-’"><a href="#4-11-符号’-’" class="headerlink" title="4.11 符号’`’"></a>4.11 符号’`’</h4><p>起到标记作用。如：</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ctrl+a</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><p>效果：</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ctrl+a</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><h4 id="4-12-上标、下标"><a href="#4-12-上标、下标" class="headerlink" title="4.12 上标、下标"></a>4.12 上标、下标</h4><p>markdown是支持HTML语法的，所以可以用HTML的语法表示下标、下标等。</p><p>上标： <code>&lt;sup&gt;xxx&lt;/sup&gt;</code><br>语法：<code>2&lt;sup&gt;32&lt;/sup&gt; - 1</code><br>效果：2<sup>32</sup> - 1</p><p>下标： <code>&lt;sub&gt;xxx&lt;/sub&gt;</code><br>语法：<code>a=log&lt;sub&gt;2&lt;/sub&gt;b</code><br>效果：a=log<sub>2</sub>b</p><h4 id="5-谁在用？"><a href="#5-谁在用？" class="headerlink" title="5. 谁在用？"></a>5. <em>谁</em>在用？</h4><p>Markdown的使用者：</p><ul><li>GitHub</li><li>简书</li><li>Stack Overflow</li><li>Apollo</li><li>Moodle</li><li>Reddit</li><li>等等</li></ul><h4 id="6-尝试一下"><a href="#6-尝试一下" class="headerlink" title="6. 尝试一下"></a>6. 尝试一下</h4><ul><li><strong>Chrome</strong>下的插件诸如<code>stackedit</code>与<code>markdown-here</code>等非常方便，也不用担心平台受限。</li><li><strong>在线</strong>的dillinger.io评价也不错</li><li><strong>Windowns</strong>下的MarkdownPad也用过，不过免费版的体验不是很好。</li><li><strong>Mac</strong>下的Mou是国人贡献的，口碑很好。</li><li><strong>Linux</strong>下的ReText不错。</li></ul><p><strong>当然，最终境界永远都是笔下是语法，心中格式化 :)。</strong></p><hr><p><strong>注意</strong>：不同的Markdown解释器或工具对相应语法（扩展语法）的解释效果不尽相同，具体可参见工具的使用说明。 虽然有人想出面搞一个所谓的标准化的Markdown，[没想到还惹怒了健在的创始人John Gruber] (<a href="http://blog.codinghorror.com/standard-markdown-is-now-common-markdown/" target="_blank" rel="noopener">http://blog.codinghorror.com/standard-markdown-is-now-common-markdown/</a> )。</p><hr><p>以上基本是所有traditonal markdown的语法。</p><h3 id="其它："><a href="#其它：" class="headerlink" title="其它："></a>其它：</h3><p>列表的使用(非traditonal markdown)：</p><p>用<code>|</code>表示表格纵向边界，表头和表内容用<code>-</code>隔开，并可用<code>:</code>进行对齐设置，两边都有<code>:</code>则表示居中，若不加<code>:</code>则默认左对齐。</p><table><thead><tr><th>代码库</th><th>链接</th></tr></thead><tbody><tr><td>MarkDown</td><td><a href="https://github.com/younghz/Markdown" target="_blank" rel="noopener">https://github.com/younghz/Markdown</a></td></tr><tr><td>MarkDownCopy</td><td><a href="https://github.com/younghz/Markdown" target="_blank" rel="noopener">https://github.com/younghz/Markdown</a></td></tr></tbody></table><p>关于其它扩展语法可参见具体工具的使用说明。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以上内容来源自：https:<span class="regexp">//gi</span>thub.com<span class="regexp">/younghz/</span>Markdown</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;学习一下Markdown的语法，以便更好地组织文章结构。&lt;br&gt;在此记录，以便日后的查阅。&lt;/p&gt;
    
    </summary>
    
      <category term="markdown" scheme="http://changsk.top/categories/markdown/"/>
    
    
      <category term="markdown" scheme="http://changsk.top/tags/markdown/"/>
    
      <category term="syntax" scheme="http://changsk.top/tags/syntax/"/>
    
  </entry>
  
</feed>
